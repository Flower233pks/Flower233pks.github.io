<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随想 · 目次表]]></title>
    <url>%2F2050%2F12%2F31%2F%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[终于又开始了。 我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。 在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。 是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。 var ap = new APlayer({ element: document.getElementById("aplayer-ChYjHqFc"), narrow: false, autoplay: false, showlrc: false, music: { title: "花", author: "Hello Nico", url: "Hello Nico-花.flac", pic: "/2050/12/31/随想·目次表/qwq.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 以下是目录： 题目 链接（点击即可） 随想一 · 山丘 $Link$ 随想二 · 丘吉尔 $Link$ 随想三 · 本赛季最后的随想/启示录 $Link$ 随想四 · 故人 咕 随想五 · 手中没有红玫瑰 $Link$ 随想六 · 难 $Link$ 随想七 · 言叶之庭 $Link$ 随想八 · 逃吧 咕 随想九 · 意义 $Link$ 随想十 · 繁星 咕]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【泛做】构造题选做 · 1]]></title>
    <url>%2F2019%2F12%2F24%2F%E6%9E%84%E9%80%A01%2F</url>
    <content type="text"><![CDATA[从网课和 uoj 群里的课件扒出来的构造题，都挺(不)好(会)的(做)。 1 神秘的题目设 $f_A$ 表示 $A$ 的本质不同子串个数给出 $x, y$，要求构造出两个字符串 $A, B$满足：$f_A = x , f_B = y , f_{A+B} = x + y$ $x, y ≤ 5000$ 考虑 $x$ 个 $a$，$y$ 个 $a$ ，然后拼起来就好…… 2 CF743C给出 n，构造出 x, y, z，满足： $$\frac{2}{n} = \frac{1}{x}+\frac{1}{y}+\frac{1}{z}\\\x\not= y, x\not= z, y\not= z$$无解输出 −1$n ≤ 10^4$ 考虑通分（分时裂项），即$$\frac{1}{n}-\frac{1}{n+1}=\frac{1}{n(n+1)}\\\\frac{1}{n}=\frac{1}{n+1}+ \frac{1}{n(n+1)}\\\\frac{2}{n}=\frac{1}{n} + \frac{1}{n+1}+ \frac{1}{n(n+1)}$$然后就做完了。 注意1要特判。 3 CF359B给出 $n, k , 2k ≤ n$，构造出 $2n$ 的一个排列，满足： $$∑^n_{i=1} |a_{2i−1} − a_{2i}| − |∑^n_{i=1}(a_{2i−1} − a_{2i})| = 2k$$ $n ≤ 50000$ 寄几想了一种构造，就是$a_{i+1} = a_i+k,~i=2p,~p \in \mathbb{N+}$，然后随便两次交换两项就好了。然而并不对，因为这样构造出的结果并不合法；于是遂决定改成$a_{i+1} = a_i+2k,~i=2p,~p \in \mathbb{N+}$，但也不对，单次交换的步长太长了，是$4k$。于是我又想能否有什么诡异的交换方法可以补救回来$2k$……失败了qaq 然而其实很简单，我们只要把步长控制为$1$就一定能凑出来。所以一开始先令$a_i=a_{i+1}+1$这种感觉，然后交换$k$次即可。 $\color{violet}{4~ \rm{CF}\it{512E}}$对于一个正 n 边形，可以用 n − 3 条边分成 n − 2 个三角形给出两种划分，你需要进行若干次操作把第一种划分变成第二种划分每次操作选择一个四边形删去它的对角线，连另外一条对角线n ≤ 1000，操作次数不超过 20000 开始掉线…… 其实主要思想就是酱油瓶状态替换，把起始状态 $s$ 变成对角线都从 $1$ 出发的状态 $p$，再从 $p$ 出发变成终态 $t$。 具体操作好像是 别想了，掉线了怎么可能还会有？ $5$ 神秘的题目 给出一棵树，定义一个点的邻居集合为到它距离 $\leq 2$ 的所有点。 给出所有点的邻居集合，还原原树。 $n\leq 1,000$ 考虑一个结论，如果两个点的邻居集合交集大小为 $2$， 那么交集中的点一定有连边。（$\rm bitset$ 做到 $\frac{n^3}{w}$） 于是就可以先把 非叶子节点 两两之间的连边求出来 然后考虑如何求出叶子。发现叶子有个性质，就是叶子到某些非叶节点的距离一定 $=$ 与之相邻的非叶节点到某些非叶节点的距离 $+1$。所以就可以再把离每个非叶节点距离为 $1$ 的非叶节点求出来，称这个点集为旁边集合。那么如果叶子 $u$ 的邻居集合与非叶节点 $v$ 的旁边集合相同，那么 $u$ 就一定挂在 $v$ 上。 $6$ AT3877 给定 $\rm X,Y$， 给出 $[d_{i,j}]$ 表示当 $\mathrm X=i,\mathrm Y=j$ 时，$\rm S$ 到 $\rm T$ 的最短路。 构造这张图，使之点数 $&lt;300$，无自环和重边，每条边的权值 $\leq 100$， 权值可以是数也可以是 $\rm X,Y$，并给出 $\rm S,T$ 。 设 $g_{i,j}$ 表示从 $\rm S$ 到 $\rm T$ ，经过了包含 $i$ 条 $\rm X$ 边， $j$ 条 $\rm Y$ 边的路径，其它边的边权最小和。 那么发现这东西可以这么转移出 $[d_{i,j}]$来$$d_{i,j}= \min_{p,q}{(p\cdot i+q\cdot j + g_{p,q})}$$然后可以得到松弛条件$$\forall p,q, \quad \exists~ d_{i,j}\leq p\cdot i+q\cdot j+g_{p,q}$$移项可以得到$$g_{p,q}=\max_{i,j}{(d_{i,j}-p\cdot i - q\cdot j)}$$于是考虑求出 $g $ ，之后反推出 $[d_{i,j}]’$ 观察是否吻合。吻合则考虑根据经过的 $\rm X,Y$ 连边即可。 $7$ ARC 095F 给定一棵树 $\rm T$, 要求构造一个排列 $p$ . 对于每一个 $p_i$ ，找到最大的 $j$ 使得 $p_j&lt;p_i$，然后在 $i,j$ 间连边。 问是否可以构造出与 $\rm T$ 同构的树。 如果可以，则给出字典序最小的排列。 $n\leq 100,000$ 反向考虑，观察对于一个排列生成的树。按照排列的权值升序操作，维护最靠右的位置 $mxp$ 即可。 然后发现由于一个排列不可能同时有两个最大值，这样生成的树一定会是一根长链周围分散着单点。 于是考虑把直径抽出来，对上面的点扫一遍。遇到有挂在上面的肯定考虑从小到大放在前面，然后就没有然后了。 可能实现还不太会，要再想想。 $8$ 小题整理8.1 覆盖 平面上给定 $n$ 个点，每个点可以覆盖 $\frac{1}{4}$ 的平面，求最少需要多少个点才能覆盖所有点 orz我和ouuuyuuu一开始觉得题很傻，最多四个，结果发现原来最多两个就可以，然后发现我们很傻。。 找某一维坐标最大/最小的两个点，再判一下是不是只需要一个点就可以满足，就做完了。 8.2 CF477B 有 $n$ 个集合，彼此交集为空。 每个集合有 $4$ 个元素，两两之间均有 $\gcd = k$ 求 $4n$ 个数中最大值的最小值 $1\leq n\leq 10000$ 发现可以同除以 $k$ ，于是就变成两两互质了，于是 $4$ 个数中至多 $1$ 个偶数。 同时发现一个鬼能发现的性质，就是相邻两个奇数一定互质，那么就构造$$\mathrm{S}:{6i-1,6i-3,6i-5,6i-4 }$$可知它们互质。然后就没了。 $9$ CF 527D 每个元素有一个 $a_i$ 一个 $b_i$ . 求一个最大的点集使得 $\forall p,q\in \mathrm{S},\quad |a_p-a_q|\geq b_p+b_q$ $n\leq 200,000$ 我丢，其实就是把每个元素看做 $(a_i-b_i,a_i+b_i)$ 这么一段区间，然后求的就是最长不相交的区间个数。 然后就没了……就没了…… $10$ ARC 084D 求出 $K$ 的倍数中，各位数字的和最小的那个数字的数字和。 $K \leq 100,000$ 考虑从 $i$ 到 $i+1$ 连一条长度为 $1$ 的边，$i$ 到 $10\cdot i$ 连长度为 $0$ 的边。然后按照$\bmod k$ 的余数建边，最后就是 $1\to 0$ 的最短路。 $11$ 神秘的题目 给出一张 $n \cdot m$ 的网格图，曼哈顿距离为 $2$ 或 $3$ 的点之间连一条边，构造出一条哈密尔顿回路。 可能无解。哈密尔顿回路：经过每个点恰一次。 发现可以走法可以是棋盘染色，即黑白相间染色，先走完黑色再走完白色。 发现只有 $n=2,m=2$ 时无解。当 $\min(n,m)=1$ 时，考虑 $(1,2),(1,3),(2,4),(2,5)$ 都必须连（保证有回路），剩下的瞎构造即可。 $12$ CF 468A 用 $1\sim n$ 的所有数凑出 $24$，输出方案。 每个数都要用，只能用 +、-、× 三种运算。 $n\leq 100,000$ 发现 $n\leq 3$ 显然不行。 然后 $n=4$ 的时候阶乘即可，$n=5$ 的时候发现可以 $5\times 3+4\times 2+1$ 这么算。 然后考虑 $n&gt;5$，那么 $n$ 一定可以由 $n-2$ 推过来，因为只要乘上 $n-(n-1)$ 即可。发现这样总是可以构造出来合法解。 $13$ Loj #525 给定一个正整数 $k$，你需要寻找一个系数均为 $0$ 到 $k−1$ 之间的非零多项式 $f(x)$，满足对于任意整数 $x$ 均有 $f(x)≡0~(\bmod k)$ 要求 $\deg(f)\leq 60000$ $k\leq 30000$ 首先发现只要对 $0\sim k-1$ 成立那么就满足条件。 然后就变成傻题了，分治FFT！分治FFT！ 然而分治FFT会T。不妨令 $q\geq \varphi(k)$，则由于扩展欧拉定理有：$$x^q\equiv x^{q\bmod \varphi(k)+\varphi(k)}(\mod k)$$那么如果令 $v=q+\varphi(k)$，就会有 $$\begin{aligned}x^v &amp; \equiv x^{v\bmod \varphi(k)+\varphi(k)} (\bmod k) \\ &amp;\equiv x^{(q\bmod \varphi(k)+\varphi(k) \bmod \varphi(k))\bmod \varphi(k) +\varphi(k)} (\bmod k)\\ &amp; \equiv x^{q\bmod \varphi(k)+\varphi(k)}(\bmod k)\\ &amp; \equiv x^q(\bmod k)\end{aligned}$$然后就构造第 $\varphi(k)$ 项系数为 $k-1$，第 $2\cdot \varphi(k)$ 项系数为 $1$ 即可。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【泛做】构造题选做 · 2]]></title>
    <url>%2F2019%2F12%2F24%2F%E6%9E%84%E9%80%A02%2F</url>
    <content type="text"><![CDATA[没啥特别原因，就是底下那篇文章题太多了就分流出一部分。 $1$ UVa1697 给定一排长度为 $4n$ 的格子，编号从 $-2n+1$ 到 $2n$ 每个编号为正的格子中有一个物品，其中每个编号为奇数的格子中有一个 $B$ 类物品，编号为偶数的格子中有一个 $A$ 类物品。 你只能进行一种操作：选择某两个相邻的都有物品的格子，移动到另外两个相邻的空格子中，同时不能改变两个格子的相对位置。 要求进行最少的操作使得所有物品以 AAA…ABBB…B ($n$ 个 $A$ 和 $n$ 个 $B$) 的形式排列在一起 输出一种可行方案 $3\leq n \leq 100$ 人类智慧学不来了orz 考虑 $n=3,4,5,6,7$ 的时候都可以人类智慧。那么对于 $n &gt; 7$ 时考虑增量构造，即从 $n$ 构造到 $n+4$。 那么 $n=4$ 时可以这么构造： __babababa abbabab__a abba__bbaa a__abbbbaa aaaabbbb__ 然后考虑对于 $n+4$，记 $|BA|$ 表示有一堆 bababa 这种东西。 那么考虑 $n+4$ 可以这么玩： __|BA| ab|BA|b__a abba__|BA|bbaa 发现中间那一段和起始状态是一样的，就可以大力递归，回代的时候回代一下即可。 $n=3\sim 7$ 我选择直接从网上抄来别人的人类智慧，毕竟我莫得智慧.jpg 1234567891011121314151617181920212223void oo(int x, int y)&#123; cout &lt;&lt; x &lt;&lt; " to " &lt;&lt; y &lt;&lt; '\n' ;&#125;void work(int L, int R)&#123; int len = R - L + 1 ; if (len == 3 &lt;&lt; 1) return oo(2, -1), oo(5, 2), oo(3, -3), void() ; if (len == 4 &lt;&lt; 1) return oo(L + 5, L - 2), oo(L + 2, L + 5), oo(L - 1, L + 2), oo(L + 6, L - 1), void() ; if (len == 5 &lt;&lt; 1) return oo(L + 7, L - 2), oo(L + 2, L + 7), oo(L + 5, L + 2), oo(L - 1, L + 5), oo(L + 8, L - 1), void() ; if (len == 6 &lt;&lt; 1) return oo(L + 9, L - 2), oo(L + 6, L + 9), oo(L + 1, L + 6), oo(L + 5, L + 1), oo(L - 1, L + 5), oo(L + 10, L - 1), void() ; if (len == 7 &lt;&lt; 1) return oo(L + 7, L - 2), oo(L + 4, L + 7), oo(L + 11, L + 4), oo(L + 2, L + 11), oo(L + 8, L + 2), oo(L - 1, L + 8), oo(L + 12, L - 1), void() ; oo(R - 2, L - 2), oo(L + 2, R - 2), work(L + 4, R - 4), oo(L - 1, R - 5), oo(R - 1, L - 1) ;&#125;int main()&#123; while (cin &gt;&gt; N) work(1, N * 2), puts("") ;&#125; $2$ BZOJ4148 Pillars 给定一个 $n\times m$ 的矩形，其中有 $f$ 个 $2\times 2$ 的障碍物，其中任意两个障碍物中心之间的欧几里得距离至少为 $6$，且每个障碍物的中心到边缘的距离至少为 $3$。 请找到一条从左下角 $(1,1)$ 出发经过所有没有障碍物的点各一次的且最后回到左下角的回路。 保证 $n,m$ 均为偶数，且 $1\leq n,m\leq 1000$ . 发现是乱搞题 Claris居然搬过这样的题 就是考虑如果没有障碍的走法，由于 $n,m$ 都是偶数，所以可以从 $(1,1)$ 上到 $(1,n)$，然后从 $(1,n)$ 到 $(n,n)$ 再到 $(n,n-1)$ 再到 $(2,n-1)$ 这么蛇形走。 考虑有了障碍，因为每个障碍可以看做是独立的的，所以大概可以这么走： 其中紫色是障碍，黄色是原来的路线，红色是新的。由于 $6$ 的限制，所以可以这么绕。 所以是道细节题233 代码先鸽着，什么时候有心情再写。s $3$ 【UR #6】 智商锁 构造一个节点数不超过 $100$ 的无向图，使其生成树个数对 $998244353$ 取模的结果为 $k$ 。 $k\leq 10^9$ 看题，仔细一想，莫非是什么神秘的 $\boldsymbol{EGF}$ 大力乱搞（警觉）。 结果人傻了……以下是官方做法： 考虑如果两个图只有一个公共点，那么生成树个数为两个图相乘。那么随机 $1000$ 个随机无向图，两两拼凑出 $10^6$ 个无向图，然后对每一个在 map 里找 $k$ 的逆元即可。如果没有就再随机一遍。 发现这样实际上几乎不可能没有解。。。 降智打击.jpg $4$ 【UNR #1】Jakarta Skyscrapers 有一个数集，最初其中只有 $a$ 和 $b$。 你可以进行最多 $400$ 次操作，每次选择集合中满足 $i&gt;j$ 的 $i$ 和 $j$，把 $i-j$ 加入集合中，使得最后 $c$ 在这个集合中。 $a,b,c\leq 10^{18}$ 考虑构造中间状态。发现可以用 $a-(a-b-c)$ 构造 $b+c$， 可以用 $a-(a-b-b)$ 构造倍增，于是考虑先辗转相除得到 $1$，然后倍增，然后就没了。注意，如果一开始 $(a,b) \not|~c$ 的话是无解的。那么考虑同除 $(a,b)$ 就可以快乐地更相减损得到 $1$ 了。 代码先鸽着…]]></content>
      <categories>
        <category>学习笔记</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【练习记录】之前的杂题整理（To Be Continued....）]]></title>
    <url>%2F2019%2F12%2F22%2F%E6%9D%82%E9%A2%98%E6%B3%9B%E5%81%9A%C2%B7%E4%B9%8B%E5%89%8D%2F</url>
    <content type="text"><![CDATA[主要是 CSP-S 2019 之前的杂题整理，天知道我为了整理这些东西要花费怎样漫长的时间去 read back 我的提交记录…… 1、LG5317 花园 发现一共只有两种方格，并且转移只跟 $\rm M$ 有关，于是考虑状压。考虑 $g(s, t)$ 表示从状态 $s$ 转移到 $t$ 的方案数。其中转移指的是向右扩展一格。 那么显然这东西可以 dfs 预处理出来。然后发现这东西类似于 floyd 的转移矩阵，然后就快速幂。考虑由于花圃是个环，那么合法的方案就是 $1…m$ 和 $n+1….n+m$ 要相同。所以就直接把开头结尾相同的累加一波。 2、LG4218 完全平方数 一道傻题，大概就是考察 $\mu$ 的性质。 $\rm Algorithm~1$ 发现可以容斥，且 $\mu$ 函数的性质在于，$\mu (x) = (-1)^k$，当且仅当 $x$ 不含平方因子且 $x$ 的不同素因子个数为 $k$。所以就考虑先二分，二分完了求一下 $$\sum _{i=1}^{\sqrt n} \mu(i)\lfloor \frac{n}{i^2}\rfloor$$ 就变成傻题了。复杂度 $T \cdot \sqrt n \log n$ 顺便记录一个很绝的 idea $\rm Algorithm~2$ 根据 $\mu$ 的性质，发现似乎只有 $\mu(x) = 0$ 时，$x$ 才会被讨厌。所以其实二分求的就是 $$\sum _{i=1}^{x}\mu^2(x)\leq K$$ 然后我们发现这东西可以直接杜教筛。于是复杂度就变成了 $T\cdot n^{\frac{2}{3}} \log n$。然而实际记忆化了会更快。 但显然杜教筛被暴力给爆锤了好吗 3、[]]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>技巧/状态压缩</tag>
        <tag>容斥/暴力容斥</tag>
        <tag>数学/线性代数/矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP-S2019游记]]></title>
    <url>%2F2019%2F12%2F20%2FCSP-S2019%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[想不到吧，还有这个时候写游记的。 在机房啥题都做不动了，难受。于是打算写篇游记？不过CSP已经过去几百年了啊，我这篇文章按道理应该已经属于“历史文献”而不是“游记”了吧233 这是一个什么故事呢？这只是一个普通人在挣扎的故事而已吧。 $\rm Day\quad -???$LCEZ机房终于只剩8个人了。 分别是经常会灵光一现的wxl，稳得一批的yjk，经常被膜被AKIOI的wx，玩梗宅男ljp，爱占便宜的lwy，智商不低的qcr，首席颓蛋/电视导购lzr和我。 其实初三刚来实验班一开始是12个人，但是后来1个人去了友校，1个人选择在 NOIP2018 之前去学文化课，我们把她在团队里的名字改成了“等你回来”，但是最后也没等到；剩下两个人选择考完NOIP2018就退出，现在其中一个因为选了一科地理去了平行班，另一个选择留在文化课班专攻文化课。当然，那就是另一个故事了。 NOIP2018，我们之中有人考得很好，有人铩羽而归，而我属于后者。所以大家都在积极准备着，选择在国庆之后就停课。 国庆的时候，我和lzr，wx和qcr去了青岛参加正睿，自认为是停课效果排名比较靠前的一次外出培训了。我只记得前几天每天闲的时候会选择去打 _This is the police 2_，并且在走的前一天成功丢了身份证awa，lzr 则在狂颓上古卷轴Online，wx和qcr在另一个屋，所以我并不清楚。无论怎样，青岛的培训也是很值得回忆的吧。我到现在也可以回想起夜里无人的大街、昏黄的房间只有一件台灯、抑郁的我、经常去买的大桶雪碧和辣条和我丢了的身份证。 无论怎样，青岛的外卖没有济南的好吃，嘿嘿。 $\rm Day\quad -??$我选择把每天上午安排给ZR的模拟赛，一般名次都不会很高，唉菜死了。 剩下人可能在做题，可能在颓。印象最深刻的就是我每五次去找yjk玩，有三次他都在刷知乎。。。 发现自己无论什么大型比赛之前都会发现自己原来有整理不完的博客，平时习惯太差带来的后果真可怕e 不过似乎是有我引起的一阵风，机房里大家都开始晚上喝_香飘飘_，甚至连铁公鸡yjk也拔毛了买过几次奶茶，于是走廊上就一股浓郁的奶茶味233 之前嘛，就做了做dp，学了学odt，第一次写莫队结果被逼着调了半天最后套了个线段树。剩下的或许就没有什么印象深刻的事情了。 哦，胜利一中的神仙们一直很在状态。我就很奇怪为什么会有人每天坚持打比赛还能坚持整完所有题目的……期间我整天听歌，还抽了一个晚上看了集《奇葩说》，感觉李诞认真起来实力也不弱蛤。 要来了吗？要来了吧。 $\rm Day\quad-3$给最喜欢的语文老师写了封信，跟她说我觉得我可能在考完之后不会继续走下去了，这让我很难过，因为我割舍不下那些回忆，觉得她可能会理解我。她回信了。我很高兴她没有硬塞什么心灵鸡汤。于是每天晚上我都会拿出信来读一遍。 哦对，她以前是我的语文老师，文化课/奥赛分班之后她就只教隔壁了。 其实你说现在我有什么感受呢？我也不知道，就是蔡琴唱过的 _让它好好的来，让它好好的去_ 这种感觉吧。 $\rm Day\quad 0$报到日，群体乘大巴。大巴上我教yjk打音游和拳皇，打deemo他菜的一批233 到了考点，日照什么职业技术大学。校园一般，宿舍还行，起码有插头和桌子。 去试了试饭菜，感觉还可以，挺丰富的。发现是兑换餐币，于是就换了三种面值的留下作纪念了。 晚上去试机，豪华六边形方桌，和机房里一样，感到很开心。键盘也很轻。听别人说键盘难用、座位之间间距太小，才知道原来不是每个考场都是豪华六边形方桌。有抽中大奖的喜悦233 试机回来就是瞎写了写板子，写了写博客。睡前听的是德彪西的《月光》。 考前和yjk估摸了一下，Day1要拿260左右才能稳，不知道明天会怎样。 哦，对，当时听的那一版《月光》，是我听完好多版之后最喜欢的一个版本。但之后我尝试找过，但无论怎么找都找不到了… $\rm Day\quad 1$考啦考啦。 开题发现有一些奇怪的说明，没管。 开 $\rm T1$，发现是个sb题，写了$\rm [5,10]min$ 左右切了，开考 $15\min$ 的时候拍上了。 开 $\rm T2$，发现 $50$ 在送，于是先写了 $50$ 。之后寻思着去做做 $\rm T3$，发现不太会。本着求稳，写了 $10pts$ 就回去写 $\rm T2$了。于是就开始演，演了半小时写出了一堆不知道啥东西，然后又演了半小时发现大样例爆栈了…… 我不会告诉你我接下来浪费了快半小时去回忆Dev怎么开栈…… 最后还是失败了，但是发现其实大样例不需要 dfs ，于是写了个序列版本给演过去了。之后 $\rm T2$ 就拍上了。此时大概是 $10:15$ 。 觉得去刚 $\rm T3$ 应该不至于一分没有，结果就真的一分没有，伤心。 之后就自闭了。出了考场，我戴紧冲锋衣帽子冲到了一个僻静的小路里面，周围都是密密麻麻的树，开始思考人生。在家庭群里用微信发了句 “考挂了，没救了”，跟妹子说了声“要退役了”就找了个角落开始思考人生。思考完之后开始在校园里闲逛，不想回宿舍。我觉得一定会有 sb 学弟或者 sb 同级生在对 tnd 答案，结果最后手机没电了不得不回去。 回去之后要了份脆皮鸡饭叫上 yjk 出去逛，发现原来大家都是 210 左右，心态得到了放松。结果不知道为啥，后半程跟 yjk 越走越自闭。我们俩大概是这么聊天的： 我：你最后考到多少名还学？ yjk：20~30吧。 我：嗯我也是。那 70 以后呢（因为他去年这个名次）？ yjk：不学了吧。。 我：嗯我也是。 yjk：今天的题感觉没有区分度啊 我：是啊，没有区分度啊。回去还要补文化课。大家今天都 210，全天下都 210，明天还会更难，肯定会加大区分度，那我可能就被区分下去了…（开始碎碎念） yjk：是啊…… 于是我俩就在四季桥那里自闭了，和俩二傻子一样蹲在桥边，如果忽略肤色，宛如两尊佛。 不过后来走着走着心态又回来了。回到宿舍后被辅导员骂了一顿，因为手机落在宿舍并且没签到，233. 之后选择去吃晚饭，碰到了胜利一中的神仙，但是显然他们不可能认识我，所以我就像一个狗仔一样单方面盯着他们看……233 晚饭挺不错！这是真的！之后去买了红牛，希望明天能用上。 晚上其实一直在颓火影和拳皇……睡之前写了写博客，hexo -d 之后就睡了。 还是听的《月光》。 $\rm Day\quad 2$……自闭了。 开场看T1，发现是计数，不会。去搞 T2，觉得很可做，发现40在送；写完去看T3，发现40在送。于是决定写 T2。然后 T2 猜了一波单调性发现可以 64，于是数据分治了一下，拍上了；之后去写了个T3的40。T2推了推，觉得似乎可以斜率优化，但是发现有二次项似乎很难办，就没管。剩下的时间就在做T1…… 最大的失误是啥呢？可能就是我T1把 n 和 m 看反了，并且过了前两个样例，于是觉得这题64在送。但是死活过不去第三个样例。好久之后才发现看反了，赶紧写了个玄学dfs。赛后一测re了。真开心。T3当时看的时候觉得75都是送，但是最后也没来得及写……于是第二天就这么凉了。 一出来，就自闭了。闲逛了好久，用QQ跟妹子说“真退役了”，用微信跟家长说“已经准备迎接新生活了”，后来就没有后来了。回去一问发现大家也都挂了……yjk哭了，我头一次见他哭。 不用想的，Day2就是考区分度。之前zr做题的时候就明白了，我是那种被区分下去的人。容斥、dp、贪心之类的这些基本功，我都很烂很不扎实，被区分下去是我活该。你说我会为自己以前拼命学多项式感到不值吗？可能确实不值，但是说啥都没用了。 回去的路上还是比较愉快的。车上的电视终于不放上21世纪初的悲情无脑乡村恋爱歌曲，改放《欢乐喜剧人》，于是最终和yjk看了一路233 rqy哭了，可能是因为觉得我们都退役了吧。但是我感觉我和他已经不是一个世界的人了。我一直感觉，如果让我从实力和陪伴里面选一个，我肯定毫不迟疑地选择前者。但，结束了。 晚上回家了，就是在一直颓而已，没啥别的，期间励志要开启新生活，觉得很有斗志。 $\rm Day ~7$在校的周六，选择去机房收拾东西，顺便看了眼民间数据成绩单。发现自己和yjk都是省里50多名，还一个分…这就很难了，我们之前没讨论过这个区间该干啥呀？ 现在之后？之后就是我又滚回来追梦，yjk去文化课了，剩下的人都退役了。 LCEZ55 级的机房故事，也就这么结束了吧？我一直觉得，我们机房没有其它机房可爱，我是罪魁祸首。我身为队长，要张罗日常事务，但是从来没真正关心过谁，加上脾气很差容易着急（虽然现在好很多了？）。并且一开始我很菜，要一直不遗余力的提升自己实力，不顾什么”同学友谊“啊啥的，功利且浮躁。大家平时也不怎么敢跟我交流，于是机房就很冷清。 但机房里也时常会有笑声，比如联赛前，机房里一直其乐融融的。现在看来那似乎是遥远的回忆了。 现在机房里只有我一个人了，我开心吗？终于等到了我喜欢的悠远的寂静，我更快乐吗？ 向前走吧。 我还很菜，啥都不会，迷茫且不知所措。 但是人生也就应该是这样的吧。 明天你好。 结语大家一起加油吧！为了梦想和明天。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】闲谈]]></title>
    <url>%2F2019%2F12%2F15%2F%E9%97%B2%E6%89%AF%2F</url>
    <content type="text"><![CDATA[别名：一句话日记 可能就是用来随时记录自己感悟的东西？ 12.26上午下午一共做了三道题，从李煜东的蓝书上看来的。中途写挂了好几次，但是最终调出来还是挺有成就感的。 饭卡丢了，有点郁闷。毕竟电话卡和饭卡是一张卡，电话卡丢了还要去电信营业厅补办。。。太麻烦了吧233 ……然后……然后就因为一些奇怪的事情陷入了奇怪的思考。感觉自己正在被拽进奇怪的漩涡中，感觉自己似乎如同「奇异人生」里面 Max 经常梦到的场景，在风暴之中，自己在被撕扯着想要登上灯塔。可惜只有我一个人。 看着一堆东西还没学，也不是很想学。后天还要考政治，什么都没背，感觉有点不太好。 似乎我走迷了路。或者说，我经常会走迷了路。高中到现在为止我一直在追求着什么，放弃了很多，但是到现在我也一直不知道我到底在追求些什么。是奥赛吗？我恍惚了。是功成名就吗？我恍惚了。 感觉到现在为止，我只有每个学期刚刚开始，即18年9月 $\sim$ 10月和今年的9月 $\sim$ 10月有认真学过文化课，剩下的时间都在划水；美其名曰学研究奥赛，学来的线性规划或者 HLPP 可能永远也用不上。我在干什么？其他人丰富有趣、值得回忆的高中生活，在我眼里就是一场又一场的白日梦，一次又一次地跌倒再爬起来再欺骗自己：你没跌倒。这一切的一切，真是我想要的吗？ 我又在瞎想了。给梁文道做序的某作家（忘了名字）说，为什么人们喜欢寓哲学于文学呢，因为人们喜欢问没有答案的问题，喜欢去体味这种求索的感觉。可能对我来说，这也算是一点心理安慰了吧。 嗯，写完这些感觉内心明显平静了许多。 12.25今天有点颓，上午只写了一篇题解，下午做$[\rm SNOI2019]$的D2T1，做了好久，剩下的时间不知道干什么去了。 晚上继续和 ouuuyuuu 出去跑圈。外面开始下雪了，十分开心。但是一边跑，风雪夹带着冷雨扑打过来有点难受。眼镜中途还因为镜面上水太多，想用手套擦，结果擦成了磨砂玻璃…233摘下眼镜来继续跑就会感觉跟喝了一壶一样，看着周围都是一派虚无缥缈的景象。 开始看梁文道的《我执》了。感觉还行。但是毕竟只看了一点，也不知道到底有什么精彩等待着我。 发现自己写文章的时候，可能是因为平时说话说太快了，一直不喜欢加句号。大多数情况下都是一大段全是逗号233 晚上发现胜利一中的神仙们去逛了我的 Luogu 博客，比较开心。因为似乎我也没法跟别人交流了。 瞎扯一句，感觉 rqy 能一个人在这儿奋斗两年，十分厉害。孤独+经常会有的绝望+偶尔的希望，不把人逼自闭已经算是很好了。 诶，刚刚才发现原来自己有三个博客，但是这三个博客上的东西几乎都不一样。。。233 12.24平安夜，很自闭233 看了一上午+大半个下午的构造，感觉一般。听 ouuuyuuu 说构造题只能长经验，是学不会的，感觉有点小失落。 人总要有梦想，万一我就学会了呢 晚上复盘了一下自己的 $\rm CSP-S~2019$ ，感觉虽然和大家都很有差距，但是如果从进步的意义上来讲，比起去年来自己进步还是蛮多的。毕竟去年也就那点水平。 嗯，所以呢，谁知道将来我会不会进步到我想象不到的水平呢？加油吧，我可是想要创造奇迹的笨蛋啊！ 12.23越来越困了，发现啥都学不会，然后自闭了。 发现去了 pkuwc 的小伙伴们似乎都有约拿了，感觉更自闭了。 ……我觉得我现在应该是全校最盼着放寒假的人了。当初觉得似乎机房生活会很轻松，结果发现比文化课生活自闭了不止一个量级。可海星…… 发现啥都学不会了，发现比别人拉下的不止一点半点……有点难受，但是一想到马上要放假了（虽然还有一个多月）就会开心一点phh 12.22……之前换了几天的 jacman 主题，说实话感觉不是很漂亮。换主题的原因是我关了一次 icloud，然后他就给我吞了……迷惑。于是只能重新建一个主题。不过好在我找回了失去的脑子找到了对应的文件夹，于是九成功复原了。于是现在就又换回了 next 主题。 怎么说呢，虽然 next 主题确实用的比较多，有烂大街的嫌疑，但是你要真让我去挑其他的喜欢的并且配置出来，确实很麻烦。 嗯，这个故事告诉我们要学会备份。 12.15upd:因为不知为啥，hexo的背景炸了，觉得似乎白色也挺漂亮，就决定不设置背景了。 新建了这个文档，本想写很多，结果突然发现自己WC都去不了。 然后就自闭了，我为什么还要死命坚持下去呢？又有什么意义呢？]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Manacher简单题泛做]]></title>
    <url>%2F2019%2F12%2F15%2FManacher%E6%B3%9B%E5%81%9A%2F</url>
    <content type="text"><![CDATA[在？为啥不用PAM？ emm那可能是空间开不下（自我安慰 $1$ LG1659 [国家集训队]拉拉队排练 求前$k$大的奇数长度回文串的长度之积。 $\rm |S|\leq 1e6,K\leq 1e12$ ……一开始觉得挺水，就开始二分最少长度能到多少。写写写…写到最后发现细节很烦人…然后最后发现是错的qaq 二分是没错，只是最后计算错了。大概就是考虑二分出的最小长度是$k$，对于一个大于$k$的长度$l$有好多个，没法知道$l$们到底要算到几，也就是说$7$中一定包含着$3/5/7$，但是对于$l$，其中可能有拆出$7,5$来的，也有可能有拆出$7,5,3$来的，无法同一个长度一起算。 以下是错误代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; int N, L = -1 ; LL K, res, fact = 1, _up ; char In[MAXN] ;il LL expow(LL x, LL y)&#123; LL ret = 1 ; while (y)&#123; if (y &amp; 1) (ret *= x) %= Mod ; (x *= x) %= Mod, y &gt;&gt;= 1 ; &#125; return ret ; &#125;il bool check(int p)&#123; LL ret = 0 ; int x = ed[p], i ; if (x % 2 == 0) return 0 ; for (int i = 1 ; i &lt; p ; ++ i) ret += 1ll * ((ed[i] - ed[p] + 2) / 2) * 1ll * buc[ed[i]] ; return (bool)(ret + (buc[ed[p]]) &gt;= K) ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K &gt;&gt; (In + 1) ; ns[++ L] = '$', ns[++ L] = '#' ; int id = 0, rt = 0 ; for (int i = 1 ; i &lt;= N ; ++ i) ns[++ L] = (int)In[i], ns[++ L] = '#' ; for (int i = 1 ; i &lt;= L ; ++ i)&#123; if (rt &lt;= i) base[i] = 1 ; else base[i] = min(base[2 * id - i], rt - i + 1) ; while (ns[i - base[i]] == ns[i + base[i]]) ++ base[i] ; if (rt &lt;= i + base[i] - 1) rt = i + base[i] - 1, id = i ; &#125; for (int i = 1 ; i &lt;= 2 * N + 2 ; ++ i) buc[base[i] - 1] ++ ; for (int i = 1 ; i &lt; MAXN ; i += 2) if (buc[i]) ed[++ tot] = i ; reverse(ed + 1, ed + tot + 1) ; int L = 1, R = tot, Mid, ans, pos = 0 ; while (L &lt;= R)&#123; Mid = (L + R) &gt;&gt; 1 ; /*if (rand() % 2) while (ed[Mid] % 2 == 0 &amp;&amp; Mid &lt; R) ++ Mid ; else while (ed[Mid] % 2 == 0 &amp;&amp; Mid &gt; L) -- Mid ;*/ if (check(Mid)) ans = Mid, R = Mid - 1 ; else L = Mid + 1 ; &#125; pos = ans, res = 1ll, _up = ed[1] ; for (int i = ed[pos] ; i &lt;= ed[1] ; i += 2) fact *= 1ll * i ; for (int i = 1 ; i &lt;= pos ; ++ i)&#123; while (ed[i] &lt; _up) fact /= _up, _up -= 2 ; if ((ed[i] - ed[pos] + 2) / 2 &gt; K)&#123; int j = 0 ; while (ed[i] &gt;= ed[pos] &amp;&amp; j &lt; K) res = res * 1ll * ed[i], ed[i] -= 2, ++ j ; break ; &#125; res = res * expow(fact, buc[ed[i]] &lt;= K ? buc[ed[i]] : K) % Mod ; K -= 1ll * ((ed[i] - ed[pos] + 2) / 2) * 1ll * buc[ed[i]] ; if (K &lt;= 0) break ; &#125; cout &lt;&lt; res &lt;&lt; endl ; return 0 ; &#125; 观察失误点，贡献无法提前计算，那么可以考虑延后计算，这样一定能保证准确凑出来$K$. 1234567891011121314151617181920212223242526272829303132int tot, ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; int N, L ; LL K, res, fact = 1, _up ; char In[MAXN] ;il LL expow(LL x, LL y)&#123; LL ret = 1 ; while (y)&#123; if (y &amp; 1) (ret *= x) %= Mod ; (x *= x) %= Mod, y &gt;&gt;= 1 ; &#125; return ret ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K &gt;&gt; (In + 1) ; ns[++ L] = '$', ns[++ L] = '#' ; int id = 0, rt = 0 ; for (int i = 1 ; i &lt;= N ; ++ i) ns[++ L] = (int)In[i], ns[++ L] = '#' ; for (int i = 1 ; i &lt;= L ; ++ i)&#123; if (rt &lt;= i) base[i] = 1 ; else base[i] = min(base[2 * id - i], rt - i) ; while (ns[i - base[i]] == ns[i + base[i]] &amp;&amp; i + base[i] &lt;= L &amp;&amp; i - base[i] &gt;= 1) ++ base[i] ; if (rt &lt;= i + base[i] - 1) rt = i + base[i], id = i ; &#125; for (int i = N ; i &gt;= 1 ; -- i)&#123; ans += buc[i] ; if (!(i &amp; 1)) continue ; if (ans &lt;= K) (res *= expow(i, ans)) %= Mod, K -= ans ; else &#123; (res *= expow(i, K)) %= Mod, K -= ans ; break ; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl ; return 0 ; &#125; 。。。这题一开始写挂了，然后两天后（就是写这行字的时候）整理这道题，又调了半天才发现为啥二分不对…qaq脑子是个好东西。 $2$ LG4555 [国家集训队]最长双回文串这题比第一题友善了很多。。。 输入长度为$n$的串$S$，求$S$的最长双回文子串$T$,即可将$T$分为两部分$X$，$Y$，（$|X|,|Y|≥1$）且$X$和$Y$都是回文串。 嗯，其实就是求以每个点为右端点/左端点的最长回文串长度。用Manacher做的话，就是一开始先推出以每个点为轴的最长回文串长度，然后用这个去更新每端点。注意到这么做有些包含在原来求出的最长回文串内部的小回文串可能并不可以求出来，于是再dp一遍即可。 12345678910111213141516171819202122 cin &gt;&gt; (In + 1), N = strlen(In + 1) ; int i, id = 0, rt = 0 ; ns[++ L] = '$', ns[++ L] = '#' ; for (i = 1 ; i &lt;= N ; ++ i) ns[++ L] = (int)In[i], ns[++ L] = '#' ; for (i = 1 ; i &lt;= L ; ++ i)&#123; if (rt &lt;= i) base[i] = 1 ; else base[i] = min(rt - i + 1, base[2 * id - i]) ; while (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ; if (i + base[i] &gt; rt) rt = i + base[i] - 1, id = i ; &#125;// for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; base[i] &lt;&lt; " " ; puts("") ;// for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; (char)ns[i] &lt;&lt; " " ; for (i = 1 ; i &lt;= L ; ++ i)&#123; int l = i / 2 - (base[i] / 2) + 1 ; int r = i / 2 + (base[i] / 2) - 1 ; if (ns[i] == 35) ++ r ; Ls[r] = max(Ls[r], base[i] - 1), Rs[l] = max(Rs[l], base[i] - 1) ; &#125; for (i = 1 ; i &lt;= N ; ++ i) Ls[i] = max(Ls[i], Ls[i + 1] - 2) ; for (i = 1 ; i &lt;= N ; ++ i) Rs[i] = max(Rs[i], Rs[i - 1] - 2) ;// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Ls[i] &lt;&lt; " " ; puts("") ;// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Rs[i] &lt;&lt; " " ; for (i = 1 ; i &lt; N ; ++ i) ans = max(ans, Ls[i] + Rs[i + 1]) ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】PAM简单题泛做]]></title>
    <url>%2F2019%2F12%2F15%2FPAM%E6%B3%9B%E5%81%9A%2F</url>
    <content type="text"><![CDATA[都是简单的PAM习题 $1$ LG5496 【模板】回文自动机 对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。 $|s|\leq 1e6$ 然后就是PAM的板子题咋感觉好像没有不是很板的PAM题呢 考虑对自动机上每个点维护一个出现次数$cnt$，那么考虑串里面的任何一个前缀的回文后缀都是其最长回文后缀的回文后缀，所以就可以有转移$$cnt_{p}=cnt_{fail_p}+1$$然后就没有然后了。 $2$ [APIO2014]回文串 给你一个由小写拉丁字母组成的字符串$s$。我们定义$s$的一个子串的存在值为这个子串在 $s$中出现的次数乘以这个子串的长度。 对于给你的这个字符串$s$，求所有回文子串中的最大存在值。 $|s|\leq 1e6$ 感觉还是比较妙的……或许也算是PAM的基本操作，就是求出每个回文子串的出现次数。考虑一个子串出现第$t$次的时候（$t&gt;1$），一定是作为其他串的回文后缀出现，而显然“串的最长回文后缀唯一”的逆命题“任何串会唯一作为其他串的最长回文后缀”也是成立的。故若记录以$u$为$fail$的所有子串集合为$\rm S(u)$，那可以直接用$$\rm f_u=ctn_u+\sum_{v\in S(u)}f_v$$其中ctn为单独出现的次数，因为可能有多个子串$s$都不作为其他串的最长回文后缀。 emmm一句话概括，PAM处理子串问题的时候有个特性，就是由于是递减式查询，所以一个回文串不会同时作为回文串和其他串的最长回文后缀出现。 12for (int i = P.sz ; i ; i --) P.f[P.pre[i]] += P.f[i], ans = max(ans, 1ll * P.len[i] * P.f[i]) ; 哪那么多P话，就是背啊 $3$ LG5555 秩序魔咒 求两个串的最长公共回文子串以及该长度的出现次数。 $\rm |S|,|T|\leq 10^6$ 恭喜发现一个新套路 观察起始$\rm PAM$本身是一棵树，添上了一堆奇奇怪怪的$fail$边才变成有向图。所以考虑，如果从奇根或者偶根同时向下dfs，走同样的转移边，那么一定可以到达同样的状态。所以考虑建两个$\rm PAM$，一起dfs，然后算个答案即可。 1234567void dfs(int x, int y)&#123; if (ans == P.len[x]) res ++ ; else if (ans &lt; P.len[x]) res = 1, ans = P.len[x] ; for (int i = 1 ; i &lt;= 26 ; ++ i) if (P.trie[x][i] &amp;&amp; Q.trie[y][i]) dfs(P.trie[x][i], Q.trie[y][i]) ;&#125; By the way，奇根/偶根都要$dp$一次。 $4$ [JSOI2013]快乐的 JYY 求两个串的不同公共回文串的个数，其中不同意思是下标不同。 $|s|,|t|\leq 10^6$ ……然而这就是前两个题结合起来。考虑先$dp$一遍算出来每个回文子串的出现次数，然后dfs，乘法原理计数，然后就做完了。 12345678910111213141516void dfs(int x, int y)&#123; if (x + y &gt; 2) ans += 1ll * P.f[x] * Q.f[y] ; for (int i = 1 ; i &lt;= 26 ; ++ i) if (P.trie[x][i] &amp;&amp; Q.trie[y][i]) dfs(P.trie[x][i], Q.trie[y][i]) ;&#125;int main()&#123; P.Init(), Q.Init() ; cin &gt;&gt; (S + 1) &gt;&gt; (T + 1) ; N = strlen(S + 1), M = strlen(T + 1) ; for (int i = 1 ; i &lt;= N ; ++ i) P.Insert(S[i] - 'A' + 1, i, S) ; for (int i = 1 ; i &lt;= M ; ++ i) Q.Insert(T[i] - 'A' + 1, i, T) ; for (int i = P.sz ; i ; -- i) P.f[P.pre[i]] += P.f[i] ; for (int i = Q.sz ; i ; -- i) Q.f[Q.pre[i]] += Q.f[i] ; dfs(1, 1) ; dfs(0, 0) ; cout &lt;&lt; ans&lt;&lt; endl ; return 0 ;&#125; $5$ 闲扯写模板题真是让人感到空虚……]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/PAM,回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】PAM & Manacher]]></title>
    <url>%2F2019%2F12%2F15%2FPAMandManacher%2F</url>
    <content type="text"><![CDATA[PAM &amp; Manacher，两种用来处理回文串的玩意儿。 $1$ Manacher挺短，背是挺好背的 Manacher用于求回文串长度。思想大概就是： 1、加入字符集之外的识别字符（比如#）分隔开原来相邻的字母，这样所有的回文串都变成了以某个字符为中心的（否则如果是偶数长度的回文串还要特判）。 2、考虑借由以前的信息求出新的回文串长度。记录到现在为止最靠右的回文串中最右侧的字符下标&amp;其对称轴的下标，不妨记这个最靠右的串为$\rm S$。那么考虑以当前位置作为对称轴的答案，一定至少是$\min${隔着$\rm S$的对称轴与其对称的另一个位置ans，$|S|-i+1$} 。然后就不断扩展即可。 3、关于复杂度证明。我们记一次帅气的操作的意义是成功让$ans_i$的初始值继承了与之对称的点的答案和边界的取$\min$，记以当前点为轴的最长回文子串为$\rm T$，$T$的右端点为$q$。可以知道 （1）$\rm S$的右端点是单增的； （2）如果当前旧的$maxlen&lt;i$，即未成功进行一次帅气的操作，那么显然while1次，$maxlen$增大一次； （3）如果当前的串经过了一次帅气的操作，那么当$q&lt;maxlen$时，直接跳出while；当$q\geq maxlen$时，$q$增大$maxlen$必增大。所以得出结论，进行一次帅气的操作和$maxlen$的增大次数是严格同阶的。 So,最终复杂度就是$\Theta(n)$的。 123456789101112131415161718192021void Manacher(char *s)&#123; int id, fars, i ; id = 0, fars = 0 ; //id : 最靠右的回文串的中心位置 //fars : 迄今为止最靠右的回文串的最右侧 for (i = 1 ; i &lt;= N ; ++ i) ns[++ L] = (int)In[i], ns[++ L] = '#' ; for (i = 1 ; i &lt;= L ; ++ i)&#123; if (fars &lt;= i) base[i] = 1 ; else base[i] = min(fars - i + 1, base[id * 2 - i]) ; while (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ; if (i + base[i] &gt; fars) id = i, fars = i + base[i] - 1 ; &#125;&#125;int main()&#123; scanf("%s", In + 1), L = -1, N = strlen(In + 1) ; ns[++ L] = '$', ns[++ L] = '#' ; Manacher(In) ; for (int i = 1 ; i &lt;= 2 * N + 2 ; ++ i) ans = max(ans, base[i] - 1) ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; $2$ PAM学了PAM，不知道为啥感觉比SAM简单？ 其实就是一种自动机，以回文串为状态，左右各添加一个字符为转移的自动机。要点如下： 0、一个串的回文子串至多有$O(n)$个。 1、首先每个节点需要保存这个节点中回文串的长度。 2、显然始状态需要有两个，即奇数长度的$s$和偶数长度的$s$，称作“奇根”和“偶根”。那么为了方便呢，奇根的长度设置为$-1$，偶根长度设置为$0$。 3、考虑要从$last$指针扩展当前状态，假设当前需要insert的字母是$c$，是这个串里面的第$p$个字符，那我们需要找到一个后缀$s[j…p-1]\quad s.t.\quad s[j…p-1]$本身回文且$s[j-1]=c$，那么就可以向下扩展。 4、考虑怎么找这个后缀，显然对于一个串$S$，他的所有回文后缀都是其最长回文后缀的回文后缀。所以考虑$fail$指针，应当从当前状态连向它的最长回文后缀。 5、插入新节点时，考虑跳完$fail$后如果没有相应的转移边，就要新建一个状态然后连$fail$. 然后是代码和一点注意： 1234567891011121314151617181920212223struct PAM&#123; int trie[MAXN][Sigma] ; int rt0, rt1, last, sz ; int len[MAXN], fail[MAXN] ;&#125;P ;void _init(PAM &amp;p)&#123; p.sz = -1, p.rt0 = ++ p.sz, p.rt1 = ++ p.sz ; p.fail[p.rt0] = p.fail[p.rt1] = p.rt1 ; p.last = p.rt0, p.len[p.rt0] = 0, p.len[p.rt1] = -1 ; &#125;void _insert(PAM &amp;p, int x, int pos, char *s)&#123; int u = p.last ; while (s[pos - p.len[u] - 1] != s[pos]) u = p.fail[u] ; if (!p.trie[u][x])&#123; int fa = p.fail[u] ; int newn = ++ p.sz ; p.len[newn] = p.len[u] + 2 ; while (s[pos - p.len[fa] - 1] != s[pos]) fa = p.fail[fa] ; p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn, &#125; p.last = p.trie[u][x] ;&#125; 6、$\rm \color{red}{WARNING}$，以下两句顺序不要写反： 1p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn, 原因是当$fa=u$时就出现环了。 $3$ 闲扯学完才知道，$\rm PAM$又简单又好背功能又多……Manacher被打爆了啊喂qwq。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>PAM,回文自动机</category>
      </categories>
      <tags>
        <tag>字符串/Manacher</tag>
        <tag>字符串/PAM,回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Codeforces前11场泛做]]></title>
    <url>%2F2019%2F11%2F15%2Fcf1-11%2F</url>
    <content type="text"><![CDATA[嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq $\rm {CF·1C}$ 求包含给定三点的正多边形最小面积。 先考虑，对于给出的三个正多边形顶点，两两连边之后，中垂线交于正多边形所在圆的圆心——原因是这三个点最优情况下一定是在顶点上的。那么可以凭此求出圆心和半径。 之后对于该多边形，我们考虑，由于其让求的正多边形需要面积最小。并且对于给出的三个点，由于在正多边形上的原因，所以圆心与其连线的角都应该是该正多边形相邻两个顶点在外接圆上所对的圆心角的整数倍 那么我们就做一个double类型的$\gcd$就好了——因为在外接圆大小一定时（三点已确定一个圆），对于正$n$边形，其面积与$n$成正相关。所以取$\gcd$一定是个最好的选择。 最后的面积嘛…大概只需要余弦定理一下就好。此处借鉴的是第一篇题解里面求面积的方法。同时，第三个角必须用$2\pi$减去另外两个角得到，如果不这样误差会相当的大……尤其是乘上一堆之后，面积会很不精确$qaq$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const double Eps = 1e-4 ;const double Pi = acos(-1.00000) ;struct Node&#123; bool mark ; // 0 = exist, 1 = inexist ; double x, y ;&#125;A, B, C, O, m1, m2, m3 ;struct Line&#123; int mark ;//0 : // x-axis, 1: // y-axis, 2: // normal ; double k, b ; double x, y ; // y = kx + b, x = k, y = k ;&#125;L[12] ; double Len[4], agl[4], R, angle ; int i ;double get_x(Line A, Line B)&#123; return A.mark == 0 ? A.x : B.x ; &#125; //which is x = k ;double get_y(Line A, Line B)&#123; return A.mark == 1 ? A.y : B.y ; &#125; //which is y = k ;double dis(Node A, Node B)&#123; return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ; &#125;inline Node get_Mid(Node A, Node B)&#123; return (Node)&#123;0, (A.x + B.x) / 2, (A.y + B.y) / 2 &#125; ; &#125;inline Line get_verti(Node n, Line a)&#123; if (!a.mark) return (Line) &#123;1, 0, 0, 0, n.y&#125; ; if (a.mark == 1) return (Line) &#123;0, 0, 0, n.x, 0&#125; ; double kk = -1.0 / a.k, bb = n.y - n.x * kk ; return (Line)&#123;2, kk, bb, 0, 0 &#125; ;&#125;inline Line get_Line(Node A, Node B)&#123; if (A. y == B. y) return (Line)&#123;1, 0, 0, 0, B.y&#125; ; if (A. x == B. x) return (Line)&#123;0, 0, 0, A.x, 0&#125; ; double kk = (A.y - B.y) / (A.x - B.x), bb = A.y - A.x * kk ; return (Line)&#123;2, kk, bb, 0, 0&#125; ;&#125;inline Node get_inter(Line A, Line B)&#123; if (A.mark == B.mark &amp;&amp; (A.mark == 1 || A.mark == 0) ) return (Node)&#123;1, 0, 0 &#125; ; if ((A.mark == 1 &amp;&amp; B.mark == 0) || (A.mark == 0 &amp;&amp; B.mark == 1)) return (Node)&#123;0, get_x(A, B), get_y(A, B)&#125; ; if (A.mark == 1 &amp;&amp; B.mark == 2) return (Node)&#123;0, (A.y - B.b) / B.k, A.y&#125; ; if (A.mark == 2 &amp;&amp; B.mark == 1) return (Node)&#123;0, (B.y - A.b) / A.k, B.y&#125; ; if (A.mark == 2 &amp;&amp; B.mark == 0) return (Node)&#123;0, B.x, B.x * A.k + A.b&#125; ; if (A.mark == 0 &amp;&amp; B.mark == 2) return (Node)&#123;0, A.x, A.x * B.k + B.b&#125; ; return (Node)&#123;0, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b&#125; ; &#125;inline double gcd(double a,double b) &#123; if (fabs(b) &lt; Eps) return a ; if (fabs(a) &lt; Eps) return b ; return gcd(b, fmod(a, b)) ; &#125;int main()&#123; cin &gt;&gt; A.x &gt;&gt; A.y &gt;&gt; B.x &gt;&gt; B.y &gt;&gt; C.x &gt;&gt; C.y ; A.mark = B.mark = C.mark = 0 ; L[1] = get_Line(A, B), L[2] = get_Line(B, C), L[3] = get_Line(A, C) ; m1 = get_Mid(A, B), m2 = get_Mid(B, C), m3 = get_Mid(A, C) ; L[4] = get_verti(m1, L[1]), L[5] = get_verti(m2, L[2]) ; O = get_inter(L[4], L[5]), R = (dis(O, A) + dis(O, B) + dis(O, C)) / 3.0 ; Len[1] = dis(A, B), Len[2] = dis(B, C), Len[3] = dis(A, C) ; for (i = 1 ; i &lt;= 3 ; ++ i) agl[i] = acos(1 - Len[i] * Len[i] / (2 * R * R) ); agl[3] = 2 * Pi - agl[1] - agl[2], angle = gcd(agl[3], gcd(agl[1], agl[2])) ; printf("%.6lf\n", (Pi * R * R * sin(angle)) / angle) ; return 0 ;&#125; $\rm CF·2B$ 给定由非负整数组成的$n \times n$的正方形矩阵，寻找一条路径，以左上角为起点, 每次只能向右或向下走 以右下角为终点。并且，如果我们把沿路遇到的数进行相乘，积应当以最小数目的$0$的结尾. $n\leq 1,000$ 考虑$0$是怎么来的，那显然是$\times\text{=10}=2\times 5$。所以就把$2,5$分开$dp$。方程也很简单，就从左边和上边填一下表就好了。然后如果原来矩阵里面有$0$并且最后答案$&gt;1$，那么就应该走$0$；否则就输出路径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152inline int qwq(int &amp;N, int fac)&#123; if (!N) &#123; zerox = i, zeroy = j ; return 1 ; &#125; int res = 0 ; while (!(N % fac)) ++ res, N /= fac ; return res ;&#125;inline void Print(int x, int y, int mark, int kind)&#123; //mark 1 : D, 2 : R ; if (!x || !y) return ; // cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ; if (kind == 1)&#123; if (x - 1 &amp;&amp; dp2[x][y] == dp2[x - 1][y] + base[x][y][kind]) Print(x - 1, y, 1, kind) ; else if (y - 1 &amp;&amp; dp2[x][y] == dp2[x][y - 1] + base[x][y][kind]) Print(x, y - 1, 2, kind) ; &#125; else&#123; // cout &lt;&lt; dp5[x][y] &lt;&lt; " " &lt;&lt; dp5[x - 1][y] &lt;&lt; " " &lt;&lt; dp5[x][y - 1] &lt;&lt; endl ; if (x - 1 &amp;&amp; dp5[x][y] == dp5[x - 1][y] + base[x][y][kind]) Print(x - 1, y, 1, kind) ; else if (y - 1 &amp;&amp; dp5[x][y] == dp5[x][y - 1] + base[x][y][kind]) Print(x, y - 1, 2, kind) ; &#125; if (!mark) return ; if (mark == 1) printf("D") ; else printf("R") ;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= N ; ++ j) scanf("%d", &amp;base[i][j][0]) ; memset(dp2, 63, sizeof(dp2)), dp2[1][0] = dp2[0][1] = 0 ; memset(dp5, 63, sizeof(dp5)), dp5[1][0] = dp5[0][1] = 0 ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= N ; ++ j) dp2[i][j] = min(dp2[i - 1][j], dp2[i][j - 1]) + (base[i][j][1] = qwq(base[i][j][0], 2)) ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= N ; ++ j) dp5[i][j] = min(dp5[i - 1][j], dp5[i][j - 1]) + (base[i][j][2] = qwq(base[i][j][0], 5)) ; Ans = min(dp5[N][N], dp2[N][N]) ; if (Ans &gt; 1 &amp;&amp; zerox &amp;&amp; zeroy)&#123; cout &lt;&lt; 1 &lt;&lt; endl ; // cout &lt;&lt; zerox &lt;&lt; zeroy &lt;&lt; endl ; for (i = 1 ; i &lt; zerox ; ++ i) printf("D") ; for (i = 1 ; i &lt; zeroy ; ++ i) printf("R") ; for (i = zerox + 1 ; i &lt;= N ; ++ i) printf("D") ; for (i = zeroy + 1 ; i &lt;= N ; ++ i) printf("R") ; &#125; else &#123; cout &lt;&lt; Ans &lt;&lt; endl ; dp5[N][N] &gt; dp2[N][N] ? Print(N, N, 0, 1) : Print(N, N, 0, 2) ; &#125; return 0 ;&#125; $\rm CF ·2C$ 给出三个互不相交的圆，求一个点使得到这三个圆的切线夹角相同。 咋又是计算几何啊 设这点为$T$， 三个圆心分别为$A, B,C$。而圆$A$的半径$r_A$与$dis(A,T)$的比值，就是$sin(\frac{1}{2}\angle A_1TA_2)$，其中$A_1$和$A_2$是过T的圆A的两条切线与圆的交点。 那么也就是说，我们如果有$\angle A_1TA_2 = \angle B_1TB_2= \angle C_1TC_2$，那么一定有$$\frac{r_A}{dis(A,T)} = \frac{r_B}{dis(B,T)} = \frac{r_C}{dis(C,T)}$$ 稍微移一下项，就会有$$\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)} $$ 那么我们就可以发现，对于两个点而言，我们要找的目标点$T$满足到两个点的距离等于一个给定的比例（$r_A$和$r_B$给定）。 事实上，这样的点的轨迹是可以刻画的。我们列一个方程即可： 设比例系数为$k(k \geq 1)$, 那么： $$\frac{\sqrt{(x_T - x_A)^2 + (y_T - y_A)^2 }}{\sqrt{(x_T - x_B)^2 + (y_T - y_B)^2 }} = k\\\frac{(x_T - x_A)^2 + (y_T - y_A)^2 }{(x_T - x_B)^2 + (y_T - y_B)^2 } = k^2$$ 稍微移一下项就会得到$$(k^2-1)x_T^2 + (k^2-1)y_T^2 - 2(k^2y_B - y_A)y_T - 2(k^2x_B - x_A)x_T+k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2 = 0$$ 看起来有点儿长…… 令$A = k^2-1, C = - 2(k^2x_B - x_A), D = -2(k^2y_B - y_A), E = k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2$ 那么就会变成$$Ax^2 + Ay^2+ Cx + Dy+E = 0$$由于$A,C,D,E$都是常数，所以这是一个圆的一般方程。 我们其实也可以发现，当$k=1$时。此时为一条直线（即中垂线），换句话说当且仅当两个圆半径相等时，点$T$的轨迹是一条直线。其余的情况则是一个圆。 我们不妨先记这种到两个圆的圆心的距离成定比例的轨迹为两个圆的生成曲线。 那么之后呢，我们发现，圆$A$和圆$C$的生成曲线，与圆$A$和圆$B$的生成曲线，至多有两个交点。那么我们只需要： $(1)~~$判断三组圆的生成曲线是否都相交且交于一点，不是则无解。 $(2)~~$对于其中两个圆的生成曲线的交点，判断是否满足条件，即是我们已经找到了符合$$\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)}$$的点，我们需要判断对于圆$C$是否也满足$$\frac{r_A}{r_C} = \frac{dis(A,T)}{dis(C,T)}$$ $(3)~~$如果选取的生成曲线恰好有$2$个交点且两个交点$T’,T’’$都满足$(2)$中的条件，那么我们选$sin$值最大的（对于$\leq \frac{\pi}{2}$的角，$sin$值与角的大小成正相关）。 然后算法就结束了。中间还有好多好多好多问题，比如圆与圆的交点怎么求，直线与直线的交点怎么求，圆与直线的交点怎么求……果然是道体力题233 代码很繁琐233 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std ;const double Eps = 1e-3 ; int i ;//以下的mark都是记录状态struct Node&#123; int mark ; double xa, ya, xb, yb ; &#125; I[5] ; // 0 = inexist, 1 = exist*1, 2 = exist*2 ;//此处我的Node存的实际上是两个点，即一个一元二次方程的两个解。struct Line&#123; int mark ; double k, b ; double x, y ; &#125;L[12] ; //0 : // x-axis, 1: // y-axis, 2: // normal ;struct Circle&#123; int mark ; // 1 : circle ; 0 : Line ; double x, y, r ; double A, B, C, D, E ; Circle friend operator -(const Circle &amp;A, const Circle &amp;B)&#123; return (Circle)&#123;0, A.x - B.x, A.y - B.y, A.r - B.r, A.A - B.A, A.B - B.B, A.C - B.C, A.D - B.D, A.E - B.E&#125; ; &#125;&#125;C[10] ;double ansx, ansy ; bool check ;inline bool Comp(Node A, Node B)&#123; return A.mark &lt; B.mark ; &#125;inline double get_x(Line A, Line B)&#123; return A.mark == 0 ? A.x : B.x ; &#125; //which is (x = k) ;inline double get_y(Line A, Line B)&#123; return A.mark == 1 ? A.y : B.y ; &#125; //which is (y = k) ;inline bool equal(double x, double y)&#123; return (x - y &lt;= Eps) &amp;&amp; (x - y &gt;= -Eps) ; &#125;inline double disa(Node A, Node B)&#123; return sqrt((A.xa - B.xa) * (A.xa - B.xa) + (A.ya - B.ya) * (A.ya - B.ya)); &#125;//第一个点之间的距离inline double disb(Node A, Node B)&#123; return sqrt((A.xb - B.xb) * (A.xb - B.xb) + (A.yb - B.yb) * (A.yb - B.yb)); &#125;//第二个点之间的距离//呃……我承认两个dis写的很麻烦……但是好像也没什么很简单的法子inline Node Line_inter(Line A, Line B)&#123;//斜截式直线求交点（之前写的直接copy过来的） if (A.mark == B.mark &amp;&amp; (A.mark == 1 || A.mark == 0) ) return (Node)&#123;0, 0, 0, 0, 0&#125; ; if ((A.mark == 1 &amp;&amp; B.mark == 0) || (A.mark == 0 &amp;&amp; B.mark == 1)) return (Node)&#123;1, get_x(A, B), get_y(A, B), 0, 0&#125; ; if (A.mark == 1 &amp;&amp; B.mark == 2) return (Node)&#123;1, (A.y - B.b) / B.k, A.y, 0, 0&#125; ; if (A.mark == 2 &amp;&amp; B.mark == 1) return (Node)&#123;1, (B.y - A.b) / A.k, B.y, 0, 0&#125; ; if (A.mark == 2 &amp;&amp; B.mark == 0) return (Node)&#123;1, B.x, B.x * A.k + A.b, 0, 0&#125; ; if (A.mark == 0 &amp;&amp; B.mark == 2) return (Node)&#123;1, A.x, A.x * B.k + B.b, 0, 0&#125; ; return (Node)&#123;1, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b, 0, 0&#125; ; &#125;inline Node get_inter (Circle A, Circle B)&#123;//“生成曲线”求交点 if ((A.mark == 0 &amp;&amp; B.mark) || (A.mark &amp;&amp; B.mark == 0))&#123;//一条是直线，一个是圆 if (!A.mark) &#123;Circle C ; C = A, A = B, B = C ;&#125; // B is a line ; double a = 1 + (B.C / B.D) * (B.C / B.D), del ; double c = A.E - B.E * A.D / B.D + B.E * B.E /((B.D) * (B.D)) ; double b = (A.C - B.C * A.D / B.D + 2 * B.C * B.E /((B.D) * (B.D)) ) ; if ((del = (b * b - 4 * a * c)) &lt; -Eps) return (Node)&#123;0, 0, 0, 0, 0&#125; ; // printf("%lf %lf %lf %lf\n", a, b, c, del) ; double xa = (-b + sqrt(del)) / (2 * a), xb = (-b - sqrt(del)) / (2 * a) ; double ya = -B.C / B.D * xa - B.E / B.D, yb = -B.C / B.D * xb - B.E / B.D ; // cout &lt;&lt; "-----------------" &lt;&lt; xa &lt;&lt; " " &lt;&lt; ya &lt;&lt; " " &lt;&lt; xb &lt;&lt; " " &lt;&lt; yb &lt;&lt; endl ; return (Node)&#123;2, xa, ya, xb, yb&#125; ;//此处由于误差等原因，不容易判断是否delta=0的情况，所如果delta=0直接记录两遍，不影响结果 &#125; if (!A.mark &amp;&amp; !B.mark)&#123; Line La, Lb ; //两条都是直线，那么就直接转化成斜截式求。 if (!A.C) La = (Line)&#123;1, 0, 0, 0, - A.E / A.D&#125; ; else if (!A.D) La = (Line)&#123;0, 0, 0, -A.E / A.C, 0&#125; ; else La = (Line)&#123;2, -A.C / A.D, -A.E / A.D, 0, 0&#125; ; if (!B.C) Lb = (Line)&#123;1, 0, 0, 0, - B.E / B.D&#125; ; else if (!B.D) Lb = (Line)&#123;0, 0, 0, -B.E / B.C, 0&#125; ; else Lb = (Line)&#123;2, -B.C / B.D, -B.E / B.D, 0, 0&#125; ; return Line_inter(La, Lb) ; &#125; if (A.mark &amp;&amp; B.mark)&#123; Circle C = A - B ; return get_inter(C, A) ; //此处需要用到一点小知识，就是两个圆的交点很难求，但是我们可以通过相减求出交线来（必修二知识点），那么就直接把这条线代回第一个if里就好。 &#125;&#125;inline Circle make_rat(Circle A, Circle B)&#123;//rat = ratio[n.]比例；比率，用来求生成曲线的函数 double _k2 = (A.r / B.r) * (A.r / B.r) ; Circle Ans ; double t ; Ans.A = Ans.B = (_k2 - 1), Ans.C = -2 * (_k2 * B.x - A.x), Ans.D = -2 * (_k2 * B.y - A.y), Ans.E = (_k2 * B.x * B.x - A.x * A.x) + (_k2 * B.y * B.y - A.y * A.y), Ans.x = Ans.y = Ans.r = 0 ; if (Ans.A != 0) Ans.mark = 1, t = Ans.A, Ans.A /= t, Ans.B /= t, Ans.C /= t, Ans.D /= t, Ans.E /= t ; else Ans.mark = 0 ; return Ans ;&#125;inline void make_for_Ans()&#123;//最后的结果，判断选哪个交点 sort(I + 1, I + 3, Comp) ;//我闲的，方便一点 if (I[1].mark &lt;= 1) ansx = I[1].xa, ansy = I[1].ya ; else &#123; double A1, A11, B1, B11 ; I[1] = get_inter(C[4], C[5]) ; A1 = disa(I[1], (Node)&#123;0, C[1].x, C[1].y, 0, 0&#125;) / C[1].r ; A11 = disa(I[1], (Node)&#123;0, C[3].x, C[3].y, 0, 0&#125;) / C[3].r ; B1 = disb(I[1], (Node)&#123;0, 0, 0, C[1].x, C[1].y&#125;) / C[1].r ; B11 = disb(I[1], (Node)&#123;0, 0, 0, C[3].x, C[3].y&#125;) / C[3].r ; if (equal(A1, A11) &amp;&amp; !equal(B1, B11)) ansx = I[1].xa, ansy = I[1].ya ; else if (!equal(A1, A11) &amp;&amp; equal(B1, B11)) ansx = I[1].xb, ansy = I[1].yb ; else if (!equal(A1, A11) &amp;&amp; !equal(B1, B11)) check = 1 ;//如果在误差范围内都不相等就说明无解。 else &#123; double Ja = sin(1 / A1), Jb = sin(1 / B1) ;//比较角的大小，通过sin来搞 if (Ja &gt; Jb) ansx = I[1].xa, ansy = I[1].ya ; else ansx = I[1].xb, ansy = I[1].yb ; &#125; &#125;&#125;int main()&#123; for (i = 1 ; i &lt;= 3 ; ++ i) cin &gt;&gt; C[i].x &gt;&gt; C[i].y &gt;&gt; C[i].r ; C[4] = make_rat(C[1], C[2]), C[5] = make_rat(C[2], C[3]), C[6] = make_rat(C[3], C[1]), I[1] = get_inter(C[4], C[5]), I[2] = get_inter(C[5], C[6]), I[3] = get_inter(C[4], C[6]) ; /*cout &lt;&lt; I[1].xa &lt;&lt; " " &lt;&lt; I[1].xb &lt;&lt; " " &lt;&lt; I[1].ya &lt;&lt; " " &lt;&lt; I[1].yb &lt;&lt; " " &lt;&lt; I[1].mark &lt;&lt; endl ; cout &lt;&lt; I[2].xa &lt;&lt; " " &lt;&lt; I[2].xb &lt;&lt; " " &lt;&lt; I[2].ya &lt;&lt; " " &lt;&lt; I[2].yb &lt;&lt; " " &lt;&lt; I[2].mark &lt;&lt; endl ; cout &lt;&lt; I[3].xa &lt;&lt; " " &lt;&lt; I[3].xb &lt;&lt; " " &lt;&lt; I[3].ya &lt;&lt; " " &lt;&lt; I[3].yb &lt;&lt; " " &lt;&lt; I[3].mark &lt;&lt; endl ;*/ if (!I[1].mark || !I[2].mark || !I[3].mark) return putchar('\n'), 0 ; make_for_Ans() ; (!check) ? printf("%.5lf %.5lf", ansx, ansy) : 1 ; return 0 ; &#125; $\rm CF·3B$ 有一辆载重量为$v$的货车， 准备运送两种物品。 物品$A$的重量为$1$， 物体$B$的重量为$2$， 每个物品都有一个价值。 求货车可以运送的物品的最大价值。 $n\leq 100,000\quad v\leq 1e9$ 其实是一个非常简单的贪心思路，就是如果两件重量为1的商品合成一件的话，比重量为2的要优我们就选合起来的。 $\mathsf {Somebody}$谈过一个小Idea，就是看上去我们期望每次取偶数个。那么我们一开始如果$M$是奇数，就从重量为1的那一堆选一个最大的……（虽然我不知道这个到底有没有用但是听起来挺科学） 有些小细节需要注意。其中拿出来一个说一下：边界问题其实不需要考虑得太仔细，只要一开始memset整个数组为-INF，那么当一种重量的用完了，另一种重量的没用完时，取max之后不会出现越界的情况 1234567891011121314151617181920212223242526272829303132333435struct Data&#123; int num ,val ;&#125; base1[MAXN], base2[MAXN] ; int N, M, p, v, v1, v2, c ;long long Ans ; int tot1, tot2, t1, t2, i ; vector &lt;int&gt; ans ;inline bool Comp(Data a, Data b)&#123; return a.val &gt; b.val ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; memset(base1, -63, sizeof(base1)) ; memset(base2, -63, sizeof(base2)) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; scanf("%d%d", &amp;p, &amp;v) ; if (p &gt; 1) base2[++ tot2].val = v, base2[tot2].num = i ; else/*qwq*/base1[++ tot1].val = v, base1[tot1].num = i ; &#125; sort(base1 + 1, base1 + tot1 + 1, Comp), sort(base2 + 1, base2 + tot2 + 1, Comp) ; // for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base1[i].num &lt;&lt; " " &lt;&lt; base1[i].val &lt;&lt; " qwwq " ; // for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base2[i].num &lt;&lt; " " &lt;&lt; base2[i].val &lt;&lt; " qwwq " ; if (M &amp; 1) ans.pb(base1[1].num), Ans += base1[1].val, ++ t1, M -- ; while (M &gt; 1)&#123;//此处&gt;1是选v=2时防止越界 v2 = base2[t2 + 1].val ; if (t1 &gt;= tot1 &amp;&amp; t2 &gt;= tot2) break ; v1 = base1[t1 + 1].val + base1[t1 + 2].val ; if (t1 + 2 &gt; tot1) v1 = base1[t1 + 1].val, c = 1 ; else c = 2 ; if (v1 &gt;= v2)&#123; Ans += v1 ; M -= c ; rep(i, 1, c) ans.pb(base1[++ t1].num) ; &#125; else Ans += v2, M -= 2, ans.pb(base2[++ t2].num) ; &#125;//因为while的条件是M&gt;1,所以需要判断一下是不是还可以选。 if (M &amp;&amp; t1 &lt; tot1) Ans += base1[++ t1].val, ans.pb(base1[t1].num) ; if (Ans &lt; 0) return puts("0\n"), 0 ; cout &lt;&lt; Ans &lt;&lt; endl ; for (vector&lt;int&gt; :: iterator k = ans.begin() ; k != ans.end() ; ++ k) cout &lt;&lt; *k &lt;&lt; " " ; $\rm{CF·4D}$ 给出一个限制$(w,h)$和$n$个物品的二维信息$(w_i,h_i)$ 求物品二维都满足$w_i&gt;w,~h_i&gt;h$的前提下的最长二维严格上升子序列以及其长度$n \leq 5,000$ 一个比较显然的想法是，由于可以随便安排顺序，所以可以直接按其中一维排一个序，把这个当做下标，然后找另一维的$\mathsf {LIS}$。 那么由于是严格升序，所以要判一下相等。路径就照例是找前驱。 12345678910111213141516for (i = 1 ; i &lt;= N ; ++ i) &#123; scanf("%d%d", &amp;A, &amp;B), f[i] = 1 ; if (A &lt;= W || B &lt;= H) continue ; E[++ tot].w = A, E[tot].h = B, E[tot].num = i ; &#125; sort(E + 1, E + tot + 1, Comp) ; for (i = 1 ; i &lt;= tot ; ++ i) for (j = 1 ; j &lt; i ; ++ j) if (E[j].w &lt; E[i].w &amp;&amp; E[j].h &lt; E[i].h) if (f[i] &lt; f[j] + 1) &#123; f[i] = f[j] + 1, r[i] = j ; &#125; for (i = 1 ; i &lt;= tot ; ++ i) if (f[i] &gt; ans) ans = f[i], End = i ; while(End) s.push(End), End = r[End] ; cout &lt;&lt; ans &lt;&lt; endl ; while (!s.empty()) cout &lt;&lt; E[s.top()].num &lt;&lt; " ", s.pop() ; return 0 ; $\rm CF·5C$ 给出一个括号序列，求出最长合法子串和它的数量。 合法的定义：这个序列中左右括号匹配。 $n\leq 1,000,000$ 好像是道$sb$题？考虑把所有可以匹配的位置置为$1$，否则为$0$，那么答案就是有最长连续的$1$的段。$dp$一下就好了吧… 123456789101112131415161718char In[MAXN] ; stack &lt;int&gt; s ; int N, dp[MAXN], f[MAXN], base[MAXN] ; int main()&#123; scanf("%s", In + 1), N = strlen(In + 1) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; if (In[i] == '(') s.push(i)/*, cout &lt;&lt; "qwq" &lt;&lt; endl */; else if (!s.empty()) base[s.top()] = base[i] = 1, s.pop() ; &#125; int ans = 0 ; for (i = 1 ; i &lt;= N ; ++ i) if (base[i]) dp[i] = dp[i - 1] + 1 ; else dp[i] = 0 ; for (i = 1 ; i &lt;= N ; ++ i) f[i] = max(f[i - 1], dp[i]) ; cout &lt;&lt; f[N] &lt;&lt; " " ; int maxx = -1 ; for (i = 1 ; i &lt;= N ; ++ i) if (dp[i] == f[N]) ++ ans ; cout &lt;&lt; (f[N] ? ans : 1) &lt;&lt; endl ; return 0 ;&#125; $\rm CF·5D$ 有一个长度为$l$的道路，你的加速是$a$。 从$[0,d]$的限速是$w$，$[0,l]$的限速是$v$，问你最少花费多少时间从起点到终点。 $w$的限速范围是$[d,d]$，即是说保证在交通标志处的速度不超过$w$即为合法。 高中物理模拟题？？ 其实就是分类讨论一下就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445bool mark ; const double eps = 1e-7 ; double x_1, x_2, ans, x ;double vnow, a, vmax, L, D, vmaxd ;inline bool equal(double a, double b)&#123; if (b &gt; a) swap(a, b) ; return ((a - b &lt;= eps) &amp;&amp; (b - a &gt;= -eps)) ;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; vmax &gt;&gt; L &gt;&gt; D &gt;&gt; vmaxd ; vnow = sqrt(0.5 * (2 * a * D + vmaxd * vmaxd)) ; if (vnow &gt; vmax) vnow = vmax, mark = 1 ; x_1 = vnow * vnow / 2 / a, x_2 = (vnow * vnow - vmaxd * vmaxd) / 2 / a ; if (vnow &gt; vmaxd || equal(vnow, vmaxd))&#123;// if (!mark)&#123; ans += vnow / a + (vnow - vmaxd) / a ; if (x_1 + x_2 &lt; D) x = D - x_1 - x_2, ans += x / vnow ; /*&#125; else &#123; ans += vnow / a + (vnow - vmaxd) / a ; x = ans += x / vnow ; &#125;*/ &#125; else &#123; vnow = vmax, x = vnow * vnow / 2 / a ; if (x &lt; L || equal(x, L))&#123; ans = vnow / a, ans += (L - x) / vmax ; printf("%.9lf", ans) ; return 0 ; &#125; else &#123; vnow = sqrt(2 * a * L) ; ans = vnow / a, printf("%.9lf", ans) ; return 0 ; &#125; &#125; x = (vmax * vmax - vmaxd * vmaxd) / 2 / a ; if (x &lt; L - D || equal(x, L - D))&#123; ans += (vmax - vmaxd) / a, ans += (L - D - x) / vmax ; printf("%.9lf", ans) ; return 0 ; &#125; else &#123; vnow = vmaxd, x = sqrt(2 * a * (L - D) + vnow * vnow) ; ans += (x - vnow) / a, printf("%.9lf", ans) ; return 0 ; &#125;&#125; $\rm CF·5E$ 有$\mathsf n$座山组成一个环，两座山互相能看到的要求是相连的圆弧上没有任何其他的山高度比它们高，求能看到的山的组数。 $n\leq 100,000$ 一眼看上去就给人一股单调栈的味道……但是看上去要断环为链？但是如果断环为链的话，有些贡献会算重。但是考虑会算重的正好是算一遍只算一个序列的答案。但是这还不够，因为我们发现成链之后，最高值和次高值在$[1,n]$能互相看到，并且在$[1,n]$和$[n+1,2n]$的交界也能互相看到。所以应该把这部分减去。 1234567891011121314151617181920212223242526272829303132inline void init(int L)&#123; for (int i = 0 ; i &lt;= L ; ++ i) stack[i] = Mp(0, 0) ;&#125;inline int Solve(int M)&#123; init(M), ans = 0 ; register int i, tp = 0 ; for (i = 1 ; i &lt;= M ; ++ i) &#123; while (tp &amp;&amp; stack[tp].first &lt; base[i]) ans += stack[tp].second, -- tp ; if (stack[tp].first != base[i]) ans += (tp &gt; 0), stack[++ tp] = Mp(base[i], 1) ; else ans += (tp &gt; 1) + stack[tp].second, ++ stack[tp].second ; &#125; return ans ;&#125;signed main()&#123; cin &gt;&gt; N ; register int i ; for (i = 1 ; i &lt;= N ; ++ i) base[i + N] = base[i] = qr() ; pair&lt;int, int&gt; St, Ed ; St = Mp(-1, 0), Ed = Mp(-1, 0) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; if (St.first &lt; base[i]) Ed = St, St = Mp(base[i], 1) ; else if (St.first == base[i]) ++ St.second ; else if (Ed.first &lt; base[i]) Ed = Mp(base[i], 1) ; else if (Ed.first == base[i]) ++ Ed.second ; &#125; Ans = Solve(2 * N) - Solve(N), Ans -= (St.second * St.second + ((St.second == 1) ? Ed.second : 0)), cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $\rm CF·6D$ 有一队人，你可以用膜某个人，会对当前人造成$a$点伤害，对旁边的人造成$b$点伤害。血量没了就会伤透心。 不能膜$1$号和$n$号，求最少多少膜多少次让所有人伤透心。 $n\leq 10$ 看数据范围觉得是状压。后来发现其实就跟$\rm CF1110$的那个麻将题差不多，只需要记录$i-1$和$i$的状态即可。于是$f_{i,j,k}$表示前$i$个人，在$i-1$这里还剩$j$血，在$i$这里还剩$k$血，且前$i$个人都伤透心$\min$。然后记录一下路径就完了。 123456789101112131415161718192021222324252627282930int dp[MAXN][MAXN][MAXN] ;int N, a, b, blood[MAXN], i, j, k, l ; pair&lt;int, int&gt; From[MAXN][MAXN][MAXN] ; void Print(int step, int jj, int kk)&#123; if (step &lt;= 1) return ; Print(step - 1, From[step + 1][jj][kk].first, From[step + 1][jj][kk].second) ; int tow = dp[step][From[step + 1][jj][kk].first][From[step + 1][jj][kk].second] ; for (int qwq = 1 ; qwq &lt;= dp[step + 1][jj][kk] - tow ; ++ qwq) printf("%d ", step) ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; a &gt;&gt; b ; for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; blood[i], ++ blood[i] ; memset(dp, 63, sizeof(dp)), dp[2][blood[1]][blood[2]] = 0 ; for (i = 2 ; i &lt; N ; ++ i) for (j = 0 ; j &lt;= blood[i - 1] ; ++ j) for (k = 0 ; k &lt;= blood[i] ; ++ k)&#123; int down_ = (j + b - 1) / b ; if (dp[i][j][k] &gt; INF) continue ; int up_ = max(down_, max((blood [i + 1] + b - 1) / b, (k + a - 1) / a)) ; for (l = down_ ; l &lt;= up_ ; ++ l)&#123; int now_j = max(0, k - a * l) ; int now_k = max(0, blood[i + 1] - b * l) ; if (dp[i + 1][now_j][now_k] &gt; dp[i][j][k] + l) dp[i + 1][now_j][now_k] = dp[i][j][k] + l, From[i + 1][now_j][now_k] = Mp(j ,k) ; &#125; &#125; cout &lt;&lt; dp[N][0][0] &lt;&lt; endl ; Print(N - 1, 0, 0) ; return 0 ; &#125; $\rm CF ·6E$ 给一个$n$个元素的序列，从中挑出最长的子序列，要求子序列中元素差的最大值不超过$k$。问有几个最长子序列，子序列长度，以及这几个子序起始、终止位置。 $n\leq 100,000$ 憨批题。显然就是个单调队列，但是发现似乎并没有什么很诡异的限制，并且只要求一个最大值最小值。于是果断想到$st$表套二分，复杂度$n\log n-n\log^2 n$……被单调队列吊起来锤233 值得注意的一点是，$st$表回答询问的复杂度，大多数写法都是亚$\log $级别的，而不是传的神乎其神的$O(1)$。但其实只要预处理一下大于等于$x$的$2$的幂即可。 然后CSP前试机的时候顺便写出了单调队列的做法，代码大概长这样： 1234567891011int q[MAXN], p[MAXN] ;int l = 1, h1 = 1, t1 = 0, h2 = 1, t2 = 0 ;for (i = 1 ; i &lt;= N ; ++ i)&#123; while (h1 &lt;= t1 &amp;&amp; base[q[t1]] &lt; base[i]) t1 -- ; while (h2 &lt;= t2 &amp;&amp; base[p[t2]] &lt; base[i]) t2 -- ; q[++ t1] = p[++ t2] = i ; while (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; base[q[h1]] - base[p[h2]] &gt; K)&#123; l ++ ; while (q[h1] &lt; l) ++ h1 ; while (p[h2] &lt; l) ++ h2 ; &#125; ans = max(ans, s[i] - s[l - 1]) ;&#125; 然后是二分$st$表 12345678910111213141516171819202122232425262728293031323334353637383940inline void build_ST()&#123; register int H = log(N) / log(2) + 1 ; for (j = 1 ; j &lt;= H ; ++ j) for (i = 1 ; i + (1 &lt;&lt; j) &lt;= N + 1 ; ++ i) dp1[i][j] = max(dp1[i][j - 1], dp1[i + (1 &lt;&lt; j - 1)][j - 1]), dp2[i][j] = min(dp2[i][j - 1], dp2[i + (1 &lt;&lt; j - 1)][j - 1]) ;&#125;inline int query_max(int l, int r)&#123; register int k = 0 ; if (l == r) return base[l] ; while (l + (1 &lt;&lt; k) &lt;= r) ++ k ; return max(dp1[l][k - 1], dp1[r - (1 &lt;&lt; k - 1) + 1][k - 1]) ;&#125;inline int query_min(int l, int r)&#123; register int k = 0 ; if (l == r) return base[l] ; while (l + (1 &lt;&lt; k) &lt;= r) ++ k ; return min(dp2[l][k - 1], dp2[r - (1 &lt;&lt; k - 1) + 1][k - 1]) ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K ; for (i = 1 ; i &lt;= N ; ++ i) dp1[i][0] = dp2[i][0] = base[i] = qr() ; build_ST(), ans = 0 ; for (i = 1 ; i &lt;= N ; ++ i)&#123; L = i, R = N ; while (L &lt;= R)&#123; Mid = (L + R) &gt;&gt; 1 ; if (query_max(i, Mid) - query_min(i, Mid) &lt;= K) t = Mid, L = Mid + 1 ; else R = Mid - 1 ; &#125; L = t ; if (L - i + 1 &gt; ans) ans = L - i + 1, Ans[cnt = 1][0] = i, Ans[cnt][1] = L ; else if (L - i + 1 == ans) Ans[++ cnt][0] = i, Ans[cnt][1] = L ; &#125; cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; cnt &lt;&lt; endl ; for (i = 1 ; i &lt;= cnt ; ++ i) printf("%d %d\n", Ans[i][0], Ans[i][1]) ; return 0 ;&#125; $\rm CF·7C$ 给定一条直线：$Ax+By+C=0$（$A,B$不同时为$0$），找到任意一个点（在$-5e18$~$5e18$之间）让它的横纵坐标均为整数，或者确定没有这样的点。 sb的exgcd。我当时为什么要做这种题？$\rm Cf$又为什么要出这种题？qwq $\rm CF·7D$ 一个长度为$n$字符串$\sf S$被叫做$k$阶回文串，当且仅当它本身是一个回文串，而且它长度为$\lfloor \frac{n}{2}\rfloor$的前缀和后缀都是$k-1$阶回文串。任何一个字符串（包括空字符串）都至少是$0$阶字符串。举例来说，abaaba是3阶字符串。 现在给定你一字符串，请你求出其所有前缀的的阶级之和。 $|\sf S|\leq 5,000,000$ 似乎有时候哈希写的比较$6$这种题几乎是秒。考虑$f_i$表示以$i$为结尾的字符串的阶数，那么$$f_i=[\quad H[1…\lfloor \frac{i}{2}\rfloor]=H[i-\lfloor \frac{i}{2}\rfloor+1…i]\quad ]\cdot (f_{\lfloor \frac{i}{2}\rfloor}+1)$$ 答案就是$\sum f_i$ 1234567891011121314151617181920212223const long long base = 131 ;bool mark[MAXN] ;char S[MAXN] ; int N, Ans, i, j, h, ans[MAXN] ;long long base1[MAXN], base2[MAXN], times[MAXN] ;inline void init()&#123; times[0] = 1 ; for (i = 1 ; i &lt;= N ; ++ i) base1[i] = (base1[i - 1] * base + S[i]) % Mod ; for (i = 1 ; i &lt;= N ; ++ i) base2[i] = (base2[i - 1] * base + S[N - i + 1]) % Mod ; for (i = 1 ; i &lt;= N ; ++ i) times[i] = times[i - 1] * base % Mod ;&#125;int main()&#123; scanf("%s", S + 1), N = strlen(S + 1), init() ; for (i = 1 ; i &lt;= N ; ++ i)&#123; h = i / 2 ; long long t1 = base1[h] % Mod ; long long t2 = (base2[N - i + h] - (base2[N - i] * times[h] % Mod) + Mod) % Mod ; ans[i] = (t1 == t2) * (ans[h] + 1), Ans += ans[i] ; &#125; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ; &#125; $\rm CF·8C$ 平面上有$n\leq 24$个物品，pks从原点出发，求全部拾起并且回到原点行走的最短总距离。注意，他不能同时拿$&gt;2$件物品。 我寻思着这不就是个欧拉路……只不过加了个限制。那么还是$\sf f_S$表示拿完$\sf S$里的东西，所走的最小距离。每次枚举两个点转移即可。但是注意即使是$\rm Cf$的机子，$2^{24}\cdot 24^2$这东西也不可能跑出来。于是考虑一个剪枝，就是考虑如果把状态中的元素两两分组，那么考虑组与组之间是没有顺序可言的。于是就可以单调地枚举状态，合法就跳出。 1234567891011121314151617181920212223242526272829303132333435363738int dp[MAXN], Pre[MAXN], Max ;int N, D[50][50], i, j, k, bit[50], tp ; pair&lt;int, int&gt; Obj[50] ;int main()&#123; cin &gt;&gt; Obj[0].fr &gt;&gt; Obj[0].sc &gt;&gt; N ; for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; Obj[i].fr &gt;&gt; Obj[i].sc ; for (i = 0 ; i &lt;= N ; ++ i) for (j = 0 ; j &lt; i ; ++ j) D[i][j] = D[j][i] = (Obj[i].fr - Obj[j].fr) * (Obj[i].fr - Obj[j].fr) + (Obj[i].sc - Obj[j].sc) * (Obj[i].sc - Obj[j].sc) ; Max = (1 &lt;&lt; N) - 1 ; for (i = 1 ; i &lt;= Max ; ++ i) dp[i] = Inf ; for (i = 1 ; i &lt;= Max ; ++ i)&#123; memset(bit, 0, sizeof(bit)), tp = 0 ; for (j = 0 ; j &lt; N ; ++ j) if (1 &lt;&lt; j &amp; i) bit[++ tp] = j + 1 ; for (j = 1 ; j &lt;= tp ; ++ j) for (k = 1 ; k &lt;= tp ; ++ k)&#123; if (j != k)&#123; if (dp[i] &gt; dp[i ^ (1 &lt;&lt; bit[k] - 1) ^ (1 &lt;&lt; bit[j] - 1)] + D[bit[k]][bit[j]] + D[0][bit[k]] + D[0][bit[j]]) dp[i] = dp[i ^ (1 &lt;&lt; bit[k] - 1) ^ (1 &lt;&lt; bit[j] - 1)] + D[bit[k]][bit[j]] + D[0][bit[k]] + D[0][bit[j]], Pre[i] = i ^ (1 &lt;&lt; bit[k] - 1) ^ (1 &lt;&lt; bit[j] - 1) ; &#125; else if (dp[i] &gt; dp[i ^ (1 &lt;&lt; bit[k] - 1)] + D[0][bit[k]] + D[bit[k]][0]) dp[i] = dp[i ^ (1 &lt;&lt; bit[k] - 1)] + D[0][bit[k]] + D[bit[k]][0], Pre[i] = i ^ (1 &lt;&lt; bit[k] - 1) ; if (dp[i] &lt; 1061109567) break ; &#125; &#125; cout &lt;&lt; dp[Max] &lt;&lt; endl ; while (Max)&#123; cout &lt;&lt; 0 &lt;&lt; " " ; int qaq = Max ^ Pre[Max] ; for (i = 0 ; i &lt; N ; ++ i) if (1 &lt;&lt; i &amp; qaq) cout &lt;&lt; i + 1 &lt;&lt; " " ; Max = Pre[Max] ; &#125; cout &lt;&lt; 0 &lt;&lt; endl ; return 0 ;&#125; $\rm CF·9D$ 用$n$个点组成二叉树，问高度大于等于$h$的有多少个。 $n\leq 35$ 没有限制就是卡特兰数这不必说……但是如果跳出思维定式的话，考虑原来的$dp_i$表示前i个点组成二叉树的方案数，转移就是枚举两个子树——那么如果要考虑高度，只需要加一维高度$j$即可，正好是高度$+1-1$的关系。 123456789int main()&#123; cin &gt;&gt; N &gt;&gt; H ; int i, j, k ; for (i = 0 ; i &lt;= N ; ++ i) dp[0][i] = 1 ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= N ; ++ j) for (k = 0 ; k &lt; j ; ++ k) dp[j][i] += dp[k][i - 1] * dp[j - k - 1][i - 1] ; cout &lt;&lt; dp[N][N] - dp[N][D - 1] ;&#125; $\rm CF·10C$ 定义函数$s(x)$，$s(x)$的值等于$x$各数位上的数值之和，定义函数$d(x)$，当$s(x)\leq 9$时$d(x)=s(x)$，否则$d(x)=d(s(x))$。举例来说，$d(6543)=d(6+5+4+3)=d(18)=9$ 现在给定一上限$N$，求在$[1….N]$内任取$A$，$B$，$C$满足$A\cdot B\not =C$且$d(C)=d(d(A)⋅d(B))$的组数。 $N\leq 1000000$ 考虑$d()$的本质：$$d(x)=\left{\begin{array}{ll}{x \bmod 9,} &amp; {x \bmod 9 \neq 0} \ {9,} &amp; {x \bmod 9=0}\end{array}\right.$$那么其实$a\cdot b=c$就一定意味着$d(d(a)\cdot d(b))=d(c)$，所以启发我们可以先求出后一部分的，然后减去前一部分。那么前一半的就是$\leq n$所有数的约数个数和。而这东西有一个经典的$O(n)$做法，就是枚举每一个$i$对它的倍数产生贡献。 那么后一半就可以考虑按照余数分类做，然后乘法原理乘起来即可。 1234567891011long long N, base[20], A, B, i, j ; int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt;= N ; ++ i) base[i % 9] ++, B += N / i ; for (i = 0 ; i &lt;= 8 ; ++ i) for (j = 0 ; j &lt;= 8 ; ++ j) A += base[i] * base[j] * base[i * j % 9] ; cout &lt;&lt; A - B &lt;&lt; endl ; return 0 ;&#125; $\rm CF·10D$ 求两个串的最长公共上升子序列。 $n\leq 500$ $n\leq 5,000$ 第一个$subtask$，考虑$\sf f_{i,j}$表示$A$到$i$，$B$到$j$的最长公共上升子序列。那么转移的时候考虑多枚举一维$k$，当$A_i=B_j$时，可以从$k$转移过来。于是复杂度为$n^3$。 123456789for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j)&#123; dp[i][j] = dp[i - 1][j] ; if (base1[i] != base2[j]) continue ; dp[i][j] = 1 ; for (k = 1 ; k &lt; j ; ++ k) if (base2[k] &lt; base2[j] &amp;&amp; dp[i][j] &lt; dp[i - 1][k] + 1) dp[i][j] = dp[i - 1][k] + 1, f[j] = k ; &#125; 但是考虑其实$j$每次向右只加了$1$，所以对于同一个$i$，有很多决策都是重复的。换句话说就是这个决策（$k$）是否应该选，在$j=k$时就可以求出来，而不用再向前扫一遍，因为在$A_i$定住的时候是没区别的。 于是最后： 123456789101112131415161718192021void dfs(int x)&#123; if (!x) return ; dfs(pre[x]), printf("%d ", B[x]) ;&#125;int main()&#123; int i, j, k, n = 0 ; for (N = qr(), i = 1 ; i &lt;= N ; ++ i) A[i] = qr() ; for (M = qr(), i = 1 ; i &lt;= M ; ++ i) B[i] = qr() ; for (i = 1 ; i &lt;= N ; ++ i)&#123; int res = 0, befo = 0 ; for (j = 1 ; j &lt;= M ; ++ j)&#123; if (A[i] != B[j]) f[i][j] = f[i - 1][j] ; else f[i][j] = res + 1, pre[j] = befo ; if (B[j] &lt; A[i]) if (res &lt; f[i - 1][j]) res = f[i - 1][j], befo = j ; &#125; &#125; for (i = 1 ; i &lt;= M ; ++ i) if (ans &lt; f[N][i]) ans = f[N][i], n = i ; cout &lt;&lt; ans &lt;&lt; endl ; dfs(n) ; return 0 ;&#125; $\rm CF·11C$ 你有一个$01$矩阵。里面有多少个正方形？ 其中正方形的边用$1$表示。我们现在只对这些正方形感兴趣： 第一种：每条边与矩阵的边平行的正方形； 第二种：每条边与矩阵的对角线平行的正方形。 $t\leq 10,000\quad 2\leq n,m\leq 250$ 然后就是个搜索，用来练程序实现的。大概就是考虑八连通地去$\sf dfs$ ，然后只搜$1$不搜$0$，记录一下搜过的周长，然后去$check$ 。$check$主要就是分类讨论是平行对角线还是平行边长。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void dfs(int x, int y, int &amp;step)&#123; if (base[x][y] != 1) return void() ; base[x][y] = -1, ++ step ; for (int i = 0 ; i &lt; 8 ; ++ i)&#123; int kx = x + dx[i], ky = y + dy[i] ; if (kx &gt;= 1 &amp;&amp; kx &lt;= N &amp;&amp; ky &gt;= 1 &amp;&amp; ky &lt;= M) dfs(kx, ky, step) ; &#125; return void() ;&#125;int chk1(int step, int x, int y)&#123; if (x + step &gt; N || y + step &gt; M) return 0 ; for (int i = 1, j ; i &lt;= step ; ++ i)&#123; j = (base[x + i][y] != -1) | (base[x][y + i] != -1) | (base[x + step][y + i] != -1) | (base[x + i][y + step] != -1) ; if (j) return 0 ; &#125; return 1 ;&#125;int chk2(int step, int x, int y)&#123; int lx = step &lt;&lt; 1 ; if (x + lx &gt; N || y + step &gt; M) return 0 ; if (base[x + lx][y] != -1 || y &lt; step) return 0 ; for (int i = 1, j ; i &lt;= step ; ++ i)&#123; j = (base[x + lx - i][y - i] != -1) | (base[x + lx - i][y + i] != -1) | (base[x + i][y - i] != -1) | (base[x + i][y + i] != -1) ; if (j) return 0 ; &#125; return 1 ;&#125;int main()&#123; cin &gt;&gt; T ; int i, j ; while (T --)&#123; cin &gt;&gt; N &gt;&gt; M, ans = 0 ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j) scanf("%1d", &amp;base[i][j]) ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j)&#123; if (base[i][j] != 1) continue ; res = 0, dfs(i, j, res) ; if (res % 4 == 0 &amp;&amp; res / 4 &lt;= min(N, M)) ans += chk1(res / 4, i, j) + chk2(res / 4, i, j) ; &#125; cout &lt;&lt; ans &lt;&lt; endl ; &#125; return 0 ;&#125; $\rm CF·11D$ 求简单无向图的环数。 $n\leq 19$ 一开始想状压边，但是发现转移比较难转移并且状态数太多。于是就考虑定$\sf f_{s,u,v}$表示走过了集合$\sf s$中的点，起点为$u$终点为$v$的方案数。枚举转移的时候考虑刷表，枚举不在集合$\sf s$中的一个新点转移。 观察到其实转移时并不需要知道是从哪个点转移过来的，这东西也不影响方案数，所以直接默认是从lowbit转移过来的，这样每次需要判一下新的点会不会破坏这个状态的起点。 1234567891011121314cin &gt;&gt; N &gt;&gt; M, Mx = (1 &lt;&lt; N) - 1 ;for (i = 1, j = 0 ; j &lt; N ; ++ j, i &lt;&lt;= 1) f[i][j] = 1 ;for (i = 1 ; i &lt;= M ; ++ i) cin &gt;&gt; u &gt;&gt; v, u --, v --, A[u][v] = A[v][u] = 1 ;for (s = 1 ; s &lt;= Mx ; ++ s)&#123; for (i = 0 ; i &lt; N ; ++ i)&#123; if (!((1 &lt;&lt; i) &amp; s) || !f[s][i]) continue ; for (j = 0 ; j &lt; N ; ++ j)&#123; if (!A[i][j] || low(s) &gt; (1 &lt;&lt; j)) continue ; if ((1 &lt;&lt; j) == low(s) &amp;&amp; (1 &lt;&lt; j &amp; s)) ans += f[s][i] ; else if (!(1 &lt;&lt; j &amp; s)) f[s | (1 &lt;&lt; j)][j] += f[s][i] ; &#125; &#125;&#125;cout &lt;&lt; ((ans - M) &gt;&gt; 1) &lt;&lt; endl ;]]></content>
      <categories>
        <category>题解</category>
        <category>Codefoces</category>
      </categories>
      <tags>
        <tag>动态规划-普通DP</tag>
        <tag>贪心</tag>
        <tag>动态规划-状压DP</tag>
        <tag>数学/扩展欧几里得</tag>
        <tag>计算几何/基础的点、直线与圆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Codeforces Round-840 Virtual]]></title>
    <url>%2F2019%2F11%2F14%2FCodeforces-840%2F</url>
    <content type="text"><![CDATA[virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233 $A$ Leha喜欢各种各样奇怪的事。最近他喜欢上了函数$F(n,k)$。考虑所有集合$[1,2,\dots,n]$ 的有$k$个元素的子集。为这些子集找到其中最小的元素。$F(n,k)$ — 就是所有$k$个元素子集中的最小元素的数学期望。 但是仅仅这个函数还不够使他高兴。他想要在这上面做一些更有趣的事情。他的妈妈给他带来了两个数组$A$和$B$，每个都有$m$ 个整数。对于所有的$i,j$ （$1\leq i,j\leq m$）都有$a_i\geq b_j$。帮助Leha重新排列$A$数组来使得有最大的$\sum_{i=1}^m F(A_i’,B_i)$ ，$A$ 是重排后的数组。 $n\leq 10^5$ 刚看到这题发现可以猜结论233……通过观察样例可以发现，应该是第二个序列中第$k$小的对应第一个序列中第$k$大的…… 然后证明，考虑对$F(n,k)$进行变形（以下是$\mathsf{\color{black}{B}\color{red}{enq}}$的过程）$$\begin{aligned}F(n,k)&amp;=\frac{\binom{n-1}{k-1}+2 \cdot \binom{n-2}{k-1}+3 \cdot \binom{n-3}{k-1}+\dots}{\binom{n}{k}}\\&amp;=\frac{\binom{n-1}{k}+\binom{n-2}{k}+\binom{n-3}{k}+\dots}{\binom{n}{k}}\\&amp;=\frac{\binom{n+1}{k+1}}{\binom{n}{k}}\\&amp;=\frac{n+1}{k+1}\end{aligned}$$然后就是对于每一项，都应该让$k+1$尽量小，让$n+1$尽量大，就变成了一个贪心问题了233 $B$ 给定你一些边，可能有重边。对于每个点给定一个$d_i$，如果为$1$表示这个点的度数为奇数，$0$表示这个点的度数为偶数，为$-1$表示这个点的度数没有限制。 你需要选出一些边（不一定联通），使得这些边构成的图符合要求。 $n\leq 3\cdot 10^5$ 首先考虑如果没有-1并且奇度点数量为奇数，那么一定无解。因为整张图的度数之和一定是$2m$为偶数。 发现似乎最简单的方式是生成一棵树，于是决定生成树；并且根据上一句的性质，只要任意时刻保证度数为和偶数即可（不要求连通）。 然后分类讨论：0的点和1的点 0的点。直接忽略，因为不产生影响； 1的点。选择它的上行边、取反其父亲并且忽略这个点。原因还是度数和不变。 于是可知这是一个合理的方案……直观上很难感觉起来是对的，但是只要紧握住“度数和为偶数”这个性质不变即可。代码实现上也可圈可点，每个点的状态在没遍历完整棵子树时都是未知，是很鲜明的信竞特点……总之我不会，学到了。 1234567891011121314151617181920212223242526//e.g.2: -1表示不能有一种方案，而0则表示我如果一条边都不选，依旧可以满足这个条件 bool vis[MAXN] ;bool ST(int u)&#123; vis[u] = 1 ; int ret = base[u] ; for (int k = head[u] ; k ; k = E[k].next)&#123; if (vis[to(k)]) continue ; if (ST(to(k))) res[++ tot] = (k + 1) &gt;&gt; 1, ret ^= 1 ; &#125; if (base[u] &lt; 0) ret = 0 ; return ret ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]), (base[i] &lt; 0) ? mr1 = i : (mr2 ^= base[i]) ; if (!mr1 &amp;&amp; mr2) return puts("-1"), 0 ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%d%d", &amp;A, &amp;B), Add(A, B) ; ST(mr1 ? mr1 : 1) ; cout &lt;&lt; tot &lt;&lt; endl ; sort(res + 1, res + tot + 1) ; for (i = 1 ; i &lt;= tot ; ++ i) printf("%d ", res[i]) ;&#125; $C$ 给定$n(1≤n≤300)$个数，求问有多少种排列方案使得任意两个相邻的数之积都不是完全平方数。由于方案数可能很大，输出方案数$\bmod 10^9+7$的值。 考虑相邻两个数之积是完全平方数的充要条件，当且仅当将两个数的所有质因子次数$\bmod ~2$后，两个数相同时，其乘积才会为完全平方数。 那么也就是说，这种性质可以传递，即$a\cdot b$为完全平方数，$b\cdot c$为完全平方数，那么$a\cdot c$也是。于是可以对所有的数暴力分组，每个组找一个代表元来记录。设每一组中有$cnt_i$个数，前$i$个组的$cnt$前缀和为$s_i$。 那么问题转化成了给定$n$个数，同一组的元素不能放在一起，求排列数。那么就是$f_{i,j}$表示前$i$个组，有$j$对相邻元素的乘积为完全平方数的排列数，转移时考虑，枚举当前这一组被分成了$k$块，插板法插出来的方案数为$\binom{cnt_i-1}{k-1}$，并且会多加上$cnt_i-k$个不合法的位置；然后考虑这$k$块插到了上一个状态中，$j$对不合法相邻的数中，$o$对不合法的数之间（即有$o$对数被拆开了），那么就会少$o$对非法数对。然后就是$\binom{j}{o}$。考虑剩下的了$k-o$块，这$k-o$块可以放到$s_i-j+1$个正常的空隙里面，于是再乘一个$\binom{s_i-j+1}{k-o}$$$f_{i,j+cnt_i-k-o}=f_{i-1,j}\times \sum\limits_{k\leq cnt_i,l\leq j} (cnt_i!)\cdot \binom{cnt_i-1}{k-1} \cdot \binom{s_i-j+1}{k-o}\cdot \binom{j}{o}$$ 1234567891011121314151617181920212223242526272829303132333435inline ll expow(ll d, ll z)&#123; ll res = 1 ; if (d == 1) return 1 ; while (z)&#123; if (z &amp; 1) (res *= d) %= Mod ; ( d *= d ) %= Mod, z &gt;&gt;= 1 ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N, dp[0][0] = 1 ; for (i = 1 ; i &lt;= N ; ++ i)&#123; cin &gt;&gt; base[i] ; bool mk = 0 ; for (j = 1 ; j &lt;= cnt ; ++ j)&#123; ll p = trunc(sqrt(base[i] * grp[j])) ; if (p * p == base[i] * grp[j])&#123;++ tm[j], mk = 1 ; break ; &#125; &#125; if (!mk) grp[++ cnt] = base[i], tm[cnt] = 1 ; &#125; for (Cm[0][0] = 1, i = 1 ; i &lt;= N ; ++ i) Cm[i][0] = 1 ; for (Frac[0] = 1, i = 1 ; i &lt;= N ; ++ i) Frac[i] = Frac[i - 1] * i % Mod ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= i ; ++ j) Cm[i][j] = (Cm[i - 1][j] + Cm[i - 1][j - 1]) % Mod ; for (i = 1 ; i &lt;= cnt ; tot += tm[i], ++ i) for (j = 0 ; j &lt;= tot ; ++ j) for (k = 1 ; k &lt;= tm[i] ; ++ k) for (l = 0, t = tm[i] - k + j ; l &lt;= j ; ++ l, t --) if(t &gt;= 0 &amp;&amp; t &lt; N) (dp[i][t] += Frac[tm[i]] * Cm[tm[i] - 1][k - 1] % Mod * Cm[j][l] % Mod * Cm[tot - j + 1][k - l] % Mod * dp[i - 1][j] % Mod) %= Mod ; cout &lt;&lt; dp[cnt][0] &lt;&lt; endl ; return 0 ; &#125; $D$这个D曾经单独写过：Link 233反正就是乱搞就对了]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>思维题/计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Codeforces Round-711 Virtual]]></title>
    <url>%2F2019%2F11%2F14%2FCodeforces-711%2F</url>
    <content type="text"><![CDATA[一个马来西亚老哥出的一场Div2，题目还算有点意思，于是就virtual了后三个题。 $C$ 给定一段序列，要对着短序列进行涂色。有些位置涂了色，就不能再涂了；没涂色的位置可以涂任意颜色，同一个位置$i$涂不同的颜色$j$有不同的代价。求将整个序列涂成$k$个颜色段的最小代价。 $n,m\leq 100$ 一眼$dp$。然后就是设计状态，记$\mathsf {f_{i,j,k}}$表示前$i$个涂成了$j$段，最后一段颜色是$k$的最小代价，暴力转移即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546cin &gt;&gt; N &gt;&gt; M &gt;&gt; K ; for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; base[i] ;for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j) cin &gt;&gt; val[i][j] ;for (i = 0 ; i &lt;= N ; ++ i) for (j = 0 ; j &lt;= K ; ++ j) for (k = 0 ; k &lt;= M ; ++ k) dp[i][j][k] = Inf ; /*for (i = 1 ; i &lt;= N ; ++ i) for (j = i - 1 ; j &gt;= 1 ; -- j) if (base[j]) &#123;pos[i] = j + 1 ; break ;&#125;*//*for (i = 1 ; i &lt;= N ; ++ i)&#123; for (j = 1 ; j &lt; i; ++ j) if (j &gt;= pos[i])&#123; for (k = 1 ; k &lt;= M ; ++ k) for (l = 1 ; l &lt;= M ; ++ l) for (w = 1 ; w &lt;= K ; ++ w) if (l != k) dp[i][w][k] = max(dp[i][w][k], dp[j][w - 1][l] + ) ; &#125; else &#123; &#125;&#125;*/if (base[1]) dp[1][1][base[1]] = 0 ;else for (i = 1 ; i &lt;= M ; ++ i) dp[1][1][i] = val[1][i] ;for (i = 2 ; i &lt;= N ; ++ i)&#123; for (j = 1 ; j &lt;= K ; ++ j)&#123; if (!base[i])&#123; for (k = 1 ; k &lt;= M ; ++ k)&#123; dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j][k] + val[i][k]); for (l = 1 ; l &lt;= M ; ++ l) if (k != l) dp[i][j][k] = min(dp[i][j][k], dp[i - 1][j - 1][l] + val[i][k]) ; &#125; &#125; else&#123; dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - 1][j][base[i]]) ; for (k = 1 ; k &lt;= M ; ++ k ) if (k != base[i]) dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - 1][j - 1][k]) ; &#125; &#125;&#125;for (Ans = Inf, i = 1 ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][K][i]) ; cout &lt;&lt; (Ans == Inf ? - 1 : Ans) &lt;&lt; endl ; return 0 ; $D$ 有$n$个点和$n$条边，第$i$条边从$i$连到$a_i$ 。 每条边需要指定一个方向（无向边变为有向边）。问有多少种指定方向的方案使得图中不出现环 一道计数题，但是比较睿智。给定的图显然是一堆基环树。那么考虑不在环上的边显然怎么定向都无所谓，在环上的边也只会是恰好都顺时针或者恰好都逆时针不合法。乘法原理乘起来就完了。 好早之前做的题了，然后当时这题卡了半天原因是我忘了怎么dfs找环了……大概就是祖先记一记，树上游一游，就做完了…类似于tarjan？…可海星 123456789101112131415161718192021inline ll expow(int b)&#123; ll res = 1, base = 2 ; while (b)&#123; if (b &amp; 1) res = res * base % Mod ; (base *= base) %= Mod, b &gt;&gt;= 1 ; &#125; return res ;&#125;void dfs(int u, int deep)&#123; dep[u] = deep, vis[u] = 1 ; for (int k = head[u] ; k ; k = E[k].next)&#123; if (!vis[to(k)]) dfs(to(k), deep + 1) ; else if (vis[to(k)] &lt;= 1) rop[++ tot] = dep[u] - dep[to(k)] + 1 ; &#125; vis[u] = 3 ;&#125;int main()&#123; cin &gt;&gt; N, Ans = 1 ; int qaq ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;qaq), Add(i, qaq) ; for (i = 1 ; i &lt;= N ; ++ i) if ( !dep[i] ) dfs(i, 1) ; cnt = 0 ; for (i = 1 ; i &lt;= tot ; ++ i) cnt += rop[i], (Ans *= (expow(rop[i]) - 2 + Mod)) %= Mod ; Ans = Ans * expow(N - cnt) % Mod ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $E$ 求一年有$2^n$天，$k$个人出现两人生日相同的可能性是多少。 $n,k\leq 10^{18},\rm Mod=1e6+3$ 首先考虑答案就是$$\frac{\prod\limits_{i=2^n-k+1}^{2^n-1}i}{2^{n \cdot {k-1}}}$$然后就变成了如果把这个东西求出来传统艺能.jpg 1、如果$k&gt;P=1e6+3$，那么根据抽屉原理分子中肯定至少有一项$\bmod \rm P=0$。 2、因为分母是$2$的幂，所以最后实际上就是在求分子中有多少个$2$乘起来 3、考虑如何求分子有多少个$2$。考虑一个引理，就是$2^n-m$和$m$中的$2$的个数一样。证明大概就是考虑令$m=2^p\cdot q$，其中$p$为极大的$2$的幂指数，那么$2^n-m=2^n-2^p\cdot q=2^p(2^{n-p}-q)$。根据整除的性质$a|b-c,a|b\Longleftrightarrow a|c$，而$2\not| ~~ q$，所以$2^n-m$中$2$的次数就是$p$. 4、然后由3中的引理，就有一个比较经典的做法。就是我们可以得到$$\begin{aligned}(\prod\limits_{i=2^n-k+1}^{2^n-1}i,2^n)&amp;=(\prod\limits_{i=2^n-k+1}^{2^n-1}(2^n-i), 2^n)\ &amp;=(\prod\limits_{i=1}^{k}i,2^n)\ &amp;=(k!,2^n)\end{aligned}$$ 再结合抽屉原理，只需要枚举$2$的幂就可以算了。 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#define Mod 1000003#define ll long longusing namespace std ; ll Son, Mom ;ll N, M, Inv, _gcd, qwq, i, base = 1, ans = 1 ;inline ll expow(ll x, ll y)&#123; ll res = 1 ; while (y)&#123; if (y &amp; 1) (res *= x) %= Mod ; (x *= x) %= Mod, y &gt;&gt;= 1 ; &#125; return res % Mod ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 1 ; i &lt;= N ; ++ i)&#123; base &lt;&lt;= 1 ; if (base &gt;= M) &#123; ans = 0 ; break ;&#125; &#125; if (ans) return puts("1 1"), 0 ; Son = 1 ; for (i = 2 ; i &lt;= M - 1 ; i &lt;&lt;= 1) qwq += (M - 1) / i ; _gcd = expow(2, qwq), Inv = expow(_gcd, Mod - 2) ; Mom = expow(2, N % (Mod - 1) * (M - 1) % (Mod - 1)) ; (Mom *= Inv) %= Mod ; if (M - 1 &gt;= Mod) return printf("%I64d %I64d", Mom, Mom), 0 ; for (i = 1 ; i &lt; M ; ++ i) Son = Son * (expow(2, N) - i + Mod) % Mod ; (Son *= Inv) %= Mod, Son = ((Mom - Son) % Mod + Mod) % Mod ; cout &lt;&lt; Son &lt;&lt; " " &lt;&lt; Mom &lt;&lt; endl ; &#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>动态规划-普通DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【赛题整理】校内模拟赛选整 · E2]]></title>
    <url>%2F2019%2F11%2F14%2Fxiaone-2%2F</url>
    <content type="text"><![CDATA[校内模拟赛第二弹 $A$ $𝑁$座楼房，立于城中。第$𝑖$座楼，高度$ℎ_𝑖$。你需要一开始选择一座楼，开始跳楼。在第𝑖座楼准备跳楼需要$𝑐_𝑖$的花费。 每次可以跳到任何一个还没有跳过的楼上去。跳楼有代价，每次跳到另外一座楼的代价是两座楼高度的差的绝对值，最后一次从楼上跳到地面上不需要代价（只能跳到地上一次）。求在代价不超过𝑇的情况下，最多跳几次楼。 性质题，找不出来人似乎就没了233 考虑最优情况下肯定会是单调地跳，即要么单增地跳，要么单减地跳。这样就可以设计状态了$f_{i,j}$为跳到$i$，跳了$j$栋楼最小代价，然后枚举一遍状态即可。 $B$ 小$c$切LuoguP5487这题，但是菜如小$c$，他写挂了。 小$c$开始了漫长的debug的阶段，2天过去了小$c$还是没有找到自己程序哪里写错了。于是他打印了自己所有函数的出入口的信息。对于小$c$写的第$i$个函数，他的入口会输出$+i$，他的出口会输出$-i$。 等到他把所有的输出打出来时，发现由于字符集的问题前面的符号消失了。但是他隐约记得某几个函数的出口的输出位置。现在小$c$想知道一个可能的打印序列，如果不存在输出NO 题解里面写这题可以倒着做，即从后向前扫，如果这个括号没有指定成右括号而且他是左括号合法，则标记为左括号；否则为右括号。跑完之后看看是否合法。思想大概就是诡异的贪心，因为左括号只会被“安排”，为了保证左/右平衡，故选择对左括号贪心。 我也是贪心做的，不过是正着做的。没有限制时，如果上一个是(，那我这一个就安排成)就好了，但算上限制时，出问题的就是会把一些左括号限制为右括号，即“强制嵌套”。那么如果原本是()(这样，第三个括号被强制为右括号，就顺便把前一个右括号改成(，即变为(()，留着去跟后面的匹配。合不合法最后再$check$一遍就好了。 12345678910111213141516171819202122cin &gt;&gt; N ; int i, j ;for (i = 1 ; i &lt;= N ; ++ i) base[i] = qr() ; for (cin &gt;&gt; M, i = 1 ; i &lt;= M ; ++ i) ok[qr()] = 1 ; for (i = 1 ; i &lt;= N ; ++ i)&#123; if (ok[i] &amp;&amp; !stk[base[i]].size())&#123; ans[i] = 1 ; stk[base[i]].pb(mat[buc[base[i]]]) ; ans[i] = 1, ans[mat[buc[base[i]]]] = ans[buc[base[i]]] = 0 ; mat[i] = buc[base[i]], mat[buc[base[i]]] = i ; buc[base[i]] = i ; &#125; else if (!stk[base[i]].size()) stk[base[i]].pb(i), ans[i] = 0 ; else mat[i] = stk[base[i]].back(), ans[i] = 1, mat[stk[base[i]].back()] = i, stk[base[i]].pop_back(), buc[base[i]] = i ; &#125; for (i = 1 ; i &lt;= N ; ++ i) if (!ans[i]) stack[++ t] = i ; else if (!t) return puts("NO"), 0 ; else stack[t --] = 0 ; if (t) return puts("NO"), 0 ; for (i = 1 ; i &lt;= N ; ++ i)&#123; printf("%c%d ", ans[i] ? '-' : '+', base[i]) ;&#125; $C$ 给定$n\leq 1,000$。求最少需要多少不同的$a_i\in[1,n]$，使得$\forall x, 1\leq x\leq n$，总可以选出某个${a}$的子集来凑出$x$。同时，求最小$|{a}|$下凑出所有$x$的方案总数。 第一问是个贪心……贪心……就是二进制分解的思路，$n$的二进制位数就是答案。感觉如果要证明，证明起来其实是挺自然的。考虑首先二进制划分一定是合法的，同时如果将其中的$&gt;1$个换出去，那么一定凑不出$1$~$n$的所有数。 第二问据说是一个经典的$dp$。考虑状态$f_{i,j,k}$表示带了$i$枚金币，和为$j$，最大值为$k$的方案数。然而对我来说状态并不是很容易定义……emmm。转移的话采用刷表法比较简单，考虑对于一个状态$f_{i,j,k}$，枚举比$k$大的$o$，那么就有$f_{i,j,k}\to f_{i+1,\min(j+o,n),l}$ . $D$ 已知C国有n个城市，城市间有m条双向道路，每条路有限重。JD公司想修建一些仓库来实现对C国所有城市的配送，仓库必须修建在某个城市。送达每个城市的货物可以由任意一个仓库发出，不过在运输途中必须满足限重的要求。 JD公司想让你设计一个程序来帮助高管决策，q次询问，每次询问计算如果想配送重量为w的物品，至少需要建多少个仓库。 质疑题面在恰饭 一个比较显然的思想就是建出最大生成树来。然后比较常规的做法就是边建树边飞询问，考虑加完第一条载重为$val$边之前，现在的连通块个数就是重量为$val-1$的询问的答案，于是离线下来飞就可以了。 然后这东西也可不离线下来再去飞询问。观察性质可以发现假设现在询问的重量为$w_q$，那么对于所有限重$w_o&lt;w_q$的边，一定会分成两个连通块。于是可以直接把最大生成树的边排一个序，然后二分出$&lt;w_q$的个数即为答案。 $E$ 给定一个字符串，每次询问一个子串中$A$的个数和$B$的个数的比值为$x:y$的子串的最长长度。 $n,q\leq 100,000$ 一开始我是真没想写这题……但是想了个线段树发现自己假了，然后就被迫入坑。。 考虑推式子$$\frac{A_r-A_{l-1}}{B_r-B_{l-1}}=\frac{x}{y}\\x\cdot (B_r-B_{l-1})=y\cdot (A_r-A_{l-1})\\y \cdot A_r-x \cdot B_r=y \cdot A_{l-1}-x \cdot B_{l-1}$$然后如果我们令$val_i=y\cdot A_i-x \cdot B_i$，那么求的就是区间内相同的数相隔的最长距离。天真的我以为这题可以线段树，然后就很开心地想做……去uoj群里问了一圈发现这个被lxl规约到了$n \sqrt n$的问题上面…… 然后就觉得，大概可以莫队吧。于是就想上莫队，结果发现这东西似乎并不是很好统计……于是写了半天之后毅然决然地写了一个线段树。最终在luogu上二分这个题的时限，卡到了100ms~6500ms这个范围……然后最终复杂度就应该是$n\sqrt q \log n$。 然后莫队确实可以卡常，大概就是不要傻傻地真把$Q$分成$\sqrt Q$块，因为常数因子导致均值不等式搞出来的结果没有那么对；然后莫队的cmp可以这么写： 1234il bool cmp(qrs a, qrs b) &#123; return (blg[a.l] ^ blg[b.l]) ? blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);&#125; 奇数块正着排，偶数块倒着排，就会快好多。 然后最后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//写了一下午QAQchar s[MAXN] ;struct qrs&#123; int l, r, id ;&#125;q[MAXN] ; int l, r, buc[MAXM], val[MAXN] ;int blg[MAXN], T[MAXM &lt;&lt; 2], ans[MAXN], Pre[MAXN], Nxt[MAXN] ;int N, X, Y, M, S, U, base[MAXN], cnt[2][MAXM], pre[MAXN][2], res, res2 ;il int qr()&#123; char c = getchar() ; int res = 0 ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res ;&#125;il bool comp(qrs a, qrs b) &#123; return blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;&#125;il bool cmp(qrs a, qrs b) &#123; return (blg[a.l] ^ blg[b.l]) ? blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; 1) ? a.r &lt; b.r : a.r &gt; b.r);&#125;void update(int rt, int L, int R, int p, int v)&#123; int mid = (L + R) &gt;&gt; 1 ; if (L == R) return T[rt] = v, void() ; if (p &lt;= mid) update(rt &lt;&lt; 1, L, mid, p, v) ; else update(rt &lt;&lt; 1 | 1, mid + 1, R, p, v) ; T[rt] = max(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]) ;&#125;void del(int p)&#123;// cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ; if (p == cnt[0][val[p]]) cnt[0][val[p]] = Nxt[p] ; if (p == cnt[1][val[p]]) cnt[1][val[p]] = Pre[p] ;// cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ; update(1, 0, MAXM, val[p], cnt[1][val[p]] - cnt[0][val[p]]) ; res = T[1] ;// cout &lt;&lt; T[1] &lt;&lt; endl ;// cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;&#125;void upd(int p)&#123; cnt[0][val[p]] = min(cnt[0][val[p]], p) ; cnt[1][val[p]] = max(cnt[1][val[p]], p) ; update(1, 0, MAXM, val[p], cnt[1][val[p]] - cnt[0][val[p]]) ; res = T[1] ;// cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; X &gt;&gt; Y ; int i, j ; for (scanf("%s", s + 1), i = 1 ; i &lt;= N ; ++ i) base[i] = s[i] - 'A', pre[i][base[i]] = pre[i - 1][base[i]] + 1, pre[i][base[i] ^ 1] = pre[i - 1][base[i] ^ 1] ; for (i = 0 ; i &lt;= N ; ++ i) val[i] = MAXN + Y * pre[i][0] - X * pre[i][1] ; memset(buc, -1, sizeof(buc)) ; for (i = 0 ; i &lt;= N ; ++ i) Pre[i] = buc[val[i]], buc[val[i]] = i ; memset(buc, 0, sizeof(buc)) ; for (i = N ; i &gt;= 0 ; -- i) Nxt[i] = buc[val[i]] ? buc[val[i]] : N + 1, buc[val[i]] = i ; M = qr() ; S = pow(M, 0.5832) ; U = ceil((double)M / S) ; memset(cnt[0], 63, sizeof(cnt[0])) ; memset(cnt[1], -1, sizeof(cnt[1])) ; for (i = 1 ; i &lt;= U ; ++ i) for (j = (i - 1) * S + 1 ; j &lt;= i * S ; ++ j) blg[j] = i ; for (i = 1 ; i &lt;= M ; ++ i) q[i].l = qr() - 1, q[i].r = qr(), q[i].id = i ; sort(q + 1, q + M + 1, comp) ; l = 0, r = -1 ; for (i = 1 ; i &lt;= M ; ++ i)&#123; while (r &lt; q[i].r) upd(++ r) ; while (l &lt; q[i].l) del(l ++) ; while (l &gt; q[i].l) upd(-- l) ; while (r &gt; q[i].r) del(r --) ; ans[q[i].id] = res ; &#125; for (i = 1 ; i &lt;= M ; ++ i) printf("%d\n", ans[i]) ; return 0 ;&#125; 不知道为啥rqy写的莫队套线段树加了个看不太透的优化比我快了一倍，迷乱233 $F$ 你的花田一共由$n-2$片花田组成，编号从$1$到$n-2$。 算上你的家和花店，一共有$n$个地点，其中你的家编号为$0$，花店编号为$n-1$。即，家、花田、花店都属于地点，且它们都有一个唯一的$0$~$n-1$的编号。有$m$条双向道路连接这些地点。保证所有地点间都是直接或间接连通的。 你需要从家里出发，经过所有的花田进行收获，再到达花店，再从花店出发经过所有花田进行播种，最后重新回到家中。当你经过一片花田的时候，你可以选择收获、播种或者什么事都不做，也就是说你经过一片未收割的花田时可以不立即收割它，播种亦然。然而，播种必须发生在你完成了所有收获并到花店交货之后。在完成最后一个花田的收获后，你必须在到达花店后才能开始播种。也就是说，在你没有收获完所有花田并到花店交货前，即使你已经经过了花店，你也不能进行播种。（啰嗦了这么多但愿讲明白了） 然而还有一个问题。在收割完花朵后，花田会变得光秃秃的，此时土地里的水分会迅速蒸发。考虑到这个问题，更早被收割的花田也理应更早地被播种。具体来说，你必须保证前$\lfloor \frac{n-2}{2}\rfloor$个被收割的花田也是前$\lfloor \frac{n-2}{2}\rfloor$个被播种的，其中符号$\lfloor \rfloor$表示向下取整。你不需要保证这些花田收割和播种的顺序完全一致，而只需要保证前$\lfloor \frac{n-2}{2}\rfloor$名的集合不变即可。 现在，你需要求出完成上述一系列动作走过的最短路程。 $n \leq 20$ 一眼看出状压$dp$，第二眼看出应该从头和尾分别$dp$，然后没看第三眼就开始写……发现不太对？？有个限制，要求前$\lfloor \frac{n-2}{2}\rfloor$必须相同。然后我就寻思着要压一下顺序？有点难写；寻思着记录一下路径？但是发现变更不对了，因为可能最后的状态根本不重合，然后就没有然后了QAQ。 然后瞅了一眼题解发现很妙。大概就是枚举$size$为$\frac{n}{2}$的状态，将整张地图分为两半。之前预处理一个floyd，然后每次的代价就是 $$\mathsf{\min _{x\in S,y\in T}(f_{S,x}+dis_{x,y}+g_{T,y})+\min _{x\in S,y\in T}(g_{S,x}+dis_{x,y}+f_{T,y}})$$ 然后枚举$\mathsf {S,T,x,y}$就完了，复杂度$O(2^{n}+\binom{n}{\lfloor\frac{n}{2}\rfloor}\cdot n^2)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int g[MAXS][MAXN], pre[MAXS][2], sz[MAXS], ans ;int A[MAXN][MAXN], dis[MAXN][MAXN], N, M, E, f[MAXS][MAXN], stk[MAXN], cnt ;int main()&#123; cin &gt;&gt; N &gt;&gt; E ; int i, j, k, o ; M = (1 &lt;&lt; N) - 1, ans = Inf ; memset(dis, 63, sizeof(dis)) ; memset(f, 63, sizeof (f)) ; f[1][0] = 0 ; for (i = 1 ; i &lt;= N ; ++ i) dis[i][i] = 0 ; for (i = 1 ; i &lt;= E ; ++ i) cin &gt;&gt; j &gt;&gt; k &gt;&gt; o, A[j][k] = A[k][j] = o, dis[j][k] = dis[k][j] = o ; for (k = 0 ; k &lt; N ; ++ k) for (i = 0 ; i &lt; N ; ++ i) for (j = 0 ; j &lt; N ; ++ j) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ; if (N == 3) return printf("%d\n", 2 * (dis[0][1] + dis[1][2])), 0 ; for (i = 1 ; i &lt;= M ; ++ i) sz[i] = sz[i - (i &amp; (-i))] + 1 ; for (i = 2 ; i &lt;= M ; ++ i)&#123; for (j = 0 ; j &lt; N ; ++ j) if (1 &lt;&lt; j &amp; i) stk[++ cnt] = j ; for (j = 1 ; j &lt;= cnt ; ++ j)&#123; int now = stk[j] ; for (k = 1 ; k &lt;= cnt ; ++ k) if (!(stk[k] ^ now)) continue ; else f[i][now] = min(f[i][now], f[i ^ (1 &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ; &#125; cnt = 0 ; &#125; memset(g, 63, sizeof(g)) ; g[1 &lt;&lt; (N - 1)][N - 1] = 0 ; for (i = (1 &lt;&lt; (N - 1)) + 1 ; i &lt;= M ; ++ i)&#123; for (j = 0 ; j &lt; N ; ++ j) if (1 &lt;&lt; j &amp; i) stk[++ cnt] = j ; for (j = 1 ; j &lt;= cnt ; ++ j)&#123; int now = stk[j] ; for (k = 1 ; k &lt;= cnt ; ++ k) if (!(stk[k] ^ now)) continue ; else g[i][now] = min(g[i][now], g[i ^ (1 &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ; &#125; cnt = 0 ; &#125;// cout &lt;&lt; g[M][1] &lt;&lt; endl ; for (i = 1 ; i &lt;= M ; ++ i)&#123; if (sz[i] != N / 2) continue ; int stA = i, stB = (~i &amp; M), res = Inf, fg = 0 ; for (int j = 1 ; j &lt; N ; ++ j) if (1 &lt;&lt; j &amp; stA) for (int k = 1 ; k &lt; N ; ++ k) if (1 &lt;&lt; k &amp; stB) res = min(res, f[stA][j] + dis[j][k] + g[stB][k]), fg = 1 ; // if (!fg) res = 0 ; stB ^= (1 &lt;&lt; N - 1), stB |= 1 ; stA ^= 1, stA |= (1 &lt;&lt; N - 1) ; for (int j = 1 ; j &lt; N ; ++ j) if (1 &lt;&lt; j &amp; stB) for (int k = 1 ; k &lt; N ; ++ k) if (1 &lt;&lt; k &amp; stA) ans = min(ans, res + f[stB][j] + dis[j][k] + g[stA][k]) ;// if (!fg) ans *= 2 ; &#125; cout &lt;&lt; ans &lt;&lt; endl ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>校内模拟赛</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>动态规划-普通DP</tag>
        <tag>动态规划-状压DP</tag>
        <tag>数据结构/线段树</tag>
        <tag>数据结构/数据结构方法/莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】树上启发式合并(dsu on tree) · 1]]></title>
    <url>%2F2019%2F11%2F13%2Fdsu-on-tree-1%2F</url>
    <content type="text"><![CDATA[$\boldsymbol{dsu ~ on ~ tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly ~Direct~ Counting~ on~ Tree}$，“优雅的树上暴力统计”。 $\rm 0x01$ 前言$\&amp;$技术分析严格来说，$\boldsymbol{EDCT}$解决的问题范围并不广泛： 1、维护子树信息； 2、不能带修改操作。 但这仍然掩盖不住这种算法自带的有趣的气质。笔者认为，这种算法虽然是个暴力，但是其中的技术含量还是不低的，代码也不是那么的浅显易懂，算是一个比较考察应用能力的算法。 然后来看技术分析。 首先，假设我们有这样一个问题： 给定一棵有根树树，每个点有一个信息。现在考虑求出每个点子树内的规定的有效信息数量。 $n,q\leq 5\cdot1e5$ 一般而言这样的题是可以上莫队的，但是便于展开就开到了$500,000$。 考虑$n^2$的暴力，即对每个节点都扫一遍子树。很容易发现这样是浪费的，因为会算重。我们考虑怎么对这棵树进行划分才能高效计算。 考虑一种合适的划分方案。结合轻重链剖里面的结论，可以知道，在轻重链剖后，一个点到根不会超过$\log n$条轻边。所以如果对于每个点，假设我们只计算他对轻祖先的贡献，需要至多$\log n$次就可以解决；同时我们考虑重儿子，每个点至多会被当成一次重儿子，所以假设我们只计算他对父亲的贡献，那么至多$1$次就可以解决。所以最后的复杂度是$O(n\log n)$的。 现在考虑实现层面，其实是一种分治的思想。我们考虑首先分治$u$的轻儿子并清除轻儿子的贡献，然后暴力计算重儿子，然后暴力计算一整棵子树的贡献。首先第一步中清除贡献是必要的，因为分治出来的几个子问题相互独立，所以必须要独立计算。之后是重儿子，由于重儿子至多有一个，所以可以直接计算而不会影响其他状态。最终再暴力一遍计算轻儿子的贡献。 所以这样就解决了维护树上信息的问题，复杂度$n\log n$。 $0x02$ 入门题目选整感觉大部分blog找的题目都很不清真233 $\rm Task1$ $\rm Cf600E$ Lomsat gelral一句话题意 一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。 考虑套$\rm EDCT$的板子： 1234567891011121314151617void dfs(int u, int fa)&#123; sz[u] = 1 ; for (int k = head[u] ; k ; k = E[k].next)&#123; if (to(k) == fa) continue ; dfs(to(k), u), sz[u] += sz[to(k)] ; if (sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ; &#125;&#125;void dfs(int u, int fa, int mk)&#123; for (int k = head[u] ; k ; k = E[k].next)&#123; if (to(k) == fa || to(k) == son[u]) continue ; dfs(to(k), u, 0) ; &#125; if (son[u]) dfs(son[u], u, 1), vis[son[u]] = 1 ; calc(u, fa, 1) ; ans[u] = res ; if (son[u]) vis[son[u]] = 0 ; if (!mk) calc(u, fa, -1), res = 0, max_cnt = 0 ;&#125; 然后就是最后的calc函数怎么写了。考虑我们最暴力的做法是什么？就是把每个颜色统计一遍。所以这么写就OK了： 123456789101112void calc(int u, int fa, int mk)&#123; buc[clr[u]] += mk ; if (mk &gt; 0 &amp;&amp; buc[clr[u]] &gt;= max_cnt)&#123; if (buc[clr[u]] &gt; max_cnt) res = 0, max_cnt = 1ll * buc[clr[u]] ; res += 1ll * clr[u] ; &#125; for (int k = head[u] ; k ; k = E[k].next)&#123; if (to(k) == fa || vis[to(k)]) continue ; calc(to(k), u, mk) ; &#125;&#125; $\rm Task2 ~Cf570D$ Tree Requests一句话题意： 给定一个以1为根的n个节点的树，每个点上有一个字母$(a-z)$，每个点的深度定义为该节点到1号节点路径上的点数.每次询问$(a,b)$查询以$a$为根的子树内深度为$b$的节点上的字母重新排列之后是否能构成回文串. 这种应该就是比较裸的$\rm EDCT$。有一步转化需要学会构造，即我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数。所以也是，直接爆算就可以了。 123456789101112131415161718192021222324void calc(int u, int fa)&#123; buc[dep[u]] ^= (1 &lt;&lt; base[u]) ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ;&#125;int getl(int x)&#123; int ret = 0 ; while (x) ret += (x &amp; 1), x &gt;&gt;= 1 ; return (bool)(ret &lt;= 1) ;&#125;void del(int u, int fa)&#123; buc[dep[u]] = 0 ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ;&#125;void dfs(int u, int fa, int mk)&#123; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, 0) ; if (son[u]) dfs(son[u], u, 1), vis[son[u]] = 1 ; calc(u, fa) ; for (int k = 0 ; k &lt; qs[u].size() ; ++ k) ans[u].pb(getl(buc[qs[u][k]])) ; vis[son[u]] = 0 ; if (!mk) del(u, fa) ; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>dsu on tree</category>
      </categories>
      <tags>
        <tag>树上技巧/dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】树上启发式合并(dsu on tree) · 2]]></title>
    <url>%2F2019%2F11%2F13%2Fdsu-on-tree-2%2F</url>
    <content type="text"><![CDATA[主要就是整理一下dsu on tree的进阶版习题。 $0x01$ $\rm Cf375D$ Tree and Queries 给出一棵$n$个结点的树，每个结点有一个颜色$c_i$ 。 询问$q$次，每次询问以$v$结点为根的子树中，出现次数 $≥k$的颜色有多少种。树的根节点是$1$。 考虑维护子树里面每种颜色出现的次数，但是显然询问的是一个$buc[c_i]$的后缀和，于是考虑上线段树来维护这个东西，calc到每个点的时候先del掉原来的再upd新的信息……然后就做完了233 然而一开始的时候我调了好久，因为我是这么写的： 12345678910111213141516171819202122232425void do_do(int u, int fa)&#123; ts[base[u]] ++ ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) do_do(to(k), u) ; &#125;void do_del(int u, int fa)&#123; ts[base[u]] -- ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) do_del(to(k), u) ; &#125;void _count(int u, int fa, int val)&#123; bool fg = 1 ; if (!chk[base[u]]) chk[base[u]] = 1, update(1, 1, N, ts[base[u]] + 1, val), fg = 0 ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) _count(to(k), u, val) ; if (!fg) chk[base[u]] = 0 ;&#125;void calc(int u, int fa)&#123; _count(u, fa, -1) ; do_do(u, fa) ; _count(u, fa, 1) ; &#125; void del(int u, int fa)&#123; _count(u, fa, -1) ; do_del(u, fa) ; _count(u, fa, 1) ; &#125; 看上去很对的亚子，但是错就错在必须每个点独立计算完贡献才能考虑下一个点，否则下一个点的信息就是错误的——也就是说不能整体del再整体upd，必须逐个逐个的del和upd。。然而事实上关键问题还是在$buc$的统计上出了问题233 于是最后的代码： 123456789101112131415161718192021222324void calc(int u, int fa)&#123; update(1, 1, N, ts[base[u]] + 1, -1) ; ts[base[u]] ++ ; update(1, 1, N, ts[base[u]] + 1, 1) ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ; &#125; void del(int u, int fa)&#123; update(1, 1, N, ts[base[u]] + 1, -1) ; ts[base[u]] -- ; update(1, 1, N, ts[base[u]] + 1, 1) ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ; &#125;void dfs(int u, int fa, int mk)&#123; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, 0) ; if (son[u]) dfs(son[u], u, 1), vis[son[u]] = 1 ; calc(u, fa) ; for (int k = 0 ; k &lt; qs[u].size() ; ++ k) ans[u].pb(query(1, 1, N, qs[u][k] + 1, N)) ; vis[son[u]] = 0 ; if (!mk) del(u, fa) ; &#125; $0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths 一棵根为$1$的树，每条边上有一个字符（$a-v$共$22$种）。 一条简单路径被称为$\rm Dokhtar-kosh$当且仅当路径上的字符经过重新排序后可以变成一个回文串。 求每个子树中最长的$\rm Dokhtar-kosh$路径的长度。 似乎是Cf570D的升级版，因为路径可以跨过根所以会显得比较复杂，不过结论还是可以用的： 我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数 然后就是考虑怎么维护这个东西。 不经过根的路径，分治做下去就好，每一层$u$对所有的$son[u]$的$ans$取$\max$. 经过根的路径，发现对于一个$u$，和$v$组合后可以产生贡献，我们只需要关心深度最大的$v$.所以自然想到用一个桶来维护二进制数值的最大深度。但是这个地方还有个问题，就是统计路径的话，$u$和$v$不能在同一棵子树中，容易发现只要满足不在同一棵子树中，那就一定满足$(u,v)$这条路径经过$root$。所以这个地方，对于一个点$u$，考虑一棵子树一棵子树地计算答案，深度做差求；而“经过根节点的路径”包括起点和终点在根节点上的路径，所以需要对$root$单独计算一次。 看上去应该这么实现： 12345678910111213141516171819202122232425262728293031323334353637void _delete(int u, int fa)&#123; f[dis[u]] = 0 ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) _delete(to(k), u) ;&#125;void calc(int u, int fa, int &amp; ans, int d)&#123; if (f[dis[u]]) ans = max(ans, f[dis[u]] + dep[u] - 2 * d) ; for (int i = 0 ; i &lt;= 21 ; ++ i) if (f[dis[u] ^ (1 &lt;&lt; i)]) ans = max(ans, f[dis[u] ^ (1 &lt;&lt; i)] + dep[u] - 2 * d) ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u, ans, d) ;&#125;void update(int u, int fa)&#123; f[dis[u]] = max(f[dis[u]], dep[u]) ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != fa &amp;&amp; !vis[to(k)]) update(to(k), u) ;&#125;void dfs(int u, int fa, int mk)&#123; for (int k = head[u] ; k ; k = E[k].next)&#123; if (to(k) == fa || to(k) == son[u]) continue ; dfs(to(k), u, 0), ans[u] = max(ans[u], ans[to(k)]) ; &#125; if (son[u]) dfs(son[u], u, 1), vis[son[u]] = 1, ans[u] = max(ans[u], ans[son[u]]) ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) != son[u] &amp;&amp; to(k) != fa) calc(to(k), u, ans[u], dep[u]), update(to(k), u) ; if (f[dis[u]]) ans[u] = max(ans[u], f[dis[u]] - dep[u]) ; for (int i = 0 ; i &lt;= 21 ; ++ i) if (f[dis[u] ^ (1 &lt;&lt; i)]) ans[u] = max(ans[u], f[dis[u] ^ (1 &lt;&lt; i)] - dep[u]) ; f[dis[u]] = max(f[dis[u]], dep[u]) ; vis[son[u]] = 0 ; if (!mk) _delete(u, fa) ;&#125; 总感觉……复杂度不是很对？感觉单次运行dfs复杂度很高的亚子……然而还是套用“一个点到根节点最多有$\log n $个轻祖先”这个理论，每个点被访问的次数还是不变的——毕竟子树之间访问不会重复。于是时间复杂度$n\log n$。 唔，感觉这个题还是比较有技巧性的233 $0x03$ $\rm NOIP2018$模拟 · 树这道题是从一个神仙的blog里嫖来的，提交的话可以到Luogu上提交：$\rm Link$ 题面： 给定一棵树。 令$[L,R]$描述的是序号在$[L,R]$内的点的集合。 同时，令函数$\boldsymbol F({ \rm S})$表示令集合$\rm S$内的点联通的需要的最小边数。 问题则是求： $$\sum_{i=1}^{n}\sum_{j=i}^n \boldsymbol F([i,j])$$ $n\leq 100,000$ 一步转化成求每条边的贡献。结合正难则反可知，一条边的总贡献至多是$\binom{n}{2}$，算多了的集合是那些位于这条边两侧中的其中一侧，不经过这条边的集合。所以考虑分别维护子树内和子树外的两个答案。 子树内的比较容易维护，考虑假设现在有了${1,2,3},{5,6}$两个集合，将其视作两个连通块，当加进来${4}$时，会和左右都相连接，不妨假设先与${1,2,3}$合并，那么最后会产生$(1,4),(2,4),(3,4)$三个新的连通块，原来的依旧要加入。所以考虑用并查集+并查集的$size$来维护。由于子树内的点在暴力时只会插入不会删除，所以并查集是$\rm van$全没问题的。 之后是子树外的。子树外的和子树内的情况差不多，但是由插入变成了删除。然后就可以考虑用set维护，因为这东西自带的单调性比较nice，并且支持删除操作。所以流程大概就是考虑把删除的点丢到set里面，最初的ans_out显然是$\binom{n}{2}$，每删除一个新的点，设其编号为$x$，set里面第一个比$x$小的元素设为$x_p$第一个比$x$大的元素设为$x_s$，那么$[x_{p}+1,x-1]$还是连续的，$[x+1,x_s-1]$还是连续的，所以新的贡献变成了$$calc(x_s-1-(x+1)+1)+calc(x-1-(x_p+1)+1)$$原来的旧贡献$calc(x_s-1-(x_p+1)+1)$理应减去。 所以就做完了，感觉神清气爽，总体来说算是一道很好的题吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344set &lt;int&gt; s ;int vis[MAXN], op[MAXN] ;LL calc(LL x)&#123; return x * (x - 1) / 2 ; &#125;void _clear()&#123; s.clear() ; ansout = calc(N), ansin = 0, s.insert(0), s.insert(N + 1) ; &#125;int _find(int x)&#123; return x == fr[x] ? x : fr[x] = _find(fr[x]) ;&#125;void fuck(int u)&#123; s.insert(u) ; op[u] = 1 ; set &lt;int&gt; :: iterator l, r, mid ; l = r = mid = s.find(u), l --, r ++ ; ansout += calc(*r - *mid - 1) + calc(*mid - *l - 1) - calc(*r - *l - 1) ; if (op[u - 1])&#123; int f1 = _find(u - 1), f2 = _find(u) ; ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ; &#125; if (op[u + 1])&#123; int f1 = _find(u + 1), f2 = _find(u) ; ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ; &#125;&#125;void _update(int u, int fa)&#123; fuck(u) ; //cout &lt;&lt; u &lt;&lt; endl ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) == fa || vis[to(k)]) continue ; else _update(to(k), u) ;&#125;void _delete(int u, int fa)&#123; op[u] = 0, fr[u] = u, bg[u] = 1 ; for (int k = head[u] ; k ; k = E[k].next) if (to(k) == fa) continue ; else _delete(to(k), u) ; // 1&#125;void dfs(int u, int fa, int mk)&#123; for (int k = head[u] ; k ; k = E[k].next)&#123; if (to(k) == fa || to(k) == son[u]) continue ; dfs(to(k), u, 0) ; &#125; if (son[u]) dfs(son[u], u, 1), vis[son[u]] = 1 ; _update(u, fa), ans += calc(N) - ansout - ansin ; if (!mk) _delete(u, fa), _clear() ; vis[son[u]] = 0 ;&#125; $\rm Warning$ 注意一个地方： 1vis[son[u]] = 0 ; if (!mk) _delete(u, fa) ; 把这两句写反了会调一下午，欢迎尝试quq]]></content>
      <categories>
        <category>学习笔记</category>
        <category>dsu on tree</category>
      </categories>
      <tags>
        <tag>树上技巧/dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】Codeforces Round-814 Virtual]]></title>
    <url>%2F2019%2F11%2F13%2Fcodeforces-814%2F</url>
    <content type="text"><![CDATA[一场cn round，然后每次cn round的最后一题都会很奇怪…… $\Omega $$\rm virtual$了一场……说实话这种div2 only的场次最后一题就经常比较毒…… 老规矩，前面几题用来水字数 $A$ 给出一个长度为$N$的非负整数序列$a_i$与长度为$K$的正整数序列$b_i$，满足$a_i$中刚好有$K$个$0$，且任一正整数在序列$a$和序列$b$中的出现次数的和不会超过$1$。 现在试判断是否存在一种方法，使得用$b_i$中的元素替换$a_i$中的$0$得到的序列不是递增序列。 sb一眼题，显然如果递减放进去还是递增就无解。 123456789inline bool cmp(int a, int b)&#123; return a &gt; b ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; K ; int j = 1 ; for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; base[i] ; for (i = 1 ; i &lt;= K ; ++ i) cin &gt;&gt; t[i] ; sort(t + 1, t + K + 1, cmp) ; for (i = 1 ; i &lt;= N ; ++ i) if (!base[i]) base[i] = t[j ++] ; for (i = 1 ; i &lt; N ; ++ i) if (base[i] &gt; base[i + 1]) return puts(&quot;Yes&quot;), 0 ; return puts(&quot;No&quot;), 0 ;&#125; $B$ 给定两个长度为$n$的不相同序列$a$和$b$，这两个序列至少有一个位置不同 现在需要构造一个长度为$n$的排列$p$，使得$p$与$a$只有一个地方不同，且$p$与$b$也只有一个地方不同 一眼就可以看出最多有两个位置不同，否则一定不合法。考虑分类讨论，如果只有一个位置不同那就放上那个没出现过的数字；如果有两个位置不同，那就考虑是$A$中第一个位置放多了还是第二个位置放多了，放上$B$的就完了. 1234567891011121314151617 for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;A[i]), Ma[A[i]] ++ ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;B[i]), Mb[B[i]] ++ ; for (i = 1 ; i &lt;= N ; ++ i) if (A[i] != B[i]) pos[++ cnt] = i ; if (cnt == 1)&#123; for (i = 1 ; i &lt;= N ; ++ i) if (!Ma.count(i) &amp;&amp; !Mb.count(i)) &#123; A[pos[1]] = i ; break ; &#125; for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i] &lt;&lt; " " ; return 0 ; &#125; if (Ma[A[pos[1]]] &gt; 1 &amp;&amp; !Ma[B[pos[1]]])&#123; A[pos[1]] = B[pos[1]] ; for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i] &lt;&lt; " " ; &#125; else &#123; A[pos[2]] = B[pos[2]] ; for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i] &lt;&lt; " " ; &#125;&#125; 本来觉得是道构造题，后来发现是道细节模拟题。。。 $C$ 给你一个由小写字母构成的字符串.有$q$个询问，每个询问给出数字$m$和小写字母$c$，你可以任意地修改字符串中的$m$个字符，求最多能够使字符串中含有多少个连续相同的字母$c$.每个询问各自独立.$|\rm S|\leq 1,500$ 其实感觉复杂度一点也不对……比如我觉得这题可以做到$5e4$以上…… 考虑弱化版（原版）的解法，大概就是用$f_{i,j}$表示前$i$个字符用了$k$次机会最长的连续段有多长。然后就可以直接$O(26n^2)$给预处理出来，每次询问回答一下即可。 但是我们发现这玩意儿复杂度一点也不平衡，因为预处理贼慢但是回答贼快。于是考虑有哪些性质没用。我们考虑预处理出原串中对于一个字符$c$，最近的两个$c$之间的位置来，然后如果要修改就显然先修改跨度小的$c_i$和$c_{i+1}$中间的部分，因为这样肯定不会更劣。同时只有把中间的非$c$区域占满才能使之连通，故每次对于一个给定的$k$，二分查找一下可以占满的区间，剩下的随便铺，对于这些占满的区间提前预处理出贡献的前缀和就完了。复杂度大概是$q\log n+26n$ 然而升级版只是口胡，什么时候闲下来再写吧qwq 12345678910111213141516for (i = 0 ; i &lt; 26 ; ++ i) for (j = 1 ; j &lt;= N ; ++ j) if ((int)S[j] == 'a' + i) dp[i][j][0] = dp[i][j - 1][0] + 1 ; for (i = 0 ; i &lt; 26 ; ++ i)&#123; for (j = 1 ; j &lt;= N ; ++ j) for (k = 1 ; k &lt;= N ; ++ k)&#123; if ((int)S[j] - 'a' == i) dp[i][j][k] = dp[i][j - 1][k] + 1 ; else dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - 1] + 1) ; ans[i][k] = max(ans[i][k], dp[i][j][k]) ; &#125;&#125;cin &gt;&gt; T ;while (T --)&#123; scanf("%d %c", &amp;k, &amp;In) ; cout &lt;&lt; ans[(int)In - 'a'][k] &lt;&lt; endl ; &#125; $D$ 有$n$个圆，将其分为两组。每组中，只有奇数个圆覆盖的区域的才会算入面积，求可能的最大面积。 首先考虑贪心。大概就是说原本的覆盖一定可以看做一团一团独立的子问题。将圆按照面积大小排序，之后考虑选每一堆最大的放到第一堆，然后把与之原本冲突的放到第二堆。这样可以发现最终减去的部分面积变成了之前产生贡献的部分面积……然而这不重要，重要的是这样保证了每次选的一定都是面积最大的圆的集合。 12345678910inline bool Comp(C A, C B)&#123; return A.r &gt; B.r ; &#125;void solve2()&#123; sort(base + 1, base + N + 1, Comp) ; for (i = 1 ; i &lt;= N ; ++ i) for(j = i + 1 ; j &lt;= N ; ++ j) if (check_in(base[i], base[j])) ++ mark[j] ; for (i = 1 ; i &lt;= N ; ++ i) if (!mark[i] || (mark[i] &amp; 1)) Ans += get_S(base[i]) ; else Ans -= get_S(base[i]) ; printf("%.8lf", Ans) ; &#125; 然而这个贪心似乎不好想，于是考虑一种精妙的$\rm dp$其实更不好想。考虑按照圆从大到小枚举顺次连边，最后连出来的会是一个森林状物。然后对于这个东西， 定义$dp[u][0/1][0/1]$表示以点$u$为根的子树里面，除$u$之外分成两堆之后，两堆分别的高度为偶数/奇数时的最优值。这东西就可以直接分类讨论求和+转移。 123456789101112131415161718192021222324252627282930313233343536373839404142inline double dist(C A, C B)&#123; return sqrt((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ;&#125;inline double get_S(C A)&#123; return Pi * A.r * A.r ; &#125;inline bool check_in(C A, C B)&#123; return A.r + B.r &gt; dist(A, B) ; &#125;namespace DP&#123; #define to(k) E[k].to struct Edge&#123; int next, to ; &#125;E[MAXN &lt;&lt; 1] ; int head[MAXN], cnt ; inline void Add(int u, int v)&#123; E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ; &#125; void do_dp(int u, int faa)&#123; long long f[2][2] ; memset(f, 0, sizeof(f)) ; for (int k = head[u] ; k ; k = E[k].next)&#123; if (to(k) == faa) continue ; do_dp(to(k), u) ; for (int ii = 0 ; ii &lt;= 1 ; ++ ii) for (int jj = 0 ; jj &lt;= 1 ; ++ jj) f[ii][jj] += dp[to(k)][ii][jj] ; &#125; for (int ii = 0 ; ii &lt;= 1 ; ++ ii) for (int jj = 0 ; jj &lt;= 1 ; ++ jj) dp[u][ii][jj] = max( f[ii ^ 1][jj] + (1ll * (ii ? -1 : 1) * base[u].r * base[u].r), f[ii][jj ^ 1] + (1ll * (jj ? -1 : 1) * base[u].r * base[u].r)) ; &#125; inline bool Comp(C A, C B)&#123; return A.r &gt; B.r ; &#125; void solve1()&#123; sort(base + 1, base + N + 1, Comp) ; for (i = 1 ; i &lt;= N ; ++ i) for(j = i + 1 ; j &lt;= N ; ++ j) if (check_in(base[i], base[j])) if (!fa[j] || base[fa[j]].r &gt; base[i].r) fa[j] = i ; for (i = 1 ; i &lt;= N ; ++ i) if (fa[i]) Add(i, fa[i]) ; for (i = 1 ; i &lt;= N ; ++ i) if (!fa[i]) do_dp(i, 0), Ans += dp[i][0][0] ; printf("%.8lf", Ans * Pi) ; &#125;&#125; $E$ 给出$n$个点和每个点的度让你构造出一张无向图满足以下两条性质： $1.$点1到点$i$仅有唯一一条最短路 $2.$点$1$到点$i$的最短路长度大于等于点$1$到点$i-1$的最短路长度 求能构成满足条件的无向图的个数 $n\leq 50, 2\leq degree_i\leq 3$ 这种计数题会是不可能会的，这辈子都不可能会了qaq 考虑一个$idea$，因为这张图无权，所以最短路一定会是$\it bfs$的分层。那么对于一个$i$来讲，他的要么和$i-1$在同一层，要么就在$i-1$的下一层。 那么考虑记$f_{i,j}$表示前$i$个点中有$j$个和$i$在同一层的方案数。那么考虑这东西的转移跟上一层中点的度数有关，也就是需要记$dp_{k,c_1,c_2}$表示当前层有$k$个点，上一层度数为$2$的点有$c_1$个，度数为$3$的点有$c_2$个这一子状态的方案数。那么有如下：$$dp_{i,j,k}=\begin{cases}{1} &amp; (i=j=k=0)\ \ {\sum\limits_{l=2}^{k-1} dp_{i,j,k-l-1} \cdot\left(\begin{array}{c}{k-1} \ {l}\end{array}\right) \cdot N_{l+1}} &amp;(i=j=0,k&gt;0) \ \ {(j-1) \cdot dp_{i,j-2,k}+k \cdot dp_{i,j,k-1}} &amp; (i=0,j&gt;0)\ \{j \cdot dp_{i-1,j-1,k}+k \cdot dp_{i-1,j+1,k-1}} &amp; (i&gt;0)\ \{0}\end{cases}$$其中$N_i$表示$\boldsymbol{i-}$项链数，也就是长度为$i$、元素各异、镜像对称的单环的数量，计算方式如下：$$N_i=\begin{cases} 1 &amp; (i=2)\ \frac{(i-1)!}{2} &amp;(i&gt;2)\ 0 &amp; \rm{otherwise}\ \end{cases}$$对于第二个转移，就是考虑向上一层插入一个点使其成为度数为$3$的点。考虑因为度数为$3$且题目要求“有位移最短路”，所以同一层中只有可能是简单的平边相连。所以就是考虑枚举原来的点里面可以与新加入的点组成项链的方案数。注意这里项链数必须$&gt;2$原因是题目中强调了不能有两个点之间连$&gt;1$条边。 对于第三个转移，考虑插入一个点使其度数为$2$，这一步转移即考虑$j-1$个点中选择一个可能变成$2$度的点和新加近来这个点相连有$j-1$种方案，相连之后两个点度数都变为$2$；同时考虑另一种可能性，就是这一个点和一个可能变成$3$度的点相连，那么原来的二度点变为三度点，新加进来的变成二度点。 对于第四个转移，考虑这一层最后一个加进来的节点，要么和上一层中一个可能变成$2$度的点相连要么和可能变成$3$度的点相连。 然后最后的答案就是枚举最后一层的点数$$ans =\sum_{j=1}^{n}f_{n,j}\cdot g_{0,c_1,c_2}$$其中$c_1$和$c_2$表示枚举到现在有多少个$d=2$和$d=3$的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 105#define ll long long#define Mod 1000000007using namespace std ; int N, clr1, clr2, base[MAXN] ; int i, j, k, l ; ll dp[MAXN][MAXN] ;ll Ans, A[MAXN], f[MAXN][MAXN][MAXN], Cm[MAXN][MAXN] ; int main()&#123; cin &gt;&gt; N ; Cm[0][0] = 1 ; for (i = 1 ; i &lt;= N ; ++ i) Cm[i][0] = 1 ; for (i = 1 ; i &lt;= N ; ++ i) for(j = 1 ; j &lt;= i ; ++ j) Cm[i][j] = (Cm[i - 1][j] + Cm[i - 1][j - 1]) % Mod ; for ( A[1] = A[0] = 0, A[2] = A[3] = 1, i = 4 ; i &lt;= N ; ++ i) A[i] = A[i - 1] * (i - 1) % Mod ; f[0][0][0] = 1 ; //Calculate g for (j = 0; j &lt;= N ; ++ j) for (k = 0 ; k &lt;= N - j ; ++ k) if (!j &amp;&amp; k) for (l = 2 ; l &lt; k ; ++ l) (f[0][j][k] += f[0][j][k - l - 1] * Cm[k - 1][l] % Mod * A[l + 1] % Mod) %= Mod ; else &#123; if (j &gt;= 2) (f[0][j][k] += f[0][j - 2][k] * (j - 1) % Mod) %= Mod ; if (k) (f[0][j][k] += f[0][j][k - 1] * k % Mod) %= Mod ; &#125; for (i = 1 ; i &lt;= N ; ++ i) for (j = 0 ; j &lt;= N - i ; ++ j) for (k = 0 ; k &lt;= N - i - j ; ++ k)&#123; if (j) (f[i][j][k] += f[i - 1][j - 1][k] * j % Mod) %= Mod ; if (k) (f[i][j][k] += f[i - 1][j + 1][k - 1] * k % Mod) %= Mod ;// cout &lt;&lt; f[i][j][k] &lt;&lt; endl ; &#125; //Calculate dp for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; base[i] ; dp[base[1] + 1][base[1]] = 1 ; for (i = base[1] + 2 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= i - base[1] - 1 ; ++ j) for (clr1 = clr2 = 0, k = 1 ; k &lt;= i - j ; ++ k)&#123; if (base[i - j - k + 1] &lt;= 2) ++ clr1 ; else ++ clr2 ; (dp[i][j] += (dp[i - j][k] * f[j][clr1][clr2] % Mod)) %= Mod ; &#125; for (clr1 = clr2 = 0, i = 1 ; i &lt; N ; ++ i)&#123; if (base[N - i + 1] == 2) ++ clr1 ; else ++ clr2 ; (Ans += (dp[N][i] * f[0][clr1][clr2]) % Mod) %= Mod ; &#125; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/构造</tag>
        <tag>思维题/计数</tag>
        <tag>动态规划-普通DP</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【赛题整理】校内模拟赛选整 · E1]]></title>
    <url>%2F2019%2F11%2F13%2Fxiaonei-1%2F</url>
    <content type="text"><![CDATA[校内模拟赛选整 大概难度都是TG里面$2$~$3$左右的。 $A$ 给定直线上$n\leq 2000$个建筑的坐标，两种覆盖方式，$A:$覆盖长度为$L$，可以用$p$次；$B$：覆盖长度为$2L$，可以用$q$次。求最小的$L$. 首先就是可以知道$p,q$可以缩到$p+q\leq n$，否则答案就是$1$。 之后考虑二分一个$L$，$check$其正确性。$check$时感觉贪心并不是很好贪，可能会有比较妙的贪心，但这个地方选择一种更加稳妥的$dp$。考虑$f_{i,j}$表示两种覆盖分别用了$i,j$个最多能覆盖到哪个建筑，则$$f_{i,j}=\max(go_p[f_{i-1,j}+1], go_q[f_{i,j-1}+1])$$其中$go_x[P]$表示在位置$P$使用第$x$种覆盖能够覆盖多少建筑。于是最后复杂度$O(n^2\log n)$. $B$ 定义string类型的递推$f_0=’0’$，$f_1=’1’$，$f_i=f_{i-2}+f_{i-1}$，其中$+$表示string类型的连接。多组询问，询问$f_n$中区间$\rm [L,R]$内的串。$n\leq 1e9,~\rm L\leq R\leq 2e9,\sum (R-L)\leq 1e7$ 拿到这题首先应该手写出前$6$项来找规律…… 发现$f_i.size()$就是斐波那切数列的第$i$项，并且序号奇偶性相同的两项$f_i,f_j$，当$j&lt;i$时满足$f_j$是$f_i$的前缀，这东西可以数学归纳出来并且肉眼看不出来。 之后可以发现$\rm L,R\leq 2e9$，而斐波那切数列的第$50$项已经超过了这个范围。于是考虑对于一个询问$f_n[L,R]$，先把$n$缩到$50$以内，然后分奇偶性赋值为$48/49$，然后每次考虑把$f_n$分成$f_{n-2}+f_{n-1}$，分治下去。注意到其实是可以预处理一些状态来提速，于是选择预处理前$20$项左右。 12345void solve(int n, int L, int R)&#123; if (n &lt;= 20) return cout &lt;&lt; f[n].substr(L, R - L + 1), void() ; if (L &lt; fib[n - 2]) solve(n - 2, L, min(R, fib[n - 2])) ; if (R &gt;= fib[n - 2]) solve(n - 1, max(0ll, L - fib[n - 2]), R - fib[n - 2]) ;&#125; $C$ 我们有一张方格纸，他大概长这样： 我们现在要从左上角$(0,0)$到右下角$(n,m)$画一条直线，然后询问它经过黑格子的长度与总长度的比值，并输出一个互质分数的形式。 sb结论题，以下是结论，觉得证的挺好的（ 无论怎样，$rqy$太强了！！ 以下是$rqy$给的严谨证明： 对于每个二元组$(n,m)$，$(\frac{n}{\gcd(n,m)},\frac{m}{\gcd(n,m)})$ 的本质与$(n,m)$是一样的。 当$n$是偶数或者$m$是偶数的时候，答案显然是$\frac{1}{2}$，因为我们可以考虑把所有的颜色翻转，答案是一样的。 余下的情况，由于我们现在已经缩小了问题规模使得$n,m$互质，所以只有可能是$n、m$均为奇数，此时我们考虑如下（前方高能）： 由于横向有$m$段，纵向有$n$段，所以总共这条直线可以分成$n \times m$段，当然，有些段的颜色相同。我们这么做的目的是为了保证每一段不会跨过每个格子的边界，即同一段的每个部分都会是相同的颜色 通过观察可以得到，对于从左上到右下的第$i$段，它应该在第$\lfloor \frac{i}{n} \rfloor$列，第$\lfloor \frac{i}{m} \rfloor$行。注意这个地方，虽然$n$表示的是行，但是$\lfloor \frac{i}{n} \rfloor$表示的是列。道理其实很简单： 对于第$i$段，它占的部分是$\frac{i}{n \times m}$ ，所以所属的行应该是$\lfloor \frac{i}{n \times m} \cdot n \rfloor$，所属的列为$\lfloor \frac{i}{n \times m} \cdot m \rfloor$，约分一下答案显而易见。 基于前两条，我们会有一个比较平凡的结论：对于某一段$i$，当$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$为偶数的时候，这一段在黑色的格子上；是奇数的时候，这一段在白色格子上。 我们可以考虑对$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$搞一些事情：$$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor\begin{align} \ \\&amp;\equiv\frac{i - i \mod n}{n}+\frac{i - i \mod m}{m} \pmod 2\ &amp;\equiv 2i - i \mod n - i \mod m \pmod 2\ &amp; \equiv i \mod n + i \mod m \pmod 2\end{align}$$ 上式的目的其实就是通过对$2$取模建立同余式，由于$n,m$均为奇数，所以在$\mod 2$意义下都是$1$，可以直接除掉。那么接下来我们考虑，这样的$i$有多少个呢？很显然的，在$0 \to n - 1$中，共有$\frac {n-1}{2}$个奇数,$\frac{n+1}{2}$个偶数；在$0 \to m-1$中，共有$\frac {m-1}{2}$个奇数，$\frac {m+1}{2}$个偶数。因为只有奇偶性相同时，才属于黑色格子，所以由中国剩余定理得$$\begin{aligned}\sum check(i) &amp;= \frac{n-1}{2} \cdot \frac{m-1}{2} + \frac{n+1}{2} \cdot \frac{m+1}{2} \\&amp; = \frac{2nm + 2}{4}\end{aligned}$$ 那么最终答案就是$$\frac {\sum check(i)}{n \cdot m} = \frac{n \cdot m+1}{2n \cdot m}$$ $D$ 给定一棵树，某些点是关键点。每条边有代价，每次可以删掉一条边并且获得这条边的代价。求最少的代价，使得所有关键点不连通。$n\leq 300,000$ 直观的想法是$dp$，即记$f_x$表示处理完以$x$为根的子树内的关键点（不互相连通）的最少代价。但是发现这样似乎很难转移，因为转移时要考虑子树之间的关键点是否连通。于是考虑再记$g_x$表示处理完以$x$为根的子树内关键点互相不连通，且不与外界连通的最小代价。 那么考虑转移，记$x$为当前节点，$y$为$x$的子节点： 当$x$为关键点时，有：$$\begin{align}f_x&amp;=\sum g_y \\g_x&amp;=f_x+pre_x\end{align}$$ 当$x$不为关键点时，有$$f_x=\min(\sum f_y-f_{y’}+g_{y’})\\g_x=\min(f_x+pre_x, \sum g_y)$$ 唔，这个第二个转移的$f_x$还是需要编一编的，大概就是考虑现在只需要不让子树内部连通，那么就可以选出一棵子树来内部不连通，其他子树都不和外部连通，可知这样是最优的（因为天选之子不需要“不和外部连通”）。 学习了，学习了。 $E$ 现在有如下一个表达式： $0 ~a_1 b_1 a_2 b_2 … a_n b_n$。其中$a_i$为一个位运算符（$\boldsymbol{and/or/xor}$），$b_i$是一 个整数。每一对$a_i,b_i$有$c_i$的概率会消失，求表达式的结果的期望。 需要建立某种神秘的条件反射，就是遇到位运算的题目就要想到“位与位之间是无关的”。那么就可以直接按位做，令$f_{i,0/1}$表示计算完前$i$对，现在这一位为$0/1$的概率是多少。转移时别忘了加上当前这一对被删除的概率，即$f_{i-1,0/1}$。]]></content>
      <categories>
        <category>题解</category>
        <category>校内模拟赛</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>奇怪的技巧</tag>
        <tag>有趣的二分答案</tag>
        <tag>动态规划-树形DP</tag>
        <tag>数学/概率,期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】分治在FFT上的应用]]></title>
    <url>%2F2019%2F08%2F27%2Ffzfft-md%2F</url>
    <content type="text"><![CDATA[其实就是cdq分治+FFT。 分治FFT解决的问题的一般形式： 给出$g_1,g_2,g_3\cdots g_{n-1},f_0=1$，且$$f_i=\sum_{j=1}^{i} f_{i-j} g_j$$求$f_1,f_2\cdots f_{n-1}$ 先展开观察性质$$\begin{aligned}f_1&amp;=g_1f_0,\\ f_2&amp;=g_1f_1+g_2f_0,\\ f_3&amp;=g_1f_2+g_2f_1+g_3f_0\\ f_4&amp;=g_1f_3+g_2f_2+g_3f_1+g_4f_0=g_1^4\end{aligned}$$我们发现如果将整个序列分成两半，前一半对后一半的贡献是：$$o_p=\sum_{i=l}^{\rm{mid}}f_ig_{p-i}$$其中$p\in(\rm{mid},r]$，$o$是额外的贡献。 我们发现，其实这是个卷积的形式，毕竟对于普通的卷积定义是：$$c_i=\sum_{j\leq i} a_jb_{i-j}$$于是我们就可以通过分治，每次暴力NTT计算前一半对后一半的贡献，类似于cdq分治的操作，复杂度$n\log ^2n$。 123456789101112131415161718void cdqNTT(int l, int r)&#123; if (l == r) &#123;if (!l) F[l] = 1 ; return ;&#125; int i ; int mid = (l + r) &gt;&gt; 1, L = r - l + 1, Len = 1, l1 = 0 ; cdqNTT(l, mid) ; while (Len &lt;= L) Len &lt;&lt;= 1, ++ l1 ; memcpy (P, G, sizeof(LL) * (r - l + 1)) ; memcpy (Q, F + l, sizeof(LL)*(mid - l + 1)) ; memset (P + r - l + 1, 0, sizeof (LL) * (Len - r + l)) ; memset (Q + mid - l + 1, 0, sizeof (LL) * (Len - mid + l)) ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l1 - 1)) ; NTT(P, Len, 1), NTT(Q, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) P[i] = P[i] * Q[i] % Mod ; NTT(P, Len, -1) ; for (i = mid + 1 ; i &lt;= r ; ++ i) (F[i] += P[i - l]) %= Mod ; cdqNTT(mid + 1, r) ;&#125;int main()&#123; cin &gt;&gt; N ; int i ; for (i = 1 ; i &lt; N ; ++ i) scanf("%lld", &amp;G[i]) ; cdqNTT(0, N - 1) ; for (i = 0 ; i &lt; N ; ++ i) printf("%lld ", F[i]) ; return 0 ;&#125; 嗯，得出结论我的分治没学好qaq 但是如果换一个角度观察，设出两个形式幂级数，即令$$\begin{aligned}\rm{F}&amp;=\sum f_ix^i\\\\rm{G}&amp;=\sum g_ix^i\end{aligned}$$然后我们把他俩卷起来，且因为F本身就是卷积的形式，即有：$$\begin{aligned}\rm{F} *\rm{G} &amp; =\sum x^i\sum_{j\leq i} f_ig_j\\\&amp;= \sum x_i f_{i+1}\\\&amp;= \rm{F}-f_0\end{aligned}$$那么先移项，之后两边同时卷一个$\rm{G}-1$ 的逆就可以得到：$$\rm{F}= \frac{1}{1-G}$$于是直接求一个逆就完了，复杂度$n\log n$。 不得不说这也算是一个小技巧了qwq]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>多项式的应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Berlekamp-Massey算法]]></title>
    <url>%2F2019%2F08%2F26%2FBM%2F</url>
    <content type="text"><![CDATA[Berlekamp-Massey算法用于在$O(n^2)$的时间内求解数列的递推式。形式化地讲，给定$a_i(i=0,1,2,3…n-1)$，求一组$b_j(j=0,1,2,3…m)$，满足：$$\forall i\geq m, a_i=\sum _{j=0}^{m} a_{i-j}b_i$$其中或许会有条件限制$m$最小。 构造考虑现在我们已经有了一个递推式$[f]$且满足了前$k$项]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Berlekamp-Massey算法</category>
      </categories>
      <tags>
        <tag>Berlekamp-Massey</tag>
        <tag>数学/常系数齐次线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】快速沃尔什变换]]></title>
    <url>%2F2019%2F08%2F26%2Ffwt%2F</url>
    <content type="text"><![CDATA[快速沃尔什变换(FWT)是一种广义上的傅里叶变换，可以解决子集并卷积、子集交卷积以及子集对称差卷积。 而在OI中决定了FWT胜过FMT的一大原因就是他可以方便地解决子集对称差卷积，即：$$c_i=\sum_{j\oplus k=i} a_jb_k$$其中$\oplus$表示二进制数的异或运算、集合的对称差运算（虽然”对称差”听起来挺有道理，但是感觉“二进制非进位加法”更有趣）。 再谈线性变换实质首先是构造，我们考虑线性变换的本质，需要有:$${\rm FWT(C)}_i={\rm FWT(B)}_i\cdot{\rm FWT(A)}_i$$那么一个思路就是先设一个辅助函数$\varphi(i,x)$出来：$${\rm FWT(F)}_i=\sum_{j\geq 0}\varphi(j,i) \cdot f_j$$那么就会有：$$\sum_{j\geq 0}\varphi(j,i) \cdot c_j=\sum_{j\geq 0}\varphi(j,i) \cdot a_j\times \sum_{j\geq 0}\varphi(j,i) \cdot b_j$$然后把$c_i=\sum_{j\oplus k=i} a_jb_k$带进去并调整：$$\begin{aligned}\sum_{j\geq 0}\varphi(j,i) \cdot \sum_{p\oplus q=j} a_pb_q &amp; =\sum_{j\geq 0}\varphi(j,i) \cdot a_j \times\sum_{j\geq 0}\varphi(j,i) \cdot b_j\\\\sum_{p \geq 0} \sum_{q\geq 0}\varphi(p\oplus q,i)\cdot a_pb_q &amp; =\sum_{p\geq 0}\sum_{q\geq 0}\varphi(p,i) \cdot \varphi(q,i)\cdot a_pb_q\\\\end{aligned}$$发现$\sum_{p\geq 0}\sum _{q\geq 0}a_pb_q$是可以消掉的，于是就有：$$\varphi(p\oplus q,i)=\varphi(p,i)\cdot \varphi(q,i)$$ 构造$\varphi$对于异或操作来说，异或前后$1$的个数的奇偶性不会改变。即也就是说$i,j$中$1$的个数加起来和$i\oplus j$中1的个数的奇偶性是一样的。形式化地讲： $$\rm bitcount(i)+bitcount(j)\equiv bitcount(i~\oplus ~j)~(\bmod 2)$$ 证明： 考虑$i \oplus j$的每一位： 若$i$和$j$的这一位相同，那么就会变成$0$，$1$的个数减二或不变； 如不同，那么就一定是$(xx1xx)\oplus(xx0xx)=(xx1xx)$，$1$的个数还是不变。 而我们发现这个引理解决的是相加不变的问题，而我们需要的$\varphi$函数需要满足相乘不变，于是自然而然地想到要放到幂上去。 于是就定义了$\varphi$:$$\varphi(s,t)=(-1)^{|s\cap t|}$$换成数值的表示方法：$$\varphi(i,j)=(-1)^{\rm bitcount \mathcal{(i ~\rm{and}~ j)}}$$这么定义的原因是：$$(i \cap x) \oplus(j \cap x)=(i \oplus j) \cap x$$即异或对交有分配律，那么： $${\rm{FWT(F)}}_i=\sum_{j \geq 0}(-1)^{|i\cap j|}f_j$$ 于是就喜提一个指数级算法 真正的$\rm{FWT}$我们发现似乎这东西没有办法dp，于是考虑： 每一次考虑新加入第$i$个物品取不取的情况，将当前集合分为$i$取和$i$不取，$i$取的放右边，$i$不取的放左边。 $i$取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小$−1$。$i$不取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小同样的不变。 这样考虑原有状态，左右两边对$i$不取的贡献都是$\text{++}$，因为集合大小不变。左边对$i$取的贡献是$+$，右边对$i$取的贡献是$\text{−−}$，因为都取$i$的话并集增加了$1$，贡献取反。 然后其实就是个模拟的思路，由于$(1xxxxxx)_2$和$(0xxxxxx)_2$的数量是一致的，所以我们可以将小于$(1000000)_2$的分为一类，大于等于$(1000000)_2$的分为一类，从数值上看就是前一半和后一半。 总之就是个FFT🦋操作的思路啦。 然后对于逆变换，因为我们刚才的结论有：$$\begin{aligned}{F[j+k] =F[j+k]+F[i+j+k]} \\ {F[i+j+k]=F[j+k]-F[i+j+k]}\end{aligned}$$所以我们现在为了得到原来的$F[i+j+k]$和$F[j+k]$，直接$$\begin{array}{c}{F[j+k]=\frac{F[j+k]+F[j+i+k]}{2}} \ {F[j+i+k]=\frac{F[j+k]-F[j+i+k]}{2}}\end{array}$$ 12345678910void fwt(int *f, int g)&#123; int i, j, k, m = 1 &lt;&lt; (N - 1), x, y ; for (i = 1 ; i &lt;= m ; i &lt;&lt;= 1) for (j = 0 ; j &lt;= M ; j += (i &lt;&lt; 1)) for (k = 0 ; k &lt; i ; ++ k)&#123; x = f[j + k], y = f[i + j + k] ; f[j + k] = 1ll * (g ^ 1 ? Inv2 : 1) * (x + y) % Mod ; f[i + j + k] = 1ll * (g ^ 1 ? Inv2 : 1) * (x + Mod - y) % Mod ; &#125;&#125; 于是时间复杂度就是$n \log n$了。 $\rm FWT$做or/and卷积艹，真是被血坑了。 才发现原来FWT做or/and卷积就是跟FMT一个道理：$$\boldsymbol{or}: F[i+j+k]+=F[j+k]\\\\boldsymbol{and}: F[j+k]+=F[i+j+k]$$然后逆变换就直接把加号改成减号就好了……原因就是“不取这个东西”一定是“取这个东西”的子集。 但是当时我认真学习FMT的时候，Rockdu博客里面FMT的代码是FWT的！！！然后再看别人的代码我就懵O了好久…… 真是zz 但是终于理解了JOHNKRAM神仙的话： 不得不说是很形象了。 后记 其实Lugou上的板子的复杂度是$2^n n$的，我一开始就觉得暴力枚举子集没啥问题，结果最后发现枚举子集不是枚举$(n)_2$的子集，而是枚举$(2^n)_2$的子集……白学了白学了 唉，本来就是功能相同的FWT和FMT，看错代码真是GG 其实只有对称差卷积难理解一些，交并卷积都是很形象的。]]></content>
      <tags>
        <tag>快速沃尔什变换(FWT)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】快速莫比乌斯变换&子集卷积]]></title>
    <url>%2F2019%2F08%2F26%2Ffmt%2F</url>
    <content type="text"><![CDATA[快速莫比乌斯变换(FMT)可以方便地解决子集交卷积和子集并卷积，形式化地讲就是求一个$\rm C$：$$c_i=\sum_{k\cup j=i} a_kb_j\\\c_i=\sum_{k\cap j=i} a_kb_j$$而快速子集变换(FST)则是在FMT基础上的扩展，解决的也是子集交卷积，但是限制了状态不重复，即$$c_i=\sum_{\substack{~k\cup j=i\\ k \cap j= \emptyset }}a_kb_j$$换个写法：$$c_s=\sum_{t\subseteq s}a_sb_{s-t}$$同时，以上两种变换所涉及的交集、并集和差集的对象都是集合（也就是$c_i$的下角标$i$指代的是集合），其二进制表示能更好地展示这一点。 $\rm{FMT}$首先我们考虑一步线性变换的实质。考虑FFT，其本质是通过DFT使得我们可以直接线性地逐项相乘，即$$\begin{aligned}\rm {C} &amp; =\rm{A*B}\\\\Longrightarrow \rm{DFT(C)_i} &amp; =\rm{DFT(A)_i\cdot DFT(B)_i}\end{aligned}$$那么我们同时也希望构造出一种变换使得可以逐项相乘。 $(1)$ 子集并卷积不妨先扩大一下范围，即若$A\cup B=C$，则一定有$A\subseteq C$且$B \subseteq C$，但是反过来不一定。 那么先考虑$\rm MT$，即考虑一种变换而不思考其复杂度。我们令$$\rm MT(F)_i= \mathcal{\sum_{j\subseteq i} f_j}$$则有$$\rm{MT(F)_i\cdot MT(G)_i}=\mathcal{\sum _{j,k\subseteq i} f_j\cdot g_k}$$而实际上我们求的是$$\rm{P_i}=\mathcal{\sum_{j\cup k=i}f_jg_k}$$而我们发现$$\begin{aligned}\sum _{j\subseteq i}{\rm}_j &amp;=\sum_{d \subseteq i} \sum_{j\cup k=d}f_jg_k\\ &amp;= \sum_{j,k\subseteq i} f_jg_k\\ &amp;= \rm{MT(P)_i}\end{aligned}$$也就是说有$$\rm MT(F)_i\cdot MT(G)_i =MT(P)_i$$于是就构造出了这样的线性变换，本质就是子集和。 但是普通的子集和是$O(2^nn)$的，但是我们的$n$是$100000$级别，所以考虑一个dp一样的东西。就是我们每次枚举每一位，那么这一位为0就是这一位为1的子集，所以类加进答案。于是这样的复杂度就变成了$n\log n$ 1234567//N = (1 &lt;&lt; M) - 1 ;void fmt_or(int *f, int g)&#123; int i, j ; for (i = 0 ; i &lt; N ; ++ i) for (j = 0 ; j &lt;= M ; ++ j) if (j &gt;&gt; i &amp; 1) f[j] = (Mod + f[j] + 1ll * g * f[j ^ (1 &lt;&lt; i)]) % Mod ;&#125; $(2)$ 子集交卷积我们对称思考，即令$\rm{MOT}$表示交卷积的变换，那么应该有：$$\rm MOT(F)_i= \mathcal{\sum_{i\subseteq j} f_j}$$那么$$\rm{MOT(F)_i\cdot MOT(G)_i}=\mathcal{\sum _{i\subseteq j,i\subseteq k} f_j\cdot g_k}$$我们要求的是$$\rm{Q_i}=\mathcal{\sum_{j\cap k=i}f_jg_k}$$则：$$\begin{aligned}\sum _{i\subseteq j}{\rm}_j &amp;=\sum_{i \subseteq d} \sum_{j\cap k=d}f_jg_k\\ &amp;= \sum_{i\subseteq j,i\subseteq k} f_jg_k\\ &amp;= {\rm{MOT(Q)}_i}\end{aligned}$$于是就直接反着求一遍即可。 然后这东西就也还是个dp，复杂度$n \log n$ 123456void fmt_and(int *f, int g)&#123; int i, j ; for (i = 0 ; i &lt; N ; ++ i) for (j = M ; j &gt;= 0 ; -- j) if (~j &gt;&gt; i &amp; 1) f[j] = (Mod + f[j] + 1ll * g * f[j | (1 &lt;&lt; i)]) % Mod ;&#125; $(3)$ 优化：增量分治阅读提示：优你🐎的化，这就是个FWT。 以下是以前的翻车现场： 实际上我觉得也没怎么优化…… 拿并卷积举例，大体上就是我们考虑如果存在$i\subseteq j\subseteq k$，我们朴素的要算两次，但实际上我们对于前半部分的$k$只需要算一次。这样实际上就是我们考虑每次只转移前$n-i$个元素相同的集合。 (以下内容来自Rockdu的$blog$) 于是每当多了一个元素，即我们考虑由$i$层转移到$i+1$层，发现只是多了一个元素的状态——讨论一下这个元素取不取，发现这个元素不取，答案就和原来一样，因为它的子集和不变；如果这个元素要取，那么这个元素不取的情况是它的子集，会多出这个元素不取的子集和。最终我们发现，到第$i$层只需要把第$i$个元素不取的状态加到第$i$个元素取的状态就可以了。 于是代码： 123456void FMT(int * A, int n, int t) &#123; for(int i = 1; i &lt; (1 &lt;&lt; n); i &lt;&lt;= 1) for(int p = i &lt;&lt; 1, j = 0; j &lt; (1 &lt;&lt; n); j += p) for(int k = 0; k &lt; i; ++k) (A[i + j + k] += A[j + k]) %= Mod ;&#125; 看上去每次只用计算一半，但是JOHNKRAM神仙是这么说的： 你看他长得和FFT的蝴蝶操作一毛一样，所以还是$n\log n$的。 = =假酒害人，假代码更害人 $\rm FST$这个名字不是很吉利 这东西其实也不是非要用$\rm FMT$来做，$\rm FWT$也可以。 然后就是考虑在卷积的时候多增加一维，即$f_{i,S}$表示集合$S$中有$i$个元素，于是发现只有当元素个数相加符合时才是对的。 于是一开始将$f_{bct(s),s}$赋值为$f_s$，其中$bct(s)=\rm bitcount(s)$。然后对每一个$f_i$分别做$\rm FMT$，之后按位乘的时候需要$$P_{i, S}=\sum_{i=0}^{i} f_{j, S} * g_{i-j, S}$$输出的时候只输出$P_{bct(s),s}$即可。 板子题是LOJ #152，略微卡常，被逼无奈写了神奇的取模优化233 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 21#define MAXM 1056701#define Mod 1000000009#define I inline#define LL long longusing namespace std ; int bc[MAXM] ;int N, M ; LL A[MAXN][MAXM], B[MAXN][MAXM], C[MAXN][MAXM] ;I int read()&#123; int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;I void reduce(LL &amp;x) &#123; x += x &gt;&gt; 63 &amp; Mod ; &#125;I void Ifmt(LL *f)&#123; register int i, j ; for (i = 0 ; i &lt; N ; ++ i) for (j = 0 ; j &lt;= M ; ++ j) if (j &gt;&gt; i &amp; 1) reduce(f[j] -= f[j ^ 1 &lt;&lt; i]) ;&#125;I void fmt(LL *f)&#123; register int i, j ; for (i = 0 ; i &lt; N ; ++ i) for (j = 0 ; j &lt;= M ; ++ j) if (j &gt;&gt; i &amp; 1) reduce(f[j] += f[j ^ 1 &lt;&lt; i] - Mod) ;&#125;int main()&#123; cin &gt;&gt; N ; M = (1 &lt;&lt; N) - 1 ; register int i, j, s ; for (i = 1 ; i &lt;= M ; ++ i) bc[i] = bc[i - (i &amp; -i)] + 1 ; for (i = 0 ; i &lt;= M ; ++ i) A[bc[i]][i] = read() ; for (i = 0 ; i &lt;= M ; ++ i) B[bc[i]][i] = read() ; for (i = 0 ; i &lt;= N ; ++ i) fmt(A[i]), fmt(B[i]) ; for (i = 0 ; i &lt;= N ; ++ i) for (j = 0 ; j &lt;= i ; ++ j) for (s = 0 ; s &lt;= M ; ++ s) (C[i][s] += A[j][s] * B[i - j][s]) %= Mod ; for (i = 0 ; i &lt;= N ; ++ i) Ifmt(C[i]) ; for (i = 0 ; i &lt;= M ; ++ i) printf("%d ", C[bc[i]][i]) ;&#125; 后记实际上国际上根本不通用FMT和FST这两个简写（甚至可能国内也没几个人用FST指代”子集卷积“）,于是就只能233了 upd：有些说明参见FWT的讲解。 $\rm Referance$ $[1]$ :Dance of Faith的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :Rockdu的$blog$ $^{^{[\nearrow ]}}$]]></content>
      <categories>
        <category>学习笔记</category>
        <category>奇怪的变换</category>
      </categories>
      <tags>
        <tag>快速莫比乌斯变换(FMT)</tag>
        <tag>快速沃尔什变换(FWT)</tag>
        <tag>快速子集变换(FST)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想十 · 繁星]]></title>
    <url>%2F2019%2F08%2F20%2F10%2F</url>
    <content type="text"><![CDATA[换了新的博客，把之前博客园里的三篇搬了下来。 每次只要我写，一定是有什么奇妙/特殊/悲伤的事情发生，或者是我内心颇不宁静。当然，往往是后者起决定性因素。 时隔几个月，我读到第一篇随想时，虽然能感受出暮夏时的无奈与懵懂，但是还是十分幸福的。 读第二篇丘吉尔时，我内心在撕裂、在纠结，昔日困顿麻木却又敏感的我，再一次呈现在自己眼前，仿佛自己经历了这么多，还是原来那个不变的少年。 读我$NOIP$的启示录的时候，我能感受到我是多么绝望——我不愿意提及这件事。但无论如何，我从那里面读出了最让人动容的东西——绝处逢生的微芒希望与铺天盖地的绝望，懵懂的爱与切骨的恨，缠绵悠长，时至今日仍然震扣我的灵魂。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【赛题整理】CF Educational Round70 题解]]></title>
    <url>%2F2019%2F08%2F19%2FEr70%2F</url>
    <content type="text"><![CDATA[Educational Round，顾名思义，教育做人专场。 这场比赛巧妙地教育了一个初出茅庐的萌新Oier（我）到底该如何做人（哭晕）。 比赛链接：戳 $~A$题意：给你两个二进制字符串$x$和$y$，将$y$左移$k$位，再与$x$相加，得到字符串$s_k$，最后将其反转得到$res_k$。求当$res_k$字典序最小时的$k$。 诡异的贪心…… 实不相瞒我想了整整半个多小时（中间伴有间歇性走神）…… 其实就是转化的思想，求反串的字典序最小，就是要把正串里面的低位1们尽量消掉。又因为题目里面限制了$x&gt;y$，所以一定存在$x$的二进制表示中至少一个$1$比$y$的最低位$1$靠左。考虑贪心的思想，$x$被消掉的$1$越靠右，反串字典序就越小。所以说我们要找的就是$\boldsymbol{x}$中能被$\boldsymbol{y}$消掉的最靠右的那个$\boldsymbol{1}$的位置。 于是扫一遍。 123456789101112cin &gt;&gt; T ;while (T --)&#123; int i, posa = 0 , posb = 0 ; scanf("%s", A + 1) ;scanf("%s", B + 1) ; int La = strlen(A + 1), Lb = strlen(B + 1) ; for (i = 1 ; i &lt;= Lb ; ++ i) if (B[i] == '1') posb = i ; posb = Lb - posb + 1 ; for (i = 1 ; i &lt;= La ; ++ i) if (A[i] == '1') if (La - i + 1 &gt;= posb) posa = La - i + 1 ;// cout &lt;&lt; posa &lt;&lt; " " &lt;&lt; posb &lt;&lt; endl ; printf("%d\n", posa - posb) ;&#125; $\it{B}$题意：给定一个计数器$(x-y)$，对于每次引进的常数$z$，可以选择$\text{((+=x)mod=10)}$ 或者$\text{((+=y)mod=10)}$（$\text{mod=}$就是%=）然后把结果再丢到运算里面继续运算。现在给定一个残缺的$z$序列（省略了中间的某些结果），求$0\text{~}9$两两组合的计数器分别至少需要多少步才能还原这个串的运算。 草，我这最短路又是白学了。 首先我们考虑一个显然的$10^4\cdot \Omega(1)$的预处理，就是令$(i-j)$为计数器，从$k$到$o$的最短距离，这玩意儿显然可以BFS，由于是对$10$取模所以大概循环节也在下界为$\Theta(1)$左右酱紫。之后对于询问直接暴力枚举就好了，复杂度大概是$100\cdot O(|S|)\leq 100\times 2,000,000=2e8$……梦想算法……但其实显然那个$100$可以只做$50+$的样子，毕竟是对称的……不过还是梦想算法233 123456789101112131415161718192021222324252627282930313233343536373839int main()&#123; int i, j, k, o ; for (i = 0 ; i &lt; 10 ; ++ i) for (j = 0 ; j &lt; 10 ; ++ j) for (k = 0 ; k &lt; 10 ; ++ k) for (o = 0 ; o &lt; 10 ; ++ o)&#123; bool mark[200] ; dis[i][j][k][o] = -1 ; memset(mark, 0, sizeof(mark)) ; q.push((wk)&#123;k, 0&#125;) ; while (!q.empty())&#123; wk now = q.front() ; q.pop() ; if (now.num == o &amp;&amp; now.cnt)&#123; dis[i][j][k][o] = now.cnt ; break ; &#125; if (mark[now.num]) continue ;mark[now.num] = 1 ; q.push((wk)&#123; (now.num + i) % 10, now.cnt + 1&#125;) ; q.push((wk)&#123; (now.num + j) % 10, now.cnt + 1&#125;) ; &#125; while (!q.empty()) q.pop() ; &#125; /*for (i = 0 ; i &lt; 10 ; ++ i) for (j = 0 ; j &lt; 10 ; ++ j) for (k = 0 ; k &lt; 10 ; ++ k) for (o = 0 ; o &lt; 10 ; ++ o) cout &lt;&lt; dis[i][j][k][o] &lt;&lt; " " ;*/ cin &gt;&gt; (In + 1) ; int ans = 0, N = strlen(In + 1) ; for (i = 1 ; i &lt;= N ; ++ i) base[i] = In[i] - '0' ; for (i = 0 ; i &lt; 10 ; ++ i, puts("")) for (j = 0 ; j &lt; 10 ; ++ j)&#123; /*qwqwq*/ for (ans = 0, k = 2 ; k &lt;= N ; ++ k)&#123; if (dis[i][j][base[k - 1]][base[k]] == -1) &#123; printf("-1 "), ans = -1 ; break ; &#125; ans += dis[i][j][base[k - 1]][base[k]] ; &#125; if (ans &gt; -1) printf("%d ", ans - N + 1) ; &#125;&#125; （代码渲染会自动把tab映射成force-tab我也懒得管了= =） $\mathcal{C}$题意：给定一段某个机器人的操作序列WSAD，可以添加一个字符，求最终机器人的最小活动区域面积。 首先显然是行列无关的，所以分开考虑；接着发现最优策略肯定是让某一步相当于没走，但是假设$x_{min}$和$x_{max}$均在这次改动操作的后面，那么缩小$x_{max}$的时候也会缩小$x_{min}$，相当于没缩——所以应找到一个界点，所有的最大值都在左/右边，对应的所有最小值都在右/左边。 由于每一步操作都是有后效性的，所以考虑直接前缀和上求出$min$和$max$就好。 但是考虑无论怎么移动，都不能越过预处理出来的$x_{min}$、$x_{max}$这个界（否则会出现越贪越大）。也就是说假设有一个$x_{max}$，接着过了一会儿有一个$x_{min}$，为了“拔高”$x_{min}$我们必须要添加一个$W$，所以我们必须要保证任何时刻不会出现$x_{max}$在放上一个$W$之后越界的情况，也就是说$x_{min}$和$x_{max}$出现的位置之间必须要一个$S$才能用来抵消掉我们$W$，需要特判。 12345678910111213141516171819202122232425262728293031323334353637383940using namespace std ; LL ans ; int fhm, fhn, fwm, fwn, pos[2][5], i ; int T, N, Sw[MAXN], Sh[MAXN] ; char S[MAXN] ;int main()&#123; cin &gt;&gt; T ; while (T --)&#123; fhm = fwm = -Inf, fhn = fwn = Inf ; scanf("%s", S + 1), N = strlen(S + 1) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; Sh[i] = Sh[i - 1], Sw[i] = Sw[i - 1] ; if (S[i] == 'W') Sh[i] = Sh[i - 1] + 1 ; else if (S[i] == 'S') Sh[i] = Sh[i - 1] - 1 ; else if (S[i] == 'D') Sw[i] = Sw[i - 1] + 1 ; else if (S[i] == 'A') Sw[i] = Sw[i - 1] - 1 ; &#125;//前缀和 : w x h for (i = 0 ; i &lt;= N ; ++ i) fwm = max(Sw[i], fwm), fwn = min(Sw[i], fwn) ; for (i = 0 ; i &lt;= N ; ++ i) fhm = max(Sh[i], fhm), fhn = min(Sh[i], fhn) ; for (i = N ; ~i ; -- i) if (Sh[i] == fhn) &#123; pos[0][4] = i ; break ; &#125; //last_min h for (i = N ; ~i ; -- i) if (Sw[i] == fwn) &#123; pos[1][4] = i ; break ; &#125; //last_min h for (i = 0 ; i &lt;= N ; ++ i) if (Sh[i] == fhm) &#123; pos[0][1] = i ; break ; &#125; //first_max h for (i = 0 ; i &lt;= N ; ++ i) if (Sw[i] == fwm) &#123; pos[1][1] = i ; break ; &#125; //first_max w for (i = N ; ~i ; -- i) if (Sh[i] == fhm) &#123; pos[0][3] = i ; break ; &#125; //last_max h for (i = N ; ~i ; -- i) if (Sw[i] == fwm) &#123; pos[1][3] = i ; break ; &#125; //last_max h for (i = 0 ; i &lt;= N ; ++ i) if (Sh[i] == fhn) &#123; pos[0][2] = i ; break ; &#125; //first_min h for (i = 0 ; i &lt;= N ; ++ i) if (Sw[i] == fwn) &#123; pos[1][2] = i ; break ; &#125; //first_min w ans = 1ll * (fwn - fwm - 1) * (fhn - fhm - 1) ; //cout &lt;&lt; ans &lt;&lt; endl ; if (pos[0][3] &lt; pos[0][2] &amp;&amp; Sh[pos[0][3]] - Sh[pos[0][2]] &gt; 1) ans = min(ans, 1ll * (fhm - fhn) * (fwm - fwn + 1)) ; if (pos[1][3] &lt; pos[1][2] &amp;&amp; Sw[pos[1][3]] - Sw[pos[1][2]] &gt; 1) ans = min(ans, 1ll * (fhm - fhn + 1) * (fwm - fwn)) ; if (pos[0][4] &lt; pos[0][1] &amp;&amp; Sh[pos[0][4]] - Sh[pos[0][1]] &lt; -1) ans = min(ans, 1ll * (fhm - fhn) * (fwm - fwn + 1)) ; if (pos[1][4] &lt; pos[1][1] &amp;&amp; Sw[pos[1][4]] - Sw[pos[1][1]] &lt; -1) ans = min(ans, 1ll * (fhm - fhn + 1) * (fwm - fwn)) ; cout &lt;&lt; ans &lt;&lt; endl ; pos[0][1] = pos[1][1] = pos[0][2] = pos[1][2] = Inf ; pos[0][3] = pos[1][3] = pos[0][4] = pos[1][4] = -Inf ; &#125;&#125; emmmm好像当时debug了好久的样子。 $\rm{D}$题意：构造一个含有1/3/7的串，使得子序列1337的数量恰好为$x$。 这特么就是一个智商题。就是考虑一个最简单的构造133..3337这种，但是不是每一个$x$都可以表示成$\frac{p(p-1)}{2}$这种形式的……所以考虑找出最大的$p~\rm{s.t.}$ $p(p-1)\leq 2x$，然后拼命地向第一组33后面添加7就好了。这样总长度是上限是$2\sqrt x$的，挺稳。 1234567891011121314int main()&#123; cin &gt;&gt; T ; while (T --)&#123; cin &gt;&gt; N ; int p = sqrt(2*N); for (int i = p ; i &lt;= 2*N ; ++ i)&#123; if (i * (i - 1) &gt; 2 * N) break ; L1 = i * (i - 1) / 2, L2 = N - L1, L1 = i ; &#125; printf("133") ; for (int i = 1 ; i &lt;= L2 ; ++ i) putchar('7') ; for (int i = 1 ; i &lt;= L1 - 2 ; ++ i) putchar('3') ; printf("7\n") ; &#125;&#125; $\mathbb{E}$题意：给定$N~(\leq 1e5)$个模板串$s_i$和一个文本串$T$，求所有的$s_i+s_j~(i\not=j)$在$T$中出现的次数之和。 嗯，顺带复习了一下$AC$自动机。 思路其实也很简单，就是建俩$AC$自动机，一个跑正串，一个跑反串，然后枚举每个合法的i作为中间的结合位点，乘法原理就好了……但其实这种结论能轻易得出还是建立在$AC$自动机掌握十分扎实的基础上啊。 哦对，似乎对于AC自动机的题目，树形dp才是正确的打开方式。每次重新跳fail根本吃不消。。（CF真的有数据去卡这东西，aaa..aa这种……） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859char S[MAXN], In[MAXN] ; int N ; struct ACm&#123; queue &lt;int&gt; q ; int cnt ; int tr[MAXN][27], res[MAXN] ; int fail[MAXN], ans[MAXN], e[MAXN] ; #define v(x) tr[rt][x] void insert(char *s, int Id)&#123; int i, j = strlen(s), k, rt = 0 ; for (i = 0 ; i &lt; j ; ++ i)&#123; k = s[i] - 'a' ; if (!v(k)) v(k) = ++ cnt ; rt = v(k) ; &#125; e[rt] ++ ; &#125; void build()&#123; int i, rt = 0 ; for (i = 0 ; i &lt; 26 ; ++ i) if (v(i)) q.push(v(i)) ; while (!q.empty())&#123; rt = q.front(), q.pop() ; for (i = 0 ; i &lt; 26 ; ++ i)&#123; if (!v(i)) v(i) = tr[fail[rt]][i] ; else fail[v(i)] = tr[fail[rt]][i], q.push(v(i)) ;// if (e[fail[v(i)]]) last[v(i)] = fail[v(i)] ; else last[v(i)] = last[fail[v(i)]] ; &#125; &#125; &#125;/* void work(char *s)&#123; int i, j = strlen(s), p, rt = 0 ; for (i = 0 ; i &lt; j ; ++ i)&#123; rt = v(s[i] - 'a'), p = rt ; while(p) res[i] += e[p], p = fail[p] ; &#125; &#125;*/ int dfs(int rt)&#123; if (!rt) return 0 ; if (res[rt] != -1) return res[rt] ; return res[rt] = e[rt] + dfs(fail[rt]) ; &#125; void work(char *s)&#123; memset(res, -1, sizeof(res)) ; int i, j = strlen(s), p, rt = 0 ; for (i = 0 ; i &lt; j ; ++ i) rt = v(s[i] - 'a'), ans[i] = dfs(rt) ; &#125;&#125;P, Q ; LL ans ; int main()&#123; cin &gt;&gt; S &gt;&gt; N ; int i, j ; for (i = 1 ; i &lt;= N ; ++ i)&#123; scanf("%s", In), P.insert(In, i) ; j = strlen(In), reverse(In, In + j), Q.insert(In, i) ; &#125; P.build(), Q.build() ; j = strlen(S) ; P.work(S), j = strlen(S) ; reverse(S, S + j) ; Q.work(S) ;// for (i = 0 ; i &lt; j ; ++ i) cout &lt;&lt; P.res[i] &lt;&lt; " " ; puts("") ;// for (i = 0 ; i &lt; j ; ++ i) cout &lt;&lt; Q.res[i] &lt;&lt; " " ; for (i = 0 ; i &lt; j ; ++ i) ans += 1ll * P.ans[i] * Q.ans[j - 2 - i] ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; $\mathfrak{F}$题意：给定大写字母$A$和$B$的数量，求可以组成多少种不同的最短周期。其中周期的定义式不完全的，即只需要满足$\forall i,s[i]=s[i~\bmod~k]$，$k$就是周期。 这真是神仙题…… 下文中用$a,b$表示输入的那俩值。 考虑对于一个合法的$k$而言，假设在这个$k$满足$k=\lfloor n/p\rfloor,p\in \mathbb{N}$，那么$p$就是循环节的数量。现在我们假设有$q_a+q_b=k$，即每一段循环节中$A$的数量和$B$的数量。那么一定需要满足的是$q_a\cdot p\leq a$并且$q_b\cdot p\leq b$。 同时考虑一定会有$$q_a \leq \lfloor\frac{a}{p}\rfloor, q_b \leq \lfloor\frac{b}{p}\rfloor$$但同时还有一个条件，就是虽然实际上多出去一堆下脚料，但$a_{rest},b_{rest}$必须小于等于$q_a$和$q_b$。也就是说需要有$$(p+1)\cdot q_a \geq a,(p+1)\cdot q_b\geq b$$ 美化一下就是 $$\lceil \frac{a}{p+1} \rceil \leq q_a\leq \lfloor \frac{a}{p} \rfloor \\\\lceil \frac{b}{p+1} \rceil \leq q_b\leq \lfloor \frac{b}{p} \rfloor$$ 就可以通过从$1$到$n$枚举$p$来求得$q_a$和$q_b$，那么根据定义，$q_a$和$q_b$是一段循环节中的$A$和$B$的数量，所以$q_a+q_b$对$k$产生贡献。 还有一个小问题，就是如何保证一定是最小的$k$。这个其实也很简单。假设对于每一段完整的循环节他同时也自循环，段和段之间$A$和$B$个数一定相同，所以可以考虑直接把每一段的$A$丢到前面，$B$丢到后面，就避免了自循环这种情况。 然后这东西显然是可以数论分块的，所以我们分一下块就做完了. 123456789101112131415161718#define LL long long#define Mod 1000000007using namespace std ;int N, M, L ; LL Ans ;int main()&#123; cin &gt;&gt; N &gt;&gt; M, L = N + M ; for (int g, l = 1, r ; l &lt;= L ; l = r + 1)&#123; g = L / l, r = L / g ; if (N &lt; g || M &lt; g) continue ; int ln = (N + g) / (g + 1), hn = N / g ; int lm = (M + g) / (g + 1), hm = M / g ; if (hn &gt;= ln &amp;&amp; hm &gt;= lm) Ans += max(0ll, 1ll * (min(hn + hm, r) - max(l, lm + ln) + 1)) ; &#125; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; 完结撒🌹fa~]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/构造</tag>
        <tag>奇怪的技巧</tag>
        <tag>动态规划-树形DP</tag>
        <tag>AC自动机</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】留言板]]></title>
    <url>%2F2019%2F08%2F09%2F%E7%95%99%E8%A8%80%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[学rvalue造了个留言板，也顺便整理一些有趣的事情。 看起来似乎是用来留言的？或许吧233 Σ( ° △ °|||)︴这东西是给大家留言的辣，挂友链/踩爆我/吐槽blog的设计都阔以的啊QAQ 以下是被教育做人的经历： ​ 人生有许多道：曾经踏足的是道，即将踏往的也是道，那什么才是道呢？唯有脚下走的才是道。一切精神或者物质都归于虚无，然后从混沌中衍生出三万道。在悲喜间涉足一条无数前人经历过，且将有无数后人奔赴的道，无论是否已经或者将要到达彼岸，然后便不再回头或是左顾右盼，即使有些道繁盛至极，夜灯如昼，无数人一浪又一浪的涌去，造就了世人皆知的辉煌；即使有些道草木凋敝，荒草丛生，只等勇敢的开拓者斩开荆棘，创造一片天地；这些都无所关，无所在意，彼岸何如、来日何方甚至过往旧事都化作一缕云烟，飘渺碧霄，我自撷高山之月色，独随足落处往行。 ​ ——SD队长ckw 笔蘸波涛饰昆仑 ​ ——konoset学长 居然有人想要我这种老年选手的企鹅号：2836531293]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】多项式的快速插值和求值]]></title>
    <url>%2F2019%2F08%2F07%2Fqzcz%2F</url>
    <content type="text"><![CDATA[多项式的求值即给出一支多项式$\rm{F}$，同时给出多个$x$求出相应的${\rm{F}}_{[x]}$ 多项式的插值即给出$n+1$个点对$(x,{\rm F}_{[x]}),$ 根据唯一分解定理求出对应的多项式$\rm{F}$ $1$ 多点求值还是分治+构造。 首先一种思维是：用多项式除法来降次。 具体来说就是$$\rm{F=PQ+R}$$这是带余除法的标准式，其中一定保证了$\deg(\rm{R})\leq \deg(\rm{P})$且$\deg(\rm{R})\leq \deg(\rm{Q})$. 所以假设我们令$\rm{P_{[x]}Q_{[x]}}=0$，那么对于同一个$x$就会有$\rm{F_{[x]}=R_{[x]}}$。 所以我们如果想要分治，那么就需要先构造出一个$\rm{Q}$且$\deg(\rm{Q})=\frac{1}{2}\deg(\rm F)$ 那么我们直接让$\rm F$对$\rm Q$取模就可以得到$\rm R$，然后不断分治下去就可以$n \log^2 n$计算了。 设第$i$个需要求值的$x$是$A_i$，那么关于F的构造其实很简单，只需要让他满足$\rm Q_{[A_i]}=0$即可，所以完全可以想到构造一个$m$次的多项式$\rm Q$：$$\rm Q=\prod(x-A_i)$$显然这个东西，他还是可以分治来做，于是多点求值似乎就不能再优化了，因为他复杂度完全平衡了，即预处理复杂度和运算复杂度都是$\log^2$级别的。 哦，然后对于LuoguP5050这道题，卡常十分严重，所以一开始的版本是这个画风的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#pragma GCC target("avx")#pragma GCC optimize(2)#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#pragma GCC optimize("inline")#pragma GCC optimize("-fgcse")#pragma GCC optimize("-fgcse-lm")#pragma GCC optimize("-fipa-sra")#pragma GCC optimize("-ftree-pre")#pragma GCC optimize("-ftree-vrp")#pragma GCC optimize("-fpeephole2")#pragma GCC optimize("-ffast-math")#pragma GCC optimize("-fsched-spec")#pragma GCC optimize("unroll-loops")#pragma GCC optimize("-falign-jumps")#pragma GCC optimize("-falign-loops")#pragma GCC optimize("-falign-labels")#pragma GCC optimize("-fdevirtualize")#pragma GCC optimize("-fcaller-saves")#pragma GCC optimize("-fcrossjumping")#pragma GCC optimize("-fthread-jumps")#pragma GCC optimize("-funroll-loops")#pragma GCC optimize("-fwhole-program")#pragma GCC optimize("-freorder-blocks")#pragma GCC optimize("-fschedule-insns")#pragma GCC optimize("inline-functions")#pragma GCC optimize("-ftree-tail-merge")#pragma GCC optimize("-fschedule-insns2")#pragma GCC optimize("-fstrict-aliasing")#pragma GCC optimize("-fstrict-overflow")#pragma GCC optimize("-falign-functions")#pragma GCC optimize("-fcse-skip-blocks")#pragma GCC optimize("-fcse-follow-jumps")#pragma GCC optimize("-fsched-interblock")#pragma GCC optimize("-fpartial-inlining")#pragma GCC optimize("no-stack-protector")#pragma GCC optimize("-freorder-functions")#pragma GCC optimize("-findirect-inlining")#pragma GCC optimize("-fhoist-adjacent-loads")#pragma GCC optimize("-frerun-cse-after-loop")#pragma GCC optimize("inline-small-functions")#pragma GCC optimize("-finline-small-functions")#pragma GCC optimize("-ftree-switch-conversion")#pragma GCC optimize("-foptimize-sibling-calls")#pragma GCC optimize("-fexpensive-optimizations")#pragma GCC optimize("-funsafe-loop-optimizations")#pragma GCC optimize("inline-functions-called-once")#pragma GCC optimize("-fdelete-null-pointer-checks")#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define rr register#define MAXN 270009#define LL long long#define Mod 998244353using namespace std ;const LL Gp = 3 ; vector &lt;int&gt; P[MAXN] ;int N, M, base[MAXN], F[MAXN], gg[20][MAXN], Ls[MAXN], R[MAXN] ;inline LL expow(LL a, int b)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= Mod ; a = a * a % Mod, b &gt;&gt;= 1 ; &#125; return res ;&#125;inline void NTT(int *J, const int &amp;L, const int &amp;flag)&#123; rr int m = 0, i ; for (i = 0 ; i &lt; L ; ++ i) if (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ; for (i = 1 ; i &lt; L ; i &lt;&lt;= 1, ++ m)&#123; rr int *rua = gg[m] ; for (int j = 0 ; j &lt; L ; j += (i &lt;&lt; 1))&#123; for (int k = 0 ; k &lt; i ; ++ k)&#123; LL real = J[j + k], iroot = J[j + k + i] * (LL)rua[k] ; J[j + k] = (real + iroot) % Mod, J[j + k + i] = ((real - iroot) % Mod +Mod)%Mod; &#125; &#125; &#125; if (flag &gt; 0) return ; rr int Inv = expow(L, Mod - 2) ; reverse(J + 1, J + L) ; for (int i = 0 ; i &lt; L ; ++ i) J[i] = 1ll * J[i] * Inv % Mod ;&#125;int X[MAXN], Y[MAXN] ;void segNTT(int l, int r, int rt)&#123; if (l == r)&#123; Ls[rt] = 1 ; P[rt].push_back((-base[l]%Mod+Mod)%Mod) ; P[rt].push_back(1) ; return ; &#125; int i ; int lc = rt &lt;&lt; 1 ; int rc = rt &lt;&lt; 1 | 1 ; int mid = (l + r) &gt;&gt; 1 ; segNTT(l, mid, rt &lt;&lt; 1) ; segNTT(mid + 1, r, rt &lt;&lt; 1 | 1) ; Ls[rt] = Ls[rt &lt;&lt; 1] + Ls[rt &lt;&lt; 1 | 1] ; int Len = 1, l1 = 0 ; while (Len &lt; ((Ls[rt] + 1) &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l1 ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l1 - 1)) ; for (i = Ls[lc] + 1 ; i &lt; Len ; ++ i) X[i] = 0 ; for (i = Ls[rc] + 1 ; i &lt; Len ; ++ i) Y[i] = 0 ; for (i = 0 ; i &lt;= Ls[lc] ; ++ i) X[i] = P[lc][i] ; for (i = 0 ; i &lt;= Ls[rc] ; ++ i) Y[i] = P[rc][i] ; NTT(X, Len, 1), NTT(Y, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) X[i] = (LL)X[i] * (LL)Y[i] % Mod ; NTT(X, Len, -1) ; for (i = 0 ; i &lt;= Ls[rt] ; ++ i) P[rt].push_back(X[i]) ;&#125;int t[MAXN], ig[MAXN] ;int gt[MAXN], ft[MAXN] ;void Inv(int *f, int *g, const int &amp;len)&#123; if (len &lt;= 1) &#123; g[0] = expow(f[0], Mod - 2) ; return ; &#125; int i, l = 0, Len = 1 ; Inv(f, g, (len + 1) &gt;&gt; 1) ; while (Len &lt; (len &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; for (i = 0 ; i &lt; len ; ++ i) t[i] = f[i] ; NTT(g, Len, 1), NTT(t, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) g[i] = (2ll - (LL)t[i] * (LL)g[i] % Mod + Mod) % Mod * (LL)g[i] % Mod ; NTT(g, Len, -1) ; for (i = len ; i &lt; Len ; ++ i) g[i] = 0 ;&#125;int G[MAXN] ;inline void _Mod(int *f, vector&lt;int&gt; g, int n, int m, int* Rs)&#123; register int l = 0, O = n - m + 1, L , i ; for (i = 0 ; i &lt;= (n &lt;&lt; 1) ; ++ i) ig[i] = ft[i] = gt[i] = 0 ; for (i = 0 ; i &lt;= n ; ++ i) ft[i] = f[n - i] ; for (i = 0 ; i &lt;= m ; ++ i) gt[i] = g[m - i] ; l = 0, L = 1 ; for (i = O ; i &lt; (n &lt;&lt; 1); ++ i) ft[i] = gt[i] = 0 ; Inv(gt, ig, O) ; while (L &lt; (O &lt;&lt; 1)) L &lt;&lt;= 1,++ l ; for (i = 0 ; i &lt;= L ; ++ i) t[i] = 0 ; for (i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; NTT(ig, L, 1), NTT(ft, L, 1) ; for (i = 0 ; i &lt; L ; ++ i) X[i] = 1ll * ft[i] * ig[i] % Mod ; NTT(X, L, - 1) ; reverse(X, X + O) ; for (i = O ; i &lt; L ; ++ i) X[i] = 0 ; O = n + 1, L = 1, l = 0 ; while (L &lt; (O &lt;&lt; 1)) L &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; L ; ++ i) G[i] = Y[i] = 0 ; for (i = 0 ; i &lt;= m ; ++ i) G[i] = g[i] ; for (i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; NTT(X, L, 1) ; NTT (G, L, 1) ; for (i = 0 ; i &lt; L ; ++ i) Y[i] = 1ll * G[i] * X[i] % Mod, X[i] = 0 ; NTT(Y, L, -1) ; for (i = 0 ; i &lt;= m - 1 ; ++ i) Rs[i] = ((1ll * f[i] - Y[i]) + Mod) % Mod ;&#125;void cdqNTT(int l, int r, int rt, int *f)&#123; if (l == r) &#123; printf("%d", *f), putchar('\n') ; return ;&#125; int T[(Ls[rt] + 2) &lt;&lt; 1] ; rr int mid = (l + r) &gt;&gt; 1, i, lc = rt &lt;&lt; 1, rc = rt &lt;&lt; 1 | 1 ; _Mod(f, P[lc], Ls[rt] - 1, Ls[lc], T) ; cdqNTT(l, mid, lc, T) ; _Mod(f, P[rc], Ls[rt] - 1, Ls[rc], T) ; cdqNTT(mid + 1, r, rc, T) ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; int i, j ; for (i = 0 ; i &lt; 19 ;++ i)&#123; int *rua = gg[i] ; rua[0] = 1 ; int gi = rua[1] = expow(3, 998244352/(1 &lt;&lt; (i + 1))) ; for (j = 2 ; j &lt; (1 &lt;&lt; i) ; ++ j) rua[j] = 1ll * rua[j - 1] * gi % Mod ; &#125; for (i = 0 ; i &lt;= N ; ++ i) scanf("%d", &amp;F[i]) ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%d", &amp;base[i]) ; segNTT(1, M, 1), memset(X, 0, sizeof(X)), memset(Y, 0, sizeof(Y)) ; if (N &gt;= M) _Mod(F, P[1], N, M, F) ; cdqNTT(1, M, 1, F) ; return 0 ;&#125; 逼得我差点上指令集 然后发现是这个NTT常数太大了，所以考虑直接边角暴力，区间长度小到一定地步直接暴力秦九韶并且循环展开： 1234567891011121314151617181920212223void cdqNTT(int l, int r, int rt, int *f)&#123; if (r - l &lt;= 1024) &#123; for (int i = l ; i &lt;= r ; ++ i)&#123; LL x = base[i], c1, c2, c3, c4, now = f[r - l] ; b[0] = 1 ; for (int j = 1 ; j &lt;= 16 ; ++ j) b[j] = b[j - 1] * x % Mod ; for (int j=r-l-1;j-15&gt;=0;j-=16)&#123; c1=(1ll*now*b[16]+1ll*f[j]*b[15]+1ll*f[j-1]*b[14]+1ll*f[j-2]*b[13])%Mod, c2=(1ll*f[j-3]*b[12]+1ll*f[j-4]*b[11]+1ll*f[j-5]*b[10]+1ll*f[j-6]*b[9])%Mod, c3=(1ll*f[j-7]*b[8]+1ll*f[j-8]*b[7]+1ll*f[j-9]*b[6]+1ll*f[j-10]*b[5])%Mod, c4=(1ll*f[j-11]*b[4]+1ll*f[j-12]*b[3]+1ll*f[j-13]*b[2]+1ll*f[j-14]*b[1])%Mod, now=(0ll+c1+c2+c3+c4+f[j-15])%Mod; &#125; for(int j = (r-l)%16-1 ; j &gt;= 0 ; -- j)now=(1ll*now*x+f[j])%Mod; printf("%d", now), putchar('\n') ; &#125; return ; &#125;// if (l == r) &#123; printf("%d", *f), putchar('\n') ; return ;&#125; int T[(Ls[rt] + 2) &lt;&lt; 1] ; rr int mid = (l + r) &gt;&gt; 1, i, lc = rt &lt;&lt; 1, rc = rt &lt;&lt; 1 | 1 ; _Mod(f, P[lc], Ls[rt] - 1, Ls[lc], T) ; cdqNTT(l, mid, lc, T) ; _Mod(f, P[rc], Ls[rt] - 1, Ls[rc], T) ; cdqNTT(mid + 1, r, rc, T) ;&#125; 然后就可以随便过了。 $2$ 快速插值首先思考拉格朗日插值：$$\rm{F}=\mathcal{\sum y_i\prod_{i\neq j}\frac{x-x_j}{x_i-x_j}}$$我们发现$\prod (x-x_j)$就是个弟弟，于是考虑：$$\rm{G}=\mathcal {\sum \frac{y_i}{\prod_{i\neq j}x_i-x_j}}$$如果我们随便设一个多项式$ \phi(x)$$$\phi=\prod(x-x_i)$$那么原式就变成了：$$\rm{G}=\mathcal {\sum \frac{y_i}{\frac{\phi(x_i)}{x-x_i}}}$$这东西就可以： 就可以洛！即$$\lim _{x \rightarrow a} \frac{f(x)}{g(x)}=\lim _{x \rightarrow a} \frac{f^{\prime}(x)}{g^{\prime}(x)}$$由于是形式幂级数之间的运算，于是就可以胡搞，也就是$$\frac{\phi(x_i)}{x-x_i}=\phi’(x_i)$$显然关于这个$\phi$是可以分治的，分治完求一个导然后再多点求值即可。 回代之后，求个逆就可以求出G，之后接着分治后面的$\prod(x-x_j)$就完了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define rr register#define MAXN 300011#define LL long long#define Mod 998244353using namespace std ; int Len[MAXN], Q[MAXN], R[MAXN] ;int N, *P[MAXN], *K[MAXN], bx[MAXN], gg[25][MAXN], by[MAXN], cy[MAXN] ;const int ch_top=4e7+3;char ch[ch_top],*now_r=ch-1,*now_w=ch-1;inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x;&#125;inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w=' ';&#125;inline LL expow(int a, int b)&#123; rr LL res = 1 ; while (b)&#123; if (b &amp; 1) res = res * 1ll * a % Mod ; a = 1ll * a * a % Mod, b &gt;&gt;= 1 ; &#125; return res ;&#125;inline void pre()&#123; rr int i, j ; for (i = 0 ; i &lt; 20 ; ++ i)&#123; int *now = gg[i] ; now[0] = 1 ; int p = now[1] = expow(3, 998244352 / (1 &lt;&lt; (i + 1))) ; for (j = 2 ; j &lt; (1 &lt;&lt; i) ; ++ j) now[j] = 1ll * now[j - 1] * p % Mod ; // -1 &#125;&#125;void NTT(int *J, int L, int o)&#123; rr int i, j, k, m = 0 ; for (i = 0 ; i &lt; L ; ++ i) if (i &lt; R[i]) swap(J[R[i]], J[i]) ; for (i = 1 ; i &lt; L ; i &lt;&lt;= 1, ++ m)&#123; const int *now = gg[m] ; for (j = 0 ; j &lt; L ; j += (i &lt;&lt; 1)) for (k = 0 ; k &lt; i ; ++ k)&#123; const LL x = J[j + k], y = 1ll * now[k] * J[i + j + k] ; J[j + k] = (x + y) % Mod, J[i + j + k] = ((x - y) % Mod + Mod) % Mod ; &#125; &#125; if (o &gt; 0) return ; const int inv = expow(L, Mod - 2) ; reverse(J + 1, J + L) ; for (i = 0 ; i &lt; L ; ++ i) J[i] = 1ll * inv * J[i] % Mod ;&#125;int ft[MAXN], gt[MAXN], ig[MAXN] ;int t[MAXN], G[MAXN], X[MAXN], Y[MAXN] ;void Inv(int *f, int *g, const int &amp;len)&#123; if (len &lt;= 1) &#123; g[0] = expow(f[0], Mod - 2) ; return ; &#125; rr int i, l = 0, Len = 1 ; Inv(f, g, (len + 1) &gt;&gt; 1) ; while (Len &lt; (len &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; for (i = 0 ; i &lt; len ; ++ i) t[i] = f[i] ; NTT(g, Len, 1), NTT(t, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) g[i] = (2ll - (LL)t[i] * (LL)g[i] % Mod + Mod) % Mod * (LL)g[i] % Mod ; NTT(g, Len, -1) ; for (i = len ; i &lt; Len ; ++ i) g[i] = 0 ;&#125;void solve(int l, int r, int rt)&#123; if (l == r)&#123; P[rt] = new int[2] ; Len[rt] = 1 ; P[rt][0] = (-bx[l]+Mod)%Mod , P[rt][1] = 1 ; return ; &#125; rr int i ; int lc = rt &lt;&lt; 1 ; int rc = rt &lt;&lt; 1 | 1 ; int mid = (l + r) &gt;&gt; 1 ; solve(l, mid, lc), solve(mid + 1, r, rc) ; Len[rt] = Len[lc] + Len[rc], P[rt] = new int[Len[rt] + 1] ; rr int L = 1, l1 = 0 ; while (L &lt; ((Len[rt] + 1) &lt;&lt; 1)) L &lt;&lt;= 1, ++ l1 ; for (i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l1 - 1)) ; for (i = Len[lc] + 1 ; i &lt; L ; ++ i) X[i] = 0 ; for (i = Len[rc] + 1 ; i &lt; L ; ++ i) Y[i] = 0 ; for (i = 0 ; i &lt;= Len[lc] ; ++ i) X[i] = P[lc][i] ; for (i = 0 ; i &lt;= Len[rc] ; ++ i) Y[i] = P[rc][i] ; NTT(X, L, 1), NTT(Y, L, 1) ; for (i = 0 ; i &lt; L ; ++ i) X[i] = 1ll * X[i] * Y[i] % Mod ; NTT(X, L, -1) ; for (i = 0 ; i &lt;= Len[rt] ; ++ i) P[rt][i] = X[i] ;&#125;void _Dev(int *f, int *g, int len)&#123; rr int i ; g[len] = 0 ; for(i = 1 ; i &lt;= len ; ++ i) g[i - 1] = 1ll * i * f[i] % Mod ;&#125;void _Mod(int *f, int *g, int *res, int n, int m)&#123; int L = 1, l = 0, i, o = n - m + 1, d = n &lt;&lt; 1 ; for (i = 0 ; i &lt; d ; ++ i) ft[i] = gt[i] = ig[i] = 0 ; for (i = 0 ; i &lt;= n ; ++ i) ft[i] = f[n - i] ; for (i = 0 ; i &lt;= m ; ++ i) gt[i] = g[m - i] ; for (i = o ; i &lt; (n &lt;&lt; 1) ; ++ i) ft[i] = gt[i] = 0 ; Inv(gt, ig, o) ; while (L &lt; (o &lt;&lt; 1)) L &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; L ; ++ i) t[i] = 0, R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ;//1 NTT(ig, L, 1) ; NTT(ft, L, 1) ; for (i = 0 ; i &lt; L ; ++ i) X[i] = 1ll * ft[i] * ig[i] % Mod ; NTT(X, L, -1) ; reverse(X, X + o) ; for (i = o ; i &lt; L ; ++ i) X[i] = 0 ; o = n + 1, L = 1, l = 0 ; while (L &lt; (o &lt;&lt; 1)) L &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; L ; ++ i) G[i] = 0 ; for (i = 0 ; i &lt;= m ; ++ i) G[i] = g[i] ; for (i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ;//2 NTT(X, L, 1) ; NTT(G, L, 1) ; for (i = 0 ; i &lt; L ; ++ i) Y[i] = 1ll * X[i] * G[i] % Mod, X[i] = 0 ;//3 NTT(Y, L, -1) ; for (i = 0 ; i &lt;= m - 1 ; ++ i) res[i] = ((1ll * f[i] - Y[i]) % Mod + Mod) % Mod;&#125;LL b[100] ;void cdqNTT(int l, int r, int rt, int *f)&#123; if (r - l &lt;= 512) &#123; for (int i = l ; i &lt;= r ; ++ i)&#123; LL x = bx[i], c1, c2, c3, c4, now = f[r - l] ; b[0] = 1 ; for (int j = 1 ; j &lt;= 16 ; ++ j) b[j] = b[j - 1] * x % Mod ; for (int j=r-l-1;j-15&gt;=0;j-=16)&#123; c1=(1ll*now*b[16]+1ll*f[j]*b[15]+1ll*f[j-1]*b[14]+1ll*f[j-2]*b[13])%Mod, c2=(1ll*f[j-3]*b[12]+1ll*f[j-4]*b[11]+1ll*f[j-5]*b[10]+1ll*f[j-6]*b[9])%Mod, c3=(1ll*f[j-7]*b[8]+1ll*f[j-8]*b[7]+1ll*f[j-9]*b[6]+1ll*f[j-10]*b[5])%Mod, c4=(1ll*f[j-11]*b[4]+1ll*f[j-12]*b[3]+1ll*f[j-13]*b[2]+1ll*f[j-14]*b[1])%Mod, now=(0ll+c1+c2+c3+c4+f[j-15])%Mod; &#125; for(int j = (r-l)%16-1 ; j &gt;= 0 ; -- j)now=(1ll*now*x+f[j])%Mod; cy[i] = now ; &#125; return ; &#125;// if (l == r) &#123; printf("%d", *f), putchar('\n') ; return ;&#125; int T[(Len[rt] + 2) &lt;&lt; 1] ; rr int mid = (l + r) &gt;&gt; 1, i, lc = rt &lt;&lt; 1, rc = rt &lt;&lt; 1 | 1 ; _Mod(f, P[lc], T, Len[rt] - 1, Len[lc]) ; cdqNTT(l, mid, lc, T) ; _Mod(f, P[rc], T, Len[rt] - 1, Len[rc]) ; cdqNTT(mid + 1, r, rc, T) ;&#125;/*void cdqNTT(int l, int r, int rt, int *f)&#123; int T[(Len[rt] + 2) &lt;&lt; 1] ; if (l == r) &#123; cy[l] = f[0] ; return ; &#125; int mid = (l + r) &gt;&gt; 1, lc = rt &lt;&lt; 1, rc = lc | 1 ; _Mod(f, P[lc], T, Len[rt] - 1, Len[lc]), cdqNTT(l, mid, lc, T) ; _Mod(f, P[rc], T, Len[rt] - 1, Len[rc]), cdqNTT(mid + 1, r, rc, T) ;&#125;*/void cdqLg(int l, int r, int rt)&#123; if (l == r)&#123; K[rt] = new int[2] ; K[rt][0] = 1ll * by[l] * expow(cy[l], Mod - 2) % Mod ; K[rt][1] = 0 ; return ; &#125; static int A[MAXN], B[MAXN], C[MAXN], D[MAXN] ; rr int mid = (l + r) &gt;&gt; 1, lc = rt &lt;&lt; 1, rc = lc | 1, i ; cdqLg(l, mid, lc), cdqLg(mid + 1, r, rc) ; int L = 1, l0 = 0 ; while (L &lt; ((Len[rt] + 1) &lt;&lt; 1)) L &lt;&lt;= 1, ++ l0 ; for (i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l0 - 1)) ; for (i = Len[lc] + 1 ; i &lt; L ; ++ i) A[i] = C[i] = 0 ; for (i = Len[rc] + 1 ; i &lt; L ; ++ i) B[i] = D[i] = 0 ; for (i = 0 ; i &lt;= Len[lc] ; ++ i) A[i] = K[lc][i], C[i] = P[lc][i] ; for (i = 0 ; i &lt;= Len[rc] ; ++ i) B[i] = K[rc][i], D[i] = P[rc][i] ; NTT(A, L, 1), NTT(B, L, 1), NTT(C, L, 1), NTT(D, L, 1) ; for (i = 0 ; i &lt; L ; ++ i) A[i] = (1ll * A[i] * D[i] % Mod + 1ll * B[i] * C[i] % Mod) % Mod ; NTT(A, L, -1) ; K[rt] = new int[Len[rt] + 1] ; for(i = 0 ; i &lt;= Len[rt] ; ++ i ) K[rt][i] = A[i] ;&#125;int main()&#123;// rr int W ; freopen("2.in", "r", stdin) ; fread(ch,1,ch_top,stdin); N = read() ; int i ; pre() ; for (i = 1 ; i &lt;= N ; ++ i) bx[i] = read(), by[i] = read() ; solve(1, N, 1) ; memset(X, 0, sizeof(X)) ; memset(Y, 0, sizeof(Y)); _Dev(P[1], Q, Len[1]) ; cdqNTT(1, N, 1, Q) ; cdqLg(1, N, 1) ;// for (i = 0 ; i &lt; N ; ++ i) cout &lt;&lt; K[1][i] &lt;&lt; " " ; for (i = 0 ; i &lt; N ; ++ i) write(K[1][i]) ; fwrite(ch,1,now_w-ch,stdout) ; return 0 ;&#125; 总结：すべて分割べることのできる多項式生活最高だ！（一切皆可分治的多项式生活赛高！）]]></content>
      <tags>
        <tag>多项式基础</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】常系数齐次线性递推]]></title>
    <url>%2F2019%2F08%2F07%2Fxxdt%2F</url>
    <content type="text"><![CDATA[$\boldsymbol{k}$阶常系数齐次线性递推指的是以下问题： 给出$k$阶线性递推式$\boldsymbol{f}$以及初始项$\boldsymbol{a_0,a_1…a_{k-1}}$，并满足：$$a_{n}=\sum_{i=1}^{k} f_{i} \times a_{n-i}$$对于某个$o$，求解$f_o$在某个固定模数下的值。 然后以下是shadowice1984的人话版本： 1.它是常系数的，换句话说递推系数和下标n无关 2.它是线性的，换句话说递推式中每一项的次数都是1，没有乱七八糟的2次3次项 3.它是齐次的，换句话说递推式的常数项等于0 这个问题的弱智解法是$O(k^3\log n)$的矩阵快速幂。但是通过多项式加速可以将复杂度优化至$O(k^2\log n)$甚至$O(k\log k \log n)$. 于是这个世界上就再也没有矩阵快速幂了 $1$ 特征向量与特征多项式首先，给定$n$阶矩阵$\boldsymbol{A}$，若存在向量$\boldsymbol{x}$使得$\exists \lambda \in \mathbb {R}$ ，满足：$$\tag{1} \boldsymbol{A}\cdot \boldsymbol{x} = \lambda\boldsymbol{x}$$则称$\boldsymbol{x}$是$\boldsymbol{A}$的特征向量，$\lambda$称为$\boldsymbol{A}$的特征值，$(1)$式称之为特征方程。 同时也可以写作$$(\boldsymbol{A}-\lambda\boldsymbol{I})\cdot \boldsymbol{x}= \boldsymbol{0}$$有解的条件是$$\tag{2} \det(\boldsymbol{A}-\lambda\boldsymbol{I})=0$$同时定义特征多项式为类形式幂级数，即不考虑未知数$x$的数学形态，$x$可以为矩阵、向量$ etc.$ 我们观察，$(2)$中右边的行列式计算的性质保证了行列式展开后每一项一定至多是$\lambda$的$n$次（主对角线相乘）、$n-1$次$\cdots$ $0$次，那么特征多项式即为关于$\lambda$的$\det(\boldsymbol{A}-\lambda\boldsymbol{I})$展开，记为$\boldsymbol{\phi(\lambda)}$. 接着观察$\phi(\lambda)$:$$\begin{aligned}\phi(\lambda)= |\boldsymbol{A}-\lambda \boldsymbol{I}| &amp; = \left[\begin{array}{ccccc}{ \lambda} &amp; {0} &amp; {\cdots} &amp; {0} &amp; {0} \\ {0} &amp; {\lambda} &amp; {\cdots} &amp; {0} &amp; {0} \\ {\cdots} &amp; {\cdots} &amp; {\cdots} &amp; {\cdots} &amp; {\cdots} \\ {0} &amp; {0} &amp; {\cdots} &amp; {\lambda} &amp; {0} \\ {0} &amp; {0} &amp; {\cdots} &amp; {0} &amp; {\lambda}\end{array}\right]-\left[\begin{array}{ccccc}{ 0} &amp; {0} &amp; {\cdots} &amp; {0} &amp; {a_{k}} \\ {1} &amp; {0} &amp; {\cdots} &amp; {0} &amp; {a_{k-1}} \\ {0} &amp; {1} &amp; {\cdots} &amp; {0} &amp; {a_{k-2}} \\ {\cdots} &amp; {\cdots} &amp; {\cdots} &amp; {\cdots} &amp; {\cdots} \\ {0} &amp; {0} &amp; {\cdots} &amp; {0} &amp; {\lambda}\end{array}\right]\\ &amp; =\left[\begin{array}{ccccc}{\lambda} &amp; {0} &amp; {\cdots} &amp; {0} &amp; {-a_{k}} \\ {-1} &amp; {\lambda} &amp; {\cdots} &amp; {0} &amp; {-a_{k-1}} \\ {0} &amp; {-1} &amp; {\cdots} &amp; {0} &amp; {-a_{k-2}} \\ {\cdots} &amp; {\cdots} &amp; {\cdots} &amp; {\cdots} &amp; {\cdots} \\ {0} &amp; {0} &amp; {\cdots} &amp; {-1} &amp; {\lambda-a_{1}}\end{array}\right]\end{aligned}$$ 然后对于这个我们可以进行拉普拉斯展开（就是用代数余子式展开一个行列式），我们选择最后一列： $$\phi(\lambda)=\sum\limits_{i=1}^{k} a_{k-i+1}(-1)^{i+k}\phi(\lambda)_{i, k}$$ 其中$\phi(\lambda)_{i,k}$表示丢掉$(i,k)$同行同列之后的代数余子式。 这东西可以暴力迭代式化简/直接良序归纳得出他的背诵化简形式：$$\phi(\lambda)=(-1)^{n}\left(\lambda^{n}-\sum_{i=1}^{n} a_{i} \lambda^{n-i}\right)$$ 好像胡扯了半天也没扯到点子上，递推在哪？？ $2$ 一步转化/构造現在は大力构造時間です！！ 我们考虑构造一个这样的数列$\boldsymbol{g}$，满足：$$\boldsymbol{A}^n=\sum_{i=0}^{k-1}g_i\boldsymbol{A}^i$$ 然后我们两边同时左乘一个初始状态$\boldsymbol{F_0}$:$$\boldsymbol{F_0\cdot A}^n=\sum_{i=0}^{k-1}g_i\boldsymbol{F_0\cdot A}^i$$ 我们考虑对于矩阵乘法的$\boldsymbol{res}$矩阵，我们关心的是它的$(0,0)$处的值，不妨记为$\boldsymbol{res_0}$，那么就有：$$\boldsymbol{res}_0=(\boldsymbol{F_0\cdot A} ^ n)_0 =\sum_{i=0}^{k-1}g_i(\boldsymbol{F_0\cdot A}^i)_0$$其中$\boldsymbol{X}_p$表示一维向量$\boldsymbol{X}$的第$p$项。 然后使用观察法，我们发现$\boldsymbol{F_0\cdot A}^i$这东西就是转移了$i$次之后的第$0$项，换言之也就是$\boldsymbol{F_0}$的第$i$项，那么就会有：$$\boldsymbol{res_0}=\sum_{i=0}^{k-1}g_i\boldsymbol{(F_0)}_i$$所以只要我们可以构造出一组$g$，我们就可以在$O(k)$的时间内求出答案。 $3~$ 快速线性递推现在我们的任务就是构造$\boldsymbol{g}$序列了。 首先我们随便设一个关于$\boldsymbol{A}$的多项式：$$\boldsymbol{A}^n=P(\boldsymbol{A})Q(\boldsymbol{A})+R(\boldsymbol{A})$$于是我们发现，似乎根据带余除法的性质$\deg (R(\boldsymbol{A}))\leq \deg(\boldsymbol{A}^n)=n$，正好满足$\deg(\sum_{i=0}^{k-1}g_i\boldsymbol{(F_0)}_i)\leq n$的性质，所以我们考虑当$P(\boldsymbol{A})Q(\boldsymbol{A})$这一项为$\boldsymbol{0}$时，恰好构造出一组可行的答案。 我们结合特征多项式考虑，$\phi(\lambda)=0$，恰好满足我们的需求。于是我们直接令$\boldsymbol{A}^n \bmod \phi(\lambda)$即可求出$R(\boldsymbol{A})=g$。 然后普通的就可以直接$k^2$暴力NTT，如果很闲并且模数是NTT模数的话还可以用$\log^2$的复杂度搞出来。 以下是LuoguP4723 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#define Gp 3#define rr register#define MAXN 251003#define LL long long#define Mod 998244353using namespace std ;LL base[MAXN], p[MAXN] ;int N, M, L, K, R[MAXN] ;LL F[MAXN], G[MAXN], P[MAXN], Ans ;inline LL expow(LL a, int b)&#123; rr LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= Mod ; a = 1ll * a * a % Mod, b &gt;&gt;= 1 ; &#125; return res ;&#125;void NTT(LL *J, const int &amp;l, const int &amp;flag)&#123; rr LL Gn, Gi = 1 ; for (rr int i = 0 ; i &lt; l ; ++ i) if (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ; for (rr int i = 1 ; i &lt; l ; i &lt;&lt;= 1)&#123; Gn = expow(Gp, (Mod - 1) / (i &lt;&lt; 1)) ; for (int j = 0 ; j &lt; l ; Gi = 1, j += (i &lt;&lt; 1))&#123; for (int k = 0 ; k &lt; i ; ++ k, Gi = 1ll * Gi * Gn % Mod)&#123; int real = J[j + k], iroot = 1ll * J[j + k + i] * Gi % Mod ; J[j + k] = (real + iroot) % Mod, J[j + k + i] = (real - iroot + Mod) % Mod ; &#125; &#125; &#125; if (flag &gt; 0) return ; rr int Inv = expow(1ll * l, Mod - 2) ; reverse(J + 1, J + l) ; for (rr int i = 0 ; i &lt; l ; ++ i) J[i] = 1ll * J[i] * Inv % Mod ;&#125;LL t[MAXN], T[MAXN] ;void _Inv(LL *f, LL *g, int len)&#123; if (len &lt;= 1) &#123; g[0] = expow(f[0], Mod - 2) ; return ; &#125; rr int i, l = 0, Len = 1 ; _Inv(f, g, (len + 1) &gt;&gt; 1) ; while (Len &lt; (len &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; for (i = 0 ; i &lt; len ; ++ i) t[i] = f[i] ; NTT(g, Len, 1), NTT(t, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) g[i] = (2ll - t[i] * g[i] % Mod + Mod) % Mod * g[i] % Mod ; NTT(g, Len, -1) ; for (i = len ; i &lt; Len ; ++ i) g[i] = 0 ;&#125;LL IG[MAXN], Ft[MAXN], Gt[MAXN] ;void _Div(LL *f, const int &amp;Len)&#123; rr int L1 = (K &lt;&lt; 1), D, i ; while (!f[-- L1]) ; if (L1 &lt; K) return ; for (i = 0 ; i &lt; Len ; ++ i) Ft[i] = 0 ; for (i = 0 ; i &lt;= L1 ; ++ i) Ft[i] = f[i] ; D = L1 - K + 1 ; reverse(Ft, Ft + L1 + 1) ; for (i = D ; i &lt;= L1 ; ++ i) Ft[i] = 0 ; NTT(Ft, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) P[i] = Ft[i] * IG[i] % Mod ; NTT(P, Len, - 1) ; for (i = D ; i &lt;= L1 ; ++ i) P[i] = 0 ; reverse(P, P + D) ; NTT(P, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) (P[i] *= G[i]) %= Mod ; NTT(P, Len, -1) ; for (i = 0 ; i &lt; K ; ++ i) f[i] = (f[i] - P[i] + Mod) % Mod ; for (i = K ; i &lt;= L1 ; ++ i) f[i] = 0 ;&#125;int main()&#123;// freopen("2.in", "r", stdin) ; rr int Len = 1, l = 0, i ; cin &gt;&gt; N &gt;&gt; K ; while (Len &lt; (K &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ; F[0] = 1 ; Len &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; for (i = 1 ; i &lt;= K ; ++ i) scanf("%lld", &amp;p[i]), p[i] = p[i] &lt; 0 ? p[i] + Mod : p[i] ; for (i = 0 ; i &lt; K ; ++ i) scanf("%lld", &amp;base[i]), base[i] = base[i] &lt; 0 ? base[i] + Mod : base[i] ; for (i = 1 ; i &lt;= K ; ++ i) Gt[K - i] = G[K - i] = Mod - p[i] ; T[1] = G[K] = Gt[K] = 1 ;reverse(Gt, Gt + K + 1) ; NTT(G, Len, 1) ; _Inv(Gt, IG, Len &gt;&gt; 1), NTT(IG, Len, 1) ; while(N)&#123; NTT(T, Len, 1) ; if (N &amp; 1) &#123; NTT(F, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) F[i] = F[i] * T[i] % Mod ; NTT(F, Len, -1) ; _Div(F, Len) ; &#125; for (i = 0 ; i &lt; Len ; ++ i) (T[i] *= T[i]) %= Mod ; NTT(T, Len, -1) ; _Div(T, Len), N &gt;&gt;= 1 ; &#125; for (i = 0 ; i &lt; K ; ++ i) (Ans += (F[i] * base[i]) % Mod) %= Mod ; printf("%lld ", Ans) ; return 0 ;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>常系数齐次线性递推</category>
      </categories>
      <tags>
        <tag>数学/常系数齐次线性递推</tag>
        <tag>多项式的应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】多项式求幂/开根]]></title>
    <url>%2F2019%2F08%2F07%2Frooti%2F</url>
    <content type="text"><![CDATA[形式化来讲，我们要解决这两个问题：$$\begin{aligned}G &amp;= F^k (\bmod x^n)\\\G^k &amp;= F (\bmod x^n)\end{aligned}$$然而实际上后一个咕了，我曾把这玩意儿当作多项式牛顿迭代的课后题来着……并且更重要的原因没人出这玩意儿的题，所以直接简化成$G^2\equiv F$好了。。。 $1$ 求幂首先思考式子$$G=F^k(~\bmod~x^n)$$怎么化开。那么喜闻乐见的就是一步求对数然后exp回去：$$\ln G = k \ln F~(\bmod~x^n)\\\\exp(k\ln F)=G~(\bmod ~x^n)$$对应的是Luogu的P5245: 1234567891011signed main()&#123; int i, y ; cin &gt;&gt; N, M = 1 ; Gi = expow(Gp, P - 2) ; while (M &lt;= N) M &lt;&lt;= 1 ; cin &gt;&gt; In ; y = strlen(In) ; for (i = 0 ; i &lt; N ; ++ i) scanf("%lld", &amp;F[i]) ; for (i = 0 ; i &lt; y ; ++ i) K = (K * 10 + In[i] - '0') % P ; _Ln(F, L, M) ; for (i = 0 ; i &lt; N ; ++ i) L[i] = 1ll * L[i] * K % P ; _Exp(L, G, M) ; for (i = 0 ; i &lt; N ; ++ i) printf("%lld ", G[i]) ; return 0 ;&#125; 但是这种方法只能应用于$a_0=1$的情况下，原因在写exp的时候整理过。 但这东西显然是可以$\Theta(n\log^2n)$暴力ntt做的，我很快乐地水过了这道题的加强版P5273，即不保证$a_0=1$的版本： 似乎大家都是诡异的写法，没有人用$O(n\log^2 n)$去暴力艹这道题。 然而事实上是完全可以卡过去的。我的提交虽然加了-O2和#pragma显得十分弟弟，但是其实去掉之后也是很快的。不吹，绝对比大部分的普通$O(n\log^2n)$的NTT跑得快。 那么以下是几个优化的措施：$\#1$ 预处理原根的次幂——卡常利器。 12345for (i = 0 ; i &lt; 19 ;++ i)&#123; rr int *rua = gg[i] ; rua[0] = 1 ; rr int gi = rua[1] = expow(3, 998244352/(1 &lt;&lt; (i + 1))) ; for (j = 2 ; j &lt; (1 &lt;&lt; i) ; ++ j) rua[j] = 1ll * rua[j - 1] * gi % P ; &#125; 然后每次NTT就不需要重新再计算了。 $\#2$ 做快速幂的时候注意可以少几次NTT。这点常数优化也是需要的。 1234567891011while (K)&#123; NTT(F, M, 1) ; if (K &amp; 1)&#123; NTT(A, M, 1) ; for (i = 0 ; i &lt; M ; ++ i) A[i] = 1ll * A[i] * F[i] % P ; NTT(A, M, -1) ; for (i = N ; i &lt; M ; ++ i) A[i] = 0 ; &#125; for (i = 0 ; i &lt; M ; ++ i) F[i] = 1ll * F[i] * F[i] % P ; NTT(F, M, -1) ; for (i = N ; i &lt; M ; ++ i) F[i] = 0 ; K &gt;&gt;= 1 ; &#125; $\#3$ 不用long long. 这其实一个通用的技巧，因为long long一般都比int多好多常数。同时不要强制类型转换而选择1ll*这种形式。实测可以快许多。 不得不说，这个预处理原根确实是一个卡常黑科技qwq $2$ 开根普通的开根还是exp和ln：$$G^2=F\\\2 \ln G = \ln F\\\G = \exp(\frac{\ln F}{2})$$然后就可以胡搞LuoguP5205： 123456void _Invsqr(int *f, int *g, int len)&#123; int Len = 1, l = 0, i, o ; while (Len &lt; (len &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ; o = expow(2ll, P - 2) ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1) ; _Ln(f, E, M) ; for (i = 0 ; i &lt; Len ; ++ i) E[i] = E[i] * o % P ; _Exp(E, g, M) ;&#125; 但是还是有问题，就是因为需要$\exp$，上述也必须要$F_0=1$。于是当$F_0\neq 1$时，我们可以直接暴力求二次剩余，注意这种方法就需要用牛迭来实现开根 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768namespace solveroot&#123; #define fr first #define sc second #define pint pair&lt;int, int&gt; #define mp(a, b) make_pair(a, b) struct complex&#123; int x, y ; &#125; ; complex mul(complex a, complex b, int p, int rt)&#123; int nx = (1ll * a.x * b.x % p + 1ll * a.y * b.y % p * rt % p) ; int ny = (1ll * a.x * b.y % p + 1ll * a.y * b.x % p) ; return (complex)&#123;nx % p, ny % p&#125; ; &#125; complex expow(complex a, int b, int p, int z)&#123; complex res = (complex)&#123;1, 0&#125; ; while (b)&#123; if (b &amp; 1) res = mul(res, a, p, z), b -- ; a = mul(a, a, p, z), b &gt;&gt;= 1 ; &#125; return res ; &#125; int expow(int a, int b, int p)&#123; int res = 1 ; while (b)&#123; if (b &amp; 1) res = 1ll * a * res % p ; a = 1ll * a * a % p ; b &gt;&gt;= 1 ; &#125; return res ; &#125; void seed()&#123; srand((int)'x'+'q'+'I'+'L'+'o'+'v'+'e'+'u') ; &#125; pint solve(int n, int p)&#123; seed() ; if (!n) return mp(0, 0) ; int x, y ; while (1)&#123; x = rand() % p ; y = (1ll * x * x + (p - n)) % p ; if (expow(y, (p - 1) &gt;&gt; 1, p) == p - 1) break ; &#125; complex now = (complex)&#123;x, 1&#125;, ansp, ansn ; ansp = expow(now, (p + 1) &gt;&gt; 1, p, y), ansn = (complex)&#123;p - ansp.x, ansp.y&#125; ; if (ansp.x &gt; ansn.x) swap(ansp, ansn) ; return mp(ansp.x, ansn.x) ; &#125;&#125;。。。。。LL Ig[MAXN], pf[MAXN] ;using namespace solveroot ;void _sqr(LL *f, LL *g, int len)&#123; if (len &lt;= 1)&#123; g[0] = solve(f[0], P).fr ; return ; &#125; rr int i, l = 0, Len = 1 ; _sqr(f, g, (len + 1) &gt;&gt; 1) ; while (Len &lt; (len &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ; for (i = len ; i &lt; Len ; ++ i) pf[i] = Ig[i] = 0 ; for (i = 0 ; i &lt; len ; ++ i) Ig[i] = 0, pf[i] = 2 * g[i] % P ; _Inv(pf, Ig, len) ; for (i = 0 ; i &lt; Len ; ++ i) /* */ t[i] = 0 ; for (i = 1 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; ( l - 1 )) ; NTT(g, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) g[i] = g[i] * g[i] % P ; NTT(g, Len, -1) ; for (i = 0 ; i &lt; len ; ++ i) g[i] = (g[i] + f[i]) % P ; NTT(g, Len, 1) ; NTT(Ig, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) g[i] = g[i] * Ig[i] % P ; NTT(g, Len, -1) ; for (i = len ; i &lt; Len ; ++ i) g[i] = 0 ;&#125; 然后为了做这道题还去学了Cipolla，然后还顺便发现luogu上少一道二次剩余的板子就顺手出了道题2333]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】多项式带余除法]]></title>
    <url>%2F2019%2F08%2F07%2Fchumod%2F</url>
    <content type="text"><![CDATA[解决一类$$G=F\cdot P+R ~(\bmod~x^n)$$其中$F, G$给定，求解$P$和$R$ 然而最后变成了老年选手的多项式瞎吹？ $1$这就很苟，最近要被多项式除法给整疯了，原因大概是我换一道模板就需要换一种写法……原来那种怎么改都不对就很智障…… 然后划式子过程就很苟，是一种诡异的构造方式，前置芝士大概是$F(\frac{1}{x})=F^T(x)$，其中$T$表示转置——当然是一个不严谨的记号，意思就是把这个形式幂级数的系数reverse掉。 以下是过程：$$\begin{aligned}G(x)&amp;=F(x)P(x)+R(x)\\\G(\frac{1}{x})&amp;=F(\frac{1}{x})P(\frac{1}{x})+R(\frac{1}{x})\\\\because A_r&amp;= x^nA(\frac{1}{x})\\\\therefore x^nG(\frac{1}{x})&amp;=x^nF(\frac{1}{x})P(\frac{1}{x})+x^nR(\frac{1}{x})\\\\Longrightarrow x^nG(\frac{1}{x})&amp;=x^mF(\frac{1}{x})\cdot x^{n-m}P(\frac{1}{x})+x^{m-1}\cdot x^{n-m+1}R(x)\\\\Longrightarrow G_r(x)&amp;=F_r(x)\cdot P_r(x)+x^{n-m+1}R_r(x)\\\\Longrightarrow G_r(x)&amp;=F_r(x)\cdot P_r(x)+x^{n-m+1}R_r(x) ~(\bmod x^{n-m+1})\\\\Longrightarrow P_r(x)&amp;=F_r(x)\cdot G_r^{-1}(x)~(\bmod x^{n-m+1})\\\\end{aligned}$$之后求出$P_r$之后就可以回代原式：$$\begin{aligned}G=F\cdot P+R\\\R = G - F\cdot P\end{aligned}$$于是就完了 $2$但是实际写法有些问题，比如板子P4512 【模板】多项式除法 这其实就直接做就好，不是很需要考虑清零什么的。但是我总觉得在Inv之后是不是需要重新算一下R……不清楚诶。 1234567891011121314151617181920LL Ft[MAXN], Gt[MAXN], IG[MAXN] ;void _Div()&#123; int l = 0, O = N - M + 1 ; reverse(Ft, Ft + N), reverse(Gt, Gt + M) ; l = 0, L = 1 ; while (L &lt; (O &lt;&lt; 1)) L &lt;&lt;= 1, ++ l ; for (int i = O ; i &lt; N ; ++ i) Ft[i] = Gt[i] = 0 ; for (int i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; _Inv(Gt, IG, O), NTT(IG, L, 1), NTT(Ft, L, 1) ; for (int i = 0 ; i &lt; L ; ++ i) P[i] = Ft[i] * IG[i] % Mod ; NTT(P, L, - 1) ; reverse(P, P + O) ; for (int i = 0 ; i &lt; O ; ++ i) printf("%lld ", P[i]) ; for (int i = O ; i &lt; N ; ++ i) P[i] = 0 ; O = N, L = 1, l = 0 ; while (L &lt; (O &lt;&lt; 1)) L &lt;&lt;= 1, ++ l ; for (int i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; NTT(P, L, 1), NTT(G, L, 1) ; for (int i = 0 ; i &lt; L ; ++ i) Q[i] = (P[i] * G[i]) % Mod ; NTT(Q, L, -1) ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M, ++ N, ++ M ; int i ; for (i = 0 ; i &lt; N ; ++ i) scanf("%lld", &amp;F[i]), Ft[i] = F[i] ; for (i = 0 ; i &lt; M ; ++ i) scanf("%lld", &amp;G[i]), Gt[i] = G[i] ; _Div() ; puts("") ; for (i = 0 ; i &lt; M - 1 ; ++ i) printf("%lld ", (F[i] - Q[i] + Mod) % Mod) ;&#125; 但是之后线性递推时需要进行的取模操作： 12345678910111213141516void _Div(LL *f, int Len)&#123; int L1 = (K &lt;&lt; 1), D, i ; while (!f[-- L1]) ; if (L1 &lt; K) return ; for (i = 0 ; i &lt; Len ; ++ i) Ft[i] = 0 ; for (i = 0 ; i &lt;= L1 ; ++ i) Ft[i] = f[i] ; reverse(Ft, Ft + L1 + 1) ; for (D = L1 - K + 1, i = D ; i &lt;= L1 ; ++ i) Ft[i] = 0 ; NTT(Ft, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) P[i] = Ft[i] * IG[i] % Mod ; NTT(P, Len, - 1) ; for (i = D ; i &lt;= L1 ; ++ i) P[i] = 0 ; reverse(P, P + D) ; NTT(P, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) Q[i] = (P[i] * G[i]) % Mod ; NTT(Q, Len, -1) ; for (i = 0 ; i &lt; K ; ++ i) f[i] = (f[i] - Q[i] + Mod) % Mod ; for (i = K ; i &lt;= L1 ; ++ i) f[i] = 0 ;&#125;//main_function for (i = 1 ; i &lt;= K ; ++ i) G[K - i] = Mod - p[i] ; for (i = 0 ; i &lt;= K ; ++ i) Gt[i] = G[i] ; reverse(Gt, Gt + K + 1) ; NTT(G, Len, 1) ; _Inv(Gt, IG, Len &gt;&gt; 1), NTT(IG, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; 看上去很正常，只是多了几个预处理而已。但是不知为何当时写的就很迷。。。并且从这个板子开始我明白了，多项式长度+是否清空这个组合绝对是多项式入门里面最难受的细节。 之后就更迷了，多点求值这玩意儿实在毒瘤： 123456789101112131415161718192021inline void _Mod(int *f, vector&lt;int&gt; g, int n, int m, int* Rs)&#123; register int l = 0, O = n - m + 1, L , i ; for (i = 0 ; i &lt;= (n &lt;&lt; 1) ; ++ i) ig[i] = ft[i] = gt[i] = 0 ; for (i = 0 ; i &lt;= n ; ++ i) ft[i] = f[n - i] ; for (i = 0 ; i &lt;= m ; ++ i) gt[i] = g[m - i] ; l = 0, L = 1 ; for (i = O ; i &lt; (n &lt;&lt; 1); ++ i) ft[i] = gt[i] = 0 ; Inv(gt, ig, O) ; while (L &lt; (O &lt;&lt; 1)) L &lt;&lt;= 1,++ l ; for (i = 0 ; i &lt;= L ; ++ i) t[i] = 0 ; for (i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; NTT(ig, L, 1), NTT(ft, L, 1) ; for (i = 0 ; i &lt; L ; ++ i) X[i] = 1ll * ft[i] * ig[i] % Mod ; NTT(X, L, - 1) ; reverse(X, X + O) ; for (i = O ; i &lt; L ; ++ i) X[i] = 0 ; O = n + 1, L = 1, l = 0 ; while (L &lt; (O &lt;&lt; 1)) L &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; L ; ++ i) G[i] = Y[i] = 0 ; for (i = 0 ; i &lt;= m ; ++ i) G[i] = g[i] ; for (i = 0 ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; NTT(X, L, 1) ; NTT (G, L, 1) ; for (i = 0 ; i &lt; L ; ++ i) Y[i] = 1ll * G[i] * X[i] % Mod, X[i] = 0 ; NTT(Y, L, -1) ; for (i = 0 ; i &lt;= m - 1 ; ++ i) Rs[i] = ((1ll * f[i] - Y[i]) + Mod) % Mod ;&#125; 这就很烦……鬼知道你tm什么时候忘清空或者忘开long long了就要调一年……艹 $3$最后趁机说一下写多项式的心得其实就是瞎吹： 好烦啊（ 代码好长啊（ 为什么踏马每次徒手写NTT都会挂啊（ 学了半天原来FFT是最没用的啊（ 调死我了啊 还不如直接照着模板背呢，每天早读背一发，那个什么教辅不是说来着？“背虽传统，也最实用”（ 卧槽每次写一道板子就要交上一整页，我不要面子的吗（ 正经一点的话，大概就是我这几个板子都是用数组写的，所以会有memset或者for for for之类的，闲得很凌乱。再加上之前很智障地每次都要重新推一遍蝴蝶操作的Rev数组，就显得很弱智。于是决定下一次多项式复习的时候，自己可以学的更成体系，也可以用上operator和vector这两个利器。 upd：就在落笔不到5min之后想到了一个问题，就是你会发现在多项式题目里面有$\mod x^n$和$\mod \rm{NTTPrime}$ 两种约束，一直以为的是不同的运算有不同的约束，但这是$\color{red}{\text{错的}}$ 。真正的区别是，前者是对次数的约束，后者是对系数的约束。 = =也就只有我会智障到现在才明白。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】多项式ln/exp]]></title>
    <url>%2F2019%2F08%2F07%2Flnexp%2F</url>
    <content type="text"><![CDATA[其实这两个东西只是一个拓展，思想也是简单的思想，只不过由于$\ln$运算的乘方转乘法很好用，所以大部分套路都是先多项式$\ln$乱搞一通再多项式$\exp$回去。 形式化地讲，我们就是要解决以下两个问题：$$\begin{aligned}1)\quad G&amp;= \ln F (\bmod p)\\\2)\quad G&amp;= e^{F} (\bmod p)\end{aligned}$$ $1~\ln$其实就是瞎jb记一下式子啦$$G’= F’\cdot \frac{1}{F}=\frac{F’}{F}$$……然后就先对F求个导+求个逆然后再不定积分回去就好。 12345678910111213141516int A[MAXN], B[MAXN] ;void _Dev(int *f, int *g, int len)&#123; int i ; g[len - 1] = 0 ; for(i = 1 ; i &lt; len ; ++ i) g[i - 1] = i * f[i] % P ;&#125;void _Invdev(int *f, int *g, int len)&#123; g[0] = 0 ; int i ; for(i = 1 ; i &lt; len ; ++ i) g[i] = f[i - 1] * expow(i, P - 2) % P ;&#125;void _Ln(int *f, int *g, int len)&#123; _Dev(f, A, len), _Inv(f, B, len) ; int i ; int Len = 1, l = 0 ; while (Len &lt; (len &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; NTT(A, Len, 1), NTT(B, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) A[i] = 1ll * A[i] * B[i] % P ; NTT(A, Len, -1), _Invdev(A, g, len) ; return ;&#125; 也算是小清新的多项式板子了，毕竟没有诡异的清空和鬼畜的码长。 $2~\exp$$$\begin{aligned}G &amp;= G_h - \frac{T(G_h)}{T’(G_h)}\\\\Longrightarrow G &amp;= G_h-\frac{\ln G_h -F}{\frac{1}{G_h}}\\\\Longrightarrow G &amp;=G_h-G_h\ln G_h+G_hF\\\\Longrightarrow G &amp;=G_h(1-\ln G_h+F)\\\\end{aligned}$$ 然后需要的知识点就是牛顿迭代了，这玩意儿之前写过，懒得再叙述一遍了…… 123456789101112131415161718192021void _Ln(int *f, int *g, int len)&#123; int i, Len = 1, l = 0 ; _Dev(f, A, len) ; _Inv(f, B, len) ; while (Len &lt; (len &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ;// for (i = 0 ; i &lt;= Len ; ++ i) cout &lt;&lt; A[i] &lt;&lt; " " &lt;&lt; B[i] &lt;&lt; endl ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1) ; NTT(A, Len, 1), NTT(B, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) A[i] = A[i] * B[i] % P ; NTT(A, Len, -1), _Invdev(A, g, len) ; memset(t, 0, sizeof(t)), memset(B, 0, sizeof(B)), memset(A, 0, sizeof(A)) ;&#125;int C[MAXN], D[MAXN] ;void _Exp(int *f, int *g, int len)&#123; if(len == 1)&#123; g[0] = 1 ; return ; &#125; _Exp(f, g, len + 1 &gt;&gt; 1) ; int Len = 1, l = 0, i ; while (Len &lt; (len &lt;&lt; 1)) Len &lt;&lt;= 1, ++ l ; for (i = 0 ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1) ; for (i = 0 ; i &lt; (len &lt;&lt; 1) ; ++ i) C[i] = D[i] = 0 ; _Ln(g, C, len) ; for(i = 0 ; i &lt; len ; ++ i) D[i] = f[i] ; NTT(g, Len, 1), NTT(C, Len, 1), NTT(D, Len, 1) ; for (i = 0 ; i &lt; Len ; ++ i) g[i] = (1ll + D[i] - C[i] + P) * g[i] % P ; NTT(g, Len, -1) ; for (i = len ; i &lt;= Len ; ++ i) g[i] = 0 ;&#125; 比较重要的就是清空，由于$\exp$是迭代实现的，所以要进行多次$\ln$。。。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】形式幂级数的牛顿迭代]]></title>
    <url>%2F2019%2F08%2F01%2Fdiedai%2F</url>
    <content type="text"><![CDATA[多项式的牛顿迭代，是借助泰勒展开进行的一种对于形式幂级数的常规操作，解决的主要问题是：$$G(F) \equiv 0~(\bmod x^n)$$给定形式幂级数$G$，求解$F$。 而解决途径则是通过对降半次的$F_0$向上迭代解决的。 $1$假设我们现在已经求出了$G(F_0)\equiv 0~(\bmod~x^{\frac{n}{2}})$ 首先之前标准的式子左边在$F_0(x)$处进行泰勒展开，可以得到：$$\begin{aligned} G(F(x)) &amp;=G\left(F_{0}(x)\right) \\ &amp;+\frac{G^{\prime}\left(F_{0}(x)\right)}{1 !}\left(F(x)-F_{0}(x)\right) \\ &amp;+\frac{G^{\prime \prime}\left(F_{0}(x)\right)}{2 !}\left(F(x)-F_{0}(x)\right)^{2} \\ &amp;+\cdots (\mod ~x^n)\end{aligned}$$ 但是我们考虑在$\mod ~x^n$意义下，$F$和$F_0$的最后$\frac{n}{2}$项相同，所以在上面的式子，$(F-F_0)^k,~k&gt;2$时，最低次项的次数一定会大于$2\cdot\lfloor \frac{n}{2}\rfloor$，也就是说在$\mod~x^n$意义下都是全0项。那么我们就可以得到： $$G(F(x)) \equiv G\left(F_{0}(x)\right)+G^{\prime}\left(F_{0}(x)\right)\left(F(x)-F_{0}(x)\right) \quad\left(\bmod x^{n}\right)$$然后因为$G(F)=0~(\bmod~x^n)$，所以我们可以得到：$$F(x)\equiv F_0(x) - \frac{G(F_0(x))}{G^{\prime}\left(F_{0}(x)\right)} \quad\left(\bmod x^{n}\right)$$于是直接递推就好。 $2$接下来看几个课后练习 $(1)~G^2\equiv F~(\bmod~x^n)$$$\begin{aligned}G^2&amp;=F\\\G^2-F&amp;=0\\\\end{aligned}$$令$T(G)=G^2-F$,套用公式可以得到：$$\begin{aligned}T(G)&amp;=G^2-F,F\Longleftrightarrow \mathbb{C} \\\G &amp;= G_h-\frac{T(G_h)}{T’(G_h)}\\\\Longrightarrow G&amp;=G_h-\frac{G_h^2-F}{2G_h}\\\\Longrightarrow G&amp;=\frac{G_h^2+F}{2G_h}\end{aligned}$$ $(2)~G\equiv e^{F}~(\bmod ~x^n)$按照套路应该两边同时取$\ln$:$$\ln G=F~(\bmod~x^n)$$之后我们令$T(G)=\ln G-F$，套用公式可以得到$$\begin{aligned}G &amp;= G_h - \frac{T(G_h)}{T’(G_h)}\\\\Longrightarrow G &amp;= G_h-\frac{\ln G_h -F}{\frac{1}{G_h}}\\\\Longrightarrow G &amp;=G_h-G_h\ln G_h+G_hF\\\\Longrightarrow G &amp;=G_h(1-\ln G_h+F)\\\\end{aligned}$$ $(3)~G^k\equiv F~(\bmod ~x^n)$$$T(G) = G^k-F=0$$ 套用公式可以得到$$\begin{aligned}G &amp;= G_h - \frac{T(G_h)}{T’(G_h)}\\\\Longrightarrow G &amp;= G_h-\frac{G_h^k-F}{kG_h^{k-1}}\\\\Longrightarrow G &amp;=\frac{(k-1)G_h^k+F}{kG_h^{k-1}}\end{aligned}$$然后就算这个东西就变成$\log^3~\text{or}~\log^2$可以算的东西了。 $(4)~2G \ln G\equiv F~(\bmod x^n)$$$T(G)\equiv 2G\ln G-F~(\bmod~x^n)$$ 同样的台词……$$\begin{aligned}G &amp;= G_h - \frac{T(G_h)}{T’(G_h)}\\\\Longrightarrow G &amp;= G_h-\frac{2G_h\ln G_h-F}{2\ln G_h+2G_h\cdot \frac{1}{G_h}}\\\\Longrightarrow G &amp;=\frac{2G_h\ln G_h-F}{(2\ln+1)G_h}\end{aligned}$$然后这东西好像是可以$\log^2$做的……不过有些小朋友特别喜欢出无脑的多项式板子，像这种东西就很没有意思qaq。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】多项式求逆]]></title>
    <url>%2F2019%2F07%2F27%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[给定$F(x)$，求$G(x)$满足$G(x)\cdot F(x) \equiv1~(\bmod x^n)$. 不妨考虑$G’(x)\cdot F(x) =1~(\bmod x^{\frac{n}{2}})$ 则有如下：$$\because G’\cdot F =1~(\bmod x^{\frac{n}{2}})\\ ~G\cdot F \equiv1~(\bmod x^{\frac{n}{2}})\\\\therefore G’ -G\equiv0~(\bmod x^{\frac{n}{2}})\\ \Longrightarrow G’^2+G^2-2G’G\equiv0~(\bmod x^{n})$$ 两端同时卷上一个$F(x)$则有： $$\because F\cdot G\equiv1~(\bmod x^n)\\\\therefore G\equiv 2G’-FG’^2~(\bmod x^n)$$ 以此为递推式即可递推出$G(x)$的值，时间复杂度$O(n\log^2 n)$. $1~$【模板】多项式求逆 就是板子，NTT一下就好= = 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define rr register #define MAXN 300023#define Mod 998244353const int G = 3 ;using namespace std ; int t[MAXN] ;int N, base[MAXN], Ans[MAXN], rev[MAXN] ;inline int expow(int x, int y)&#123; int res = 1 ; while (y) res = ((y &amp; 1) ? 1ll * res * x % Mod : res), x = 1ll * x * x % Mod, y &gt;&gt;= 1 ; return res % Mod ;&#125;void NTT(int *J, int L, int flag)&#123; rr int Gn, Gi = 1 ; for (rr int i = 0 ; i &lt; L ; ++ i) if (i &lt; rev[i]) J[i] ^= J[rev[i]] ^= J[i] ^= J[rev[i]] ; for (rr int i = 1 ; i &lt; L ; i &lt;&lt;= 1)&#123; Gn = expow(G, (Mod - 1) / (i &lt;&lt; 1)) ; for (rr int j = 0 ; j &lt; L ; Gi = 1, j += (i &lt;&lt; 1))&#123; for (rr int k = 0 ; k &lt; i ; ++ k, Gi = 1ll * Gi * Gn % Mod)&#123; rr int real = J[j + k], iroot = 1ll * J[j + k + i] * Gi % Mod ; J[j + k] = (real + iroot) % Mod, J[j + k + i] = (real - iroot + Mod) % Mod ; &#125; &#125; &#125; if (flag &gt; 0) return ; int Inv = expow(L, Mod - 2) ; reverse(J + 1, J + L) ; for (rr int i = 0 ; i &lt; L ; ++ i) J[i] = 1ll * J[i] * Inv % Mod ;&#125;void Inv_NTT(int Len, int *A, int *B)&#123;//递推 if (Len &lt;= 1)&#123; B[0] = expow(A[0], Mod - 2) ; return ; &#125; Inv_NTT((Len + 1) &gt;&gt; 1, A, B) ; rr int Lim = 1, len = 0 ; while (Lim &lt; (Len &lt;&lt; 1)) Lim &lt;&lt;= 1, ++ len ; rr int i, j, k ; for (i = 0 ; i &lt; Lim ; ++ i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (len-1)) ; for (i = 0 ; i &lt; Len ; ++ i) t[i] = A[i] ; NTT(t, Lim, 1), NTT(B, Lim, 1) ; for (i = 0 ; i &lt; Lim ; ++ i) B[i] = 1ll * (2ll - 1ll * t[i] * B[i] % Mod + Mod) % Mod * B[i] % Mod ; NTT(B, Lim, -1) ; for (i = Len ; i &lt;= Lim ; ++ i) B[i] = 0 ;&#125;int main()&#123; cin &gt;&gt; N ; int i ; for (i = 0 ; i &lt; N ; ++ i) scanf("%d", &amp;base[i]) ; Inv_NTT(N, base, Ans) ; for (i = 0 ; i &lt; N ; ++ i) printf("%d ", Ans[i]) ;&#125; $2$【模板】多项式求逆（加强版） 然而就是把模数换成了非NTT模数= = 于是就做一遍MTT就好了，这里写的是带有共轭优化的版本= = 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define rr register #define MAXN 300020#define MAXM MAXN#define Mod (1000000007)const double Pi = acos(-1) ;const int G = 3 ; int T[MAXN] ;using namespace std ; int t[MAXN] ;int N, base[MAXN], Ans[MAXN], rev[MAXN] ;inline int expow(int x, int y)&#123; int res = 1 ; while (y) res = ((y &amp; 1) ? 1ll * res * x % Mod : res), x = 1ll * x * x % Mod, y &gt;&gt;= 1 ; return res ;&#125;struct node&#123; long double r, i ;&#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM], qaq ; int L1, L2, P ;inline node operator + (const node &amp;J, const node &amp; Q)&#123; return (node)&#123;J.r + Q.r , J.i + Q.i&#125; ; &#125;inline node operator - (const node &amp;J, const node &amp; Q)&#123; return (node)&#123;J.r - Q.r , J.i - Q.i&#125; ; &#125;inline node operator * (const node &amp;J, const node &amp; Q)&#123; return (node)&#123;J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r&#125; ; &#125;inline void FFT(node *J, const int &amp;Lim, int flag)&#123; for (rr int i = 0; i &lt; Lim; i ++) if(i &lt; rev[i]) qaq = J[i], J[i] = J[rev[i]], J[rev[i]] = qaq ; for (rr int j = 1; j &lt; Lim; j &lt;&lt;= 1) for(rr int k = 0; k &lt; Lim ; k += (j &lt;&lt; 1)) for(rr int l = 0 ; l &lt; j ; ++ l)&#123; rr node T = w[Lim / j * l] ; if (flag &lt; 0) T.i *= -1 ; rr node Nx = J[k + l], Ny = T * J[k + j + l] ; J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ; &#125;&#125;void MTT(int *J, int *K, int Length, int P, int Lim, int *ret)&#123; rr node ia, ib, a1, a2, b1, b2 ; rr int t, k, q1, q2, q3 ; for (rr int i = 0 ; i &lt; (Length &lt;&lt; 1) ; ++ i) A[i] = B[i] = (node)&#123;0, 0&#125; ; for (rr int i = 1 ; i &lt; Lim ; i &lt;&lt;= 1) for(k = 0 ; k &lt; i ; ++ k) w[Lim / i * k] = (node)&#123;cos(k * Pi / i) , sin(k * Pi / i)&#125; ; for (rr int i = 0 ; i &lt;= Length ; ++ i) A[i].r = J[i] &amp; 32767, A[i].i = J[i] &gt;&gt; 15, B[i].r = K[i] &amp; 32767, B[i].i = K[i] &gt;&gt; 15 ; FFT(A, Lim, 1), FFT(B, Lim, 1), t = Lim - 1 ; for (rr int i = 0 ; i &lt; Lim ; ++ i)&#123; k = (Lim - i) &amp; t ; ia = (node)&#123; A[k].r, -A[k].i &#125;, ib = (node)&#123; B[k].r, -B[k].i &#125; ; a1 = (ia + A[i]) * (node) &#123;0.5, 0&#125;, a2 = (A[i] - ia) * (node) &#123;0, -0.5&#125; ; b1 = (ib + B[i]) * (node) &#123;0.5, 0&#125;, b2 = (B[i] - ib) * (node) &#123;0, -0.5&#125; ; t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * (node)&#123;0, 1&#125;, t2[i] = a2 * b2 ; &#125; FFT(t1, Lim, -1), FFT(t2, Lim, -1) ; for (rr int i = 0 ; i &lt; Length ; ++ i)&#123; q1 = (long long)(t1[i].r / Lim + 0.5) % P, q2 = (long long)(t1[i].i / Lim + 0.5) % P ; q3 = (long long)(t2[i].r / Lim + 0.5) % P, ret[i] = ((1ll * q3 &lt;&lt; 30) % P + (1ll * q2 &lt;&lt; 15) % P + q1) % P ; &#125;&#125;void Inv_MTT(int Len, int *A, int *B)&#123; if (Len &lt;= 1)&#123; B[0] = expow(A[0], Mod - 2) ; return ; &#125; Inv_MTT(Len &gt;&gt; 1, A, B) ; rr int Lim, len = 0 ; for (Lim = 1 ; Lim &lt;= Len ; Lim &lt;&lt;= 1) ++ len ; for (rr int i = 0 ; i &lt; Lim ; ++ i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (len-1)) ; MTT(A, B, Len, Mod, Lim, T), MTT(T, B, Len, Mod, Lim, t) ; for (rr int i = 0 ; i &lt; Len ; ++ i) B[i] = 1ll * (2ll * B[i] - t[i] + Mod) % Mod ;&#125;inline int qr()&#123; rr int k = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48 ,c = getchar() ; return k ;&#125;int main()&#123; cin &gt;&gt; N ; rr int i, Np ; for (Np = 1 ; Np &lt; N ; Np &lt;&lt;= 1) ; for (i = 0 ; i &lt; N ; ++ i) base[i] = qr() ; Inv_MTT(Np, base, Ans) ; for (i = 0 ; i &lt; N ; ++ i) printf("%d ", Ans[i]) ;&#125; 开了一发O2发现快了三倍，woc…]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【赛题整理】洛谷三月月赛 P5240 Derivation]]></title>
    <url>%2F2019%2F07%2F26%2Fbiaodashishu2%2F</url>
    <content type="text"><![CDATA[小 R 学会微积分中求导这一概念后，他的数学老师要求他开始做一部分导数的练习题加深自己的理解。 但颖悟绝伦的小 R 对繁复的练习题并不感兴趣。他希望你帮他设计一个程序，计算一个给定函数 $f(x)$ 的导数。 第一行一个正整数 T，表示小 R 要完成的练习题数量，亦即测试数据的组数。每组测试数据的第一行是一个非空字符串，描述了输入的函数 $f(x)$。设 $p=998244353$。 字符串中可能包含的元素有： 1、系数为 $1$ 的单项式，包括 $x^2,x^0$ 等，我们保证指数为非负整数为 $1$ 时不省略，不会超过 $p-1$。所有幂号用 ^ 代替。2、常数，如 $0,19260817$ 等；我们保证一切常数是非负整数且不超过 $p-1$。3、复合函数。将以上两种函数组合的方式可以为加乘幂，括号等。数学中会省略乘号和括号，但我们保证任意情况下都不省略（也不会无意义冗余，即不存在 ((x)),(3)+(4)）；保证任何指数都是常数，即不存在 $x^{g(x)}$的情况。 测试数据的第二行为两个整数，值在$[0,p)$之间。你需要输出两个整数，表示这些整数代入导函数后的值模 $p$ 的结果。 本题中认为 $0^0=1$。 这道题也是很神= = 首先求导不求导的，先把树建出来，然后就会发现这个题的本质还是合并左右孩子。但是有一点很神，就是合并时要用扩展欧拉定理合并，原因是我们存在^这个运算。然后就考虑我们可以存储当x=v时对所有扩欧展开时的模数取模，更新的时候按秩更新就好了= = 还有就是在调这题时，我发现了一个以前程序的bug。 关于建树时的鬼畜判断，我当时是这么加的判断: 123456789101112void Init()&#123; tp = 0, memset(brac, 0, sizeof(brac)) ; for (rr int i = 1 ; i &lt;= N ; ++ i)&#123; if (In[i] == '(') stk[++ tp] = i ; if (In[i] == ')') brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ; &#125;&#125;blablabla....inline int build(int l, int r)&#123; if (brac[l] == r) l ++, r -- ; blablabla...&#125; 这东西每次memset显然会超时，于是便采用一个退化版本1234inline int build(int l, int r)&#123; if (In[l] == '(' &amp;&amp; In[r] == ')') l ++, r -- ; // 1 blablabla...&#125; tm当时自己因为这个调了好久也是很佛了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#define rr register#define ll long longint mod[MAXM], n, v ;int phi(int x)&#123; int ret = x ; for (int i = 2 ; i * i &lt;= x ; ++ i) if (!(x % i))&#123; ret = ret / i * (i - 1) ; while (!(x % i)) x /= i ; &#125; if (x &gt; 1) ret = ret / x * (x - 1) ; return ret ; &#125;void _prework()&#123; for (int i = Mod ; i &gt; 1 ; i = phi(i)) mod[++ n] = i ; mod[++ n] = 1, mod[++ n] = 1 ; &#125;int brac[MAXN], stk[MAXN], tp ;char op[MAXN], In[MAXN] ; int N, T ; int root, L[MAXN], R[MAXN], tot ; ll val[MAXN] ;inline bool isop(char x)&#123; return x == '+' || x == '*' || x == '^' ; &#125;void Init()&#123; for (rr int i = 1 ; i &lt;= N ; ++ i)&#123; if (In[i] == '(') stk[++ tp] = i ; if (In[i] == ')') brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ; &#125;&#125;inline int build(int l, int r)&#123; if (In[l] == '(' &amp;&amp; In[r] == ')') l ++, r -- ; // 1 rr int rt = 0, rt1 = 0, rt2 = 0, x = 0 ; for (int i = l ; i &lt;= r ; ++ i)&#123; if (In[i] == '(') i = brac[i] + 1 ; if (i &gt; r) break ; if (In[i] == '+' &amp;&amp; !isop(In[i - 1])) &#123; rt = i ; break ; &#125; if (In[i] == '*') rt1 = i ; if (In[i] == '^' &amp;&amp; !rt2) rt2 = i ; &#125; if (rt) x = rt ; else if (rt1) x = rt1 ; else x = rt2 ; if (!x)&#123; x = r ; if (In[r] == 'x') op[x] = 'X', val[x] = 1 ; else op[x] = '?', sscanf(In + l, "%lld", &amp;val[x]), val[x] %= Mod ; L[x] = R[x] = 0 ; return x ; &#125; op[x] = In[x], L[x] = build(l, x - 1), R[x] = build(x + 1, r) ; return x ; &#125;struct Node&#123; ll y[MAXM], dy[MAXM] ; &#125;;ll mul(ll a,ll b,ll p)&#123; // 2 return a * b &lt; p ? a * b : a * b % p + p ;&#125;ll add(ll a,ll b,ll p)&#123; // 2 return a + b &lt; p ? a + b : (a + b) % p + p ;&#125;ll expow(ll a, ll b, ll p)&#123; ll res = 1 ; while (b)&#123; if (b &amp; 1) res = mul(res, a, p) ; a = mul(a, a, p) ; b &gt;&gt;= 1 ; &#125; return res ; &#125;Node dp(int x)&#123; Node res ; if (!L[x] &amp;&amp; !R[x])&#123; if (op[x] == 'X') for (int i = 1 ; i &lt;= n ; ++ i) res.y[i] = v % mod[i], res.dy[i] = 1 ; else for (int i = 1 ; i &lt;= n ; ++ i) res.y[i] = val[x] % mod[i], res.dy[i] = 0 ; &#125; else &#123; Node l = dp(L[x]), r = dp(R[x]) ; if (op[x] == '+') for (int i = 1 ; i &lt;= n ; ++ i) res.y[i] = add(l.y[i], r.y[i], mod[i]), res.dy[i] = add(l.dy[i], r.dy[i], mod[i]) ; else if (op[x] == '*') for (int i = 1 ; i &lt;= n ; ++ i) res.y[i] = mul(l.y[i], r.y[i], mod[i]), res.dy[i] = add(mul(l.dy[i], r.y[i], mod[i]), mul(l.y[i], r.dy[i], mod[i]), mod[i]) ; else&#123; rr ll calc ; res.y[n] = res.dy[n] = 0 ; for (int i = n - 1 ; i &gt;= 1 ; -- i) // 1 res.y[i] = expow(l.y[i], r.y[i + 1], mod[i]), calc = (!(l.y[i] % mod[i]) &amp;&amp; (r.y[i + 1] % mod[i + 1] == 1)) ? 1 : expow(l.y[i], (r.y[i + 1] + mod[i + 1] - 1) % mod[i + 1], mod[i]), res.dy[i] = mul(mul(l.dy[i], r.y[i], mod[i]), calc, mod[i]) ; //calc: 此题认为0^0=1，因此判一下。s &#125; &#125; return res ; &#125;int main()&#123; _prework() ; cin &gt;&gt; T ; int i ; while (T --)&#123; In[1] = '(', scanf("%s", (In + 2)) ; N = strlen(In + 1), In[++ N] = ')' ; Init(), tot = 0, root = build(1, N); for (i = 0 ; i &lt; 2 ; ++ i)&#123; cin &gt;&gt; v ; Node res = dp(root) ; printf("%d%c", res.dy[1] % Mod, " \n"[i == 1]) ; &#125; &#125; return 0 ;&#125; 还有，就是当时自己觉得自己已经理解了怎么操作就开始瞎写，结果就开始疯狂地挂，于是发现了这两个函数： 123456ll mul(ll a,ll b,ll p)&#123; // 2 return a * b &lt; p ? a * b : a * b % p + p ;&#125;ll add(ll a,ll b,ll p)&#123; // 2 return a + b &lt; p ? a + b : (a + b) % p + p ;&#125; 平心而论，这两个函数是最不起眼的两个函数……但是对于某些老年OI降智选手确实致命性的打击：这两个函数不是凭空存在的，是为了配合扩展欧拉定理的！ 基本形式大概就是： $$n^k\equiv \begin{matrix} \qquad n^{[k mod \varphi(m)]+\varphi(m)} (k\geq \varphi(m))\\ n^k \qquad (k&lt;\varphi(m)) \end{matrix} \qquad (mod m)$$ 也就是说最后的$+p$是必要的= = 这也是很佛。。 然后就是我当时还奇怪为什么兔队写的这么快，结果写上一篇文章时发现原来是自己的复杂度写假了，如果按上文中的写，复杂度应该是$O(q|S|\log|S|\log^2p)$。 于是为了优化掉这个log我们需要写一遍后缀表达式版的求导= = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXM 100#define MAXN 100010#define ll long long#define Mod 998244353#define rr registerusing namespace std ;struct Node&#123; ll y[MAXM], dy[MAXM] ; &#125;;char stk[MAXM] ; Node Ans[MAXN] ; int ans, i, j, tp, pt ;char In[MAXN], op[MAXN], res[MAXN] ; int T, N, L, mod[MAXM], n ; ll val[MAXN] ;int phi(int x)&#123; int ret = x ; for (int i = 2 ; i * i &lt;= x ; ++ i) if (!(x % i))&#123; ret = ret / i * (i - 1) ; while (!(x % i)) x /= i ; &#125; if (x &gt; 1) ret = ret / x * (x - 1) ; return ret ;&#125;void _prework()&#123; for (int i = Mod ; i &gt; 1 ; i = phi(i)) mod[++ n] = i ; mod[++ n] = 1, mod[++ n] = 1 ;&#125;inline ll mul(ll a,ll b,ll p)&#123; return a * b &lt; p ? a * b : a * b % p + p ; &#125;inline ll add(ll a,ll b,ll p)&#123; return a + b &lt; p ? a + b : (a + b) % p + p ; &#125;inline ll expow(ll a, ll b, ll p)&#123; rr ll res = 1 ; while (b)&#123; if (b &amp; 1) res = mul(res, a, p) ; a = mul(a, a, p) ; b &gt;&gt;= 1 ; &#125; return res ;&#125;inline int calc(const char &amp;x)&#123; if (x =='(') return 1 ; if (x =='+') return 2 ; if (x =='*') return 3 ; if (x =='^') return 4 ; return 0 ;&#125;inline bool Comp(const char &amp;a, const char &amp;b)&#123; return calc(a) &gt;= calc(b) ; &#125;int main()&#123; _prework() ; cin &gt;&gt; T ; while (T --)&#123; scanf("%s", In + 1), N = strlen(In + 1) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; ll ret = 0 ; if (isdigit(In[i]))&#123; while (isdigit(In[i])) ret = (ret &lt;&lt; 1) + (ret &lt;&lt; 3) + In[i] - '0', ++ i ; i --, val[++ L] = ret, res[L] = 'N' ; &#125; else if (In[i] == 'x') val[++ L] = 1, res[L] = 'X' ; else if (In[i] == '(') stk[++ tp] = In[i] ; else if (In[i] == ')')&#123; while (stk[tp] != '(') res[++ L] = stk[tp --] ; tp -- ; &#125; else &#123; while (tp &amp;&amp; Comp(stk[tp], In[i])) res[++ L] = stk[tp --] ; stk[++ tp] = In[i] ; &#125; &#125; while (tp) res[++ L] = stk[tp --] ; for (int o = 1 ; o &lt;= 2 ; ++ o)&#123; rr int v ; scanf("%d", &amp;v) ; for (j = 1 ; j &lt;= L ; ++ j)&#123; rr Node ret ; if (!calc(res[j])) &#123; if (res[j] == 'X') for (i = 1 ; i &lt;= n ; ++ i) ret.y[i] = v % mod[i], ret.dy[i] = 1 ; else for (i = 1 ; i &lt;= n ; ++ i) ret.y[i] = val[j] % mod[i], ret.dy[i] = 0 ; Ans[++ pt] = ret ; continue ; &#125; rr Node p1 = Ans[pt --] ; rr Node p2 = Ans[pt --] ; if (res[j] == '+') for (int i = 1 ; i &lt;= n ; ++ i) ret.y[i] = add(p1.y[i], p2.y[i], mod[i]), ret.dy[i] = add(p1.dy[i], p2.dy[i], mod[i]) ; else if (res[j] == '*') for (int i = 1 ; i &lt;= n ; ++ i) ret.y[i] = mul(p1.y[i], p2.y[i], mod[i]), ret.dy[i] = add(mul(p1.dy[i], p2.y[i], mod[i]), mul(p1.y[i], p2.dy[i], mod[i]), mod[i]) ; else&#123; rr ll calcc ; swap(p1, p2) ; ret.y[n] = ret.dy[n] = 0 ; for (int i = n - 1 ; i &gt;= 1 ; -- i) // 1 ret.y[i] = expow(p1.y[i], p2.y[i + 1], mod[i]), calcc = (!(p1.y[i] % mod[i]) &amp;&amp; (p2.y[i + 1] % mod[i + 1] == 1)) ? 1 : expow(p1.y[i], (p2.y[i + 1] + mod[i + 1] - 1) % mod[i + 1], mod[i]), ret.dy[i] = mul(mul(p1.dy[i], p2.y[i], mod[i]), calcc, mod[i]) ; &#125; Ans[++ pt] = ret ; &#125; printf("%lld ", Ans[pt].dy[1] % Mod), pt -- ; &#125; L = 0, puts("") ; &#125; return 0 ;&#125; 写完我才发现我的大常数是救不了的了，兔爷写的60ms，我写的1120ms，这tm20倍的常数宛如写了$\rm{|S|\log|S|}$……不过说会话比建树的快了些。 看了看题解似乎应该是兔爷多写了一层欧拉展开，于是又消掉一个log = = $O(q|S|\log^2 p)$ $O(q|S|\log |S| log^2 p)$ 卡常真是荼毒人名= =]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>表达式/表达式树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】表达式树入门]]></title>
    <url>%2F2019%2F07%2F26%2Fbiaodashishu%2F</url>
    <content type="text"><![CDATA[严格来讲，我们所谈的表达式树是对一个计算式的中缀表达式所构造的二叉树形结构，在求解表达式的值时十分的方便。 对于一棵表达式树，其中每一个节点都表示一个字符，特别的是数值只会是叶子节点，这些数值由其祖先节点——均是“计算符号”的节点连接起来。而计算方式则是：$$\rm{S_u=calc(S_{v_1}, S_{v_2})}$$其中u为当前节点，calc函数的计算方式取决于点$u$上的符号。 从而只需要递归计算即可。 $1$ 递归建树1234567891011121314151617181920212223242526272829303132333435363738394041424344inline bool isop(const char &amp;x)&#123; return x == '+' || x == '-' || x == '*' || x == '/' || x == '^' ;&#125;int build(const int &amp;l, const int &amp;r)&#123; if (brac[l] == r) return build(l + 1, r - 1) ; rr int rt = 0, ls = 0, rs = 0, x = 0 ; for (rr int k = l ; k &lt;= r ; ++ k)&#123; if (In[k] == '(') k = brac[k] + 1 ; if (k &gt; r) break ; if ((In[k] == '+' || In[k] == '-') &amp;&amp; k != l &amp;&amp; !isop(In[k - 1])) &#123; rt = k ; break ; &#125;//! if (In[k] == '*' || In[k] == '/') ls = k ; if (In[k] == '^' &amp;&amp; !rs) rs = k ; &#125; if (rt) x = rt ; else if (ls) x = ls ; else x = rs ; if (!x) &#123; x = r, op[x] = '?' ; sscanf(In + l, "%d", &amp;val[x]) ; val[x] %= Mod ; return x ; &#125; op[x] = In[x] ; L[x] = build(l, x - 1), R[x] = build(x + 1, r) ; return x ; &#125;int expow(int a, int b)&#123; rr int res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= Mod ; (a *= a) %= Mod ; b &gt;&gt;= 1 ; &#125; return res ; &#125;int dp(const int &amp;x)&#123; if (op[x] == '?') return val[x] ; rr int l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = 0.0 ; if (op[x] == '+') res = (l + r) % Mod ; if (op[x] == '-') res = (l - r) % Mod ; if (op[x] == '*') res = (l * r) % Mod ; if (op[x] == '/') res = l * expow(r, Mod - 2) % Mod ; if (op[x] == '^') res = expow(l ,r) ; return res ; &#125;signed main()&#123; cin &gt;&gt; In + 1, N = strlen(In + 1) ; for (rr int i = 1 ; i &lt;= N ; ++ i)&#123; if (In[i] == '(') stk[++ tp] = i ; if (In[i] == ')') brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ; &#125; root = build(1, N), cout &lt;&lt; dp(root) &lt;&lt; endl ; return 0 ; &#125; 其实也没啥好说的，这道题是NOIP2013普及组的表达式求值。然后建树的时候需要注意优先级…… 但其实这个地方想说的不是这个东西，而是一个复杂度的问题。喜闻乐见的这个玩意儿的复杂度是$O(n^2)$的，但是在我加了 123if ((In[k] == '+' || In[k] == '-') &amp;&amp; k != l &amp;&amp; !isop(In[k - 1])) &#123; rt = k ; break ; &#125;//! 中的break之后，他就可以在400ms内的龟速把1e6的数据给艹过去了……也算是很迷 但听说似乎真正$O(|S|)$的建树其实只需要预处理一下每个位置之前最近的符号就好…… 12345678910111213141516171819202122232425262728int build(int l, int r)&#123; int rt = -1 ; if (Code[r][1] &gt;= l) rt = Code[r][1] ; else if (Code[r][2] &gt;= l) rt = Code[r][2] ; if (rt &gt; 0)&#123; op[rt] = In[rt], L[rt] = build(l, rt - 1), R[rt] = build(rt + 1, r) ; return rt ; &#125; op[r] = '?', sscanf(In + l, "%d", &amp;val[r]) ; val[r] %= Mod ; return r ;&#125;int dp(int x)&#123; if (op[x] == '?') return val[x] ; int l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = 0.0 ; if (op[x] == '+') res = (l + r) % Mod ; if (op[x] == '*') res = (l * r) % Mod ; return res ;&#125;int main()&#123; cin &gt;&gt; (In + 1) ; N = strlen(In + 1) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; if (In[i] == '+') Add = i ; else if (In[i] == '*') Mul = i ; Code[i][1] = Add, Code[i][2] = Mul ; &#125; root = build(1, N) ; cout &lt;&lt; dp(root) &lt;&lt; endl ;&#125; 这似乎就是线性的了（flag * 1）。然而测了一下速发现： $n^2$写法 $|S|$写法 似乎并没有什么区别……于是这就很佛了。。（fo * 1） $2$ 用栈建树这其实是在UOJ群里面iki9推荐的方式，我看到似乎兔队也是这么建的，于是就打算学一学。 然后其实也是蛮简单的，大概就是先用$|S|$的时间转化成后缀表达式，然后再用$|S|$的时间求出来。 转后缀表达式也挺简单，就是注意一定要是先计算优先级高的、后计算低的，所以我们需要一个优先级单调递减的栈来保存。 计算的时候用一个栈记录，每遇到一个计算符就弹出最顶上的俩数计算。因为后缀表达式的完备性所以一定是可行的。 好了我去写了…… ……这踏马是什么操作啊喂…先贴代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344stack &lt;char&gt; stk ; stack &lt;int&gt; Ans ; int ans, i ;char In[MAXN], op[MAXN], res[MAXN] ; int N, L, val[MAXN] ;int calc(char x)&#123; if (x =='(') return 1 ; if (x =='+') return 2 ; if (x =='-') return 2 ; if (x =='*') return 3 ; if (x =='/') return 3 ; if (x =='^') return 4 ; return 0 ;&#125;bool Comp(char a, char b)&#123; return calc(a) &gt;= calc(b) ;&#125;int main()&#123; cin &gt;&gt; (In + 1), N = strlen(In + 1) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; int ret = 0 ; if (isdigit(In[i]))&#123; while (isdigit(In[i])) ret = (ret &lt;&lt; 1) + (ret &lt;&lt; 3) + In[i] - '0', ++ i ; i --, val[++ L] = ret, res[L] = 'N' ; &#125; else if (In[i] == '(') stk.push(In[i]) ; else if (In[i] == ')')&#123; while (stk.top() != '(') res[++ L] = stk.top(), stk.pop() ; stk.pop() ; &#125; else &#123; while (!stk.empty() &amp;&amp; Comp(stk.top(), In[i])) res[++ L] = stk.top(), stk.pop() ; stk.push(In[i]) ; &#125; &#125; while (!stk.empty()) res[++ L] = stk.top(), stk.pop() ; for (i = 1 ; i &lt;= L ; ++ i)&#123; if (!calc(res[i])) &#123; Ans.push(val[i]) ; continue ; &#125; int p1 = Ans.top() ; Ans.pop() ; int p2 = Ans.top() ; Ans.pop() ; if (calc(res[i]) == 2) &#123;int p = (p1 + p2) % Mod ; Ans.push(p) ; &#125; else if (calc(res[i]) == 3) &#123;int p = (p1 * p2) % Mod ; Ans.push(p) ; &#125; &#125; cout &lt;&lt; Ans.top() % Mod &lt;&lt; endl ; return 0 ;&#125; 再贴结果： ？？？ 思考了思考，似乎刚才递归那种写法不是$O(|S |)$的？嗯，很有道理，那玩意儿复杂度应该是$O(|S|\log |S|)$的啊，毕竟tm终究是棵完全二叉树…… 我佛了]]></content>
      <categories>
        <category>学习笔记</category>
        <category>语义树</category>
      </categories>
      <tags>
        <tag>表达式/表达式树</tag>
        <tag>树模型</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想九 · 意义]]></title>
    <url>%2F2019%2F07%2F18%2FNine%2F</url>
    <content type="text"><![CDATA[Let’s say sunshine for everyone 人们说生活总是充满阳光But as far as I can remember 但在我的记忆中We’ve been migratory animals 我们一直只是如野兽般流浪Living under changing weather 四季变换，我们如常Someday we will foresee obstacles 总有一天，我们会看见那些困难阻碍Through the blizzard through the blizzard 在那片风雪之中，在那片风雪之后Today we will sell our uniform 如今我们将曾经的校服变卖Live together live together 一同离去，一同启程 var ap = new APlayer({ element: document.getElementById("aplayer-qRWJDGUF"), narrow: false, autoplay: false, showlrc: false, music: { title: "Obstacles", author: "Syd Matters", url: "Obstacles.flac", pic: "/2019/07/18/Nine/lis.png", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); $1$最近暑假了，一直颓的很。并不想说太多，每天晚上昏睡之际眼前的火苗会在第二天早上太阳升起时熄灭，似乎也不再是什么稀罕事。不过倒是也有所收获。先是去B站看C菌的《奇异人生二·实况》，才知道有《Life is Strange》这么一款游戏，于是索性只看了《二》，自己从steam上买了第一部，津津有味地玩了起来。奈何CPU是1.8GHz的，仅达到了最低配的要求，故画面体验有些差，但倒也无妨。但或许游戏时长有点多？别人都说“15小时通关”，似乎我也是在拽平均分了。 奇怪的是一直没有官方的的汉化包（但是2和续作都有汉化包，只有1官方没发布），于是只能凭很渣的英语阅读能力来玩，中间自然也是和看《哈利波特》一样，有许多细节是看不懂的，但是95%+还是没有问题。可惜玩完之后，毕竟是12 P.M.了，不知是真的出于困倦，亦或是别的原因，我并没有什么特别的感觉，大概就是“啊，结束了”便没了后文。 之后的一天半全用来看韩剧《秘密森林》，豆瓣上9分+的悬疑力作，确实不错；但是看完到现在似乎已经过了10个小时多，自己却一点深刻的感觉也没有，仅仅也是“啊，结束了”。我逼自己在脑海里构思出过几个结论，诸如“剧情好，情节紧凑”、“主角们身上的品质值得学习”之类的老套的东西，毕竟自己不喜欢接受“我浪费了时间”这种事实。 但是我从QQ音乐上（我一直不用网易云）搜到了Life is Strange的soundtrack，听了听最后选择Cloye后的BGM，或者说谢场曲，Obstacles，渐渐地有了感觉。这时我才意识到，或许这真是一款伟大的游戏。 $2$到现在我才发现，一个真正的爱的东西，或许一张照片就能表达，不许要各个角度的拍摄、点缀——此感慨大概是来源于我本来想把自己很有感触的片段啊、镜头啊、台词啊都整理出来，丢到博客上封存起来。但碍于自己实力不够又太懒，最终决定放弃了。当然，或许这个感慨也仅是一个心理安慰而已吧。 不知怎的，最近无论做什么事都有种“却道天凉好个秋”的感觉。纵然坐在屏幕前，单曲循环着Obstacles的我心中不断闪回无数个游戏中的镜头，我从来没意识到的感动、满足在心中游动，我却只想淡淡地描述它，仿佛真的有什么东西一说出口，就会化作烟云飘飞走，再也不回。 最后我选择了Cloye，毫不犹豫地，毁掉了小镇。大概是太感性了吧，看着C菌玩出的拯救小镇的结局最后，棺材上翩翩落下的那只蓝蝴蝶和最后的Max的笑，我感到一阵目眩。经过了23个小时的奋战，我仿佛已经和Max融为了一体：我会感叹超能力滥用的危害，我看着Cloye开心的样子自己也会喜不自胜，看到游戏中周围的场景也恨不得赶紧拍一张，也十分想拥有和Max一样的书画方式，句里话间贯穿着充满浓郁美国西部风味的笑话，但却永远不失简约和得体。我感叹自己身为Max所经历的一切，不断变换的结局，不断迎来的挑战，直到最后才发现可以改变事实的自己有多么无力，才发现Cloye活着才是我唯一想要的。无论最后Cloye是否为此牺牲了，我都会很感慨和Cloye在一起厮混、感慨我成功救下了Kate，感慨自己房间的小清新和Cloye房间的独特，感慨Max和Cloye的那种爱情和友情不断相互叠加，创造出的那种至美至真的情感。 整体上来看，这应该是个悲伤的故事——无论选哪种结局。但是或许也只有悲剧会把生活中的美好撕碎给人看，之后人们才会从那些碎片里面重新拾起向前走的动力吧。 我很想和Max和Cloye做朋友。那一定是一件很幸福的事情吧。 $3$从现在开始，我开始很惧怕看一部新剧或者玩一部新的游戏。我害怕情节会太妙、人物会太精致导致我沉浸其中无法自拔，正如我看《哈利波特》、我看《言叶之庭》、我玩《生化危机7》、我玩Life is Strange一样，要缓好几天才能缓过来。我会泄气为什么我的生活没有那么多缤纷的元素——没有魔法、没有值得我守护的东西、没有改变时间的超能力、没有跨越鸿沟的极致爱情；我会感慨为什么我没有主人公那种超凡脱俗的品质、惊人的意志或者优秀的人际关系。仿佛每多一部文学作品，就如同我心底黑暗的夜空多了一颗星点，但我却只能蜷缩在远处黑暗的角落，瑟瑟地发着抖，看着天空中的光芒我竟会觉得刺眼，觉得避之不及。不知道什么时候，我连欣赏美好的能力都没了。 确实，虽然上文提到的Obstacles这支歌确实是Life is Strange在我心中最完美的诠释，但是我毫不留情面地把它移出了我的曲库。不在于别的，只是因为我不想再一听某首歌就有想哭的冲动，不想再听一首歌就感到自己有多么孤独。rqy口中的“早在心里哭过了”或许就是这种感觉吧。 我又能做什么呢？无论周围有多少人跟我成天开玩笑啊、斗嘴啊，我真的把他们打心底当作过理解我的人吗？我感觉自己每天就如同一座空壳一样，行尸走肉般地担心着一切。大概我是很难把心敞开给谁的把，或者即使我敞开了我也不认为自己敞开了吧；以此为理由说“大概是因为没有另一半造成的”，也不过是病急乱投医吧。我就仿佛一只迷途的小船，永远不知道自己的下一站在哪里。- 其实说到底，还是我根本不知道如何去生活。之前积累的浮躁让我不知道该如何面对平常人的生活，来到高中之后我才知道“哦，原来努力才是硬道理”。或许是rqy太强了，强到他的光芒洒在我眼前时会让我有种我也可以轻松到达那个高度的错觉——整个高一仿佛只有最后一星期不是浮躁的。 或许，我一直是个很好的$\rm{Admirator}$ (羡慕者)而不是一个好的$\rm{Doer}$(实践者)吧。 $4$我一直想知道自己现在到底为何而活，活的意义又是什么。 放眼四周全是烟雾弥漫，我畏惧了。 或许只要我强一些，在文化课上、或者在奥赛上取得了骄人的成绩我就可以全身心投入其中一者了。但奈何实力不足，两者都不是我的拿手项。我开始慌了。之前的岁月仿佛都是虚度，自己去年多么弱，今年似乎也并没有什么实质的变化。我开始慌了。 大家都说“不能功利地搞OI啊”，周围mcfx、rqy的成功也都反复论证了这一点。但是我，我…对我而言，似乎没有比这个更高的精神动力了啊。周围异样的目光接踵而来，因为我不是强者，不可能说出什么“走自己的路，让别人说去吧”的豪言壮语——按着传统的步调都不能取胜，自己的步调大概只是飞蛾扑火吧。 我似乎觉得有些奇怪，大概自己本来就不是搞OI的人，或许是个文学家更合适；但是看到期末考试惨不忍睹的语文分数，我又迷茫了；大概自己本来就没有多努力，但是我感觉今年省选前自己已经够努力了啊，或许只是方向错了——但是方向又在哪呢，我又迷茫了。 似乎天地之大，只有我一个人整日沉浸在迷茫之中无法脱身：人与人真是不一样啊。有些人就是可以无问西东、敢想敢干；我则只会是一个杂鱼，睡死在漫无边际的冬日。 每到这个时候，我都好想逃跑，我想跑到Max和Cloye的那个小镇，和他们一起无忧无虑地活着，没有文化课的压力，没有升学的压力，没有豪言壮语的压力，没有OI的压力，就只是简单地活着……最重要的，我可以不思考我为何而活。 当然，以上都是一个高中生的无病呻吟而已。说到底，我还是没有任何勇气的蝼蚁，不知道该怎样直面生活的痛击，不知道如何自在地活，敏感，而颓废。 除了勇气，我什么都不缺。 Life is Strange，Max，Cloye，寄托着的，是我遥不可及的一个梦啊。 $5$终于我要重新上路了，过去的快乐我想抹去，过去的心酸我想埋葬。眼泪垂青过的土地是翻上来的新泥，在心里死了好几次也必须重生。 至于文学作品，我能想到的最好的结束便是如下： 或许，每一份精致的艺术作品都是一个有条不紊的世界；有关那个世界的回忆，不如折叠起来，就留在那个世界吧。 是啊，Max和Cloye的故事，就留给阿卡迪亚湾和他们即将抵达的西雅图吧；秋月孝雄和雪野百香里的故事就留在那个古色古香的雨亭吧。一切的一切都是碎片，在时空里面穿行，倏而消失不见，倏而又出现在我眼前。铭记和沉沦没有意义；这个世界的一切，无论多么无聊与不可期待，明天太阳升起时，便还要继续。 意义？似乎意义这东西本身就是没有意义的。理解生命、理解生活反而是某种屈从，而真正的英雄则是命运的斗士——就好像JO5里面的主角们，坚定地举起反抗命运的大旗。 明日是否如同今日一样沉沦？我不知道。我只知道把握住下一秒就足够了。之前的生活的每一帧仿佛都像是飘在空中的泡影而已，洗刷着存在于虚妄中的记忆，一次一次，如同枷锁一样阻遏着我的前进。 所以，请君勿言什么明天更好之类的P话了，在绝望中求生才是人生的常态。就如同从峭壁中生出的兰花，挤落一捻石尘都是成功。 《随想》系列目次表：$Link$]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【泛做】Old-NOIP 泛做二]]></title>
    <url>%2F2019%2F07%2F11%2FOld-NOIP2%2F</url>
    <content type="text"><![CDATA[事实上我不久前才发现原来NOIP里面的一些题是很好的…… 然后大概接下来整理的都是些我认为挺有难度的吧qwq 但是感觉似乎这么好的题放在一块有点憋屈……于是就缩短了篇幅增多了篇目 $1~2011F$ 观光公交$Link$ 这题我还是去年的3月19号做的，显然是抄的题解，于是现在又要重做一遍/sad 那么其实贪心的思路很简单，找最多人经过的那条路。由于$n$是$1000$所以直接$O(nk)$的暴力就很稳了。然后注意消除后效性——大体上就是如果你这一站用了什么“氮气加速”，结果下一站还得在那等着，就没有任何作用了，这种情况就gg[i]=i+1，你只能拯救下一站下车的乘客；否则你也可以拯救更多的，就是gg[i]=gg[i+1]，也算是一种状态转移的思想吧。在我看来似乎这是本题唯一的难点了…… 1234567891011121314151617181920212223242526272829303132333435struct person&#123; int w,f,t;&#125;p[100001];int max_each[100001],sum_max[100001],get[100001],time[100001],gg[100001];int main()&#123; int n,m,k,ans=0; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(register int i=1;i&lt;=n-1;i++)cin&gt;&gt;time[i]; for(register int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;p[i].w&gt;&gt;p[i].f&gt;&gt;p[i].t; max_each[p[i].f] = max(p[i].w,max_each[p[i].f]); sum_max[p[i].t]++ ; &#125; for(register int i=2;i&lt;=n;i++) sum_max[i]+=sum_max[i-1]; get[1]=max_each[1]; for(register int i=2;i&lt;=n;i++) get[i]=max(get[i-1],max_each[i-1])+time[i-1]; for(register int i=1;i&lt;=m;i++)&#123; ans+=(get[p[i].t]-p[i].w); &#125;//cout&lt;&lt;ans&lt;&lt;endl; while(k--)&#123; gg[n]=gg[n-1]=n; int maxn=0,f; for(int i=n-2;i&gt;=1;i--) gg[i]=get[i+1]&lt;=max_each[i+1]?i+1:gg[i+1]; for(int i=1;i&lt;n;i++) if(sum_max[gg[i]]-sum_max[i]&gt;maxn&amp;&amp;time[i])&#123; maxn=sum_max[gg[i]]-sum_max[i];f=i; &#125; ans-=maxn;time[f]--; for(int i=2;i&lt;=n;i++)get[i]=max(get[i-1],max_each[i-1])+time[i-1]; &#125; cout&lt;&lt;ans;&#125; 拿什么拯救我当年幼稚的码风啊 $2~2015C$ 斗地主Link 一道喜闻乐见的搜索题。其实蛮简单的，就是每次把能出的牌出一遍就好了，就是调有点难调，在这个时候输出调试法+肉眼查错法比什么gdb好用多了。 以下是整理的细节： 至于如何出单牌和对子，只需要每次dfs时每次最后把不能出花的都出了就好，就是这样： 1for (int j = 1 ; j &lt;= 14 ; ++ j) if (buc[j]) step ++ ; Ans = min(Ans, step) ; return ; 反之如果在出单牌/对子的时候再设置回溯——没有必要且严重扩展了状态数。 还是剪枝，大概就是一个最优性剪枝：1if (step &gt;= Ans) return ; ​ 可能是因为太套路了我一直记不住= = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void dfs(int m, int step)&#123; if (step &gt;= Ans) return ; for (int j = 1 ; j &lt;= 12 ; ++ j)&#123; //单顺子 int cnt = 0, pos ; for (int k = 1 ; ; ++ k) if (!buc[j + k - 1] || j + k &gt; 13) &#123; cnt = k - 1 ; pos = j + k - 2 ; break ; &#125; if (cnt &gt;= 5)&#123; for (int k = j ; k &lt;= pos ; ++ k) buc[k] -- ; dfs(m - cnt, step + 1) ; for (int k = j ; k &lt;= pos ; ++ k) buc[k] ++ ; &#125; &#125; for (int j = 1 ; j &lt;= 12 ; ++ j)&#123; //双顺子 int cnt = 0, pos ; for (int k = 1 ; ; ++ k) if (buc[j + k - 1] &lt; 2 || j + k &gt; 13) &#123; cnt = k - 1 ; pos = j + k - 2 ; break ; &#125; if (cnt &gt;= 3)&#123; for (int k = j ; k &lt;= pos ; ++ k) buc[k] -= 2 ; dfs(m - cnt * 2, step + 1) ; for (int k = j ; k &lt;= pos ; ++ k) buc[k] += 2 ; &#125; &#125; for (int j = 1 ; j &lt;= 12 ; ++ j)&#123; //三顺子 int cnt = 0, pos ; for (int k = 1 ; ; ++ k) if (buc[j + k - 1] &lt; 3 || j + k &gt; 13) &#123; cnt = k - 1 ; pos = j + k - 2 ; break ; &#125; if (cnt &gt;= 3)&#123; for (int k = j ; k &lt;= pos ; ++ k) buc[k] -= 3 ; dfs(m - cnt * 3, step + 1) ; for (int k = j ; k &lt;= pos ; ++ k) buc[k] += 3 ; &#125; &#125; for (int j = 1 ; j &lt;= 13 ; ++ j)&#123; //炸弹 or 四带二 int p[3], tot = 0, q[3], cnt = 0 ; if (buc[j] &gt;= 4)&#123; for (int k = 1 ; k &lt;= 14 ; ++ k)&#123; if (j != k)&#123; if (buc[k] &gt;= 2 &amp;&amp; cnt &lt; 2) q[++ cnt] = k ; else if (buc[k] &amp;&amp; tot &lt; 2) p[++ tot] = k ; &#125; &#125; if (tot &lt; 2 &amp;&amp; cnt &lt; 2) &#123; buc[j] -= 4 ; dfs(m - 4, step + 1) ; buc[j] += 4 ; &#125; else if (cnt &lt; 2) &#123; buc[p[2]] --, buc[p[1]] --, buc[j] -= 4 ; dfs(m - 6, step + 1) ; buc[p[2]] ++, buc[p[1]] ++, buc[j] += 4 ; &#125; else &#123; buc[q[2]] -= 2, buc[q[1]] -= 2, buc[j] -= 4 ; dfs(m - 8, step + 1) ; buc[q[2]] += 2, buc[q[1]] += 2, buc[j] += 4 ; &#125; &#125; &#125; for (int j = 1 ; j &lt;= 13 ; ++ j)&#123; // 三带XXX if (buc[j] &gt;= 3)&#123; buc[j] -= 3 ; for(int k = 1 ; k &lt;= 14 ; ++ k)&#123; if( !buc[k] || k == j ) continue ; buc[k] -- ; dfs(m - 4, step + 1) ; buc[k] ++ ; &#125; for(int k = 1 ; k &lt;= 13 ; ++ k)&#123; if( buc[k] &lt;= 1 || j == k) continue ; buc[k] -= 2 ; dfs(m - 5, step + 1) ; buc[k] += 2 ; &#125; buc[j] +=3 ; &#125; &#125; for (int j = 1 ; j &lt;= 14 ; ++ j) if (buc[j]) step ++ ; Ans = min(Ans, step) ; return ;&#125; = =其实这题最恶心的还是粗心地写错，毕竟那么多函数都是ctrl c+ctrl v的，鬼知道什么地方就崩掉了…… $3~2015\text{C+/G}$ 斗地主加强版Link 直接粘一份代码过来你甚至可以获得74pts的好成绩= = 其实主要思想就是拆牌，原因是假设你又两组三张，一组炸，你的思路是出三次，但实际上只需要两次就可以——把一组三张拆成一单+一对，然后带走只需要两次。 但是我并不想写诡异的剪枝，于是索性根据题解区写了一个DP。即设$dp_{i,j,k,l,o}$表示剩下的单张有$i$个，对牌有$j$个，三张有$k$组，四张有$l$组，王有$o$个的最小出牌次数。然后转移就是朴素的转移，同时由于拆牌的存在，我们需要多加两组拆牌的转移，这就需要我们先枚举三张和炸才能转移。 1234567891011121314151617181920212223242526272829303132333435void Init_dp()&#123; memset(dp, 63, sizeof(dp)) ; dp[0][0][0][0][0] = 0 ; for (rr int l = 0 ; l &lt;= N ; ++ l) for (rr int k = 0 ; k &lt;= N ; ++ k) for (rr int i = 0 ; i &lt;= N ; ++ i) for (rr int j = 0 ; j &lt;= N ; ++ j) for (rr int o = 0 ; o &lt;= 2 ; ++ o)&#123; rr int res = 100 ; // Single if (i) res = min(res, dp[i - 1][j][k][l][o] + 1) ; if (j) res = min(res, dp[i][j - 1][k][l][o] + 1) ; if (k) res = min(res, dp[i][j][k - 1][l][o] + 1) ; if (l) res = min(res, dp[i][j][k][l - 1][o] + 1) ; if (o) res = min(res, dp[i][j][k][l][o - 1] + 1) ; if (o &gt; 1) res = min(res, dp[i][j][k][l][o - 2] + 1) ; // T -&gt; 1 if (i &amp;&amp; k) res = min(res, dp[i - 1][j][k - 1][l][o] + 1) ; if (k &amp;&amp; o) res = min(res, dp[i][j][k - 1][l][o - 1] + 1) ; // T -&gt; 2 if (j &amp;&amp; k) res = min(res, dp[i][j - 1][k - 1][l][o] + 1) ; // F -&gt; 2 if (l &gt; 1) res = min(res, dp[i][j][k][l - 2][o] + 1) ; if (j &amp;&amp; l) res = min(res, dp[i][j - 1][k][l - 1][o] + 1) ; if (i &gt; 1 &amp;&amp; l) res = min(res, dp[i - 2][j][k][l - 1][o] + 1) ; if (j &gt; 1 &amp;&amp; l) res = min(res, dp[i][j - 2][k][l - 1][o] + 1) ; if (o &gt; 1 &amp;&amp; l) res = min(res, dp[i][j][k][l - 1][o - 2] + 1) ; if (i &amp;&amp; o &amp;&amp; l) res = min(res, dp[i - 1][j][k][l - 1][o - 1] + 1) ; // CHAI if (l) res = min(res, dp[i + 1][j][k + 1][l - 1][o]) ; if (k) res = min(res, dp[i + 1][j + 1][k - 1][l][o]) ; // Trans dp[i][j][k][l][o] = min(res, dp[i][j][k][l][o]) ; &#125; &#125; 拆牌分别是“炸拆成三张和单张”以及“三张拆成对子和单张”。 然后由于顺子这种东西不能根据数量转移，所以就还是dfs暴力算（dp按理说也是暴力吧/kk），最后加回来就完了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void dfs(int m, int step)&#123; if (step &gt;= Ans) return ; for (rr int j = 1 ; j &lt;= 12 ; ++ j)&#123; //单顺子 rr int cnt = 0 ; for (rr int k = 1 ; ; ++ k) if (!buc[j + k - 1] || j + k &gt; 13) &#123; cnt = k - 1 ; break ; &#125; if (cnt &gt;= 5)&#123; for (rr int p = 5 ; p &lt;= cnt ; ++ p)&#123; for (rr int k = j ; k &lt;= j + p - 1 ; ++ k) buc[k] -- ; dfs(m - p, step + 1) ; for (int k = j ; k &lt;= j + p - 1 ; ++ k) buc[k] ++ ; &#125; &#125; &#125; for (rr int j = 1 ; j &lt;= 12 ; ++ j)&#123; //双顺子 rr int cnt = 0, pos ; for (rr int k = 1 ; ; ++ k) if (buc[j + k - 1] &lt; 2 || j + k &gt; 13) &#123; cnt = k - 1 ; break ; &#125; if (cnt &gt;= 3)&#123; for (rr int p = 3 ; p &lt;= cnt ; ++ p)&#123; pos = j + p - 1 ; for (rr int k = j ; k &lt;= pos ; ++ k) buc[k] -= 2 ; dfs(m - cnt * 2, step + 1) ; for (int k = j ; k &lt;= pos ; ++ k) buc[k] += 2 ; &#125; &#125; &#125; for (rr int j = 1 ; j &lt;= 12 ; ++ j)&#123; //三顺子 rr int cnt = 0, pos ; for (rr int k = 1 ; ; ++ k) if (buc[j + k - 1] &lt; 3 || j + k &gt; 13) &#123; cnt = k - 1 ; break ; &#125; if (cnt &gt;= 2)&#123; for (rr int p = 2 ; p &lt;= cnt ; ++ p)&#123; pos = j + p - 1 ; for (rr int k = j ; k &lt;= pos ; ++ k) buc[k] -= 3 ; dfs(m - cnt * 3, step + 1) ; for (int k = j ; k &lt;= pos ; ++ k) buc[k] += 3 ; &#125; &#125; &#125; memset(tong, 0, sizeof(tong)) ; for (int j = 1 ; j &lt;= 13 ; ++ j) tong[buc[j]] ++ ; tong[5] = buc[14] ; Ans = min(Ans, step + dp[tong[1]][tong[2]][tong[3]][tong[4]][tong[5]]);return ;&#125; $4~2015E$ 子串$Link$ 又是一道情怀题，还记得当时做的时候觉得可难了…（当时的pks：这个转移是人能想出来的吗？） 但其实状态很简单，$f_{i,j,k,0/1}$记录A到了$i$，B到了$j$，A迄今为止分成$k$段，$A[i]$选或者不选的方案数。 然后转移时考虑分类讨论： 首先 $A[i] = B[j]:$ 1 ： $f_{i,j,k,1} = f_{i-1,j-1,k-1,1} + f_{i-1,j-1,k-1,0} + f_{i-1,j-1,k,1}$ 也就是{i,j}和前面的是一段/不是一段且和前面的段之间有空格/不是一段且和前面的段之间没空格（讨论空格是为了保证转移的完整性）。 2 ： $f_{i,j,k,0} = f_{i - 1,j, k, 1} + f_{i -1, j, k, 0}$ 前面一位选/不选 否则 $A[i]\not = B[j]$ 1： $f_{i,j,k,1} = 0\\$ 不合法的转移2： $f_{i,j,k,0} = f_{i - 1,j, k, 1} + f_{i -1, j, k, 0}$ 其实感觉这个方程…怎么说呢，挺有学习意义的。这其实也算是做了一个状态的前缀和，因为理论上是要从$k\text{~}i-1$中转移的，但因为是方案数，所以可以直接做一个前缀和过来；同时因为此时我们的“主元”是$A$，所以如果不选的话只能是从$(i-1,j)$转移过来而不是$(i,j-1)$（即$k$这一维限制的是$i$） 。 然而还有另外一种定义状态的方式； 其余的都差不多，还是$f_{i,j,k,1}$表示必选，但是$f_{i,j,k,0}$则表示“可选可不选”。那我们来思考这样如何转移： 1：$f_{i,j,k,1} = (f_{i-1,j-1,k,1} +f_{i - 1,j-1, k-1, 0})\cdot [A_i=B_j] $ 还是分类讨论“连不连成一整段” 2：$f_{i,j,k,0} = f_{i−1,j,k,0}+f_{i,j,k,1}$，即保证了这一位不选的上一位的选/不选和保证了这一位必选的方案数。 思想也大体相同。注意数据范围的限制，滚一下就好了。 嗯，是一道不错的题。 12345678910111213141516int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K ; dp[0][0][0] = 1 ; for(i = 1; i &lt;= N; i ++) cin &gt;&gt; A[i] ; for(i = 1; i &lt;= M; i ++) cin &gt;&gt; B[i] ; for(d = i = 1; i &lt;= N; i ++, d ^= 1)&#123; dp[d][0][0] = 1 ; for(j = 1; j &lt;= M; j ++) for(k = 1; k &lt;= K ;k ++)&#123; if(A[i] == B[j]) f[d][j][k] = (dp[d ^ 1][j - 1][k - 1] + f[d ^ 1][j - 1][k]) % mod ; else f[d][j][k] = 0 ; dp[d][j][k] = (dp[d ^ 1][j][k] + f[d][j][k]) % mod ; &#125; &#125; cout &lt;&lt; dp[N &amp; 1][M][K]% mod ;&#125; $5~2011C$ Mayan游戏Link 想当年这可真是噩梦…… 简单来讲就是爆搜吧，只不过记得当时没想到是真的每次搜一遍$7\cdot5$的方阵…… 然后这是以前的笔记： 1、每次搜索要保留本次的状态，这是比较好想的，我也成功的想到了。但是问题是我们不能单纯地用一个二维数组来$copy$，需要记录步数，因为如果单纯的reset会导致之前走过的也消失。于是最终我们需要一个三维数组来记录。后半段是$qcr$告诉我的。 2、还有就是一个小小的剪枝。就是由于对于每一个格子，我们考虑它向两边替换，而我们为了避免重复搜索，所以就决定单向搜索，即对于每个块，如果他左边也是一个块，那就不去$exchange$，只考虑右边；而如果左边是空白格，才$exchange$。显然这个剪枝的优化性是很显著的。 3、我一开始写的$remove()$、$down()$和$check()$十分的麻烦——或者说专一?反正之后我懒得调试了，直接听的$qcr$的，每次执行这几个函数的时候，直接全屏扫一遍。 4、$qcr$给我讲了一个很神的$down()$函数——其实也不算多神，只是很简单地处理了每一行的悬空态方块，但是说“神”的原因则是因为“简单”。对，简单，而有时往往我会想复杂。 5、对于$exchange$，我们要不断的$while(remove()) ~;$，因为会不断地有新情况出现。 6、最后我挂了……几个点来着……忘记了。反正原因是因为，每次$remove()$之前应该先$down()$，然而我并没有$down()$干净233 7、最后再说一个剪枝儿，不是必要性的，但是确实可以加快速度。就是我们再每次遍历$7 \times 5$的时候，遇到空白的，不是continue而是break，因为我们$down$一定是完备的，即从下向上枚举时，如果下方的已经clear了，上方的不可能悬空。所以可以少好几次空遍历。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687struct D&#123; int x, y ;&#125; ; stack &lt;D&gt; s ;struct Ans&#123; int x, y, d ;&#125; res[100] ; int Remove[50][50] ;int N, T[30][30], base[4000][10][10], qwq[4000][30], color[30], i, j, t, tot ;inline int qr()&#123; ....&#125;inline void down()&#123; int ttt = 0 ; for(int di = 1 ; di &lt;= 5 ; ++ di)&#123; ttt = 0 ; for(int dj = 1 ; dj &lt;= 7 ; ++ dj) if(T[di][dj] == -1) ++ ttt ; else&#123; if(! ttt) continue ; T[di][dj - ttt] = T[di][dj], T[di][dj] = -1 ; &#125; &#125;&#125;inline bool remove()&#123; // void -&gt; bool bool Mark = 0 ; memset(Remove, 0, sizeof(Remove)) ; for (int di = 1 ; di &lt;= 5 ; ++ di) for (int dj = 1 ; dj &lt;= 7 ; ++ dj)&#123; if (T[di][dj] != -1 &amp;&amp; di &gt;= 2 &amp;&amp; di &lt;= 4 &amp;&amp; T[di][dj] == T[di + 1][dj] &amp;&amp; T[di][dj] == T[di - 1][dj])&#123; Remove[di + 1][dj] = Remove[di - 1][dj] = Remove[di][dj] = 1, Mark = 1 ; &#125; if (T[di][dj] != -1 &amp;&amp; dj &gt;= 2 &amp;&amp; dj &lt;= 6 &amp;&amp; T[di][dj] == T[di][dj + 1] &amp;&amp; T[di][dj] == T[di][dj - 1])&#123; Remove[di][dj + 1] = Remove[di][dj - 1] = Remove[di][dj] = 1, Mark = 1 ; &#125; &#125; if (!Mark) return 0 ; for (int di = 1 ; di &lt;= 5 ; ++ di) for (int dj = 1 ; dj &lt;= 7 ; ++ dj) T[di][dj] = (!Remove[di][dj]) ? T[di][dj] : -1 ; down() ; return 1 ; &#125;inline bool judge()&#123; for (int di = 1 ; di &lt;= 5 ; ++ di) for (int dj = 1 ; dj &lt;= 7 ; ++ dj) if (T[di][dj] != -1) return false ; return true ;&#125;inline void Prepare(int x)&#123;//copy for (int di = 1 ; di &lt;= 5 ; ++ di) for (int dj = 1 ; dj &lt;= 7 ; ++ dj) base[x][di][dj] = T[di][dj] ;&#125;inline void _reset(int x)&#123;//copy_back for (int di = 1 ; di &lt;= 5 ; ++ di) for (int dj = 1 ; dj &lt;= 7 ; ++ dj) T[di][dj] = base[x][di][dj] ;&#125;inline void dfs_work(int step)&#123; if (judge())&#123; for (int di = 1 ; di &lt;= N ; ++ di) printf("%d %d %d\n", res[di].x, res[di].y, res[di].d) ; exit(0) ; &#125; if (step == N + 1) return ; Prepare(step) ; for (int di = 1 ; di &lt;= 5 ; ++ di) for (int dj = 1 ; dj &lt;= 7 ; ++ dj)&#123; if (T[di][dj] == -1) break ; if (di &gt; 1 &amp;&amp; T[di - 1][dj] == -1)&#123; swap(T[di][dj], T[di - 1][dj]) ; down() ; while (remove()) ; res[step] = (Ans)&#123;di - 1, dj - 1, -1&#125; ; dfs_work(step + 1) ; _reset(step) ; res[step] = (Ans)&#123;-1, -1, -1&#125; ; &#125; if (di &lt; 5 &amp;&amp; T[di][dj] != T[di + 1][dj])&#123; swap(T[di][dj], T[di + 1][dj]) ; down() ; while(remove()) ; res[step] = (Ans)&#123;di - 1, dj - 1 ,1&#125; ; dfs_work(step + 1) ; _reset(step) ; res[step] = (Ans)&#123;-1, -1, -1&#125; ; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; N ; memset(T, -1, sizeof(T)) ; for (i = 1 ; i &lt;= 5 ; ++ i) T[i][0] = 0 ; for (i = 1 ; i &lt;= 5 ; ++ i) while((t = qr()) != 0) T[i][++ T[i][0]] = t ; dfs_work(1) ; cout &lt;&lt; -1 &lt;&lt; endl ; return 0 ;&#125; $\text{Afterwords}$“ 准确来说，没有人在到达之前知道自己到底要去哪儿。 ”]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>动态规划-普通DP</tag>
        <tag>奇怪的技巧</tag>
        <tag>贪心</tag>
        <tag>NOIP系列</tag>
        <tag>搜索-剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【泛做】Old-NOIP 泛做三]]></title>
    <url>%2F2019%2F07%2F11%2Fold-NOIP-0%2F</url>
    <content type="text"><![CDATA[$NOIP2016$以及之前年份$NOIP$中优秀题目的泛做。 以下的题是我做了之后不禁感慨“啊，真是个好题”的题们…… 然后首先打出难度标签： 然后以下题目按照得较高的部分分的难度排序 $ 1 2013F$ 华容道$Link$ 可能这道题很难…但是它有70分的暴力分！70分！在loj你甚至可以获得80分！tm这样的话暴力和正解有什么区别吗…从得分的时间分布上来讲，想正解就是大写的不值…… 首先我们思考什么信息是有用的，嗯，空白格子的位子和当前棋子的位置，所以只要我们用BFS（而不是DFS，DFS的状态开销极大，但更可能的是我DFS的打开方式不对吧/sigh）的话，状态数就是$O(n^2m^2)$的，然后总复杂度就是$O(qn^2m^2)$，大概是四亿零500万的运算量上限…然而一开始我算成了四千五百万还纳闷为什么开了-O2在1s以内还跑不出来…… 先贴个暴力吧： 1234567891011121314151617181920212223242526void bfs()&#123; memset(vis, 0, sizeof(vis)) ; ans = Inf, vis[ex][ey][sx][sy] = 1 ; q.push((state)&#123;ex, ey, sx, sy, 0, 1&#125;) ; while (!q.empty())&#123; state n = q.front() ; q.pop() ; if (n.sx == tx &amp;&amp; n.sy == ty) ans = min(ans, n.s) ; for (int k = 0 ; k &lt; 4 ; ++ k)&#123; int kx = n.bx + dx[k], ky = n.by + dy[k], px, py ; if (kx == n.sx &amp;&amp; ky == n.sy) px = n.bx, py = n.by ; else px = n.sx, py = n.sy ; if (!base[kx][ky] || kx &gt; N || ky &gt; M || kx &lt; 1 || ky &lt; 1 || vis[kx][ky][px][py]) continue ; vis[kx][ky][px][py] = 1 ; q.push((state)&#123;kx, ky, px, py, n.s + 1, n.num + 1&#125;) ; &#125; &#125; if (ans &gt;= Inf) puts("-1") ; else printf("%d\n", ans) ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j) scanf("%d", &amp;base[i][j]) ; while (Q --) cin &gt;&gt; ex &gt;&gt; ey &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty, bfs() ; return 0 ;&#125; 喜闻乐见…不过自己打暴力的能力还是不行啊，还得练啊qaq 之后就是更加喜闻乐见的状态压缩。我们思考，这$n^2m^2$个状态都他娘的有鸟用吗（李云龙疾呼态），如果空白格子不在目标格子周围，那么无论空白格子怎么移动都不可能用爱发电。所以我们考虑吧直接预处理出来每个空白格子与目标格子（即起始格子）相邻的状态之间的代价，之后直接对此跑个$SPFA$就好了，毕竟最坏情况下SPFA的复杂度也只是$O(nM)$的，大概就是$O(n\cdot 4nm)&lt;\frac{O(n^2m^2)}{7.5}$，也算是很稳的复杂度了。 然后我们思考这样的复杂度是多少。考虑目标格子有$nm$种情况，空白格子在有效情况下只能在其四周，故状态数是$O(4nm)=nm$的。 然后关于代码实现这块需要比较深入的理解。首先我们先预处理出来当当前格子在随便一个格子上，空白格子想要转到另一个方向的步数。这样就可以抽象成一张空白图上先有的一个一个树（也就是一坨森林）。然后为了让这些森林之间能连上边，再将“空白格子和目标格子换了个位置”这种转移连上边（不连的话就不存在从一个格子到另一个格子的转移了）。同时不要忘了对状态的编号。即： 12345678910111213141516171819202122232425inline int _get(int x, int y, int d)&#123; return x * 120 + y * 4 + d ; &#125;void bfs(int fx, int fy, int ox, int oy, int d)&#123; int Id = _get(ox, oy, d) ; memset(dis, 0, sizeof(dis)), dis[fx][fy] = 1, q.push((state)&#123;fx, fy&#125;) ; // cout &lt;&lt; fx &lt;&lt; " " &lt;&lt; fy &lt;&lt; endl ; while (!q.empty())&#123; state n = q.front() ; int nx = n.x, ny = n.y ; q.pop() ; for (int k = 0 ; k &lt; 4 ; ++ k)&#123; int kx = nx + dx[k], ky = ny + dy[k] ; if (kx &gt; N || ky &gt; M || kx &lt; 1 || ky &lt; 1) continue ; if (base[kx][ky] &amp;&amp; !dis[kx][ky] &amp;&amp; (kx != ox || ky != oy)) dis[kx][ky] = dis[nx][ny] + 1, q.push((state)&#123;kx, ky&#125;) ; &#125; &#125; if (d &gt; 3) return ; for (int k = 0 ; k &lt; 4 ; ++ k)&#123; int kx = ox + dx[k], ky = oy + dy[k] ; if (kx &gt; N || ky &gt; M || kx &lt; 1 || ky &lt; 1) continue ; if (dis[kx][ky] &amp;&amp; (kx != fx || ky != fy) &amp;&amp; base[kx][ky]) Add(Id, _get(ox, oy, k), dis[kx][ky] - 1) ; &#125; Add(Id, _get(fx, fy, d) ^ 1, 1) ;&#125; 以及 1234567891011for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j) cin &gt;&gt; base[i][j] ;for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j)&#123; if (!base[i][j]) continue ; if (base[i - 1][j]) bfs(i - 1, j, i, j, 0) ; if (base[i + 1][j]) bfs(i + 1, j, i, j, 1) ; if (base[i][j - 1]) bfs(i, j - 1, i, j, 2) ; if (base[i][j + 1]) bfs(i, j + 1, i, j, 3) ; &#125; 然后我们考虑在SPFA之前，我们需要求出空白格子从(ex,ey)到(sx, sy)周围需要的步数作为起始点，然后SPFA就好了。 12345678910111213141516void Spfa()&#123; for (int k = 0 ; k &lt; MAXS ; ++ k) f[k] = Inf, vis[k] = 0 ; for (int k = 0 ; k &lt; 4 ; ++ k)&#123; int Id = _get(sx, sy, k), kx = sx + dx[k], ky = sy + dy[k] ; if (dis[kx][ky]) f[Id] = dis[kx][ky] - 1, Q.push(Id), vis[Id] = 1 ; &#125; while (!Q.empty())&#123; int n = Q.front() ; Q.pop() ; vis[n] = 0 ; for (int k = head[n] ; k ; k = E[k].next)&#123; if (f[to(k)] &gt; f[n] + E[k].val)&#123; f[to(k)] = f[n] + E[k].val ; if (!vis[to(k)]) vis[to(k)] = 1, Q.push(to(k)) ; &#125; &#125; &#125;&#125; $2~2012C$ 开车旅行 $Link$ 不得不说2012的题目质量是真心好啊…… 首先这题为了看上去不是那么毒瘤，于是加了一个70分的暴力分。然而…细节贼多——或者说只是我不细心，比如说把A和B怎么走看反了、算比值的时候用了个假double之类的…… 于是70分好像有个头就会写吧= = 不知道当年什么区分度= = 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct Path&#123; int v1, v2 ; int Id1, Id2 ;&#125;P[MAXN] ; int i, j ; double o, q ;int res, ans, N, M, T, base[MAXN], s[MAXN], x[MAXN], p ;inline int mabs(int x)&#123; return x &lt; 0 ? -x : x ; &#125;inline void GO(int S, int H)&#123; int u = 0 ; res = ans = 0 ; for (j = S ; j &lt;= N &amp;&amp; j ; u ^= 1)&#123; if (u) if (res + ans + P[j].v1 &gt; H) return ; else res += P[j].v1, j = P[j].Id1 ; else /*pkspks*/ if (res + ans + P[j].v2 &gt; H) return ; else ans += P[j].v2, j = P[j].Id2 ; // cout &lt;&lt; j &lt;&lt; endl ; &#125;&#125;signed main()&#123; cin &gt;&gt; N ; q = Inf ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%lld", &amp;base[i]) ; cin &gt;&gt; T &gt;&gt; M ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%lld%lld", &amp;s[i], &amp;x[i]) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; int tp = Inf, w = 0 ; for (j = i + 1 ; j &lt;= N ; ++ j)&#123; int qwq = abs(base[i] - base[j]) ; if (qwq &lt; tp || (qwq == tp &amp;&amp; base[w] &gt; base[j])) tp = qwq, w = j ; &#125; P[i].Id1 = w, P[i].v1 = tp ; tp = Inf, w = 0 ; for (j = i + 1 ; j &lt;= N ; ++ j)&#123; int qwq = abs(base[i] - base[j]) ; if (qwq &lt; tp &amp;&amp; (qwq &gt; P[i].v1 || (qwq == P[i].v1 &amp;&amp; base[P[i].Id1] &lt; base[j]))) tp = qwq, w = j ; &#125; P[i].Id2 = w, P[i].v2 = tp ; &#125; // GO(2, T), cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ; // GO(4, T), cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ; // for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; P[i].v1 &lt;&lt; " " &lt;&lt; P[i].Id1 &lt;&lt; " " &lt;&lt; P[i].v2 &lt;&lt; " " &lt;&lt; P[i].Id2 &lt;&lt; endl ; for (i = 1 ; i &lt;= N ; ++ i)&#123; GO(i, T) ; o = 1.0 * res ? (1.0 * ans) / (1.0 * res) : Inf ; if (o &lt; q ||(o == q &amp;&amp; base[p] &lt; base[i])) q = o, p = i ; &#125; cout &lt;&lt; p &lt;&lt; endl ; for (i = 1 ; i &lt;= M ; ++ i) GO(s[i], x[i]), printf("%lld %lld\n", ans, res) ; return 0 ;&#125; 然后感觉从暴力到正解完全不是一个难度的。首先考虑到底是什么地方阻碍了社会的发展——初始化似乎是$n^2$的，走似乎是$&lt;n^2$的，那么从初始化入手： $\rm{Part~1}$ 初始化的优化我们思考如果当前轮到第$i$高的城市了，并且此时所有现存城市中不存在编号在$i$之前的城市，即$i$是最左边的城市，那么对其有用的信息只会在第$i-1,i-2,i+1$或者第$i+2$的城市中选取。这就提示我们似乎如果从值域上考虑就是$O(4n)$的了——只要我们保证不存在在$i$左边的城市、即对应城市不可走的情况。 然后这个时候有个很神仙的想法就是双向链表优化，我们考虑按高度排完序之后，对相邻元素建立双向链表。然后按照从左到右的顺序枚举城市、get信息然后删除掉这个城市。 1234567891011121314151617181920212223inline bool cmp(BASE A, BASE B)&#123; return A.h &lt; B.h ; &#125;inline bool cmp2(BASE A, BASE B)&#123; return A.id &lt; B.id ; &#125;inline int inlaw(int pos)&#123; return (pos &gt; N || !pos) ? Inf : 0 ; &#125;signed main()&#123; cin &gt;&gt; N ; q = Inf ; for (i = 1 ; i &lt;= N ; ++ i) pre[i] = i - 1, nxt[i] = i + 1 ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%lld", &amp;base[i].h), base[i].id = i ; cin &gt;&gt; T &gt;&gt; M ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%lld%lld", &amp;s[i], &amp;x[i]) ; sort(base + 1, base + N + 1, cmp) ; for (i = 1 ; i &lt;= N ; ++ i) Tid[base[i].id] = i ; for (i = 1 ; i &lt;= N ; ++ i)&#123; int t = Tid[i] ; d[1].h = inlaw(pre[t]) + abs(base[pre[t]].h - base[t].h), d[2].h = inlaw(pre[pre[t]]) + abs(base[pre[pre[t]]].h - base[t].h) ; d[3].h = inlaw(nxt[t]) + abs(base[nxt[t]].h - base[t].h), d[4].h = inlaw(nxt[nxt[t]]) + abs(base[nxt[nxt[t]]].h - base[t].h) ; d[1].id = base[pre[t]].id, d[2].id = base[pre[pre[t]]].id, d[3].id = base[nxt[t]].id, d[4].id = base[nxt[nxt[t]]].id, sort(d + 1, d + 5, cmp) ; P[i].Id1 = d[1].id, P[i].v1 = d[1].h, P[i].Id2 = d[2].id, P[i].v2 = d[2].h ; pre[nxt[t]] = pre[t], nxt[pre[t]] = nxt[t] ; &#125; 然后初始化的工作就优化完了。至此可以在Luogu获得75pts的好成绩。 $\rm{Part~2}$ 走的优化…然而只有第一个优化情况并不会好转多少。查看数据之后发现原来最后几个点的$s$和$x$都完全是随的那种……所以就复杂度爆炸。然后我们考虑这么一个喜闻乐见的事情——限制似乎只有“小于x”和“可以继续走”诶，于是似乎相邻的几步如果都不超过限制是不是就可以一起走？于是想到倍增预处理。 我们用$A_{i,j}$表示从i号点开始，走$2^j$轮之后$A$走过的路程；同理$B_{i,j}$表示从i号点开始，走$2^j$轮之后$B$走过的路程。并且选择用$f_{i,j}$表示从i开始走$2^j$轮之后到达的点。然后值得注意的是最后可能走的不满一整轮，于是特判一下A能不能再走一次就好。 123456789101112131415161718192021sort(base + 1, base + N + 1, cmp2) ;//重排回来= = for (i = 1 ; i &lt;= N ; ++ i)&#123; f[i][0] = P[P[i].Id2].Id1 ; if (P[i].Id2) A[i][0] = abs(base[P[i].Id2].h - base[i].h) ; if (P[P[i].Id2].Id1) B[i][0] = abs(base[P[i].Id2].h - base[P[P[i].Id2].Id1].h) ; &#125; for (i = 1 ; i &lt;= 20 ; ++ i) for (j = 1 ; j &lt;= N ; ++ j) f[j][i] = f[f[j][i - 1]][i - 1], A[j][i] = A[f[j][i - 1]][i - 1] + A[j][i - 1], B[j][i] = B[f[j][i - 1]][i - 1] + B[j][i - 1] ;...inline void GO(int S, ll H)&#123; ans = res = 0 ; for (j = 20 ; j &gt;= 0 ; -- j) if (f[S][j] &amp;&amp; A[S][j] + B[S][j] &lt;= H) ans += A[S][j], res += B[S][j], H -= (A[S][j] + B[S][j]), S = f[S][j] ; if (A[S][0] &lt;= H) ans += A[S][0] ; &#125; $3~2016B$ 天天爱跑步$Link$ ……当年的毒瘤题，还记得那还是我第一次参加NOIP（普及组），不出所料地考挂，然后rqy不出所料地考好…… 咳，偏题了，然后对于这道题，我索性把每个部分分都写了一遍： $\rm{Part~1}$ 25pts$n,m\leq 1000$ 其实就是LCA一下然后$nm$的统计答案就完了。 12345678910111213141516171819202122232425262728293031void build(int now, int f)&#123; fa[now][0] = f, dep[now] = dep[f] + 1 ; for (int k = head[now] ; k ; k = E[k].next) if (to(k) == f) continue ; else build(to(k), now) ;&#125;void Setup()&#123; h = log(N) / log(2) + 1 ; for (j = 1 ; j &lt;= h ; ++ j) for (i = 1 ; i &lt;= N ; ++ i) fa[i][j] = fa[fa[i][j - 1]][j - 1] ;&#125;int lca(int u, int v)&#123; if (dep[u] &lt; dep[v]) u ^= v ^= u ^= v ; l = dep[u] - dep[v] ; for (int k = h ; k &gt;= 0 ; -- k) if (dep[fa[u][k]] &gt;= dep[v]) u = fa[u][k] ; if (u == v) return u ; for (int k = h ; k &gt;= 0 ; -- k) if (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k] ; return fa[u][0] ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 1 ; i &lt; N ; ++ i) scanf("%d%d", &amp;x, &amp;y), Add(x, y) ; build(1, 0), Setup() ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]) ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%d%d", &amp;s[i], &amp;e[i]), lca1[i] = t = lca(s[i], e[i]), _up[i] = -(dep[t] &lt;&lt; 1) + (dep[s[i]] + dep[e[i]]) ; for (i = 1 ; i &lt;= N ; ++ i, printf("%d ", ans), ans = 0) for (j = 1 ; j &lt;= M ; ++ j) t = lca(e[j], i), p = lca(s[j], i), w1 = -(dep[p] &lt;&lt; 1) + (dep[i] + dep[s[j]]), w2 = dep[i] + dep[e[j]] - (dep[t] &lt;&lt; 1), ans += (w1 == base[i]) * (_up[j] == w1 + w2) ; return 0 ; &#125; $\rm{Part~2}$ 15pts这部分是链，保证$i$到$i+1$有一条边。 那么其实这个问题就转化成了在一个序列上，与点$i$相隔恰好为$t[i]$的点的个数，顺便注意判断一下走没走完就好。但是这个地方我用了一个肥肠zz的写法，就是每次加完之后删除到这个点停止的那些点，而“那些点”的求法则是我手写了一个很诡异的二分…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445namespace Tink&#123; struct Nodes&#123; int s, e, n ; &#125;u[MAXN], v[MAXN] ; int t1, t2 ; int be[MAXN], bs[MAXN], res[MAXN], k1 = 0, k2 = 0 ; bool cmp1(Nodes a, Nodes b) &#123; return a.e &lt; b.e ; &#125; bool cmp2(Nodes a, Nodes b) &#123; return a.e &gt; b.e ; &#125; void del(int p, bool m)&#123; int l = 1, r = (m ? k2 : k1) + 1 , mid, l0, l1 ; if (!m)&#123; while (l &lt; r)&#123; mid = (l + r) &gt;&gt; 1 ; if (u[mid].e &lt; p) l = mid + 1 ; else r = mid ; &#125; l0 = l, l = 1, r = k1 + 1 ; while (l &lt; r)&#123; mid = (l + r) &gt;&gt; 1 ; if (u[mid].e &lt; p + 1) l = mid + 1 ; else r = mid ; &#125; l1 = l ; for (int i = l0 ; i &lt; l1 ; ++ i) bs[u[i].s] -- ; &#125; else&#123; while (l &lt; r)&#123; mid = (l + r) &gt;&gt; 1 ; if (v[mid].e &lt; p) l = mid + 1 ; else r = mid ; &#125; l0 = l, l = 0, r = k2 + 1 ; while (l &lt; r)&#123; mid = (l + r) &gt;&gt; 1 ; if (v[mid].e &lt; p + 1) l = mid + 1 ; else r = mid ; &#125; l1 = l ; for (int i = l0 ; i &lt; l1 ; ++ i) be[v[i].s] -- ; &#125; &#125; void Solve2()&#123; for (int i = 1 ; i &lt;= M ; ++ i) &#123; t1 = qr(), t2 = qr() ; if (t1 &lt; t2) bs[t1] ++, u[++ k1] = (Nodes)&#123;t1, t2, k1&#125; ; else /**/be[t1] ++, v[++ k2] = (Nodes)&#123;t1, t2, k2&#125; ; &#125; sort(u + 1, u + k1 + 1, cmp1) ; for (int i = 1 ; i &lt;= N ; ++ i) res[i] += bs[i - base[i]], del(i, 0) ; sort(v + 1, v + k2 + 1, cmp1) ; for (int i = N ; i &gt;= 1 ; -- i) res[i] += be[i + base[i]], del(i, 1) ; for (int p = 1 ; p &lt;= N ; ++ p) cout &lt;&lt; res[p] &lt;&lt; " " ; &#125;&#125; $\rm{Part~3}$ 20pts保证所有起点都在根（1号点）。 其实这个部分也是挺水的。就是考虑一个树形DP即可。然后判断也很好判断，如果这个点的开眼时间正好是根到它的距离（深度差），那么就会一定会满足到它的点和到它的子树内的所有的点。否则就肯定不行，也就是一个都不满足。 1234567891011121314151617namespace DP&#123; int dp[MAXN], dis[MAXN] ; int dfs(int now, int fa)&#123; int sum = 0 ; for (int k = head[now] ; k ; k = E[k].next)&#123; if (to(k) == fa) continue ; dis[to(k)] = dis[now] + 1, sum += dfs(to(k), now) ; &#125; dp[now] += sum ; return dp[now] ; &#125; inline void Solve3()&#123; memset(dis, 63, sizeof(dis)), dis[1] = 0 ; for (int i = 1 ; i &lt;= M ; ++ i) dp[e[i]] ++ ; dp[1] = dfs(1, 0) ; for (int i = 1 ; i &lt;= N ; ++ i) if (base[i] == dis[i]) printf("%d ", dp[i]) ; else cout &lt;&lt; 0 &lt;&lt; " " ; &#125;&#125; 于是现在就有了60pts的优秀分数。似乎这样的话就可以直接把剩下的部分弃了去写T3的期望DP辽233 $\rm{Part~4~and~5}$ 40pts剩下的部分没有选择分开写所以就不算谢了每个部分分是不是，因为剩下的两个部分实在是太像了，都要用到一种思想——桶. 其实80pts还有一种不是很想写的写法在这里就留个图吧： 然后我们思考桶的解法。我们把每一段路程拆成向上和向下两段。下文中设$x$为当前节点。 对于向上的路径 首先可以产生贡献的点就是子树内的$buc[dep[x]+ base[x]]$，这个我们用作差来求解（原因是我们可能会遍历许多棵子树所以会产生数值相同但不合法的贡献）。 其次我们需要知道，如果一个人的起点和终点的LCA在子树内但不是$x$，那么也不会产生贡献。解决方案是每次dfs完一个点向上回溯的时候删除掉子树内所有以该点为LCA的点。 同时也需要我们更新以该节点为起点的路径的桶。 对于向下的路径 首先对于一条路径$(u,v)$，当对点i产生贡献时可以推出来式子： $$dep_v-dis_{u,v}=dep_i-base_i$$ 那么也就是说我们可以通过把每条路径的$dep_v-dis_{u,v}$压到桶里面，然后每次计算贡献。 同时我们还是需要消除贡献，即消除那些对于儿子而言在父亲那里停止的路径，方法就是在向下迭代之前先把所有以当前点为终点的贡献加上，到儿子时通过作差就可以减去这部分。注意向上回溯时还是需要删除那些蜷缩在子树内的路径。 之后还有需要注意的，就是如果在一条路径的LCA处正好可以观察到这条路径，那么就需要-1，因为我们上升下降统计了两遍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566namespace Prepare&#123; //25 inline int max(const int &amp;a, const int &amp;b) &#123; return a &gt; b ? a : b ; &#125; inline void Add(int u, int v)&#123; E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ; &#125; void build(int now, int f)&#123; fa[now][0] = f, dep[now] = dep[f] + 1, H = max(H, dep[now]) ; for (int k = head[now] ; k ; k = E[k].next) if (to(k) == f) continue ; else build(to(k), now) ; &#125; void Setup()&#123; h = log(N) / log(2) + 1 ; for (j = 1 ; j &lt;= h ; ++ j) for (i = 1 ; i &lt;= N ; ++ i) fa[i][j] = fa[fa[i][j - 1]][j - 1] ; &#125; int lca(int u, int v)&#123; if (dep[u] &lt; dep[v]) u ^= v ^= u ^= v ; l = dep[u] - dep[v] ; for (int k = h ; k &gt;= 0 ; -- k) if (dep[fa[u][k]] &gt;= dep[v]) u = fa[u][k] ; if (u == v) return u ; for (int k = h ; k &gt;= 0 ; -- k) if (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k] ; return fa[u][0] ; &#125; inline int qr()&#123; register int k = 0 ; char c = getchar() ; while(!isdigit(c)) c = getchar() ; while(isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ; &#125; inline int wo(int a, int b, int c)&#123; return -(dep[c] &lt;&lt; 1) + (dep[a] + dep[b]) ; &#125;&#125;namespace pks&#123; using namespace Prepare ; vector &lt;int&gt; v1[MAXN], v2[MAXN], v3[MAXN] ; int buc_d[MAXN &lt;&lt; 2], buc_u[MAXN &lt;&lt; 2], ans[MAXN] ; void dfs1(int now, int fa)&#123; int co = base[now] + dep[now], ks ; if (co &lt;= H) ks = buc_d[co] ; for (int k = head[now] ; k ; k = E[k].next) if (fa ^ to(k)) dfs1(to(k), now) ; buc_d[dep[now]] += cnbt[now] ; if (co &lt;= H) ans[now] = buc_d[co] - ks ; for (int k = 0 ; k &lt; v1[now].size() ; ++ k) -- buc_d[dep[v1[now][k]]] ; &#125; void dfs2(int now, int fa)&#123; int co = dep[now] - base[now] + N, ks = buc_u[co] ; for (int k = 0 ; k &lt; v2[now].size() ; ++ k) ++ buc_u[v2[now][k] + N] ; for (int k = head[now] ; k ; k = E[k].next) if (fa ^ to(k)) dfs2(to(k), now) ; ans[now] += buc_u[co] - ks ; for (int k = 0 ; k &lt; v3[now].size() ; ++ k) -- buc_u[v3[now][k] + N] ; &#125; void Solve5()&#123; for (int i = 1 ; i &lt;= M ; ++ i) cnbt[s[i]] ++, v1[LCA[i]].push_back(s[i]) ; dfs1(1, 0) ; for (int i = 1 ; i &lt;= M ; ++ i) v2[e[i]].push_back(dep[e[i]] - _up[i]), v3[LCA[i]].push_back(dep[e[i]] - _up[i]) ; dfs2(1, 0) ; for (int i = 1 ; i &lt;= M ; ++ i) if (dep[s[i]] - dep[LCA[i]] == base[LCA[i]]) -- ans[LCA[i]] ; for (int i = 1 ; i &lt;= N ; ++ i) printf("%d ", ans[i]) ; &#125;&#125;int main()&#123; using namespace Prepare ; cin &gt;&gt; N &gt;&gt; M ; for (i = 1 ; i &lt; N ; ++ i) x = qr(), y = qr(), Add(x, y) ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]) ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%d%d", &amp;s[i], &amp;e[i]) ; build(1, 0), Setup() ; for (i = 1 ; i &lt;= M ; ++ i) LCA[i] = lca(s[i], e[i]), _up[i] = wo(s[i], e[i], LCA[i]) ; pks :: Solve5() ; return 0 ; &#125; 嗯，然后这道题就完了。不得不说虽然当时用心做了，但是过上几周再反过头来看还是觉得有些细节理解的并不到位、或者说是满分做法中的有些流程当时根本没有仔细推导。 不过不得不说这个题还是非常妙的。或许有时候题面复杂、需求复杂会让人忘记这道题到底有多巧妙…反正就是感觉这道题用“桶+即时修改”这个组合思想还是很nice的。 $4~2012F$ 疫情控制$Link$ …这个题之所以放在最后一个是因为我真的不知道部分分该怎么写啊。 嗯，首先是二分，这倒是可以想到。之后一开始想的是似乎不断把城市向上移动就好了，毕竟越靠上越优；但是样例就把我这种写法卡掉了，原因很浅显，我忽略了绕过根继续走的那些点可以继续产生贡献……于是就很GG。 …于是我选择统计了那些可以跨越根的节点。对于最终每个被覆盖的节点，我用的是直接更新vector预处理出来挂在每个点底下的叶子节点，check的时候直接判一下每个节点的mark。然而这样写的很繁琐，并且复杂度也是个迷…最后只能不了了之了 所以大概这个题我想出了50%~60%？…然而还是没有分数。 $\rm{Part~1}$ 倍增！倍增！倍增！首先喜闻乐见的是，我们向上跳的时候van♂全可以用倍增来搞，只要预处理出$2^k$级祖先就好了。 然后注意顺便判断一下可不可以拐弯，即跳到根之后是否在二分的时间内可以继续向下跳。 1234567891011121314151617181920#define fr first#define sc second#define mp(a, b) make_pair(a, b)pair&lt;int ,int&gt; Army[MAXN], Pest[MAXN] ;memset(res, 0, sizeof(res)) ;memset(Army, 0, sizeof(Army)) ;memset(Pest, 0, sizeof(Pest)) ;for (i = 1 ; i &lt;= M ; ++ i)&#123; t = base[i] ; for (j = 20 ; j &gt;= 0 ; -- j) if (!fa[t][j] || Sum[base[i]] - Sum[fa[t][j]] &gt; x) continue ; else t = fa[t][j] ; if (t &gt; 1) res[t] = 1 ; else &#123; t = base[i] ; for (j = 20 ; j &gt;= 0 ; -- j) if (fa[t][j] &gt; 1) t = fa[t][j] ; Army[++ n] = mp(x - Sum[base[i]], t) ; &#125;&#125; $\rm{Part~2}$ 转化！转化！转化！这个地方有个肥肠有意思的点，就是我们思考假设一个叶子节点没有被覆盖，那么就说明一定存在它的某一级祖先的整棵子树没有被覆盖。那么这就提示我们可以考虑直接判断根的每个儿子是否都被覆盖了（树形结构的优越性） 嗯，于是对于我们上一部分打完mark之后的那些点（暂时是只有不会拐弯的被打了mark），我们直接考虑不进行一次$O(n)$的dfs就可以完成push_up的操作。 然后我们考虑如何操作那些可以拐弯的点。思考最优的方案一定是越高越好，所以不妨就让他拐过来之后落在根的儿子上。于是我们需要统计这个的代价，并对收集来的两个信息分别排序。之后就直接双指针扫一遍根的全部儿子，看看是否全部都被覆盖了即可。 1234567891011121314151617181920void push_down(int rt)&#123; bool x = 1, y = 0 ; for (int k = head[rt] ; k ; k = E[k].next)&#123; if (to(k) == fa[rt][0]) continue ; push_down(to(k)) ; x &amp;= res[to(k)] ; y = 1 ; &#125; if (rt &gt; 1 &amp;&amp; x &amp;&amp; y) res[rt] = 1 ;&#125;.... push_down(1) ; for (int k = head[1] ; k ; k = E[k].next) if (res[to(k)]) continue ; else Pest[++ m] = mp(E[k].v, to(k)) ; j = 1 ; sort(Army + 1, Army + n + 1, cmp), sort(Pest + 1, Pest + m + 1, cmp) ; for (i = 1 ; i &lt;= n ; ++ i)&#123; if (!res[Army[i].sc]) res[Army[i].sc] = 1 ; else if (Army[i].fr &gt;= Pest[j].fr) res[Pest[j].sc] = 1 ; while (res[Pest[j].sc] &amp;&amp; j &lt;= m) ++ j ; &#125; return j &gt; m ;&#125; 嗯，贴个总程序吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct Edge&#123; int to, next, v ;&#125;E[MAXN &lt;&lt; 1] ; int cnt, head[MAXN], n, m ; bool res[MAXN] ;int N, M, P, Sum[MAXN], ans, base[MAXN], fa[MAXN][25], i, j, l, r, mid ;inline void Add(int u, int v, int w)&#123; P += w ; E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;&#125;#define fr first#define sc second#define mp(a, b) make_pair(a, b)pair&lt;int ,int&gt; Army[MAXN], Pest[MAXN] ;inline bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)&#123; return a.fr &lt; b.fr ; &#125;void Init()&#123; for (i = 1 ; i &lt;= 20 ; ++ i) for (j = 1 ; j &lt;= N ; ++ j) fa[j][i] = fa[fa[j][i - 1]][i - 1] ;&#125;void dfs(int now, int f)&#123; fa[now][0] = f ; for (int k = head[now] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; Sum[to(k)] = Sum[now] + E[k].v ; dfs(to(k), now) ; &#125;&#125;void push_down(int rt)&#123; bool x = 1, y = 0 ; for (int k = head[rt] ; k ; k = E[k].next)&#123; if (to(k) == fa[rt][0]) continue ; push_down(to(k)) ; x &amp;= res[to(k)] ; y = 1 ; &#125; if (rt &gt; 1 &amp;&amp; x &amp;&amp; y) res[rt] = 1 ;&#125;bool check(int x)&#123; int t ; n = m = 0 ; memset(res, 0, sizeof(res)) ; memset(Army, 0, sizeof(Army)) ; memset(Pest, 0, sizeof(Pest)) ; for (i = 1 ; i &lt;= M ; ++ i)&#123; t = base[i] ; for (j = 20 ; j &gt;= 0 ; -- j) if (!fa[t][j] || Sum[base[i]] - Sum[fa[t][j]] &gt; x) continue ; else t = fa[t][j] ; if (t &gt; 1) res[t] = 1 ; else &#123; t = base[i] ; for (j = 20 ; j &gt;= 0 ; -- j) if (fa[t][j] &gt; 1) t = fa[t][j] ; Army[++ n] = mp(x - Sum[base[i]], t) ; &#125; &#125; push_down(1) ; for (int k = head[1] ; k ; k = E[k].next) if (res[to(k)]) continue ; else Pest[++ m] = mp(E[k].v, to(k)) ; j = 1 ; sort(Army + 1, Army + n + 1, cmp), sort(Pest + 1, Pest + m + 1, cmp) ; for (i = 1 ; i &lt;= n ; ++ i)&#123; if (!res[Army[i].sc]) res[Army[i].sc] = 1 ; else if (Army[i].fr &gt;= Pest[j].fr) res[Pest[j].sc] = 1 ; while (res[Pest[j].sc] &amp;&amp; j &lt;= m) ++ j ; &#125; return j &gt; m ;&#125;int main()&#123; cin &gt;&gt; N ; int a, b, c ; for (i = 1 ; i &lt; N ; ++ i) scanf("%d%d%d", &amp;a, &amp;b, &amp;c), Add(a, b, c) ; cin &gt;&gt; M ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%d", &amp;base[i]) ; dfs(1, 0) ; Init() ; l = 0, r = P ; while (l &lt;= r)&#123; mid = (l + r) &gt;&gt; 1 ; if (check(mid)) r = mid - 1, ans = mid ; else l = mid + 1 ; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; $\rm{Afterword}$其实总感觉自己做这些题还是有些力不从心233 不得不说类似于“二分答案”这种东西是很有OI风味的，毕竟是一种特殊的思想…不知道自己什么时候能把类似的所有思想真正地打包学会啊qaq]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>树模型</tag>
        <tag>奇怪的技巧</tag>
        <tag>贪心</tag>
        <tag>搜索-剪枝</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【泛做】Old-NOIP 泛做一]]></title>
    <url>%2F2019%2F07%2F11%2Fold-noip%2F</url>
    <content type="text"><![CDATA[首先简介一下这篇文章的来历…… 此时的我正在瞎翻之前做过的、看起来还可以的NOIP水题，觉得哪个地方值得注意就整了下来。然而实际上我是只想整理“泛做二”里的题目。不过一想似乎自己基础不扎实，于是才有了这篇水文。 $1~2013B$ 火柴排队Link 这真是个水题。但是之前做的时候没意识到一些问题，前几天翻来看看又把这个题秒了一遍。 观察整个式子，我们拆开之后就发现是在最小化$-\sum a_ib_i$，也就是最大化$\sum a_ib_i$。然后根据选修4-5里面的排序不等式，逆序和&lt;乱序和&lt;顺序和，直接找逆序对就好。 偷偷学数学真有用啊/kk $2 ~2014C$ 飞扬的小鸟Link ……一道gou题。 当时全天下都知道状态$f_{i,j}$就我不会转移…背包其实挺显然的，上升的时候做完全背包，注意由于即使🐦在天花板里面($h= m$)时也可以跳，所以多转移几次， 且注意既可以从i-1转移过来，也可以从现在的i转移过来；下降的时候做反向值域的01背包。 1234567891011121314151617181920212223242526272829303132333435int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K ; ans = Inf ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d%d", &amp;up[i], &amp;dw[i]) ; for (i = 1 ; i &lt;= N ; ++ i) Wd[i][0] = -1, Wd[i][1] = M + 1 ; memset(dp, 63, sizeof(dp)) ; for (i = 1 ; i &lt;= K ; ++ i) scanf("%d", &amp;k), S[k] = 1, scanf("%d%d", &amp;Wd[k][0], &amp;Wd[k][1]) ; for (i = 0 ; i &lt;= M ; ++ i) dp[0][i] = 0 ; /*for (i = 2 ; i &lt;= N ; ++ i) for (j = Wd[i][0] + 1 ; j &lt; Wd[i][1] ; ++ j)&#123; dp[i][j] = dp[i - 1][j + dw[i]] ; for (k = 0 ; k &lt;= (j - Wd[i - 1][0] - 1) / up[i] ; ++ k) dp[i][j] = min(dp[i - 1][j - k * up[i]] + k, dp[i][j]) ; &#125;*/ for (i = 1 ; i &lt;= N ; ++ i)&#123; for (j = up[i] + 1 ; j &lt;= M + up[i] ; ++ j) dp[i][j] = min(dp[i - 1][j - up[i]], dp[i][j - up[i]]) + 1 ; for (j = M + 1 ; j &lt;= M + up[i] ; ++ j) dp[i][M] = min(dp[i][M], dp[i][j]) ; for (j = 0 ; j &lt;= M - dw[i] ; j ++) dp[i][j] = min(dp[i][j], dp[i - 1][j + dw[i]]) ; for (j = 0 ; j &lt;= Wd[i][0] ; ++ j) dp[i][j] = Inf ; for (j = Wd[i][1] ; j &lt;= M ; j ++) dp[i][j] = Inf ; &#125; for (i = 1 ; i &lt;= M ; ++ i) ans = min(ans, dp[N][i]) ; if (ans &lt; 19260817) return printf("%d\n%d\n", 1, ans),0 ; for (i = 1 ; i &lt;= N ; ++ i) S[i] = S[i - 1] + S[i] ; l = 1, r = N, p ; while (l &lt;= r)&#123; mid = (l + r) &gt;&gt; 1, ans = Inf ; for (i = 1 ; i &lt;= M ; ++ i) ans = min(ans, dp[mid][i]) ; if (ans &lt; 19260817) l = mid + 1, p = mid ; else r = mid - 1 ; &#125; cout &lt;&lt; 0 &lt;&lt; endl &lt;&lt; S[p] &lt;&lt; endl ; return 0 ;&#125; $3~2001C$ 统计单词数$Link$ 一道很水的DP，难点（如果可以称之为难的话）在于判断。然后此处用的是哈希，判断的时候就瞎判就好了（雾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using namespace std ;pair &lt;int, int&gt; p ; char D[MAXLEN][10] ;const UN LL base = 131 ;LL Hash[MAXLEN][MAXLEN], H[10] ;stack&lt; pair &lt;int, int&gt; &gt; s, s2 ;const UN LL Mod = 192183781721LL ;int dp[MAXLEN][50], Len, Length[10], o ;int P, M, K, i, j, k, di, dj ; char S[MAXLEN] ; inline LL Hashh(int Mark)&#123; UN LL res = 0 ; if (!Mark) &#123; for (k = j ; k &lt;= i ; ++ k) res = (res * base + S[k]) % Mod ; return res ; &#125; for (k = 0 ; k &lt;= Length[Mark] ; ++k) res = (res * base + D[Mark][k]) % Mod ; return res ;&#125;inline int Sum(int x, int y)&#123; LL res[7] ; memset(res, 0, sizeof(res)) ; for (di = 1; di &lt;= M ; ++ di) for (dj = x ; dj &lt;= y - Length[di] ; ++ dj) if (Hash[dj][dj + Length[di]] == H[di]) ++ res[di] ; while (!s.empty()) &#123; p = s.top() ; res[p.first] &gt; res[p.second] ? res[p.second] : res[p.first] = 0 ; s.pop(), s2.push(p) ; &#125; while (!s2.empty()) s.push(s2.top()), s2.pop() ; return res[1] + res[2] + res[3] + res[4] + res[5] + res[6] ;&#125;signed main()&#123; cin &gt;&gt; P &gt;&gt; K ; for (i = 0 ; i &lt; P ; ++ i) scanf("%20s", S + i * 20) ; cin &gt;&gt; M ; Len = strlen(S) ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%s", D[i]), Length[i] = strlen(D[i]) - 1, H[i] = Hashh(i) ; for (i = 1 ; i &lt;= M ; ++ i) for (j = 1 ; j &lt; i ; ++ j)&#123; bool flag = 1 ; for (di = 0 ; di &lt;= min(Length[j], Length[i]) ; ++ di) if (D[j][di] != D[i][di])&#123; flag = 0 ; break ; &#125; if (flag) s.push(&#123;i, j&#125;), ++ o ; &#125; for (i = 0 ; i &lt; Len ; ++ i) for (j = 0 ; j &lt;= i ; ++ j) Hash[j][i] = Hashh(0) ; /*for (i = 0 ; i &lt; Len ; ++ i) for (j = 0 ; j &lt; i ; ++ j) printf("%d%c", Sum(j, i)," \n"[j == i - 1]) ;*/ for (k = 1 ; k &lt;= K ; ++ k) for (i = 0 ; i &lt; Len ; ++ i) for (j = k - 1 ; j &lt;= i ; ++ j) dp[i][k] = max(dp[i][k], dp[max(0, j - 1)][k - 1] + Sum(j, i)) ; cout &lt;&lt; dp[Len - 1][K] &lt;&lt; endl ; return 0 ;&#125; $4~2005B$ 过河$Link$ 也是一道很水的DP。整理这个题的原因是因为好久之前的当时做这题时用了一种诡异的做法，即通过对$\sqrt{1e9}$取模进行压缩，但是这显然不对因为1：我的写法没有处理mod之后位置相同的情况；再者转移过程也十分地不服责任： 1234567891011121314151617181920int mod=32501;int f[200000];bool pos[200000];int main()&#123; int n,l,r,m,cnt=0; cin&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; int x; cin&gt;&gt;x; pos[x%mod]=1; if(l==r&amp;&amp;x%l==0)cnt++; &#125; if(l==r)&#123; cout&lt;&lt;cnt; return 0;&#125; for(int i=1;i&lt;=mod;i++) f[i]=MAXN; f[0]=0; for(int i=1;i&lt;=mod;i++) for(int j=l;j&lt;=r;j++)&#123; int k=i%mod; if(i&gt;=j)f[i]=min(f[i],f[i-j]+pos[k]); &#125; cout&lt;&lt;f[mod];&#125; 但问题是，它过了，这就很迷。仔细想想，似乎可能是因为石头数量太小了，只有100，所以随机丢到空间里去期望意义上每$1e7$会有一块石头，且mod之后位于同一个位置的概率的相反数是$32501$，所以很难有这种数据出现……换句话说，数据水死了。 然而真正的做法应该是“2520缩”，意思就是因为题目中的 s~t 的取值范围是 1~10，所以取$lcm(1,2,..,10)=2520$是可行的。 $5~2009B$ Hankson的趣味题$Link$ 整这个题只是因为情怀…… 遥不可及的过去啊……Solution $6~2004D$ 虫食算$Link$ 整这个题更是因为情怀了…… 当时是何时？不记得是末冬还是暑假，只记得我十分开心地去高中部培训，吃早饭之前跟rqy瞎聊，聊什么“是不是只要我发明出可以处理负权边的Dijkstra就可以上清华了”，不自觉地聊到了这道题。嗯…场景什么的都历历在目，尤其是餐厅东边洒落的白色的阳光，一直在我的记忆中闪亮… 可惜我不是当年那个我了，rqy也不是当年那个rqy了，大家都在迈着自己的步子踏实地前进，终于还是会分道扬镳吧…… 诶诶我在干什么，qaq，学习，学习…… 暴力就是枚举全排列，但显然只有30pts。 于是考虑一个可行性剪枝，其实就是每次dfs刚开始先check一遍合不合法。但是整理这个题的目的也不在于此，而在于其中的pos数组，其实就是用来记录从低位到高位每个未知数的出现顺序的。那么实际上这也是一个优秀的剪枝，因为在dfs里面我们可以根据此对靠近低位的未知数先赋值、先判断（第一个剪枝）。 所以大概就是可行性剪枝和最优性剪枝相辅相成的结果，比较巧妙。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647char _Char ; int pos[MAX] ;int Ans[MAX] ; bool mark[MAX] ;int N, A[MAX], B[MAX], C[MAX], tot ;inline void Print()&#123; for(int i = 0; i &lt; N ; ++ i) cout &lt;&lt; Ans[i] &lt;&lt; " " ; exit(0) ;&#125;inline bool Judge()&#123; int X = 0 ; for(int i = N - 1; i &gt;= 0 ; -- i)&#123; int NA = Ans[A[i]], NB = Ans[B[i]], NC = Ans[C[i]] ; if((NA + NB + X) % N != NC) return 0 ; X = (NA + NB + X) / N ; &#125; return 1 ;&#125;inline bool Speed()&#123; if(Ans[A[0]] + Ans[B[0]] &gt;= N) return 0 ; for(int i = N - 1; i &gt;= 0 ; i --)&#123; int NA = Ans[A[i]], NB = Ans[B[i]], NC = Ans[C[i]] ; if (NA == -1 || NB == -1 || NC == -1) continue ; if ((NA + NB) % N != NC &amp;&amp; (NA + NB + 1) % N != NC) return 0 ; &#125; return 1 ;&#125;inline void dfs(int sum)&#123; if (!Speed()) return ; if (sum == N + 1)&#123;if (Judge()) Print() ; return ;&#125; for(int i = N - 1; i &gt;= 0 ; -- i) if(!mark[i])&#123; Ans[pos[sum]] = i, mark[i] = 1 ; dfs(sum + 1) ; Ans[pos[sum]] = -1, mark[i] = 0 ; &#125; return ;&#125;inline void work_pos(int x)&#123;if(!mark[x]) mark[x] = 1, pos[++ tot] = x ;&#125;int main()&#123; cin &gt;&gt; N ; fill(Ans, Ans + MAX + 2, -1) ; for (int i = 0; i &lt; N ; ++ i)&#123; cin &gt;&gt; _Char ; A[i] = _Char - 'A' ;&#125; for (int i = 0; i &lt; N ; ++ i)&#123; cin &gt;&gt; _Char ; B[i] = _Char - 'A' ;&#125; for (int i = 0; i &lt; N ; ++ i)&#123; cin &gt;&gt; _Char ; C[i] = _Char - 'A' ;&#125; for (int i = N - 1; i &gt;= 0 ; -- i) work_pos(A[i]), work_pos(B[i]), work_pos(C[i]) ; fill(mark, mark + MAX + 2, 0) ; dfs(1) ; return 0 ;&#125; $\rm{Afterword}$ 遥望扬州满地雪，不知已是惊蛰节。]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>奇怪的技巧</tag>
        <tag>NOIP系列</tag>
        <tag>数学/不等式</tag>
        <tag>动态规划-背包模型</tag>
        <tag>搜索-剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【赛题整理】NOIP2017泛做]]></title>
    <url>%2F2019%2F07%2F11%2FNOIP2017%2F</url>
    <content type="text"><![CDATA[$NOIP2017$的泛做。 $\Omega$嗯，这个代表“前言”的字母很帅。 先来总结一下每个题的难度，A题提高（证明）/普及-（找规律）, B题提高， C题提高+，总结来看，Day1比较送；D题普及+，E题省选-，F题省选-，Day2不如Day1水。 PS: 提高以NOIP提高组平均难度为准，省选以弱省省选为准（比如以SNOI2019平均难度作为基准线） $A$由于当时场上切了这道题，导致我对“找规律“这种投机取巧的做题方式情有独钟，从而在某些计数题时不好好想DP反而猜sb规律……感觉很GG…… 其实这个题就是给一个方程：$$ax+by \not= t \quad x,y, \in\mathbb{N},\quad t\in \mathbb{N+} \quad (a,b)= 1$$求$\max{t}$ 呃，首先，我想了一种很zz的证明方式： 当$t = a \cdot b - a - b$时，$t$满足这个方程 我们通过移项可以得到： $$ax+by-ab+a+b=0 \\\a(x-b +1) + b(y+1) = 0 \\\$$ 观察这个式子，要么有$y+1=0$且$x-b+1=0$，要么有$$a(b-x-1) = b(y+1)\cdots(1)$$ 第一种情况显然不成立，那么我们考虑第二种情况。此时因为$(a,b)=1$，所以会有$b~|~(b-x-1) \to b ~|~(x+1)$, 同理$a~|~(y+1)$ .但同时我们将$(1)$式搞一搞就可以得到$$\frac{a}{b} = \frac{b-(x+1)}{y+1}$$但因为$a,b \in \mathbb{N+}$，所以会有$b&gt;(x+1)$ ; 因为$b~|~(x+1)$，有$b\leq x+1$或$x+1=0$（舍） ，矛盾，故此时$t$满足这个方程。 当$t&gt;a\cdot b-a-b$时，$t$总不满足。 不妨设$t_0=a\cdot b-a-b, ~t=t_0+k, ~k\in\mathbb{N+}$ 此时……然后就不会了2333——以下是借鉴的星星之火OIer巨佬的思路： 对于任意正整数$k\geq ab−a−b+1$，即$k+a+b\geq ab+1$ 设$k+a+b = \mu a+m~~(k\geq b,1\leq m &lt;a)$. 同时：$$\because (a,b)=1\\\\therefore \exists x_0,y_0 \in \mathbb{Z} \quad s.t. \quad ax_0+by_0=1 \\\\therefore \exists x_1,y_1∈\mathbb{Z}，−(b−1)\leq x_1\leq 0 \quad s.t.\quad ax_1+by_1=m\\\$$这里的意思其实是设$−(b−1)\leq x_1\leq 0$，一定存在整数$y_1$使得$ax_1+by+_1=m$成立。原因就是在整数$x_1$的取值中一共有$b$个数，$y_1=(m−ax_1)/b$，根据鸽笼原理之类的zz定理，我们总是可以找到$x_1$使得$m−ax_1$能被$b$整除。 显然，$y_1\geq 1(ax_1\leq 0,m &gt;0, b&gt;0, 因此y_1\geq 1,)$。于是，取$x=\mu+x_1−1,y=y_1−1$。注意到$x_1,y_1$的取值范围，得$x,y\geq 0$， 即有$ax+by=k$ ？？？不知不觉写了小半个下午？？看起来A题确实是结论题了（sigh 12345long long A, B ;int main()&#123; cin &gt;&gt; A &gt;&gt; B ; cout &lt;&lt; A * B - A - B ;&#125; $B$ ……像这种题不就是看脸题吗…手一抖就调不出来了$\rm{qaq}$ 题解以前写过，于是直接把主要部分引用过来（以前的码风还真是抽搐 读入： 我们先用$while$按字符读入每个程序的第一行，抠出需要检验的复杂度，$O(1)$用$0$来存$[n^0=1 $ $~~~$ $ (n!=0)]$. 注意，有可能有两位数，需要多扣一位…… 12345678910111213&gt; while(o!=')')&#123;&gt; if(o=='1'&amp;&amp;!chk) &gt; need_check=0;&gt; if(o=='n')&#123;&gt; cin&gt;&gt;o&gt;&gt;o;&gt; need_check=o-48;&gt; chk=1;&gt; &#125;&gt; o=getchar();&gt; if(isdigit(o)&amp;&amp;chk)need_check*=10,need_check+=(o-48); &gt; &#125;&gt; getchar();&gt; 至于最后为什么要再$gatchar()$一次……自己试试就知道了。 那么接下来就要按行读入循环了，比较简单。 初始化： 为了使码风简洁，所以写到函数里了。这个地方我用到了三个栈，一个用来记录每个循环的答案（因为有可能有多个相互独立的循环），一个用来记录每次$F$时读入的循环上下界。以上两个都是$int$栈,还有一个$char$栈，存储每次定义的循环变量，而这个字符栈搭配一个$bool$性的数组，用于记录是否可用。 1234567891011&gt;#define MAX 1000000&gt;int i,x,y,t,tt,num,cntf,cnte,res,ans[MAX],T,l,now,need_checks,stk[MAX];&gt;bool check[150],flag,spj,chk;&gt;char s[3010],o,stkk[MAX]; &gt;inline void init()&#123;&gt; memset(check,0,sizeof(check));&gt;memset(stkk,0,sizeof(stkk));&gt;memset(stk,0,sizeof(stk));&gt;now=t=tt=cntf=cnte=res=flag=spj=chk=0;&gt;&#125;&gt; $ps:$虽然不知道用一个二进制位的$0$来初始化字符数组会怎样……不过好像海星。 $cnte$和$cntf$用来记录$F$和$E$的数量，$num$、$t$、$tt$都是栈的指针，$spj$用来判断一个独立循环是否结束（如果结束就把当前的得到压入栈）,$now$用来搭配$spj$记录当前独立循环体的时间复杂度， $chk$用于读入每个程序的第一行（即含有需要判断的时间复杂度的那一行），$flag$用于判断输出。 主要操作 对于读入的东西，分类讨论，然后$continue$……没什么可说的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; while(l--)&#123;&gt; gets(s);&gt; for(i=0;i&lt;strlen(s);)&#123;&gt; while(s[i]==' ')i++;&gt; if(s[i]=='F')&#123;&gt; if(cntf&gt;cnte&amp;&amp;cnte)&#123;&gt; ans[++num]=now;&gt; now=0;&gt; &#125;&gt; cntf++,i++;&gt; continue;&gt; &#125;&gt; if(s[i]=='E')&#123;&gt; y=stk[t],t--;&gt; x=stk[t],t--;&gt; cnte++;&gt; if(cnte==cntf)spj=1;&gt; if(x!=MAX)&#123;&gt; if(y==MAX)now++;&gt; if(y&lt;x)now=0;&gt; &#125;&gt; else&#123;&gt; if(y!=MAX)now=0;&gt; &#125;&gt; check[stkk[tt]-'a']=0;&gt; tt--,i++;&gt; if(spj)&#123;&gt; ans[++num]=now;&gt; now=0;&gt; spj=0;&gt; &#125;&gt; continue;&gt; &#125;&gt; if(!isdigit(s[i])&amp;&amp;s[i]!='n')&#123;&gt; if(check[s[i]-'a']&amp;&amp;!flag)&#123; &gt; cout&lt;&lt;"ERR"&lt;&lt;endl;&gt; flag=1;&gt; &#125;&gt; stkk[++tt]=s[i];&gt; check[s[i]-'a']=1;&gt; &#125;&gt; else &#123; &gt; if(s[i]=='n')&#123;&gt; my_push(s[i],s[i+1]);&gt; i+=2;&gt; &#125; &gt; my_push(s[i],s[i+1]);&gt; &#125;&gt; i++;&gt; &#125;&gt; &#125;&gt; 唯一需要注意的是入栈操作，因为要把字符压入整型，所以我又写了个函数来入栈。入栈的时候当然需要注意是不是两位数…… 哦，还有，如果这次轮到$n$入栈了，那么就随便入栈一个大于一百的数即可。 1234567891011&gt;inline void my_push(char a,char b)&#123;&gt; if(isdigit(a))&#123;&gt; if(isdigit(b))&#123;&gt; stk[++t]=(a-48)*10+b-48;&gt; i++;&gt; &#125;&gt; else stk[++t]=a-48; &gt; &#125;&gt; if(a=='n')stk[++t]=MAX;&gt;&#125;&gt; 最后判断一下输入输出即可 1234567891011&gt; if(!flag&amp;&amp;cntf!=cnte)&#123;&gt; cout&lt;&lt;"ERR"&lt;&lt;endl;&gt; flag=1;&gt; &#125;&gt; while(num)&#123;&gt; res=max(res,ans[num]); &gt; num--;&gt; &#125;&gt; if(!flag) if(res==need_check) cout&lt;&lt;"Yes"&lt;&lt;endl;&gt; else cout&lt;&lt;"No"&lt;&lt;endl;&gt; 嗯~o(￣▽￣)o这就是满分做法了。 唉，时光一去不复返啊。 $C$……其实不算是个新题，只是似乎当时这道题场上很卡常？感觉就是好多东西的杂糅，先SPFA判个全$0$环，再倒着记搜一遍……感觉已经不算什么新题了，T3出成这样感觉很失望qaq…… 但怎么说呢，也是个练习码力的机会吧，转移方程挺好想的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657deque &lt;int&gt; q ; bitset &lt;MAXN&gt; vis ;struct Edge&#123; int fr, to, next, v ;&#125;E[MAXM] ; int head[MAXN][2], cnt ;int T, N, L, M, K, P, A, B, C, ss[MAXN] ;int Es[MAXM][2], dfn[MAXN], low[MAXN], tot ; bool flag ; LL Ans, dp[MAXN][MAXK], dist[MAXN] ;inline void _Add(int u, int v, int w)&#123; E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u][1], head[u][1] = cnt ; E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v][0], head[v][0] = cnt ; &#125;inline void Init()&#123; register int k ; vis.reset() ; memset(dp, -63, sizeof(dp)), cnt = 0 ; for (k = 0 ; k &lt;= L + 3 ; ++ k) dist[k] = Inf, ss[k] = head[k][1] = head[k][0] = 0 ; &#125;inline void SPFA()&#123; register int now, k ; q.push_front(1), vis[1] = 1, dist[1] = 0, ++ ss[1] ; while (!q.empty())&#123; now = q.front(), vis[now] = 0, q.pop_front() ; for (k = head[now][1] ; k ; k = E[k].next)&#123; if (dist[to(k)] &gt;= dist[now] + E[k].v)&#123; ++ ss[to(k)] ; dist[to(k)] = dist[now] + E[k].v ; if (ss[to(k)] &gt;= N)&#123; flag = 1 ; return ; &#125; if (!vis[to(k)])&#123; if (q.empty() || dist[to(k)] &lt; dist[q.front()]) q.push_front(to(k)) ; else q.push_back(to(k)) ; vis[to(k)] = 1 ; &#125; &#125; &#125; &#125; &#125;LL dp_work(int now, int op)&#123; if (dp[now][op] &gt;= 0) return dp[now][op] ; dp[now][op] = 0 ; for (register int k = head[now][0] ; k ; k = E[k].next)&#123; LL t = op - dist[to(k)] + dist[now] - E[k].v ; if (t &gt; K || t &lt; 0) continue ; dp[now][op] = (dp[now][op] + dp_work(to(k), t)) % P ; &#125; return dp[now][op] ;&#125;int main()&#123; register int i ; cin &gt;&gt; T ; while(T --)&#123; L = 200000, Init() ; Ans = 0 ; N = qr(), M = qr(), K = qr(), P = qr() ; for (i = 1 ; i &lt;= M ; ++ i) A = qr(), B = qr(), C = qr(), _Add(A, B, C) ; SPFA() ; dp[1][0] = 1 ; L = N ; if (flag) &#123; flag = 0, printf("-1\n") ; continue ; &#125; for (i = 0 ; i &lt;= K ; ++ i) Ans = (Ans + dp_work(N, i)) % P ; printf("%lld\n", Ans) ; &#125; return 0 ; &#125; 想了一下，似乎出题人是故意把时间押给$B$的，所以$C$比较送。 $D$也是挺送的一道题，注意开long long就好…用并查集维护一下最上面和最下面的两个洞在不在一条“连通链”上即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct hole&#123; long long x,y,z;&#125;c[10001];inline long long find(long long a)&#123; if(f[a]!=a)a=find(f[a]); return a;&#125;inline void unionn(long long xz,long long yz)&#123; if(c[find(yz)].z&gt;c[find(xz)].z) f[find(yz)]=f[find(xz)]; else f[find(xz)]=f[find(yz)];&#125;inline bool check(hole a,hole b)z&#123; long long d; d=(a.z-b.z)*(a.z-b.z)+(a.y-b.y)*(a.y-b.y)+(a.x-b.x)*(a.x-b.x); if(d&lt;=4*r*r)return 1; return 0;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; memset(f,0,sizeof(0)); cin&gt;&gt;n&gt;&gt;h&gt;&gt;r; for(long long i=1;i&lt;=n;i++) &#123; scanf("%lld%lld%lld",&amp;c[i].x,&amp;c[i].y,&amp;c[i].z); f[i]=i; &#125; for(long long i=1;i&lt;=n;i++) for(long long j=i+1;j&lt;=n;j++) if(f[i]!=f[j]&amp;&amp;check(c[i],c[j]))unionn(i,j); bool cc=0; for(long long i=1;i&lt;=n;i++) if(c[i].z+r&gt;=h&amp;&amp;c[find(i)].z-r&lt;=0) &#123; cc=1; cout&lt;&lt;"Yes"&lt;&lt;endl; break; &#125; if(!cc)cout&lt;&lt;"No"&lt;&lt;endl; cc=0; &#125; return 0;&#125; wtm以前的码风是有多犀利啊，字符间不加空格大括号也不换行 $E$emmm第一眼状压，第二眼需要把树高加到状态里，那么就是$f_{s,h}$表示现在选的点集为$S$，树高为$h$的最小花费。转移的时候大概就是朴素的$$f_{s,i} = \min\limits _{t \in s}{f_{t,i-1}+cost_{t\to s}}$$ 然后这个cost显然是可以在可接受的复杂度以内$prework$出来的。于是最终的复杂度就是$\Theta(3^n\cdot n^2)$ 求“子集的子集”的复杂度严格来讲是$3^n$而不是$4^n$，原因在于我们事实上一共有$\sum \binom{n}{k}2^k$个子集，逆向二项式展开或者叫二项式收缩一下就可以得到$$\sum \binom{n}{k}2^k = \sum \binom{n}{k}1^{n-k}\cdot 2^k = (1+2)^n = 3^n$$代码实现：12&gt; for(t = S ; t ; t = (t - 1) &amp; S)&gt; 呃，至于这句话的原理暂不可知，但是挺好用是真的qwq 但是复杂度上限此时是$531441\times 12^2= 76527504$，不可过（但事实上根本不可能跑满所以也过了），以下是Flash_hu巨佬的$\Theta(3^nn)$的做法： 我们发现似乎同一树高的所有节点，完全可以同时转移。所以我们不妨设$f_{s,t}$表示已选点集为$s$，下一层要加入的点集为$t$时， 新加入的所有点与原有点之间最小的边权之和——用于预处理。 具体的转移我们可以考虑如下： $$f_{s,t} = \min {f_{s,t-lowbit(j)}+cost_{k, s}}, k=\log _2lowbit(j)$$其中$cost_{k,s}$表示点$k$到连通块$s$的最短距离。可以用$lowbit$的原因是答案无序，所以这一部分的复杂度是$O(3^nn).$ 那么接下来考虑原先的$dp$，设$g_{s,h}$表示已选点集为$s$，当前树高为$h$的最小代价，即目标函数。那么转移就是：$$g_{s,h} = \sum_{t\in s}g_{s-t, h-1}+h\cdot f_{s-t,t}$$同样是显然的。所以最后的复杂度就是$O(3^nn)$ 。答案的话最后直接对所有$g_{_{2^n-1,h}},h\in[1,n]$取个最小值就好了。 123456789101112131415161718192021222324252627282930int cnt, T, D[MAX][MAX], a, b, c ;int F[MAXN][MAX], Next[MAX], Ans, Sup, Now ;int N, M, i, j, k, Log[MAX], Max, A[MAXN][MAXN] ; int main()&#123; memset(A, 63, sizeof(A)) ; memset(F, 63, sizeof(F)), Ans = Inf ; cin &gt;&gt; N &gt;&gt; M ; Max = (1 &lt;&lt; N) - 1 ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%d%d%d", &amp;a, &amp;b, &amp;c), A[a][b] = A[b][a] = min(c, A[a][b]) ; for (i = 0 ; i &lt;= N ; ++ i) Log[1 &lt;&lt; i] = i ; for (i = 0 ; i &lt;= N ; ++ i) F[0][1 &lt;&lt; i] = 0 ; for (i = 1 ; i &lt;= Max ; ++ i)&#123; cnt = 0 ; for (j = Sup = Max ^ i; j ; j = (j - 1) &amp; Sup) Next[j] = cnt, cnt = j ; for (j = cnt ; j ; j = Next[j])&#123; Now = Log[j &amp; (-j)] + 1, T = Inf ; for (k = 1; k &lt;= N ; ++ k) if (1 &lt;&lt; (k - 1) &amp; i) T = min(T, A[Now][k]) ; D[i][j] = D[i][j ^ (j &amp; -j)] + T ; &#125; &#125; for (i = 1 ; i &lt; N ; ++ i) for (j = 1 ; j &lt;= Max; ++ j) for (k = j ; k ; k = (k - 1) &amp; j) F[i][j] = min(F[i][j], F[i - 1][j ^ k] + i * D[j ^ k][k]) ; for (i = 0 ; i &lt;= N ; ++ i) Ans = min(Ans, F[i][Max]) ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $F$一道我不是很会的线段树题…… 怎么说呢，感觉这个做法未曾见过吧。大概就是维护$n+1$棵动态开点的线段树，其中对每一行的前$m-1$个元素维护一个线段树，然后对最后一列单独维护一棵线段树。线段树上每个点维护自己子树内到底有多少个点被删了，用来协助寻找现在的位置。在此基础上再维护$n+1$个vector，用来记录从每棵线段树中弹出的点即可。 呃，现在的我似乎并没有很好地理解这个题的做法，有些马虎…所以希望日后再看的时候能看的更清明一点吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;int N, M, Q ;using namespace std ;inline int qr()&#123; register int k = 0 ; char c = getchar() ; while(!isdigit(c)) c = getchar() ; while(isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;namespace vio&#123; #define MAXV 2010 int x, y, t, i, j ; int base[MAXV][MAXV] ; void Solve1()&#123; t = 0 ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j) base[i][j] = ++ t ; while(Q --)&#123; x = qr(), y = qr(), t = base[x][y] ; for (i = y + 1 ; i &lt;= M ; ++ i) base[x][i - 1] = base[x][i] ; for (i = x + 1 ; i &lt;= N ; ++ i) base[i - 1][M] = base[i][M] ; printf("%d\n", (base[N][M] = t)) ; &#125; &#125;&#125;namespace segment_T&#123; #define MAXN 400010 #define ll long long #define pb push_back #define rr register int vector&lt;ll&gt; del[MAXN &lt;&lt; 4] ; int Max ; int rt[MAXN &lt;&lt; 4], L[MAXN &lt;&lt; 4], R[MAXN &lt;&lt; 4], dfn, val[MAXN &lt;&lt; 4] ; inline void update(int &amp;root, int l, int r, int pos)&#123; if (!root) root = ++ dfn ; val[root] ++ ; if (l == r) return ; rr mid = (l + r) &gt;&gt; 1 ; if (pos &lt;= mid) update(L[root], l, mid, pos) ; else update(R[root], mid + 1, r, pos) ; &#125; inline int query(int root, int l, int r, int pos)&#123; if (l == r) return l ; rr mid = (l + r) &gt;&gt; 1, dif = mid - l + 1 - val[L[root]] ; if (dif &gt;= pos) return query(L[root], l, mid, pos) ; else return query(R[root], mid + 1, r, pos - dif) ; &#125; inline ll delcase2(int x, ll y)&#123; rr now_p = query(rt[N + 1], 1, Max, x) ; update(rt[N + 1], 1, Max, now_p) ; ll ret = now_p &lt;= N ? 1LL * now_p * M : del[N + 1][now_p - N - 1] ; del[N + 1].pb(y ? y : ret) ; return ret ; &#125; inline ll delcase1(int x, int y)&#123; rr now_p = query(rt[x], 1, Max, y) ; update(rt[x], 1, Max, now_p) ; ll ret = now_p &lt; M ? 1LL * (x - 1) * M + now_p : del[x][now_p - M] ; del[x].pb(delcase2(x, ret)) ; return ret ; &#125; inline void Solve2()&#123; rr x, y ; Max = max(N, M) + Q ; while (Q --) x = qr(), y = qr(), printf("%lld\n", y != M ? delcase1(x, y) : delcase2(x, 0)) ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q ; if (N &lt;= 5000 &amp;&amp; M &lt;= 5000) vio :: Solve1() ; else segment_T :: Solve2() ;/*pkspkspks*/ return 0 ; &#125; $\varPhi$现在来看，乐观估计，自己应该可以得到$100+100+100+100+55+30=485pts$，当且仅当自己的码力已经很强。如果是悲观估计，那大概是$100+70+40+80+55+30=375pts$。继续努力吧，现在还差得很远啊……]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划-普通DP</tag>
        <tag>数学/扩展欧几里德</tag>
        <tag>NOIP系列</tag>
        <tag>数据结构/线段树</tag>
        <tag>暴力,brute-force</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】舞蹈链(DLX)入门]]></title>
    <url>%2F2019%2F07%2F11%2Fdlx%2F</url>
    <content type="text"><![CDATA[“在一个全集$X$中若干子集的集合为$S$，精确覆盖（$\boldsymbol{Exact~Cover}$）是指，$S$的子集$S*$，满足$X$中的每一个元素在$S*$中恰好出现一次。在计算机科学中，精确覆盖问题指找出这样的一种覆盖，或证明其不存在。” $0x01$ 精准覆盖问题……其实是一种决策问题，给定$n$行长度为$m$的$0,1$序列，要求选出一些行，使得每一列有且仅有一个$1$，这就是精准覆盖问题。 诚然，我搜索贼菜，所以暂且不考虑爆搜，引进一种叫做“X算法”的东西，其本质上是每次选取一行，之后删掉所有与这行冲突的行，同时删掉与这行冲突的列，成为一个更小的矩阵，迭代下去。如果什么时候删没了，就说明是一种可行解；否则恢复原来的状态。 我们思考这种简洁做法的流程，发现朴素的删除与恢复无非就是将矩阵的这一个元素由$0$或$1$赋值成$-1$，记录一下状态回溯的时候再赋值回去，整个过程十分地漫长且繁复。而所谓所谓的”舞蹈链算法$\rm{DLX~(Dancing-Links ~X ~Algorithm)}$“算法则是专门用来加速这一过程。 在本人看来，$\rm{DLX}$更像是一种包装好的数据结构，一种加速措施，能更好的让爆搜达到其理论复杂度（所以本质上还是爆搜XD）……不过说实话“像翩翩起舞的舞者”我倒是看不出来…我觉得更像是一对牛仔裤上拉链，拉来拉去的那种感觉…… 诶，什么时候我的Preface开始这么意识流了啊 $0x02$ $\text{Dancing-Links}$其实算法的本质就是链表，这玩意儿插入删除都是$\Theta(1)$的。我们考虑建立一个十字循环链表，即每个元素在链表里是四联通的，并且左右成环、上下成环，目的是方便知道某些操作该什么时候停止。本质上来讲，一个求解矩阵（此处代指上文提到的$n$行$0,1$序列）初始的$\text{Dancing-Links}$ 共有$\text{1+m+Count(‘1’)}$ 个元素，其中$Count(‘1’)$指矩阵中$1$的个数。 前$\text{m+1}$个元素，大概就是列标元素（$m$个）左右连成一片，最左边的$0$号元素用来判断是否$\text{worked-out}$整个矩阵，和所有列标元素串成一条左右连通的链表。然后剩下的的元素就是真实存在的元素…该怎么连怎么连那种感觉… 那么每个元素记录$6$个值，上下左右和行标列标。 123struct Node&#123; int l, r, u, d, co, ro ;&#125;B[MAX &lt;&lt; 1] ; 初始化 12345inline void Init()&#123; cin &gt;&gt; N &gt;&gt; M ; for (int i = 0 ; i &lt;= M ; ++ i) B[i].l = i - 1, B[i].r = i + 1, B[i].u = B[i].d = i ; B[M].r = 0, B[0].l = M, cnt = M, memset(Ro, -1, sizeof(Ro)) ;&#125; 其中$R_o[]$数组记录每一行的第一个元素（第一个加进来的元素 然后Insert函数用于插入……毕竟是链表嘛，就要有个链表的样子 123456inline void Insert(int R, int C)&#123; Cs[C] ++, B[++ cnt].ro = R, B[cnt].co = C ; B[cnt].u = C, B[cnt].d = B[C].d, B[C].d = B[B[C].d].u = cnt ; if (Ro[R] &lt; 0) Ro[R] = B[cnt].l = B[cnt].r = cnt ; else B[cnt].l = B[Ro[R]].l, B[cnt].r = Ro[R], B[Ro[R]].l = B[B[Ro[R]].l].r = cnt ;&#125; 然后$C_s[]$数组用来记录每一列的元素个数，用来剪枝。 然后就是删除和恢复，都是以列为参数的函数，也都是很平凡的操作。 123456789101112inline void Del(int C)&#123; B[B[C].l].r = B[C].r, B[B[C].r].l = B[C].l ; for (int i = B[C].d ; i != C ; i = B[i].d) for (int j = B[i].r ; j != i ; j = B[j].r) B[B[j].d].u = B[j].u, B[B[j].u].d = B[j].d, Cs[B[j].co] -- ;&#125;inline void Back(int C)&#123; for (int i = B[C].u ; i != C ; i = B[i].u) for (int j = B[i].l ; j != i ; j = B[j].l) B[B[j].d].u = j, B[B[j].u].d = j, Cs[B[j].co] ++ ; B[B[C].l].r = C, B[B[C].r].l = C ; &#125; 然后是主函数 1234567891011bool dance(int step)&#123; if (!B[0].r)&#123; return (bool)(ans = step) ; &#125; int now_c = B[0].r ; for (int i = B[0].r ; i ; i = B[i].r) now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; Del(now_c) ; for (int i = B[now_c].d ; i != now_c ; i = B[i].d) &#123; Ans[step] = B[i].ro ; for(int j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ; if (dance(step + 1)) return 1 ; for(int j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ; &#125; Back(now_c) ; return 0 ; &#125; 有个小剪枝，就是刚才说的$C_s[]$。如果每次从含有最少$1$的那一列开始删，似乎可以快好几倍。 我发现整理算法的文章写起来真是难受啊，还是意识流比较管用。 最后是全部的程序（$Luogu4929$）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define I_used_to_rule_the_world___Seas_would_rise_when_I_gave_the_word___Now_in_the_morning_I_sleep_alone___Sweep_the_streets_I_used_to_own Init#define I_used_to_roll_the_dice___Feel_the_fear_in_my_enemy_s_eyes___Listen_as_the_crowd_would_sing_Now_the_old_king_is_dead__Long_live_the_king Done#define One_minute_I_held_the_key__Next_the_walls_were_closed_on_me__And_I_discovered_that_my_castles_stand__Upon_pillars_of_salt_pillars_of_sand work #define MAXN 520#define MAX 30010using namespace std ;struct Node&#123; int l, r, u, d, co, ro ;&#125;B[MAX &lt;&lt; 1] ; int cnt, ans ; int N, M, Ans[MAX], Ro[MAX], Cs[MAX] ;inline void Init()&#123; cin &gt;&gt; N &gt;&gt; M, memset(Ro, -1, sizeof(Ro)) ; for (int i = 0 ; i &lt;= M ; ++ i) B[i].l = i - 1, B[i].r = i + 1, B[i].u = B[i].d = i ; B[M].r = 0, B[0].l = M, cnt = M ;&#125;inline void Insert(int R, int C)&#123; Cs[C] ++, B[++ cnt].ro = R, B[cnt].co = C ; B[cnt].u = C, B[cnt].d = B[C].d, B[C].d = B[B[C].d].u = cnt ; if (Ro[R] &lt; 0) Ro[R] = B[cnt].l = B[cnt].r = cnt ; else B[cnt].l = B[Ro[R]].l, B[cnt].r = Ro[R], B[Ro[R]].l = B[B[Ro[R]].l].r = cnt ;&#125;inline void Del(int C)&#123; B[B[C].l].r = B[C].r, B[B[C].r].l = B[C].l ; for (int i = B[C].d ; i != C ; i = B[i].d) for (int j = B[i].r ; j != i ; j = B[j].r) B[B[j].d].u = B[j].u, B[B[j].u].d = B[j].d, Cs[B[j].co] -- ;&#125;inline void Back(int C)&#123; for (int i = B[C].u ; i != C ; i = B[i].u) for (int j = B[i].l ; j != i ; j = B[j].l) B[B[j].d].u = j, B[B[j].u].d = j, Cs[B[j].co] ++ ; B[B[C].l].r = C, B[B[C].r].l = C ; &#125; bool dance(int step)&#123; if (!B[0].r)&#123; return (bool)(ans = step) ; &#125; int now_c = B[0].r ; for (int i = B[0].r ; i ; i = B[i].r) now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; Del(now_c) ; for (int i = B[now_c].d ; i != now_c ; i = B[i].d) &#123; Ans[step] = B[i].ro ; for(int j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ; if (dance(step + 1)) return 1 ; for(int j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ; &#125; Back(now_c) ; return 0 ; &#125;void Done()&#123; int i, j, k ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt;= M ; ++ j) &#123; cin &gt;&gt; k ; if (k) Insert(i, j) ;&#125; &#125;inline bool work()&#123; if (!dance(0)) return puts("No Solution!") ; for (int i = 0 ; i &lt; ans ; ++ i) printf("%d ", Ans[i]) ;&#125;int main()&#123; I_used_to_rule_the_world___Seas_would_rise_when_I_gave_the_word___Now_in_the_morning_I_sleep_alone___Sweep_the_streets_I_used_to_own() ; I_used_to_roll_the_dice___Feel_the_fear_in_my_enemy_s_eyes___Listen_as_the_crowd_would_sing_Now_the_old_king_is_dead__Long_live_the_king() ; One_minute_I_held_the_key__Next_the_walls_were_closed_on_me__And_I_discovered_that_my_castles_stand__Upon_pillars_of_salt_pillars_of_sand() ; return 0 ; /* I hear Jerusalem bells are ringing Roman Cavalry choirs are singing Be my mirror my sword and shield My missionaries in a foreign field For some reason I can't explain Once you know there was never' Never an honest word That was when I ruled the world */&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>精准覆盖</category>
      </categories>
      <tags>
        <tag>精准覆盖/舞蹈链/DLX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】用舞蹈链(DLX)解决一类数独问题]]></title>
    <url>%2F2019%2F07%2F11%2Fdlx2%2F</url>
    <content type="text"><![CDATA[考虑精准覆盖问题的本质——我们把行看做决策，把列看做任务，那么其实质就是通过决策来完成任务。 那么我们来考虑数独问题的本质，对于一个$n^2\cdot n^2$的数独而言，他的目标函数有四个： 1、$r(i,j):$对于第$i$行，必须要有数字$j$ 2、$c(i,j):$对于第$i$列，必须要有数字$j$ 3、$p(i,j):$对于第$i$个宫，必须要有数字$j$ 4、$e(i,j):$对于第$(i,j)$个格子，必须要有数字 由此可知，我们有$4\times (n^2\cdot n^2)$的任务量。 同时我们可以用$n^6$的状态表示我们的决策，即$(i,j,k)$表示第$i$行$j$列填了数字$k$。 结合两者考虑，我们可以建出一个新的网格图，有$n^6$行、$4n^4$列。考虑向网格中填“$1$”表示一个决策完成了一个任务，那么对于每一个决策$(i,j,k)$，它理应可以完成$4$个任务，所以一共有$16n^4$个1. 至此建模完毕，一个$n^2\cdot n^2$的数独问题可以转化成一个$n^6$行、$4n^4$列，有$16n^4$个$1$的精准覆盖问题。 下面是代码实现部分，以SPOJ1110-SUDOKU为例： 首先是对状态进行编号 123456il int encode(int a, int b, int c)&#123; return (a &lt;&lt; 8) + (b &lt;&lt; 4) + c + 1 ; &#125;il void decode(int x, int &amp;a, int &amp;b, int &amp;c)&#123; x --, c = x % 16, x /= 16, b = x % 16, x /= 16, a = x ; &#125; 原理其实也很简单，就是i的后续状态(j,k)有$n^4=256$种组合，同理j的后续状态有$n^2=16$种组合。 然后就是连边，对于每个点判断一下，如果当前枚举到的数字是这个点的数字那么就需要insert，同理如果没有数字的话那就都insert一遍，毕竟比起有数字的点，可行的决策数要更多。至此我们就保证了原图中存在数字的方格被insert了，不存在数字的方格的所有可能情况也被insert了，之后直接dance就可以啦。 123456789101112131415161718192021222324int t[O][O], op ;const int POS = 0, Row = 1, Col = 2, Sub = 3 ; int main()&#123; cin &gt;&gt; T ; while (T --)&#123; read(), Init() ; for (int i = 0 ; i &lt; 16 ; ++ i) for (int j = 0 ; j &lt; 16 ; ++ j)&#123; t[i][j] = base[i][j] == '-' ? 0 : base[i][j] - 64 ; for (int k = 0 ; k &lt; 16 ; ++ k)&#123; if (t[i][j] &amp;&amp; t[i][j] != k + 1) continue ; op = encode(i, j, k) ; Insert(op, encode(POS, i, j)), Insert(op, encode(Row, i, k)), Insert(op, encode(Col, j, k)), Insert(op, encode(Sub, (i / 4) * 4 + j / 4, k)) ; &#125; &#125; dance(0) ; for (int i = 0 ; i &lt; 16 ; ++ i, puts("")) for (int j = 0 ; j &lt; 16 ; ++ j) printf("%c", (char)(res[i][j] + 65)) ; puts("") ; &#125;&#125; 然后是一道要求出所有解的题：NOIP2009D 靶形数独 此处需要我们求出所有可能的精准覆盖方案然后取最大值，于是小小改动一下dance就好。 123456789101112131415161718192021222324252627il int gs(const int &amp;x, const int &amp;y)&#123; if (x == 1 || y == 1 || x == 9 || y == 9 ) return 6 ; if (x == 2 || y == 2 || x == 8 || y == 8 ) return 7 ; if (x == 3 || y == 3 || x == 7 || y == 7 ) return 8 ; if (x == 4 || y == 4 || x == 6 || y == 6 ) return 9 ; return 10 ; &#125;void dance(const int &amp;step)&#123; int now_c = B[0].r ; if (!now_c)&#123; int x, y, z, ret = 0 ; for (rr int i = 0 ; i &lt; step ; ++ i) decode(ans[i], x, y, z), g[x][y] = z + 1 ; for (rr int i = 0 ; i &lt; 9 ; ++ i) for (rr int j = 0 ; j &lt; 9 ; ++ j) ret += g[i][j] * gs(i + 1, j + 1) ; res = max(res, ret) ; return ; &#125; for (rr int i = now_c ; i ; i = B[i].r) now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; Del(now_c) ; for (rr int i = B[now_c].d ; i != now_c ; i = B[i].d)&#123; ans[step] = B[i].ro ; for (rr int j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ; dance(step + 1) ; for (rr int j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ; &#125; Back(now_c) ; return ; &#125; 撒花~ （撒自己XD]]></content>
      <categories>
        <category>题解</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>精准覆盖/舞蹈链/DLX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想八 · 逃吧]]></title>
    <url>%2F2019%2F06%2F11%2F8%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prufer序列泛做]]></title>
    <url>%2F2019%2F05%2F26%2FPrufer%E5%BA%8F%E5%88%97%E6%B3%9B%E5%81%9A%2F</url>
    <content type="text"><![CDATA[Prufer数列是无根树的一种数列，常用来求解树的计数问题。 $Preface$嗯，最近学了学一个叫做Prufer序列的东西，然后主要是跟树的计数有关。 基本概念与基本操作首先下定义：Prufer序列是一个长度为$n-2$的序列。 我们考虑给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数$n&gt;2$的树总存在叶子节点，因此一棵$n$个节点的无根树唯一地对应了一个长度为$n-2$的数列，数列中的每个数都在$1$到$n$的范围内。而这就是这棵树的$\boldsymbol{Prufer}$序列。 为什么是$n-2$？ 我们观察一棵树，$n-1$条无向边决定了总度数为$2n-2$，同时由于每个节点当自己是被删成叶子的时候不会被算进去，所以每个节点需要减去一的贡献，换句话说就是$Prufer$序列的长度为$n-2$。 emmm然后一个比较平凡的结论就是$\boldsymbol{P rufer}$序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。 同时我们接下来要不加证明地断言任何一个长为$n-2$、取值范围在$1$到$n$之间的数列都唯一地对应了一棵$n$个节点的无根树. 严格证明大家可以去Mt67的博客上翻（ 想要更好的意会以上内容，需要我们考虑如何实现Prufer的呈现与复原：(摘自ProJ7-Jeffy的博客) （1）无根树转化为 $Prufer$ 序列。首先定义无根树中度数为1的节点是叶子节点。找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下2个节点。如下图的树对应的 $Prufer$ 序列就是 3，5，1，3。具体实现可以用一个 set 搞定，维护度数为 1 的节点。复杂度 $O(n\log n)$。（2）$Prufer$序列转化为无根树。设点集 V={1,2,3,...,n}，每次取出 $Prufer$ 序列中最前面的元素$u$，在V中找到编号最小的没有在 $Prufer$ 序列中出现的元素$v$，给 $u，v$ 连边然后分别删除，最后在 V 中剩下两个节点，给它们连边。最终得到的就是无根树。具体实现也可以用一个 set，维护 $Prufer$ 序列中没有出现的编号。复杂度 $O(n\log n）$。 扩展 $n$个点有标号无根树共有$n^{n-2}$种。 $\rm{Proof}:$ 仔细想想…似乎Prufer序列一共$n-2$项，于是就乘法原理就好了…… 接上一个，有根树的话因为对于每种方案里面的$n$个点都可以当作根，所以总数量是$n^{n-2}\cdot n=n^{n-1}$。 假设每个点的度数已经确定了，设第$i$号点的度数为$d_i$，则显然有$\sum_{i=1}^{n}(d_i - 1)=n-2$，那么对于每个节点度数确定的带标号无根树数量就是$$\frac{(n-2)!}{\prod_{i=1}^n(d_i-1)}$$ $\rm{Proof}:$ 大概是一个排列组合的思想，我们可以认为是一共$n$种元素，选$n-2$个，每种元素有且必须有$d_i-1$个，求排列数。然后比较显然的是$(n-2)!$是总排列数，而每个元素一共有$d_i-1$个位置，对于同一种元素的同一种位置排布，我们多算了$A_{(d_i-1)}^{(d_i-1)}=(d_i-1)!$次的，所以分母上乘法原理起来去除这些贡献就好。 接上一个, $n$ 个节点的度依次为 $d_1,d_2,…,d_{n-m}$，另外有 $m$ 个节点度数未知，求有多少种生成树？ 我们考虑首先计算一下$Prufer$序列该剩下多少未知项，设其数目为$\omega$，则$\omega=(n-2)-\sum_{d_i ~is~known} (d_i-1)$。那么本着瞎**去重的原则，我们考虑应该在分母上乘一个$\omega!$。而同时由于我们存在$m$个度数并未确定的点，在$Prufer$序列中占据了$\omega$个位置，所以我们分子上应该再乘上一个$m^{\omega}$。故总方案数就变成了： $$\frac{(n-2)!m^{\omega}}{\omega!\cdot \prod_{i=1}^{n-m}(d_i-1)}$$ $A$ [HNOI2008]明明的烦恼bzoj1005 其实就是上面扩展里面的一个推论，然后我们就用python水过去就好了233 然而BZOJ的Py只会一直Pending，所以还是什么时候再写一发高精度吧 123456789101112131415161718N = input()Fac = [1]for i in range(1, N - 1) : Fac = Fac + [Fac[i - 1] * i]Ans = Fac[N - 2]cnt = 0Sum = N - 2for i in range(0, N) : di = input() if di == -1 : cnt = cnt + 1 else : Ans = Ans / Fac[di - 1] Sum = Sum - (di - 1)Ans = Ans / Fac[Sum]for i in range(0, Sum) : Ans = Ans * cntprint (Ans) $B$ 小猴打架由于在BZOJ上是权限题，所以不得已去Luogu做…国内最大的盗版题市场 Luogu4430 我们发现这个题的Aim在于让我们求无根树有多少种不同的生成方式，比普通的Prufer序列多一个加边的顺序——毕竟Prufer只能处理树的形态不同&amp;标号不同，所以我们理所当然地乘上一个$(n-1)!$。 123456int main()&#123;//用sb代码来填补博文太短的空白 cin &gt;&gt; N ; Frac[0] = 1 ; for (i = 2 ; i &lt; N ; ++ i) (Ans *= N) %= Mod ; for (i = 1 ; i &lt; N ; ++ i) Frac[i] = Frac[i - 1] * i % Mod ; (Ans *= Frac[N - 1]) %= Mod, cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化数据结构·主席树杂谈]]></title>
    <url>%2F2019%2F05%2F18%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%BB%E5%B8%AD%E6%A0%91%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[【赛题整理】CF#Global Round 1の题解(A $\to$ G)]]></title>
    <url>%2F2019%2F05%2F10%2FCodeforces-1110%2F</url>
    <content type="text"><![CDATA[自从省选完之后状态一直不佳，感觉自己刚燃起的希望又熄灭了。所以就打算来整理一下省选之前因为懒而没整的一些题。然后你会发现前两句话一点关系都没有XD 这里是总链接$Link$. $A$ 题意：求$\sum_{i=1}^{k} a_i\times b^{k-i}$的奇偶性， $k = \Theta(n \log n)$ ……其实很容易想麻烦，比如说逐个判断，整体判断啥的。但其实只要对结果都$\bmod ~10$，然后判断奇偶性就好了。 12345cin &gt;&gt; b &gt;&gt; k ; for (i = 1 ; i &lt;= k ; ++ i) scanf("%d", &amp;base[i]) ; reverse (base + 1, base + k + 1) ; for (i = k ; i &gt;= 1 ; -- i) Sum = Sum * b + base[i], Sum %= 10 ; cout &lt;&lt; (Sum &amp; 1 ? "odd" : "even") &lt;&lt; endl ; return 0 ; 其实就是在水字数 $B$ 题意： 给定一条网格纸，$n, m, k$,分别表示点数，总长度，胶带的数量。对于输入的$n$个点，保证位置递增， 求覆盖所有的点所需的最小胶带长度（胶带数量$\leq k$）。 其实是个制杖题。我们考虑如果$k$是无限大，那么最优的方式一定是单点覆盖。所以如果胶带不够的话，就是要去额外多粘$N-k$个空白的区间。所以我们就可以排个序，求出$N-k$个空白区间的长度，再加上单点的长度和$n$，得到答案。注意空白区间的两头开的。 12345cin &gt;&gt; N &gt;&gt; M &gt;&gt; K ;for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;now), (i &gt; 1 ? (d[i - 1] = now - Last - 1) : 1), Last = now ;nth_element(d + 1, d + N - K + 1, d + N) ; //Last row, now - Last + 1 -&gt; now - Lastfor (i = 1 ; i &lt;= N - K ; ++ i) Ans += d[i] ; Ans += N ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ; emmm怎么说呢，是个显然又不显然的贪心，大概还是跟OI素养直接挂钩的吧（sigh $C$ 题目简述 : 定义函数$f(a)$$$f(a) = \max_{0 &lt; b &lt; a}{\gcd(a \oplus b, a > \&amp; > b)}$$ 给出 $q$ 个询问，每个询问为一个整数$a_i$。你需要对于每个询问，求出$f(a_i)$的值。$q=O(10^3),a=O(2^{25}).$ 也算是比较巧妙的一道题，当然这个难度评级是给的分块打表的，毕竟思维难度摆在那里……首先我们考虑这个式子的结构，最大化一个gcd，那么我们不妨考虑如果$gcd(x,y)$,存在$x=0$或者$y=0$时，$gcd(x,y)=y$或者$gcd(x,y)=x$。 所以我们考虑，对于任意的$a$，我们只需要去尝试构造一种方案 ，使得$a\oplus b$最大并且$a~\&amp; ~b$最小。那么不妨考虑直接选一个与$a$所有位上都相反的数$b$，就可以保证$a~\oplus~b$最大且$a~\&amp;~b=0$，最后的答案就是$2^{k-1}-1$，其中$k$是二进制下$a$的位数。其中合法性是不言而喻的，因为根据构造，$b$的第$k$位（二进制位下最大的那一位）上必定是$0$，所以似乎就做完了？ 然而并不是，因为$b\not =0$，所以当$~a=2^{w}-1，w\in \mathbb N~$时就会不合法。此处又有一个精妙的构造，我们发现当$a$的二进制位上都是$1$时，$\forall b&lt;a,\exists a ~\&amp; ~b=b, a~\oplus~b=a-b$, 于是最后就相当于求$\max \gcd (a-b,b)$，运用辗转相除或者更相减损的思想可以立即看出是$\max \gcd(a,b)$，于是只需要找出$a$最大的因子就好了——此处暴力即可。 于是最后的代码： 123456789101112131415161718192021#define MAXN 34000000std::bitset &lt;MAXN&gt; check ; int T, N, i, O ;inline int get_fac(int x)&#123; for (i = 3 ; i &lt;= x ; i += 2) if (!(x % i)) return (x /= i) ; &#125;int main()&#123; std::cin &gt;&gt; T ; for (i = 1 ; i &lt;= 25 ; ++ i) check[(1 &lt;&lt; i) - 1] = 1 ; while (T --)&#123; scanf("%d", &amp;N) ; if (check[N]) O = get_fac(N), printf("%d\n", O) ; else &#123; for (i = 1 ; i &lt;= N ; i &lt;&lt;= 1, O = i) ; O --, printf("%d\n", O) ; &#125; &#125; return 0 ;&#125; 不得不说是一道比较神的的题了，Brainstorm，Brainstorm….. $D$ 题目详述：你在玩一个叫做 Jongmah 的游戏，你手上有 $n$ 个麻将，每个麻将上有一个在 $1$ 到 $m$ 范围内的整数 $a_i$。为了赢得游戏，你需要将这些麻将排列成一些三元组，每个三元组中的元素是相同的或者连续的。你只能使用手中的麻将，并且每个麻将只能使用一次。请求出你最多可以形成多少个三元组。 这道题准确预报了今年各省省选里面的毒瘤雀魂题 一道动态规划，感觉思路清新、解法自然，给出题人点赞. 然后底下是我丢到Luogu的题解： $dp.$ 其实主要思想都差不多，但我发这篇$sol$为了阐明一种观点：复杂度同阶的$DP$，不同的状态设计，会导致代码难度、时空复杂度等截然不同。 我们定义状态$dp_{i,j_{1},j_{2}}$表示考虑了前$i$大序号的麻将($mahJong$)，其中有$j_{1}$个$[i - 1, i, i + 1]$类型、有$j_{2}$个$[i, i + 1, i + 2]$类型的组合，最多组成多少个三元组。 这样定义状态的原因是：我们发现如果单纯用$1$维状态转移，那么状态势必是“前$i$大序号的麻将包含的三元组个数”，但是此状态不明确——无法准确定义“包含”的意思。而此处我们定义包含指三元组右端点也$\leq i$，那么$[i - 1, i, i + 1]$和$[i, i + 1, i + 2]$便需要单独定义出来。 转移的时候直接枚举有多少个$[i + 1,i+2, i+3]$即可（因为我们使用$i$更新$i+1$而不是用$i-1$更新$i$，如是做细节少、思考难度小） 然后转移的时候也要顺便计算$[i,i,i]$的数量。而由于如果存在三个$[i,i+1,i+2]$，那么我们直接拆成三个$[i,i,i]$，三个$[i+1,i+1,i+1]$, 三个$[i+2,i+2,i+2]$即可。 1234567891011cin &gt;&gt; N &gt;&gt; M ; memset(dp, -1, sizeof(dp)), dp[0][0][0] = 0 ;for (i = 1 ; i &lt;= N ; ++ i) Sum[ qrd() ] ++ ;for (i = 1 ; i &lt;= M ; ++ i)&#123; for (j = 0 ; j &lt; 3 ; ++ j) for (k = 0 ; k &lt; 3 ; ++ k) for (l = 0 ; l &lt; 3 ; ++ l) if (Sum[i] &lt; j + k + l) continue ; else dp[i][k][l] = max(dp[i][k][l], dp[i - 1][j][k] + (Sum[i] - j - k - l)/3 + l) ;&#125;cout &lt;&lt; dp[M][0][0] &lt;&lt; endl ; return 0 ; $E$ 题目简述：给定数列$c$和$t$，每次操作都可以选择一个$1&lt;i&lt;n$，令$c_i$变成$c_i’$，其中$c_i’=c_{i+1}+c_{i-1}-c_i$。问是否可以经过若干次操作，使得$\forall c_i=t_i$. ……我管这种题叫做“疯狂暗示题”，其实也是一种做题技巧的问题。打完比赛反思了一下，似乎有好几个关键信息没有捕捉到。比如说“若干次操作”，没有限定操作次数，就说明无论怎么操作，其背后一定有某些本质不变的东西，否则应该出成一个交互题，在$k$步之内完成任务的那种感觉。而同时，每次操作一个$c_i$，都只会跟$c_{i-1}$、$c_{i+1}$有关。所以，一切的一切都在引导我们向差分靠拢。 我们思考对于一个$c_i$，令其满足$c_{i-1}+d_1=c_i, ~c_i+d_2=c_{i+1}$，那么我们新的$c_i’$就是 $$c_i’=c_i-d_1+c_i+d_2-c_i=c_i-d_1+d_2$$那么我们就会发现$$c_{i+1}-c_i’ = d_1\\ c_i’-c_{i-1} = d_2$$ 换句话说，其实就是相邻两个差换了位置！那么也就是说无论怎样，差分数组里面每个数出现的次数都是不变的，直接排个序检查就好。 12345678cin &gt;&gt; N ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;A[i]) ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;B[i]) ; if (A[1] != B[1] || A[N] != B[N]) return puts("No"), 0 ; for (i = 2 ; i &lt;= N ; ++ i) Da[i] = A[i] - A[i - 1] ; for (i = 2 ; i &lt;= N ; ++ i) Db[i] = B[i] - B[i - 1] ; sort(Da + 2, Da + N + 1), sort(Db + 2, Db + N + 1) ; for (i = 2 ; i &lt;= N ; ++ i) if (Da[i] != Db[i]) return puts("No"), 0 ; puts("Yes") ; 感觉其实$C/D/E$都是比较好的思维题……但是接下来一个就不是了。 $F$ 题目简述 ：给定一棵以$1$为根的$n$个节点有根树， 给定$m$次询问， 形如 v l r， 输出以$v$为起点，终点编号为$l$ ~$r$以内的叶子中最短的路径距离。 根据dfs序的相关知识，我们需要一棵线段树来维护dfs序上的路径长度最小值。但是很多人（比如我）会认为一定需要线段树上个树什么的，但其实有更简单的策略。 不妨直接令当前点到其他所有的点的距离是一个数组$dis$。思考如果我们把当前点的当前子节点设为$x$, 那么我们如果向下递归$x$，就会有$x$到$x$子树内的所有节点的$dis$，比其父亲的dis都小一个$E[k].v$，$x$到其他节点的距离都会大一个$E[k].v$，那么就如同状态转移一样，每次向下递归的时候先统计一遍$Ans$，再更新一下距离即可。 其实这个题是一个$tricky$题，比如我们为了用一个dis数组表示到叶子的距离，可以把非叶子之间的距离都设成$\rm{Inf}$ ；比如我们为了飞速统计答案，可以把询问离线下到一个vector里面，在dfs的时候直接统计出全部答案。 不失为一道好题啊qwq 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define rr register #define MAXN 500020#define ll long long #define to(k) E[k].to#define Inf (1LL &lt;&lt; 55)using namespace std ;struct Edge&#123; int to, next ; ll c ;&#125;E[MAXN &lt;&lt; 1] ; int N, M, A, i, q ; ll tag[MAXN &lt;&lt; 2], S[MAXN &lt;&lt; 2], Ans[MAXN], dis[MAXN], B ;int cnt, head[MAXN], Last[MAXN], Lr[MAXN], Rr[MAXN] ; vector &lt;int&gt; query[MAXN] ;inline ll min(const ll &amp;a, const ll &amp;b)&#123; return a &lt; b ? a : b ; &#125;inline ll max(const ll &amp;a, const ll &amp;b)&#123; return a &gt; b ? a : b ; &#125;void dfs(int u, int f)&#123; Last[u] = u ; for (int k = head[u] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; dis[to(k)] = dis[u] + E[k].c ; dfs(to(k), u), Last[u] = max(Last[u], Last[to(k)]) ; &#125;&#125;inline void Add(int u, int v, ll w)&#123; E[++ cnt].to = v, E[cnt].c = w, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].c = w, E[cnt].next = head[v], head[v] = cnt ;&#125;inline void push_up(int rt)&#123; S[rt] = min(S[rt &lt;&lt; 1], S[rt &lt;&lt; 1 | 1]) ; &#125;inline void push_down(int rt)&#123; if (tag[rt] == 0) return ; rr int lc = rt &lt;&lt; 1, rc = rt &lt;&lt; 1 | 1 ; tag[lc] += tag[rt], tag[rc] += tag[rt], S[lc] += tag[rt], S[rc] += tag[rt], tag[rt] = 0 ; &#125;inline void update(int rt, int l, int r, int ul, int ur, ll k)&#123; if(ul &lt;= l &amp;&amp; ur &gt;= r)&#123; S[rt] += k, tag[rt] += k ; return ; &#125; push_down(rt) ; rr int mid = (l + r) &gt;&gt; 1 ; if (ul &lt;= mid) update(rt &lt;&lt; 1, l, mid, ul ,ur, k) ; if (ur &gt; mid) update(rt &lt;&lt; 1 | 1, mid + 1, r, ul, ur, k) ; push_up(rt) ;&#125;void build(int rt, int l, int r)&#123; if (l == r)&#123; S[rt] = dis[l] ; return ; &#125; rr int mid = (l + r) &gt;&gt; 1 ; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r), push_up(rt) ;&#125;inline ll querys(int rt, int l, int r, int ql, int qr)&#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return S[rt] ; rr int mid = (l + r) &gt;&gt; 1 ; rr ll res = Inf ; push_down(rt) ; if (ql &lt;= mid) res = min(res, querys(rt &lt;&lt; 1, l, mid, ql, qr)) ; if (qr &gt; mid) res = min(res, querys(rt &lt;&lt; 1 | 1, mid + 1, r, ql, qr)) ; return res ;&#125;inline void work(int u, int f)&#123; for (int k : query[u]) Ans[k] = querys(1, 1, N, Lr[k], Rr[k]) ; for (int k = head[u] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; update(1, 1, N, 1, N, E[k].c), update(1, 1, N, to(k), Last[to(k)], -(E[k].c &lt;&lt; 1)), work(to(k), u) ; update(1, 1, N, 1, N, -E[k].c), update(1, 1, N, to(k), Last[to(k)], E[k].c &lt;&lt; 1) ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 2 ; i &lt;= N ; ++ i) scanf("%d%I64d", &amp;A, &amp;B), Add(A, i, B) ; for (i = 1 ; i &lt;= M ; ++ i) scanf("%d%d%d", &amp;q, &amp;Lr[i], &amp;Rr[i]), query[q].push_back(i) ; dfs(1, 0) ; for (i = 1 ; i &lt;= N ; ++ i) if (i != Last[i]) dis[i] = Inf ; build(1, 1, N) ; // by _pks work(1, 0) ; for (i = 1 ; i &lt;= M ; ++ i) printf("%I64d\n", Ans[i]) ; return 0; // by _pks by _pks by _pks by_pks&#125; by_pks其实是用来占位的因为我喜欢同一个代码块里，每一行的长度都是递增的XD $G$ 题目大意：给出一棵N个点的树，初始时某些节点是白色，其他节点没有颜色，有两个人在树上博弈。每一回合，一方可以将一个没有颜色的点染成白色，然后另一方可以将一个没有颜色的点染成黑色。如果在某次染色后树上存在三个点ABC满足有边$(A,B)(B,C)$且ABC都有颜色且颜色相同，则该颜色对应的人获胜。假设两人绝顶聪明，问最后结果如何。$T\leq 5e5,\sum n\leq 5e5$ emmmm一道我不会的题。其实总觉得这种博弈论有一种一脉相承的精妙之处，但是自己总是不能稔熟于心……GG 然后我选择搬了Itst巨佬的思路过来 0x01首先我们考虑，黑色是不可能获胜的，毕竟原来就已经有一堆白点了…… 其次我们考虑先忽略原树中的所有已经被染过色的点，然后用一种比较前卫的方式来分类讨论——度数讨论法。 假设有一个点的度数$\geq 4$，换句话说这个联通块的点的个数要$\geq 5$，那么根据白色先手的原则，白色的一定可以取$3$个节点，并且一定可以取$3$个连续的节点。所以白色赢； 如果存在一个点的度数$=3$，且它所连的$3$个点至少有$2$个点不是叶子节点，那么我们如果考虑讲树平展开之后，先选中间的点，就可以保证白色赢； 其余的情况我们可以考虑大力分类讨论树的形态： 我们发现，对于前两种情况都是draw的。而对于第三种情况，如果总点数是奇数个，那么白色必赢。我们考虑从左向右染色，白色第一次考虑染从左往右第二个非叶子节点，那么黑色只能染第一个；白色染第四个，黑色只能染第三个……以此类推。到最后一定会出现白色染了$2n$这个点，黑色去染$2n-1$这个点，那么白色接下来就可以染$2n+1$这个点，Winner！ 0x02接下来我们如果要算上原本就是白色的点呢？对于这种情况，一般都是转化回我们已经讨论完的0x01去。我们考虑把一个白色点拆成$4$个无色点。 其中A就是原来的$1$号点，原图上哪些点跟$1$连了边，现在也和$A$连，换句话说就是$A$多了一棵三个节点的子树。那么接下来我们考虑其可行性。 如果$A$被染成黑色，那么白色没有必要再染子树内的点，这种情况等价于不连子树。 如果$A$被染成白色，那么黑色一定要染$B$点，那么此时这棵子树又没用了，所以也等价于不连子树。 嗯，然后这个题就完了。我们可以发现就是一个大力分类讨论的过程——题还是挺好的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 500020#define to(k) E[k].tochar Input[MAXN] ;using namespace std ;struct Edge&#123; int to, next ;&#125;E[MAXN &lt;&lt; 1] ; int In[MAXN], qaq ;int T, N, head[MAXN], A, qwq, B, i, j, ans, cnt ;inline void Add(int u, int v)&#123; E[++ cnt].to = v, In[v] ++ ; E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, In[u] ++ ; E[cnt].next = head[v], head[v] = cnt ;&#125;int main()&#123; cin &gt;&gt; T ; while (T --)&#123; scanf("%d", &amp;N), ++qwq ; fill(In, In + N + 4, 0) ; fill(head, head + N + 4, 0), ans = 0, qaq = 0 ; for (i = 1 ; i &lt; N ; ++ i) scanf("%d%d", &amp;A, &amp;B), Add(A, B) ; scanf("%s", Input) ; if (N &lt; 3) puts("Draw") ; else if (N == 3)&#123; for (i = 0 ; i &lt; N ; ++ i) ans += Input[i] == 'W' ; puts(ans &gt;= 2 ? "White" : "Draw") ; &#125; else &#123; int Linshi = 0 ; for (i = 0 ; i &lt; N ; ++ i) if (Input[i] == 'W')&#123; head[++ N] = 0, Add(i + 1, N), In[N] = 3 ; &#125; for (i = 1 ; i &lt;= N &amp;&amp; ans &lt;= 0; ++ i)&#123; if (In[i] &gt; 3) ans ++ ; else if (In[i] == 3)&#123; Linshi = 0 ; for (j = head[i] ; j ; j = E[j].next) Linshi += (In[to(j)] &gt;= 2) ; ans += Linshi &gt; 1, qaq ++ ; &#125; &#125; if (qaq == 2 &amp;&amp; (N % 2)) ans ++ ; puts(ans ? "White" : "Draw") ; &#125;// if (qwq == 20) return 0 ; &#125;&#125; 总结Global Round的题目质量不低蛤。]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/构造</tag>
        <tag>动态规划-普通DP</tag>
        <tag>树模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【探究向】主席树上的不靠谱解法]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%8D%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91%E4%B8%8A%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[yy出来的假复杂度做法，但是据说有一个很强的剪枝？ $\rm{0x00~}Preface$某天机房里，公认的ezi lwy跟wxl随口说了一道luogu上的题，wxl来了兴趣，被pks听见了，于是pks就瞅了一眼这题，然后说了一句”这不就是sb主席树上二分吗？随便一个$\Theta(n \log^2n)$就可以过啊” 然后pks那一整个晚上都在搞这个假算法，$\rm{QAQ}$ 于是就有了本文，整理了两道主席树的正确（？）应用。 $\rm{0x01~}$faebdc的烦恼传送门：https://www.luogu.org/problemnew/show/P1997 呃，其实这不是一道很难的题。因为本来就保证了数列不降，所以我们直接记录一下每个数出现区间的左右端点，瞎搞就好。但是既然我说了要主席树上二分，就一定要写写看吧qaq 我们考虑在我的这篇博客里面曾经介绍过的$T3$中的算法，我们直接去查询左右儿子值域区间内中数的个数，看看哪个可行，然后暴力找就好。 但是…他TLE了两个点，因为我是这么写的： 123456789101112131415161718192021222324252627282930int query(const int &amp;Left,const int &amp;Right,const int &amp;l, const int &amp;r, const int &amp;k)&#123; if (l == r) return aft[l] ; register int mid = (l + r) &gt;&gt; 1, qwq ; if (sum[Right] - sum[Left] &lt; k) return -1 ; int x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ; if (x &gt;= k) if ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; 0) return qwq ; if (y &gt;= k) if ((qwq = query(R[Left], R[Right], mid + 1, r, k)) &gt; 0) return qwq ; return -1 ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 1; i &lt;= N; i ++) base[i] = qr() + ADD, aft[i] = base[i] ; sort (aft + 1, aft + N + 1),Len = unique(aft + 1, aft + N + 1) - (aft + 1), T[0] = build(1, Len) ; for (i = 1; i &lt;= N; i ++) pos = lower_bound(aft + 1, aft + Len + 1, base[i]) - aft, T[i] = update(T[i - 1], 1, Len, pos) ; for (i = 1; i &lt;= M; i ++)&#123; scanf("%d%d", &amp;a, &amp;b) ; register int l = 1, r = b - a + 1, ans = 1 ; while (l &lt;= r)&#123; register int mid = (l + r) &gt;&gt; 1 ; if (query(T[a - 1], T[b], 1, Len, mid) &gt; 0) ans = mid, l = mid + 1 ; else r = mid - 1 ; &#125; printf("%d\n", ans) ; &#125;&#125; 好像很正常？但是，这个复杂度是完全错误的。最大的时候甚至可以到达单次$m \log n$的复杂度——注意是单次。因为我们每次询问的时候，如果查询了左区间不合法，那么不代表右区间合法——毕竟是二分里的check环节。而上一个类似方法的题，可以保证我们如果左区间的数的出现次数不超过$\frac{1}{2}$，那么右区间一定满足——但显然的是，本题不具有这个性质。 所以，总结一下，主席树上不可以二分。 但是如果我们加一点剪枝呢？ 我们考虑，对于主席树上的每一个点维护一个$maxx$一个$minx$，记录区间内单个数值出现的最大次数和最小次数，那么我们在$check$的时候就可以直接用这种方式判——如果$r$版本的主席树内出现的最大次数减去$l-1$版本内出现的数的最小次数$k&lt;q$（$q$是二分出的$val$），那么一定不满足。 比较显然的是，这不是一种最优性剪枝，而是一种可行性剪枝。但是对付这道题却有着不错的效果，跑的奇快。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define il inline#define ADD 393216#define rr register#define MAXN 100073using namespace std ;int a, b, c, pos, N, base[MAXN], mx[(MAXN &lt;&lt; 5) + 1], mn[(MAXN &lt;&lt; 5) + 1], aft[MAXN], M, i ;int cnt, Len, T[(MAXN &lt;&lt; 5) + 1], L[(MAXN &lt;&lt; 5) + 1], R[(MAXN &lt;&lt; 5) + 1], sum[(MAXN &lt;&lt; 5) + 1] ;il int qr()&#123; register int k = 0, f = 1 ; char c = getchar() ; while(!isdigit(c))&#123; if (c == '-') f = -1 ; c = getchar() ; &#125; while(isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k * f ;&#125;int update(const int &amp;last, const int &amp;l, const int &amp;r, const int &amp;x)&#123; register int rt = ++ cnt, mid ; sum[rt] = sum[last] + 1, R[rt] = R[last], L[rt] = L[last] ; if (l == r)&#123; mx[rt] = mn[rt] = sum[rt] ; return rt ; &#125; mid = (l + r) &gt;&gt; 1 ; if (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ; else R[rt] = update(R[last], mid + 1, r, x) ; mn[rt] = min(mn[L[rt]], mn[R[rt]]), mx[rt] = max(mx[L[rt]], mx[R[rt]]) ; return rt ;&#125;bool query(const int &amp;Left,const int &amp;Right,const int &amp;l, const int &amp;r, const int &amp;k)&#123; if (l == r) return 1 ; rr int mid = (l + r) &gt;&gt; 1, qwq ; if (mx[L[Right]] - mn[L[Left]] &gt;= k &amp;&amp; query(L[Left], L[Right], l, mid, k)) return 1 ; if (mx[R[Right]] - mn[R[Left]] &gt;= k &amp;&amp; query(R[Left], R[Right], mid + 1, r, k)) return 1 ; return 0 ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M; for (i = 1; i &lt;= N ; ++ i) base[i] = qr() + ADD, aft[i] = base[i] ; sort (aft + 1, aft + N + 1), Len = unique(aft + 1, aft + N + 1) - (aft + 1) ; for (i = 1; i &lt;= N ; ++ i) pos = lower_bound(aft + 1, aft + Len + 1, base[i]) - aft, T[i] = update(T[i - 1], 1, Len, pos) ; for (i = 1; i &lt;= M ; ++ i)&#123; a = qr(), b = qr() ; register int l = 1, mid, r = b - a + 1, ans = 1 ; while (l &lt;= r)&#123; mid = (l + r) &gt;&gt; 1 ; if (query(T[a - 1], T[b], 1, Len, mid)) ans = mid, l = mid + 1 ; else r = mid - 1 ; &#125; printf("%d\n", ans) ; &#125;&#125; $\rm{0x02~}CF840D~Destiny$传送门：http://codeforces.com/problemset/problem/840/D 简化版题意：每次给出三个参数$l,r,k$，询问区间$[l,r]$内是否存在出现次数严格大于$\frac{r-l+1}{k}$的数。如果存在就输出最小的那个$ans$，否则输出$-1$. 这个东西……就直接查询就好了啊……由于不用二分，所以复杂度相对来说稳定了一些。于是我就没有加上文中提到过的那个诡异的优化。我们每次先查左半边，就可以保证在值域上最小，也就是说每次我们都可以求出最小的合法$ans$了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546il int build(int l, int r)&#123; int rt = ++ cnt ; sum[rt] = 0 ; if(l &lt; r)&#123; L[rt] = build(l, mid) ; R[rt] = build(mid + 1, r) ; &#125; return rt;&#125;il int update(int last, int l, int r, int x)&#123; int rt = ++ cnt ; sum[rt] = sum[last] + 1 ; R[rt] = R[last] ; L[rt] = L[last] ; if (l &lt; r)&#123; if (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ; else R[rt] = update(R[last], mid + 1, r, x) ; &#125; return rt ;&#125;il int query(int Left, int Right, int l, int r, int k)&#123; if (l == r) return aft[l] ; int qwq ; // if (sum[Right] - sum[Left] &lt;= k) return -1 ; int x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ; if (x &gt; k) if ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; 0) return qwq ; if (y &gt; k) if ((qwq = query(R[Left], R[Right], mid + 1, r, k)) &gt; 0) return qwq ; return -1 ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M; for(i = 1; i &lt;= N; i ++) base[i] = qr(), aft[i] = base[i] ; sort(aft + 1, aft + N + 1) ; Len = unique(aft + 1, aft + N + 1) - (aft + 1) ; T[0] = build(1, Len) ; for(i = 1; i &lt;= N; i ++)&#123; pos = lower_bound(aft + 1, aft + Len + 1, base[i]) - aft; T[i] = update(T[i - 1], 1, Len, pos) ; &#125; for(i = 1; i &lt;= M; i ++)&#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c) ; int k = (b - a + 1) / c ; cout &lt;&lt; query(T[a - 1], T[b], 1, Len, k) &lt;&lt; endl ; &#125; return 0 ; &#125; 事实上，加上那优化之后，总用时大约$27000ms$，而我这个不加优化的版本足足跑了$56677ms$……真丢人啊]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构/可持久化/可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防守战线[ZJOI2013] & 志愿者招募[NOI2008]]]></title>
    <url>%2F2019%2F04%2F05%2Ffszx-and-zyzzm%2F</url>
    <content type="text"><![CDATA[$\rm{0x01}$ [ZJOI2013]防守阵线传送门：https://www.luogu.org/problemnew/show/P3337 首先就是要明白怎么建模，大概就是： $$\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots n)\\\\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} x_{j} \geq d_i \quad (i = 1,2,3\cdots m)$$ 其中$x_j$表示$j$这个地方有几座塔。 那我们首先把它对偶过去，就会得到：$$\text{最大化} \quad \sum d_iy_i \quad(i = 1, 2,3 \cdots m) \\\\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} y_{j} \leq c_i\quad (i = 1,2,3\cdots n)$$然后我们考虑，似乎价值不能带小数啊，毕竟题目中规定了价值都为整数(事实上并没有规定但是数据是这样给的)，换句话说我们不能存在建某座塔的一部分(比如只建一半)。 那么这就是整数线性规划问题，换句话说就是自变量取值范围是$\Z$的线性规划。 呃，这问题已经被证明是$\rm{NP-Hard}$的问题了…但是，有一种矩阵叫做全幺模矩阵，即元素只会是$\boldsymbol{0,1,-1}$的矩阵，被证明肯定至少有一组最优解保证整数线性规划与实数线性规划的方案一致。 啥，你说啥？你要关于全幺模矩阵这个性质的争鸣？是百家争鸣那个争鸣吗？学OI呢别瞎讨论历史 然后就可以一发单纯形给艹过去啦~开心心~ 123456789101112131415161718192021222324252627282930313233const double eps = 1e-8, INF = 1e9 ;using namespace std ; double A[MAXN][MAXM] ;int N, M, B, E, i, j, k, p ; double res, t, cost[MAXM], _need[MAXM] ;inline void Pivot(int e, int l)&#123; cost[l] /= A[l][e], t = A[l][e], A[l][e] = 1; for (i = 1 ; i &lt;= M ; ++ i) if (i != e) A[l][i] /= t ; for (i = 1 ; i &lt;= N ; ++ i) if (i != l &amp;&amp; abs(A[i][e]) &gt; eps)&#123; cost[i] -= A[i][e] * cost[l] ; for (p = 1 ; p &lt;= M ; ++ p) if (p != e) A[i][p] -= A[i][e] * A[l][p] ; A[i][e] = - A[i][e] * A[l][e] ; &#125; res += _need[e] * cost[l] ; for (i = 1 ; i &lt;= M ; ++ i) if (i != e) _need[i] -= _need[e] * A[l][i] ; _need[e] = - _need[e] * A[l][e] ;&#125;double simplex()&#123; while (true)&#123; double MINX = INF ; j = 0, k = 0 ; for (j = 1 ; j &lt;= M ; ++ j) if (_need[j] &gt; eps) break ; if (j &gt; M) return res ; for (i = 1 ; i &lt;= N ; ++ i) if (A[i][j] &gt; eps &amp;&amp; MINX &gt; cost[i] / A[i][j]) k = i, MINX = cost[i] / A[i][j] ; if (MINX &gt;= INF) return INF ; Pivot(j, k) ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%lf", &amp;cost[i]) ; for (i = 1 ; i &lt;= M ; ++ i)&#123; scanf("%d%d%lf", &amp;B, &amp;E, &amp;_need[i]) ; //约束 for (j = B ; j &lt;= E ; ++ j) A[j][i] = 1.0 ; &#125; printf("%d\n", (int)(simplex() + 0.5)) ; return 0 ;&#125; 怎么说呢，似乎单纯形有好多地方的写法都比较灵活让我不知道背什么样的板子会更好 $\rm{0x02}$ [NOI2008] 志愿者招募传送门：https://www.luogu.org/problemnew/show/P3980 什么鬼啊这不是上面的那道题吗 还是：$$\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots m)\\\\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \geq A_i \quad (i = 1,2,3\cdots n)$$其中$x_j$表示选择的第$j$类志愿者的个数，$w_{i,j}$表示在第$i$天，第$j$类志愿者能否选择。那么还是老样子，对偶过去就可以得到：$$\text{最大化} \quad \sum A_ix_i \quad(i = 1,2,3\cdots n)\\\\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \leq c_i \quad (i = 1,2,3\cdots m)$$怎么说呢……这个一开始的建模比上一个题还是有难度的，因为上一个题的$L_i,R_i$跟约束有关，而这次的$L_i,R_i$则是跟目标函数有关——或许不应该这么说，但是看上去确实不如上面那题跟约束有关系就对了(我在BB一堆什么啊) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cmath&gt; #include &lt;cstdio&gt;#include &lt;iostream&gt;#define INF 1e9#define MAXN 1035#define MAXM 10010const double eps = 1e-8 ; double res ;using namespace std ; int b[MAXM], e[MAXM] ; int N, M, i, j, k ; double C[MAXM], _need[MAXM], A[MAXM][MAXN] ; inline void Pivot(int posN, int posC)&#123; C[posC] /= A[posC][posN] ; // constraint divided by A_&#123;l,e&#125; for (int p = 1 ; p &lt;= N ; ++ p) if (p != posN) A[posC][p] /= A[posC][posN] ;//this line Booom A[posC][posN] = 1 ; // Pivot is above, taking it back is below for (int p = 1 ; p &lt;= M ; ++ p)//taking back to constraints if (p != posC &amp;&amp; fabs(A[p][posN]) &gt; eps)&#123; C[p] -= A[p][posN] * C[posC] ; for (i = 1 ; i &lt;= N ; ++ i) if (i != posN) A[p][i] -= A[p][posN] * A[posC][i] ; A[p][posN] = 0 ; &#125; res += _need[posN] * C[posC] ;//this time results in a better INIT-Sol for (int p = 1 ; p &lt;= N ; ++ p) if (p != posN) _need[p] -= _need[posN] * A[posC][p] ; _need[posN] = - _need[posN] * A[posC][posN] ;&#125;inline double simplex()&#123; while(1)&#123; j = 0, k = 0 ; double MAX = INF ; for (j = 1 ; j &lt;= N ; ++ j) if (_need[j] &gt; eps) break ; /*1*/ if (j &gt; N) return res ; //make-it-sure if go on for (i = 1 ; i &lt;= M ; ++ i) if (A[i][j] &gt; eps &amp;&amp; MAX &gt; C[i] / A[i][j]) MAX = C[i] / A[i][j], k = i ; //find the min_val constraint if (MAX &gt;= INF) return INF ; /* this task is unbounded */ Pivot(j, k) ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; _need[i] ; for (i = 1 ; i &lt;= M ; ++ i)&#123; scanf("%d%d%lf", &amp;b[i], &amp;e[i], &amp;C[i]) ; for (j = b[i] ; j &lt;= e[i] ; ++ j) A[i][j] = 1 ; &#125; printf("%d\n", (int)(simplex()+0.5)) ; return 0 ;&#125; $\rm{Reference}$ $[1]$ :$Candy?$的$blog$ $^{^{[\nearrow ]}}$]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
        <tag>线性规划/对偶定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络流24题专题】1·较简单的费用流]]></title>
    <url>%2F2019%2F03%2F29%2Fnw-flow-24-1%2F</url>
    <content type="text"><![CDATA[主要包括三个问题：运输问题，分配问题和数字梯形问题。 $\rm{Preface}~$关于网络流，一直是我的一个阴影……因为去年暑假，大家都会而网络流，我因为觉得这个算法没意思就没学，结果rqy来给我们考试网络流那题被全场打爆了——除了我qaq。 于是决定开始做这些题，每道题都会标注我看题解程度多少，如果太高的话会被自己嫌弃的qaq……希望自己能争气一点。 $\rm{0x01}$ 运输问题传送门：https://www.luogu.org/problemnew/show/P4015 看了，程度大概80%……呃我知道这个题不难，但是毕竟我上次写费用流可是几百年之前了啊……qaq 其实就是$$S\stackrel{f = a_i,c = 0}{\longrightarrow}i \stackrel{f = Inf,c = c_{i,j}}{\longrightarrow}j \stackrel{f = b_j,c=0}{\longrightarrow}T$$ 其中$i$代表仓库的编号，$j$代表商店的编号，建完图跑费用流即可。 由于SPFA死了，所以就一直用$dijk$做费用流，只不过难背一点……然后第二问的话就把权值取负重新做一下费用流就好。 总结一下，这个题似乎是比较裸的费用流的题了？一般费用流大概都是用来求解最优化问题的吧qwq…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct Edge&#123; int to, next, f, c ;&#125;E[MAXN] ; int head[MAXN], cnt = -1 ;int S, T, N, M, dist[MAXN], i, j, k, t[MAXN], x ; struct node&#123; int dist, num ; bool operator &lt;(const node &amp; now) const&#123;return dist &gt; now.dist ; &#125;&#125;; priority_queue&lt;node&gt; q ; bool vis[MAXN] ; int Last[MAXN], F[MAXN], H[MAXN], Pre[MAXN], MAX_C ;inline void Add(const int &amp;u, const int &amp;v, const int &amp;f, const int&amp; c)&#123; E[++ cnt].to = v, E[cnt].c = c, t[cnt] = f ; E[cnt].f = f, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].c = -c, t[cnt] = 0 ; E[cnt].f = 0, E[cnt].next = head[v], head[v] = cnt ;&#125;inline bool dijkstra()&#123; q.push((node)&#123;0, S&#125;) ; vis[S] = dist[S] = 0, F[0] = Inf ; for (i = 1 ; i &lt;= T ; ++ i) dist[i] = F[i] = Inf, vis[i] = 0 ; while (!q.empty())&#123; node now = q.top() ; q.pop() ; int fr = now.num, sec = now.dist ; if (vis[fr]) continue ; for (vis[fr] = 1, k = head[fr] ; k != -1 ; k = E[k].next)&#123; int nowc = sec + E[k].c + H[fr] - H[to(k)] ; if (E[k].f &gt; 0 &amp;&amp; !vis[to(k)] &amp;&amp; dist[to(k)] &gt; nowc)&#123; dist[to(k)] = nowc, q.push((node)&#123;dist[to(k)], to(k)&#125;) ; F[to(k)] = min(F[fr], E[k].f), Pre[to(k)] = fr, Last[to(k)] = k ; &#125;//!!!!! &#125; &#125; return dist[T] &lt; Inf ;&#125;void MCMF(int qwq)&#123; int _Ed ; MAX_C = 0 ; while (dijkstra())&#123; _Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ; while(_Ed != S) E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ 1].f += F[T], _Ed = Pre[_Ed] ; for (i = 0 ; i &lt;= T ; ++ i) H[i] += dist[i] ; /* cout &lt;&lt; MAX_C &lt;&lt; endl ; */ &#125; cout &lt;&lt; MAX_C * qwq &lt;&lt; endl ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M, S = 0 ; T = N + M + 1, memset(head, -1, sizeof(head)) ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;x), Add(S, i, x, 0) ; for (i = N + 1 ; i &lt;= N + M ; ++ i) scanf("%d", &amp;x), Add(i, T, x, 0) ; for (i = 1 ; i &lt;= N ; ++ i) for (j = N + 1 ; j &lt;= N + M ; ++ j) scanf("%d", &amp;x), Add(i, j, Inf, x) ;// for (i = 0 ; i &lt;= cnt ; ++ i) printf("%d %d %d\n", E[i].to + 1, E[i].f, E[i].c) ; MCMF(1) ; for (i = 0 ; i &lt;= cnt ; ++ i) E[i].f = t[i], E[i].c = -E[i].c ; MCMF(-1) ; return 0 ;&#125; $\rm{0x02~}$ 分配问题传送门：https://www.luogu.org/problemnew/show/P4014 这道题由于实在太水了，所以没有看题解(窃喜 其实就是建$2n$个点，然后$i \stackrel{f = Inf,c = base_{i,j}}{\longrightarrow} j$就连完了。 不得不说…建边真的是太水了，太水了，qaq 1234567891011121314151617181920此处是dijkstra……void MCMF(int qwq)&#123; int _Ed ; MAX_C = 0 ; while (dijkstra())&#123; _Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ; while(_Ed != S) E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ 1].f += F[T], _Ed = Pre[_Ed] ; for (i = 0 ; i &lt;= T ; ++ i) H[i] += dist[i] ; /* cout &lt;&lt; MAX_C &lt;&lt; endl ; */ &#125; cout &lt;&lt; MAX_C * qwq &lt;&lt; endl ;&#125;int main()&#123; memset(head, -1, sizeof(head)) ; cin &gt;&gt; N ; S = 0, T = N &lt;&lt; 1 | 1 ; for (i = 1 ; i &lt;= N ; ++ i) Add(S, i, 1, 0) ; for (i = N + 1 ; i &lt;= N + N ; ++ i) Add(i, T, 1, 0) ; for (i = 1 ; i &lt;= N ; ++ i) for (j = N + 1 ; j &lt;= N + N ; ++ j) cin &gt;&gt; x, Add(i, j, Inf, x) ; MCMF(1) ; for (i = 0 ; i &lt;= cnt ; ++ i) E[i].c = -E[i].c, E[i].f = t[i] ; MCMF(-1) ; return 0 ;&#125; $\rm{0x03}~$数字梯形问题传送门：https://www.luogu.org/problemnew/show/P4013 看题解：$90\%$+…我是真没见过这种建边方式啊喂，并且我一开始建的边很迷…我没有看到，呃，换句话说，我看到了然后忘了，一个数只能向正下方和右下方走…… 第一问·完全不相交的路径我真是要菜死了，题解里面说”拆点已经是烂大街的$trick$了”，我：？？？ 大概就是每个点拆成两个点，原因是我们需要把点上的限制转化成边上的限制，所以需要进行拆点，然后对于某个点和它的副本连一条$f=1,c=-base[x]$的边，毕竟是求最大值。然后$S$和最顶上的连$f=1,c=0$的边，$T$和最下面一层连$f=1,c=0$，就完了。 第二问 · 边不相交的路径我们考虑此时其实是删除了点的限制，那么我们就将每个点和自己的副本之间的边容量改成$Inf$，并把$T$与最底下的所有点的容量扩为$Inf$即可。注意后半部分的扩容，其目的在于防止中间节点的扩容被限制。 第三问 · 随便的路径既然都随便了，就直接把所有的边都设置成$Inf$，但是显然的是我们不能扩$S$连出去的边。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859inline bool dijk()&#123; for (i = 0 ; i &lt;= tot + 2 ; ++ i) dist[i] = F[i] = Inf, vis[i] = 0 ; dist[S] = 0, q.push((Node)&#123;S, 0&#125;) ; while (!q.empty())&#123; Node now = q.top() ; q.pop() ; int num = now.num, dis = now.dist ; if (vis[num]) continue ; for (int k = head[num] ; k != -1 ; k = E[k].next)&#123; int DIS = E[k].c + H[num] - H[to(k)] + dis ; if (DIS &lt; dist[to(k)] &amp;&amp; !vis[to(k)] &amp;&amp; E[k].f) F[to(k)] = min(F[num], E[k].f), dist[to(k)] = DIS, q.push((Node)&#123;to(k), DIS&#125;), Pre[to(k)] = num, Last[to(k)] = k ; &#125; &#125; return dist[T] &lt; Inf ;&#125;inline void MCMF()&#123; Ans = 0 ; while (dijk())&#123; _End = T, Ans += (dist[T] - H[S] + H[T]) * F[T] ; while (_End) E[Last[_End]].f -= F[_End], E[Last[_End] ^ 1].f += F[_End], _End = Pre[_End] ; for (i = 0 ; i &lt;= tot + 2 ; ++ i) H[i] += dist[i] ; /*cout &lt;&lt; -Ans &lt;&lt; endl ;*/ &#125;&#125;int L1, R1, L ;int main()&#123; memset(head, -1, sizeof(head)) ; cin &gt;&gt; M &gt;&gt; N ; S = 0, T = 1 ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt; M + i ; ++ j) cin &gt;&gt; base[i][j], Id[i][j] = (tot += 2) ; for (i = 1 ; i &lt;= M ; ++ i) Add(S, Id[1][i], 1, 0) ; L = cnt + 1 ; for (L1 = cnt + 1, i = 1 ; i &lt;= N + M ; ++ i) Add(Id[N][i] + 1, T, 1, 0) ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt; M + i ; ++ j) Add(Id[i][j], Id[i][j] + 1, 1, -base[i][j]) ; R1 = cnt ; for (i = 1 ; i &lt;= N ; ++ i) for (j = 1 ; j &lt; M + i ; ++ j) if (i &lt; N) Add(Id[i][j] + 1, Id[i + 1][j], 1, 0), Add(Id[i][j] + 1, Id[i + 1][j + 1], 1, 0) ; MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ; for (i = 0 ; i &lt;= cnt ; ++ i) E[i].f = t[i] ; for (i = L1 ; i &lt; R1 ; i += 2) E[i].f = Inf ; for (i = L1 + 1 ; i &lt;= R1 ; i += 2) E[i].f = 0 ; MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ; for (i = 0 ; i &lt;= cnt ; ++ i) E[i].f = t[i] ; for (i = L ; i &lt; cnt ; i += 2) E[i].f = Inf ; for (i = L + 1 ; i &lt;= cnt ; i += 2) E[i].f = 0 ; MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ; return 0 ;/* 以下是错误的建边 for (i = 1 ; i &lt;= M ; ++ i) cin &gt;&gt; base[++ tot], Add(S, tot, 1, -base[tot]) ; for (i = 1 ; i &lt; N ; ++ i) for (j = 1 ; j &lt;= M + i ; ++ j)&#123; cin &gt;&gt; base[++ tot] ; int sd = (2 * M + i - 2) * (i - 1) / 2 + 1 ; for (int k = sd ; k &lt;= (2 * M + i - 1) * i / 2 ; ++ k) Add(k, tot, Inf, -base[tot]) ; &#125; for (T = tot + 1, i = tot - (N + M - 1) + 1 ; i &lt;= tot ; ++ i) Add(i, T, 1, 0) ; ++ tot, MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ; */ /*MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ; */&#125; 嗯，大概这三个题就先分成一组吧！]]></content>
      <categories>
        <category>网络流二十四题</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
        <tag>费用流/最小费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想七 · 言葉の庭]]></title>
    <url>%2F2019%2F03%2F28%2F%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD%2F</url>
    <content type="text"><![CDATA[​ Hello darkness my old friend. 黯淡如旧，今时重逢。​ I’ve come to talk with you again. 阔别久日，可赴低叙？​ Because a vision softly creeping. 如梦如幻，于我心萦。​ Left its seeds while I was sleeping. 遗之入梦，齐我心同。​ And the vision that was planted in my brain. 不知归处，不知归处。​ Still remains with the sound of silence. 行舟如风，遣舟迟暮。​ In restless dreams I walk alone. 吾心独行，兰皋止息。​ Narrow streets of cobble stone. 越陌度阡，可有一醉？​ Beneath the hallo of a street lamp’, 如光化影，于我心寂。​ I turned my collar to the cold and damp. 浊寒入襟，刺我心底。​ When my eyes were stabbled. 所见皆幻，所见皆明。​ By the flash of a neon light. 万物皆虚，万物皆允。​ That split the night. 不知归处，不知归处。​ And touched the sound of silence 星瀚灿漫，行人慢走。 ​ ——『$\rm{The ~Sound~of~Silence}$』寂静之声 随想系列目次表：戳我 这次大概会写的时间线很跳跃，但我真的是被这个故事叩击了心脏最深处的地方。 $\rm{Part~1}$月考结束了。我终于有时间把这本书读完。 之前是一次周末，固定的奥赛时间。中途课件去学校的书店逛——一个不错的书吧，书墨香透着小资情调。 我在不起眼的地方，偶然发现了一本《言叶之庭》——看起来是最后一本了，想都没想就买了。38元，不便宜，薄薄的一本，但是封面却是一片令人赏心悦目的浓绿——是用油彩画的树叶，很漂亮——遂觉得不算物不抵价。 但买回来才发现，不是新海诚的写的，而是他的一个“好基友”加纳新太，站在秋月孝雄的立场写的。剧情大体上跟我一年之前看过的46分钟的短片差不多，“就当买了收藏吧”我想。 《言叶之庭》是我去年刚来实验部的时候接触的新鲜东西之一——初中时只懵懂地看过《你的名字》，被里面超越时空的爱情吸引的不要不要的。当时看完确实觉得是部好片，因为剧情很吸引人——当然，大多数都是我的主观感情在起作用，因为当时懵懂的我正好迫切地渴望一次说走就走的爱情。 那本薄薄的书又带我回想起了第一次看《言叶之庭》时的满足和愉悦，于是便决定买新海诚的原版来看。我并不认为新海诚的原版会比加版或动画版好多少，毕竟故事就是那么个故事，无非是视角不一样罢了。 并且我也觉得，似乎加版和电影版刻画的人物都太单薄了？反正我在看完加版之后，又重看了一遍电影版，发现不光人物好几处画崩了，有些东西写的似乎太少——不只是意犹未尽了，更像是连说都没说完。所以我一直期待着能够赶紧月考完，好让我在老师忙于讲题+阅卷、没空布置作业的时候，有空看一下新海诚的原版——原版是月考前的大休来的货，书封的主色调是白色的，封1是一张动画电影里的截图——一只睡莲，躺在下着雨的河里。 或许那时我还不知道，我将会看到一个怎样完整、优秀、细腻的故事——电影和加版，和原版比起来，简直贻笑大方。 $\rm{Part~2}$感动，满足，幸福，美好……都是我看完的第一想法；独步天下，绝无仅有……则是第二想法。 连续两个中午未眠，再加上考完试的轻松，让我在$3$月$28$日中午读完了这本书。还有二十分钟才吹起床哨，遂决定小眠片刻，谁知梦里朦胧的，全是言叶里面的内容，全是雪野和孝雄，全是棉花糖一样柔软香甜的梦幻，在我的脑海里欺负、沉淀、卷缩、舒张——那真是我有生以来经历过的最单纯而又美好的时光之一。 我更加坚定地认为，这种只属于梦幻的东西，这种“天上语”，“天籁之音”，都应该留在那个梦幻的世界里——大抵上就是要把“现实”和“梦幻”割裂开来吧。我认为，把这种“此曲只应天上有，人间难得几回闻”的美好，带到这个现实的、令人失望的世界，是一种对它的侮辱。 所以，我不打算去看知乎的评论，不愿去看书评，不愿去与别人聊起这部小说——我只想把这种最单纯的梦幻，留给最纯粹的世界，精心地呵护。 …… 说起原因，大抵上有很多。比如电影里剧情的淡薄，在这部小说里得到了很好的充实，让我满足得很；比如雪野和孝雄之间未曾言明，但是却无比真挚、无比纯粹、无比坚固的爱情——那是最美好的爱情了吧，厮守，陪伴大概是最长情的告白；比如书中每个人的心理活动，细腻，真切，读起来一气呵成；比如…… 但是我总感觉，这些其中的某个，或者是他们的并集，从客观上讲，都不能成为让我如此动容的理由。 现在想来，上一次如此感动至深，还是在看真人电影版的《我想吃掉你的胰脏》的时候。我自认为像这种具有强大感染力的文艺作品，用动画去表现实在是太单薄了——或许需要好的演员，或许需要好的文字，总之，小说和真人电影，都要有更好的效果——当时哭的稀里哗啦的。我也不知道到底为何而哭，明明男女主之间都没有令人羡慕的爱情，明明女主最后都已经在劝男主忘掉她，明明情节就是那么的简单俗套…… 我不知道为什么。 总之，很美就对了。我大概需要再过好多好多天才能缓过来吧。现在的状态大概是一闲下来就会想起言叶里面的内容，每当独自一个人时，脑子里便全是$1.$百香里和孝雄之间如潺潺不绝的流水一样的真挚感情$2.$百香里是如何一个人扛过那些岁月的$3.$他们最后相遇以后会怎样，在一起之后会怎样的快乐……感觉自己仿佛变成了一个多情细腻的小姑娘，重复回想着书中的一幕幕。“如果站在新海诚的作家立场上看，他这本书对我这个读者来说，已经是极为成功的了吧”我心想。 我甚至会幻想世界上真有一个百香里，一个孝雄，他们在某个时间点相遇、相伴、相携、相知、相爱……那该是多美好的童话啊。或许百香里经历的一切，其背后的原因都是那么的无厘头、甚至是荒谬——毕竟是青春期的孩子一首酿成的错误——但或许老天是为了有个利用奖赏给她一份完美的、童话般的爱情，才会先让她经历一些痛苦吧。毕竟如果雪野不经历这些，或许他跟孝雄就会是永远陌生人了…… 突然感觉自己真的…居然都开始相信主观唯心主义了…真是不可救药地沉浸在这本书里了啊。 这绝对是我读过的最美的故事了。 $\rm{Part3}$现在是$3.27$的中午，我躺在寂静的宿舍里，看着《言叶之庭》——大概，“三分之一是读完了吧?”我想。 “这本书大抵上是新海诚在拍《言叶之庭》之前写的吧，”我想，“所以或许会跟很无聊，毕竟情节是都知道的”。确实，看完加版、重温完电影版之后，如果是相同的内容，对我来说确实是有点枯燥。 但是当我现在看到主角为“秋月翔太”这一章时，似乎感到了什么奇怪的事情发生了——书中对男主哥哥的描写得如此详细，甚至绝大部分情节都是原作里面没有的。虽然前面几节里面也有或多或少的情节没在电影里出现，但是一整章的内容全部掐掉，也未免太狠心了吧。 我突然开始着迷起来，开始觉得新海诚是个小天才了——其情节设置的是如此的合理，让我越来越感到满足。原本困倦的我似乎来了精神，“一定要赶紧读完”，我心想。 …… 读完之后，后记里面新海诚是这么描述的： 我一直单恋着小说。不只是小说，我觉得自己也一直单恋着漫画、电影、动画与现实中的风景。也就是说，这是一种「我喜欢对方，对方却对我没什么兴趣」的状态。我也知道自己是四十几岁的成年人了，不该再想这些没有意义的事，但我却怎么样也摆脱不了这种情绪。 …… 写小说是很愉快的，我能够尽情写出动画表达不出来的情节，或是很难的内容。例如，写到「她的脸上浮现迷途孩子般的微笑」，我就会（对身为动画导演的自己）示威：「怎样！」怎样？这句话很难用影像表现吧！演员能恰如其分诠释出「迷途孩子般的表情」吗？动画师能画出每个人一看就知道是「迷途孩子」的脸吗？不可能！不安的表情或许可以办到，但是「迷途孩子般的」这种简洁明白的形容，很难利用影像呈现。又或是当我写到：「门外的喧闹声，宛如从耳机里外溢的声音……」，我就会狞笑心想：「这个你（影像）也做不到吧？」观众无法从教室的环境音联想到耳机声音外溢云云。我透过写作切身感受到，小说的乐趣就在于文字的连结。我注意到自己利用写后记的方式来回顾那段时光时，就会独自感到雀跃不已，总之就是非常地幸福。 …… 写完一本书最大收获，反而是更加深了我对于小说和动画的单恋情怀。反正我本来就不期待两情相悦。我有时会想到，孝雄对雪野的感情，是否也有相似的东西？若这么说来，本书里的角色多多少少都在单恋。我重新体悟到自己想写的，就是人们的这种心情——孤单渴望某个人、某项事物的心编织出这个世界。而本书想要描述的就是这点。在「爱」以前，这是段「孤独希求」的故事。这句话是电影版的宣传文案。想必现代也有不少人对于远在一千三百年前的万叶时代，将「恋爱」这个字，写作「孤悲（孤寂悲伤）」深表同感。 我想，这大概也是这部小说迷人的因素之一吧——原本就已经很完整的情节，加上妙笔的勾勒，瞬间活灵活现起来。 $\rm{Part~4}$选了几段放到这里，留作纪念。 首先是最后，孝雄和雪野重逢的情景： 走过日本庭园的木桥，雨声又起了些微变化。树叶摇曳的声音，胜过雨滴敲打水面的声音。自制的雕花皮鞋，缓缓踏在土壤上的脚步声，伴着绿绣眼清脆的鸣啭。越过日本黑松所见到的水面、杜鹃花倒映在水面上的粉红色、千头赤松树皮的红色，以及枫叶的灿绿色。孝雄的后背包里装着为那个人打造的鞋子。那是一双约五公分高的小巧尖头高跟鞋，鞋尖是浅粉红色，鞋身是近乎白色的浅肤色，脚踵处是仿佛阳光照耀的柠檬黄色，缠绕在脚踝上的长脚踝带上缝着枫叶的形状。这双鞋是为了那个人打造，一定可以走得更长更远。不知从何处传来老乌鸦强有力的鸣叫，远方的天空隐约响起了雷鸣声。——隐约雷鸣。孝雄脱口而出这句话。一股预感充满全身。已经可以看到浸湿枫叶后侧的凉亭，那里坐着一个人。孝雄吸入雨水的气味，克制住自己的心情，继续走向凉亭，穿过层层树叶后，整座凉亭映入眼帘。那是一位穿着浅绿色裙子的女人。孝雄停下脚步。有着一头剪至齐肩柔软短发的女人，正把咖啡举到嘴边，她轻轻瞥了他一眼。看着雪野从快要哭出来的紧绷表情，逐渐绽开笑容。孝雄心想，雨好像停了。 然后是孝雄表白完、雪野拒绝后，雪野的心声： 「可是你的衣服还没干……」雪野望着他远去的背影，不由得大叫。不对，这样正好。雪野逼自己收回视线，低头看着手中的咖啡杯，隐约听见他关上更衣间的门。雪野把还没喝上一口的咖啡杯举到嘴边，袅袅升起的热气微微沾湿了睫毛。她想要喝咖啡，却觉得杯子沉重异常，只得把它放回桌上。雪野体内有一团像刺猬般带刺的情绪，笨拙地四处乱闯。这情绪似乎是后悔和内疚，正一阵阵刺痛雪野的心并沉默地责怪她。不然我该怎么做？雪野几乎就要哭出来了。我从一开始就没有选择的余地。我明明那么真诚地对待每一个人，明明想成为像阳菜子老师那样温柔体贴的大人，明明努力回应任何一个需要我的人。雪野看着逐渐稀薄的咖啡热气。我不要待在世界的外围，我想进到世界的里面，我想成为这个耀眼世界的一部分。我以为只要长大，一切就会顺利；我以为照这样下去，就能和大家一样正常生活。可是，却发现自己被卷入那些像淋雨般避不掉的灾难里。先是伊藤老师出现，然后牧野同学出现，最后相泽同学也出现，我的生活变得一团糟。好不容易来到屋檐下可以躲躲雨，这回秋月出现了。每个人都在扰乱我的心，我想要静静地待着。但我一个人就连只是站着，都如此勉强，每天光是不让自己蹲下，就必须耗费莫大的力气。听见脚步声慢慢移近，雪野抬起头。他站在浅浅的青绿色影子里，身上已经换上应该还是半干的制服。「那个，我要走了。各方面来说，非常感谢你。」他静静说完，深深一鞠躬，不等雪野回应便朝着玄关走去。「啊！」雪野不自觉离座起身。等等，多待一会儿吧。你没有带伞，对吧？等雨停再走吧？——不对，不是这样，不可以这样说。雪野默然不语，又一次慢慢坐回椅子上。他的脚步声愈来愈远，穿鞋的声音，转开门把的声音。然后—— 啪嗒。关门的声音。那一瞬间，雪野突然感到很气愤。「笨蛋！」她大吼一声，抓起坐着的椅子作势要扔出去，可是，她怒视的前方已经没有半个人在。她顿时泄气地慢慢放下椅子，再次坐了下来。「……笨蛋。」她小声地又说了一次。秋月那个笨蛋。一副单方面被甩的受害者表情、一副自己没做错任何事的表情，你根本不知道你没来凉亭的暑假里，我是怀抱着什么样的心情度过。你的高一暑假一定过得很欢乐吧！你可以每天和家人一起吃饭，可以和班上女同学去喝茶，你根本完全无法想像大你十二岁的女人过着什么样的生活。一阵鼻酸，热气堵住喉咙，胸口苦闷难受，眼眶渗出泪水，她以手掌紧紧按住双眼阻止这一切，湿眼皮内侧浮现犹如细窄迷宫般的白色纹路。始终搁在桌上的那杯咖啡，仍在无声无息地持续冷却着。——结束这段时光的人，是你啊！雪野不禁有些埋怨。你果真还是个孩子。如果你不说那种话，我们说不定还能一起吃饭、交换连络方式，或是你会在我要回老家那天来送我，说不定我们还能够以温和平静、痛苦最少的方式，静静地结束我们的关系。其实我一直在忍耐。其实我一直没有说出口。其实我一直没有说出来过—— 我喜欢你。 还有两段段很有名的摘录下来： 二十七岁的我，丝毫不比十五岁时候的我聪明。雪野望着阳光愈来愈炫目、影子逐渐加深的庭园，带着有人在为自己打分数的心情，如此想着。 还有孝雄的情感爆发： 孝雄故意打断她的话，什么也不想听，「雪野姐，请你忘了我刚才说的话。」仿佛事先背好的台词，孝雄很自然、干脆地说出这句话。他直直望着雪野，说出必须说的话，说出他觉得为了她应该要这么说的话：「我其实很讨厌你。」吹进来的雨滴打在脸颊上。雪野十分哀伤地眯着眼。孝雄真的觉得自己非常厌恶事到如今才露出这副表情的她。「我一开始就觉得你这个人……有够讨厌，一大早就在公园里喝啤酒，还留下莫名其妙的和歌。」孝雄说着。过去因为这个雨女而尝到的困惑、焦躁、嫉妒、憧憬、期盼、祈求、希望、绝望等所有情绪，逐渐化为怒意。他再也管不住自己的嘴巴。「你从来不说自己的事，却老是探听我的事。你早就知道我是你的学生吧？你这种做法有够卑鄙！」讨厌！我讨厌这个女人。一副受到伤害的表情，现在又一副要哭的样子，我最讨厌她了！「如果知道你是老师，我绝对不会告诉你鞋子的事。反正你会觉得那是做不到，也不可能实现的梦想，对吧？你为什么不那样说？还是你觉得这只是小孩子讲的话，随便应付一下就好？」讨厌！我讨厌自己像孩子一样，为这种事情嚷嚷。「你一开始就知道我向往什么、憧憬谁，也知道那个人不会接受、目标永远不会实现。你都知道！」我讨厌自己在女人面前哭得这么难看，我一直一直努力当个大人，你却把我变成这副模样。我讨厌你！「……既然如此，你应该一开始就对我说啊！说我碍事！说臭小子快去上学！说你讨厌我！」但如果不这么做，我会一辈子都爱着你。好喜欢好喜欢好喜欢，就连现在的每一分每一秒也更加喜欢你。「你就一直那样……」——开什么玩笑，怎么连你也哭了？「你就一直那样，摆出若无其事的表情……」秋月的泪水滴滴答答滑落，大吼着。「——一直孤单一人，度过一生吧！」 …… 今天是三月二十九日，我突然好像明白了自己如此着迷与这个故事的原因。 孤独。 对，就是这个词，孤独。 无论是《我想吃掉你的胰脏》真人电影也好，《言叶之庭》也好，男主一直是孤独的——只不过他们自己不觉得孤独，但是却有一种呼之欲出的孤独感；紧接着他们分别遇到了女主，从此开始不再孤独——孝雄可以每逢雨天去亭子里和雪野相见，春树也可以每天有樱良为伴——虽然不清楚春树到底喜不喜欢这样。 总之，本来单调的生活，突然就多彩了起来：眼前是未曾见过的亮丽景色。一切仿佛是命中注定，有种天赐的使命感让你爱她，而她也让你的生活看起来没有那么无聊——“每个不曾起舞的日子。都是对生命的辜负”，她或许就是你生命中的领舞者。总之，心中如同拨云见日了一样，有着明快的节奏和爽朗的旋律。 或许新海诚已经说出来了，他想营造的就是“孤独”的气氛，而这冰凉冰凉的孤独如同一把有着水蜜桃香气的箭，穿过我胸腔前薄薄的几层肌肤，直戳我内心最柔软的地方——我好孤独啊。 或许一旦我忙起来，我就不再对《言叶》有这么深厚的感情了；或许一旦我有了可以让我的生活热闹起来的人，我就不再对《言叶》有这么深层次的共鸣了；或许…… 但我没有啊，哈。 但是我因此而悲伤吗？或许吧。但我更庆幸可以有这个机会，想未谙世事的小女孩一样肆意幻想这个世界上最美好的东西。这对我来说，或许已经足够了。 天边是一抹飘逸的鱼肚白，点缀着一只金黄色的太阳，随卷舒的云在碧蓝的天空中摇曳，有着别致的美感。 $\rm{Part~5/Ending}$今天是$3$月$31$日，我终于可以直面一些东西了。比如我在听到言叶的主题曲时，不在感到孤独和压抑，更多的则是对新生活的盼望。 我一直在想，这本书到底能带给我什么。 是如何小心地呵护一个人吗？是为了一个目标（比如孝雄对制鞋）要不断披荆斩棘吗？是要坚强吗？是要珍惜身边每一个人吗？是……？…… 我不知道，但我觉得我列举的每个目的都太肤浅。 或许读书，读一个令人感动的故事，真的不会带来什么特别的东西。但那会化成血与肉，填充进我的身体；会化成一缕青烟，迷蒙在我的脑海里，最终沉积下来，到它应该到的地方去。 说的太模糊了，“到它应该到的地方去”，究竟是到哪去呢？是沉积到脑袋里，沉积在心里，还是沉积在我身体上随便哪个器官上？又或许它根本不会停留，于我而言只是一个过客，可以突然从我身上蒸发走呢……？ 我不会知道——毕竟，我连自己的路都仍不知要如何去走，我连自己的去处都仍不知该何处寻觅，这种事情我也更不会知道了吧。 $\mathfrak{Orchidany, 3,31,2019}$]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】线性规划对偶定理]]></title>
    <url>%2F2019%2F03%2F19%2F%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[$\rm{Preface:} About~Duality~Theorm$线性规划对偶定理：我们朴素的线性规划大致如下：$$\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)$$那么我们称它的对偶为形如下的线性规划：$$\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)$$ 换做矩阵表示就会是这样：$$\text{最小化}\quad \boldsymbol{b^Ty} \\\text{满足约束} \quad A^T\boldsymbol{y\geq c} \\\\it{\qquad \qquad \quad} \boldsymbol {y} \geq 0$$那其实比较显然的是，我们原来线性规划中的约束向量与目标函数里的系数向量交换，目标函数的最大化变成了最小化。现在我们思考对偶的意义。 首先假设我们有这么一个线性规划：$$\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)$$其实就是上面那个 我们的目的其实等价于确定目标函数的下界。我们观察每一组约束，假设有一组约束是$$\quad \sum \limits_{j=1}^{m} a_{p,j}y_{j} \geq c_p\quad (i = 1,2,3\cdots n)$$并且我们保证有：$$\forall a_{p,j} \in \boldsymbol{a_p},\forall b_i \in{\boldsymbol{b}},\quad i=j \Longrightarrow b_i\geq a_{p,j}$$好像写的很不规矩……意思就是对应项的系数，目标函数都比这个约束里的大。 那么因为$\forall x\geq 0$，所以我们可以保证目标函数的最小值一定会是$c_p$。这个结论是显然的。 更进一步，那么我们最后确定的下界一定会是这样的（此处一点也不严谨地使用了$\Omega$符号）：$$\Omega(\rm{Aim}) = \it{\sum \limits_{j = 1}^{n}t_j\cdot\sum\limits_{i=1}^{n}\sum \limits_{k=1}^{m}a_{i,k}y_k}\\\\forall t_j \geq 0$$ 而因为我们对于原来的约束有$$\quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n)$$所以我们将其代回我们画好的式子里面：$$\Omega(\rm{Aim}) \geq \it{\sum\limits_{j=1}^{n}t_jc_j}$$那么……目标函数的下界就变成了一个和式的上界——又变成了一个求解目标函数最大值的问题。 那么这或许感性证明了对偶定理的正确性？ $\rm{Afterword:}Some~Typical~Problem$没见过吧，一篇文章只有前言和总结 其实博主就是在疯狂划水/摸鱼 其实常见的对偶问题有很多，博主功力不够，于是只能整理一个比较形式化的结论： $~$最大流问题形式化的最大流问题的线性规划如下：$$\text{最大化}\quad \quad \quad ~f_{s\to t} \quad ~ \quad \quad \quad \quad \quad \quad \\\text{满足约束} \quad \quad f_{u\to v} \leq L_{u \to v}\qquad (u,v) \in E \\ \qquad \quad \quad ~\sum\limits_{u}f_{u \to v} = \sum\limits_{v}f_{v \to u}\qquad u\in V \\ \qquad \qquad \qquad ~~\quad f_{u\to v} \geq 0 \qquad (u,v) \in E ~\cup \text{e(s,t)}$$其中$e(u,v)$表示链接$u,v$的路径集合，$f$表示流量，$L$表示容量(Limit)。 其对偶过去就会是：$$\text{最小化}\quad \quad \quad \sum_{(u,v)\in E}L_{u\to v}d_{u \to v} \quad ~ \quad \quad \quad\\\text{满足约束} \quad \quad d_{u\to v}-p_u+p_v \geq 0\qquad (u,v) \in E \\ \qquad \quad \quad \quad \quad \quad ~~p_s - p_t \geq 1\qquad u\in V \\ \qquad \qquad \qquad \quad p_i,d_{i\to j}\in\{0,1\} ~\qquad$$里面$d_{i\to j}$表示$i \to j$这条边有没有被割，同时假设我们割完之后，原来的图分成了两部分$S$和$T$,那么会有$p_i = [i \in S]$。这个限制是为了保证割的逻辑性——所有的割边都连接着$S,T$两个集合，且源点和汇点在不同的集合。 emmm我实在不想再整理了(写式子太麻烦)，等什么时候我退完役闲下来再说吧233 $\rm{Reference}$ $[1]$ :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· $^{^{[\nearrow]}}$ 提取码：vua4]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线性规划</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
        <tag>线性规划/对偶定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】NTT和任意模数NTT]]></title>
    <url>%2F2019%2F03%2F17%2FNTT1-2%2F</url>
    <content type="text"><![CDATA[$0x01\quad \rm{Preface}$无特别说明，本文不区分$n$和$N$两种符号，均表示形式为$2^j(j \in \mathbb{N+})$的多项式长度（或者，次数）。 我们知道，对于$FFT$而言，其得以优化成$\log$的根本原因是找到了单位复根这个东西，可以方便处理+计算。而另一种方法则是在模意义下，利用原根的美妙性质，进行多项式卷积。 $\boldsymbol{NTT~\text{(Fast Number-Theoreti Transform)}}$，快速数论变换。在分析$NTT$是如何利用原根之前，需要先分析$FFT$是如何利用的单位复根$^{[1]}$： $\omega_n^n = 1$。 $\omega_n^1,\omega_n^2, \omega_n^3\cdots\omega_n^{n-1}$是互不相同的，这样带入计算才能保证插出一个完整的$n$次多项式。 {$\omega_n^2$} = {$\omega_{\frac{n}{2}}^{2}$}，这使得问题规模可以在计算的时候减半。 $$\sum \limits _{k=0}^{n-1} (\omega_n^{j-i})^k = \begin{cases} 0 \quad i \neq j \newline n \quad i = j \newline \end{cases}$$ 这样可以保证我们能够使用相同的方法进行逆变换。 首先，原根的基本定义：设$g$为$p$的一个原根，则满足：$$𝑔^{𝑝−1} \equiv 1(\mod p) \\∀1≤𝑘&lt;𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)$$换句话说$g^0,g^1,g^2\cdots,g^{p-2} \quad (\bmod p)$ 是互不相同的数，满足性质二。 同时如果我们令$p-2$作为这个群的阶，那么$g^{p-1}$和$\omega_n^n$，其实就是等价的，只不过$$g^{p-1} \equiv1(\bmod~p) \ \omega_n^n=1$$而已。于是就满足性质一。 而对于性质三，我们先考虑一个转化。我们如果要将$g$作为单位根的替代的话，就需要用到$g^{\frac{p-1}{N}}$。换句话说，$N | (p-1)$。那么我们便可以令$g_n^k \equiv g^{\frac{k(p-1)}{N}} (\bmod~p)$，得到一个和单位根相似的形式。 那么接下来，因为$p$是素数，所以在$g_n^n\equiv g^{\frac{N(p-1)}{N}}\equiv g^{p-1} \equiv 1 (\bmod ~p)$的基础上，我们可以得到$g_{2n}^{n} \equiv1\quad\text{or}\quad \text{-1} (\bmod~ p)$，那么平方之后性质三便显而易见；或者考虑另一种思路，我们根据刚才得出的、跟二次剩余有些相似的式子，可以得到以下结论：$$ g_n^{\frac{n}{2}+k}=-g_n^k (\bmod~p)$$ 再结合显而易证的消去引理$g_n^k \equiv g_{jn}^{jk}$，我们可以很自然像$FFT$证明单位复根的折半性一样，证出这个结论。 至于性质四，证明的大体相似于单位单位复根。即：$$ \sum\limits_{j =0}^{n-1}{(g_n^k)^j} \equiv \frac{(g_n^k)^n -1}{g_n^k -1} \Longrightarrow \frac{(g_n^n)^k -1}{g_n^k -1} \equiv \frac{(1)^k -1}{g_n^k -1} = 0$$ 而对于$n=k$的情况，不适用于普通的几何级数求和，所以直接就是$\sum 1 =n$ 。 $0x02\quad \rm{Codes}$呃，于是NTT就完了。注意因为要保证$N | (p-1)$，且$N$是$2$的幂次，所以素数$p$一定要是$2^j+1$的形式。 至于求原根，不是本界探讨的内容。普通的NTT模数，原根可以背过；其余情况暴力求+验证即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int N, M, K, qaq ;const int MAXN = 3000010 ;LL A[MAXN], B[MAXN], Inv ;const double Pi = acos(-1.0) ;int i, j, k, l, Lim = 1, L, R[MAXN] ; const int P = 998244353, G = 3, Gi = 332748118 ; namespace IO&#123; const int ch_top=4e7+3; char ch[ch_top],*now_r=ch-1,*now_w=ch-1; inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x; &#125; inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w=' '; &#125;&#125;inline LL expow(LL a, LL b)&#123; register LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= P ; (a *= a) %= P, b &gt;&gt;= 1 ; &#125; return res ;&#125;void NTT(LL *J, int flag)&#123; for(i = 0; i &lt; Lim; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ; for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123; LL Gn = expow(flag == 1 ? G : Gi, (P - 1) / (j &lt;&lt; 1)) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123; LL g = 1 ; for(l = 0 ; l &lt; j ; l ++, g = (g * Gn) % P)&#123; LL Nx = J[k + l], Ny = g * J[k + j + l] % P ; J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ; &#125; &#125; &#125;&#125;using namespace IO ;int main()&#123; fread(ch,1,ch_top,stdin); N = read(), M = read() ; while(Lim &lt;= N + M) Lim &lt;&lt;= 1, L ++ ; for(i = 0; i &lt;= N; i ++) A[i] = (read() + P) % P ; for(i = 0; i &lt;= M; i ++) B[i] = (read() + P) % P ; for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; NTT(A, 1), NTT(B, 1); for(i = 0; i &lt;= Lim; i ++) A[i] = (A[i] * B[i]) % P ; Inv = expow(Lim, P - 2) ; NTT(A, -1) ; for(i = 0; i &lt;= N + M; i ++) write((long long) (A[i] * Inv + P) % P) ; fwrite(ch, 1, now_w - ch, stdout) ; return 0 ;&#125; 其中Gi表示$998244353$的原根的逆元。 $0x03\quad \rm{Extending}$接上节内容，$NTT$本质上是只能处理“$NTT$模数（$p=2^k+1$）”。但是当我们需要对其进行任意模数取模时，就需要我们用$CRT$合并。 然后…我也不知道从哪找到了一张比较浅显的图： 但是这个地方仍然会存在不少问题，巨佬KsCla如此解释： 具体做法是这样：先选取三个乘积在$10^{23 }$以上的便于使用NTT的模数。在这里我选的是$m_1=998244353=223∗119+1$，$m_2=1004535809=221∗479+1$，$m_3=469762049=226∗7+1$。选这三个模数的好处在于它们的原根都是3。然后用这三个模数做NTT，可以得到以下三条式子：$$~ans≡c_1~(\bmod m_1)\\\ans≡c_2~(\bmod m_2)\\\ans≡c_3~(\bmod m_3)$$虽然这三条式子可以在$10^{23}$以内唯一固定$ans$的值，但问题也随之而来：$m_1∗m_2∗m_3$很大，无法直接用long long存下，而用long double之类的则会丢失精度，所以无法用普通的$CRT$。难道要写高精度？ 不，有一种很妙的方法可以解决这个问题。首先注意到这里只有三个模数，而且两个模数乘起来是不会爆long long的，所以可以先合并前两条式子。根据CRT，有：$$ans≡(c_1m_2Inv(m_2,m_1)+c_2m_1Inv(m_1,m_2))(\bmod m_1m_2)$$其中$Inv(x,y)$表示x关于y的逆元。这条式子涉及到两个很大的数相乘然后再取模，而直接相乘会爆long long。可以用$O(\log(m_1m_2))$的快速乘，或者$O(1)$转double后相乘。为了方便，把上式化成这样的形式：$$ans≡C(\bmod M)$$然后设：$$ans=xM+C=ym_3+c_3$$接下来的部分才是精髓。我们求出$x$在$\bmod m_3$意义下的值：$$xM≡c_3−C(\bmod m_3)$$在$\bmod m_3$意义下，$ym_3$被消掉了。 然后有：$$x≡(c_3−C)M−1(\bmod m_3)$$算出右半部分的值为$q$，则可令$x=km_3+qx=km_3+q$。将其代入$ans=xM+C$：$$ans=(km_3+q)M+C=km_3M+qM+C$$也就是说：$$ans=km_1m_2m_3+qM+C$$而由于$ans∈[0,m_1m_2m_3)$，所以$k$必为0。也就是说$ans$就是$qM+C$！直接把这条式子对题面要求的模数取模即可. 嗝……其实我就是加了一遍mkd，但是也算是复习了一遍吧XD。 有一点是需要注意的： 为什么要选三个乘积大于$10^{23}$的质数作为模数？ 为了是最后的结果可以不取模 嗯，然后就是板子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define rr register#define LL long longconst int G = 3 ;int N, M, K, qaq ;using namespace std ;const int MAXN = 600010 ;int i, j, k, l, Lim = 1, L, R[MAXN] ; int Mod, P, pr[] = &#123;469762049, 998244353, 1004535809&#125; ;LL Ans[4][MAXN], A[MAXN], B[MAXN], Inv, A1[MAXN], B1[MAXN] ;inline LL qr()&#123; LL k = 0, f = 1 ; char c = getchar() ; while(!isdigit(c)) &#123;if(c == '-') f = -1 ;c = getchar() ;&#125; while(isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48 ,c = getchar() ; return k * f ;&#125;inline LL expow(LL a, LL b, LL p)&#123; register LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;void NTT(LL *J, int flag)&#123; rr int i, j, k, l ; for(i = 0; i &lt; Lim; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ; for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123; LL Gn = expow(G, (P - 1) / (j &lt;&lt; 1), P) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123; LL g = 1 ; for(l = 0 ; l &lt; j ; l ++, g = (g * Gn) % P)&#123; LL Nx = J[k + l], Ny = g * J[k + j + l] % P ; J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ; &#125; &#125; &#125; if (flag &gt; 0) return ; int Inv = expow(Lim, P - 2, P) ; reverse(J + 1, J + Lim) ; for (i = 0 ; i &lt;= Lim ; ++ i) J[i] = 1ll * J[i] * Inv % P ;&#125;void clear(LL *J, LL *L)&#123; for (rr int i = 0 ; i &lt; Lim ; ++ i) J[i] = L[i] = 0 ;&#125;void egg()&#123; return ; &#125;LL mul(LL a,LL b,LL p)&#123; LL re = 0; for (; b; b &gt;&gt;= 1,a = (a + a) % p) if (b &amp; 1) re = (re + a) % p; return re;&#125;void T_NTT()&#123; rr int i, j, k ; for (i = 0 ; i &lt;= 2 ; ++ i)&#123; P = pr[i] ; i ? clear(A1, B1) : egg() ; for (j = 0 ; j &lt;= N ; ++ j) A1[j] = A[j] ; for (j = 0 ; j &lt;= M ; ++ j) B1[j] = B[j] ; NTT(A1, 1), NTT(B1, 1) ; for (j = 0 ; j &lt; Lim ; ++ j) A1[j] = A1[j] * B1[j] % P ; NTT(A1, -1) ; for (j = 0 ; j &lt;= Lim ; ++ j) Ans[i + 1][j] = A1[j] ; &#125; rr LL Mo = 1ll * pr[1] * pr[0], k1, k2, a, b, c, mod = Mod ; LL inv1 = expow(pr[1] % pr[0], pr[0] - 2, pr[0]), inv0 = expow(pr[0] % pr[1], pr[1] - 2, pr[1]), inv3 = expow(Mo % pr[2], pr[2] - 2, pr[2]) ; for (i = 0 ; i &lt;= N + M ; ++ i)&#123; a = Ans[1][i], b = Ans[2][i], c = Ans[3][i] ; k1 = (mul(a * pr[1] % Mo, inv1, Mo) + mul(b * pr[0] % Mo, inv0, Mo)) % Mo ; k2 = ((c - k1 % pr[2]) % pr[2] + pr[2]) % pr[2] * inv3 % pr[2], Ans[0][i] = ((k2 % mod) * (Mo % mod) % mod + k1 % mod) % mod; &#125;/* LL a,b,c,t,k,M = 1ll * pr[0] * pr[1]; LL inv1 = inv(pr[1],pr[0]),inv0 = inv(pr[0],pr[1]),inv3 = inv(M % pr[2],pr[2]); for (int i = 0; i &lt;= deg; i++)&#123; a = fft[0].A[i],b = fft[1].A[i],c = fft[2].A[i]; t = (mul(a * pr[1] % M,inv1,M) + mul(b * pr[0] % M,inv0,M)) % M; k = ((c - t % pr[2]) % pr[2] + pr[2]) % pr[2] * inv3 % pr[2]; ans[i] = ((k % md) * (M % md) % md + t % md) % md; &#125;*/&#125;int main()&#123; rr int i ; N = qr(), M = qr(), Mod = qr() ; while(Lim &lt;= N + M) Lim &lt;&lt;= 1, L ++ ; for(i = 0; i &lt;= N; i ++) A[i] = qr() % Mod ; for(i = 0; i &lt;= M; i ++) B[i] = qr() % Mod ; for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; T_NTT() ; for(i = 0; i &lt;= N + M; i ++) printf("%d ", Ans[0][i]) ; return 0 ;&#125; 于是这玩意儿进行了9遍NTT，那是真的慢。。。 $\rm{Reference}$ KsCla的$blog$ $^{^{[\nearrow ]}}$]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】有趣的数学题]]></title>
    <url>%2F2019%2F03%2F17%2FMath1%2F</url>
    <content type="text"><![CDATA[两道小清新数学题，分别是[NOI2002]Savage和[Violet · 5]樱花 $\rm{[NOI2002]}$ Savage链接：$\color{violet}{Link}$ $\rm{Sol}$不算特别难…其实就是求方程$$C_{i}+P_{i}x \equiv C_j+P_jx ~(\bmod ~M)$$不存在一个解使得$x \leq min(L_i,L_j)$时，$M$的最小值。然后因为题目中的数据，假设我们令每个野人都只是绕着圈走而不重复经过对方的路径——即$M$的最大值，也不过是$100\times 106\times 100 = O(1e6)$的级别，于是考虑直接枚举$M$, 然后check。由于最多共有$15$个野人，且单次exgcd是$\log n $级别的，所以复杂度上限是$O (Mn^2 \log C_{max}) &lt; \Omega(1e8)$级别的。如果不是精心构造数据的话，可以直接艹过去。 喜闻乐见的是……我的exgcd似乎一开始有问题？我一开始是这么写的： 123456789inline bool check()&#123; for (i = 1 ; i &lt;= N ; ++ i) for(j = i + 1 ; j &lt;= N ; ++ j)&#123; int a = P[i] - P[j], b = M, x, y, w = C[j] - C[i] ; int qwq = exgcd(x, y, a, b) ; if (w % qwq) continue ; x = x * w / qwq ; while (x &lt;= 0) x += M ; if (x &lt;= min(L[i], L[j])) return 0 ; &#125; return 1 ;&#125; 然后觉得一点问题都没有，$40pts$之后愣了大半天。 而事实上这个地方$x$应该是一个特解，而不是最小解。换句话说我为了求出准确的$x$，应该不断取模$b/ \gcd(a,b)$ 为什么？至于为什么，一开始我也懵的很。直到我翻出来很久之前我的一篇题解： _这是上面这个式子为什么可以这么做的证明：_ 若有$ax+by=c$且$a_0x+b_0y=c$ 那么便有$a(x-x_0)+b(y-y_0)=0$两边同时除以$gcd(a,b)$可得：$\frac{a}{gcd(a,b)}(x-x_0)=-\frac{b}{gcd(a,b)}(y-y_0)$ $ \quad$ $(1)$ 而因为 $(\frac{a}{gcd(a,b)},\frac{b}{gcd(a,b)})=1$ 所以由$(1)$可得$\frac{b}{gcd(a,b)}$整除$(x-x_0)$ 所以很显然有$\frac{b}{gcd(a,b)}\times{t}={(x-x_0)},t \in Z$ 那么就有对于任意一个$x_i$，有 $ x_i=x_0+\frac{b}{gcd(a,b)} \times{t} $ 我特么…智商已经回退到上个世纪了吧$\rm{qaq}$，自闭了。 这就是我整理这道题的原因……还有，上面$P_i-P_j$似乎需要取模并使其变成正的，因为好像我的$exgcd$里面限制了$A&gt;0$的缘故。 心得：我退役吧嘤。 1234567891011121314151617181920int i, j, N, M, C[MAXN], P[MAXN], L[MAXN] ;int exgcd(int &amp;x, int &amp;y, int A, int B)&#123; if (!B) &#123; x = 1, y = 0 ; return A ;&#125; int t = exgcd(y, x, B, A % B) ; y -= A / B * x ; return t ; &#125;inline bool check()&#123; for (i = 1 ; i &lt;= N ; ++ i) for(j = i + 1 ; j &lt;= N ; ++ j)&#123; int a = (P[i] - P[j] + M) % M + M, b = M, x, y, w = C[j] - C[i], qwq = exgcd(x, y, a, b) ; if (w % qwq) continue ; x = x * w / qwq ; x = (x % (M / qwq) + (M / qwq)) % (M / qwq) ; if (!x) x += (M / qwq) ; if (x &lt;= min(L[i], L[j])) return 0 ; &#125; return 1 ;&#125;signed main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d%d%d", &amp;C[i], &amp;P[i], &amp;L[i]), M = max(M, C[i]) ; for ( M ; ; ++ M) if (check()) &#123; cout &lt;&lt; M &lt;&lt; endl ; return 0 ; &#125; &#125; $\rm{[Violet～5]}$ 樱花链接：$\color{violet}{Link}$ 这是好久之前做的一道题，突然被我发现了。大概就是求方程$$\frac{1}{x}+\frac{1}{y} = \frac{1}{n!}\quad (n \leq 1e6)$$的解的组数。 $\rm{Sol}$不想思考系列问题，我这么懒还是退役吧。(sigh) 我们将柿子变个形：$$\frac{x+y}{xy} = \frac{1}{n!} \\n!x + n!y = xy$$然后我就不会了，此题完结 然后有一步很妙的是两边同时$+(n!)^2$得到：$$(n!)^2 + n!(x+y) -n!(xy) = (n!)^2\\(n!-x)(n!-y)=(n!)^2$$然后就会发现我们只需要找出$(n!)^2$的因子个数就好了… 好像我从来没有写过$\tau$的样子，既然这样我就顺便记一个算因子个数的公式吧（其实就是乘法原理啦）$$x = \prod p_ix^{a_i} \longleftrightarrow\tau(x) = \prod (a_i+1)$$其实就是为了水字数 $\rm upd ~on ~6.13$ : 我发现自己似乎之前听过这个题的”另解”，以前自己整理过： $233$窝萌思考一个比较显然的问题，就是一定会有$y&gt;n!$。那窝萌不妨设$y = n!+T$，那么带回到原式里面就会有$$\frac{1}{x} + \frac{1}{n!+T} = \frac{1}{n!}$$继而有$$x = \frac{n!^2}{T}+n!$$那么其实一共就有$\tau(n!^2)$个合法答案，所以我们转而求$n!^2$的约数数量。 但是显然的是我们并不可以直接求解，当然我不知道高精度之后会怎么样，估计$nlogn$一下还是有可能过的。但是考虑到常数巨大，所以卡过$1e6$基本上是痴人说梦。所以我们思考一种清新脱俗我根本想不出来的做法。 窝萌考虑筛出所有的$1-n$素数来，然后对于一个素数而言，由于窝萌要判断的对象是$n!$，他有一个奇妙的性质就是$$n!=\prod \limits_{i=1}^{n}{i}$$那么也就是说我们只需要判断对于一个当前给定的素数$p$，在$1-n$的所有数里面，$p$作为因子出现了多少次即可。那么也就是这个式子： $$Ans = \prod \limits _{p \in prime }^{p \leq n}{\sum \limits _{i \geq 1}^{p^i \leq n}{\lfloor \frac{n}{p^i}} \rfloor +1}$$ 我们每次遍历一遍，保证只加一次，譬如质数$3$，三的倍数的个数产生的贡献是一，三的平方的倍数产生的贡献是二，但是我们从前往后扫的话，每次就只要增长一个贡献即可（类似于去重操作$233$） 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;bitset&gt;#include &lt;iostream&gt;#define ll long long#define MAXN 10000100#define Mod 1000000007int Prime[MAXN] ;std :: bitset &lt;MAXN&gt; vis ; long long N, i, j, cnt, Ans, Cnt[MAXN] ;void Ego()&#123; vis[1] = vis[0] = 1 ; for (i = 2 ; i &lt;= N ; ++ i)&#123; if (!vis[i]) Prime[++ cnt] = i ; for (j = 1 ; j &lt;= cnt ; ++ j)&#123; if (i * Prime[j] &gt; N) break ; vis[i * Prime[j]] = 1 ; if (!(i % Prime[j])) break ; &#125; &#125; for (i = 1 ; i &lt;= cnt ; ++ i) for (j = Prime[i] ; j &lt;= N ; j *= Prime[i]) ( Cnt[i] += (N / j) ) %= Mod ; &#125;int main()&#123; std :: cin &gt;&gt; N ; Ans = 1ll, Ego() ; for (i = 1 ; i &lt;= cnt ; ++ i) (Ans *= (Cnt[i] &lt;&lt; 1) + 1) %= Mod ; std :: cout &lt;&lt; Ans % Mod &lt;&lt; std :: endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学/扩展欧几里德</tag>
        <tag>数学/素数/素数筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】一类线段树的转移]]></title>
    <url>%2F2019%2F03%2F17%2FSegment-Tree1%2F</url>
    <content type="text"><![CDATA[奇奇怪怪的线段树散发着奇奇怪怪的香气（ 最近大概是泛做了线段树相关题目，但是这些线段树大概都需要比较强的思维和比较长的代码……$2333$ $\rm{Task1} $子段和其实这个算是比较简单的了，毕竟$qyf$曾经给我们讲过，当时我就觉得十分的……麻烦233. 那么例题其实就是$\rm{SPOJ}$的$GSS$系列——的前三道题(后几道题都不会做) $GSS1$区间求最大子段和(不带修)$\color{violet}{Link}$ $2333$应该算是比较简单的了。我们对于每个区间维护一个区间和，维护一个从最左端开始且必须包含最左端元素的最大子段和，再维护一个从最右端开始且必须包含最右端元素的最大子段和，最后维护一个区间最大子段和。 那么转移($push$_$up$)时就显得十分方便。我们的父区间的$Lmax$只取决于左子区间的$Lmax$和当左区间的$Sum$等于$Max$时（即左区间全部都要纳入到其最大子段和中时），左区间的$Sum$与右区间的$Lmax$的和。那么对于区间的$Rsum$，也是一个道理。最终对于该区间的最大子段和，我们不考虑从已经转移来的$Lmax/Rmax$，而是考虑从左右区间的$Max$以及左右区间的和来转移。大体代码： 123456inline void P_u(int rt)&#123; S(rt) = S(ls(rt)) + S(rs(rt)) ; Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ; Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ; Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;&#125; 还有值得注意的一点：在询问的时候，它比较膈应……就是由于是连续的，所以你不能直接像普通的线段树一样询问然后加起来……所以所就要类似于边询问，边$push_up$这种感觉。 123456789Tree query(int rt, int l, int r)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt] ; Tree res, A, B ; if (mid &gt;= R) return query(ls(rt), l, mid) ; if (mid &lt; L) return query(rs(rt), mid + 1, r) ; A = query(ls(rt), l, mid), B = query(rs(rt), mid + 1, r) ; res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ; res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; return res ;&#125; 然后总代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 200010#define LL long long#define max my_Fuckmax#define ls(rt) rt &lt;&lt; 1#define rs(rt) rt &lt;&lt; 1 | 1#define mid ((l + r) &gt;&gt; 1)using namespace std ;struct Tree&#123; LL S, Sum, Lsum, Rsum ;&#125;T[MAXN &lt;&lt; 1] ; int N, M, L, R, base[MAXN] ; #define S(x) T[x].S#define Sum(x) T[x].Sum#define Lsum(x) T[x].Lsum#define Rsum(x) T[x].Rsuminline LL my_Fuckmax(LL A, LL B)&#123; return A &amp; ((B - A) &gt;&gt; 63) | B &amp; ((~(B - A)) &gt;&gt; 63) ;&#125;inline void P_u(int rt)&#123; S(rt) = S(ls(rt)) + S(rs(rt)) ; Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ; Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ; Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;&#125;inline void build(int rt, int l, int r)&#123; if (l == r)&#123; T[rt].Lsum = T[rt].Rsum = T[rt].S = T[rt].Sum = base[l] ; return ; &#125; build(ls(rt), l, mid), build(rs(rt), mid + 1, r), P_u(rt) ;&#125;Tree query(int rt, int l, int r)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt] ; Tree res, A, B ; if (mid &gt;= R) return query(ls(rt), l, mid) ; if (mid &lt; L) return query(rs(rt), mid + 1, r) ; A = query(ls(rt), l, mid), B = query(rs(rt), mid + 1, r) ; res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ; res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; return res ;&#125;int main()&#123; cin &gt;&gt; N ; register int i ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]) ; build(1, 1, N) ; cin &gt;&gt; M ; while (M --) scanf("%d%d", &amp;L, &amp;R), printf("%lld\n", query(1, 1, N).Sum) ; return 0 ;&#125; $GSS3$ 区间求最大子段和(带修)$\color{violet}{Link}$ ……其实吧，这个带修不带修……好像影响并不大？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 200010#define LL long long#define max my_Fuckmax#define ls(rt) rt &lt;&lt; 1#define rs(rt) rt &lt;&lt; 1 | 1#define mid ((l + r) &gt;&gt; 1)using namespace std ;bool MArk ;struct Tree&#123; LL S, Sum, Lsum, Rsum ;&#125;T[MAXN &lt;&lt; 1] ; int N, M, L, R, base[MAXN] ; #define S(x) T[x].S#define Sum(x) T[x].Sum#define Lsum(x) T[x].Lsum#define Rsum(x) T[x].Rsuminline LL my_Fuckmax(LL A, LL B)&#123; return A &amp; ((B - A) &gt;&gt; 63) | B &amp; ((~(B - A)) &gt;&gt; 63) ;&#125;inline void P_u(int rt)&#123; S(rt) = S(ls(rt)) + S(rs(rt)) ; Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ; Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ; Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;&#125;inline void build(int rt, int l, int r)&#123; if (l == r)&#123; T[rt].Lsum = T[rt].Rsum = T[rt].S = T[rt].Sum = base[l] ; return ; &#125; build(ls(rt), l, mid), build(rs(rt), mid + 1, r), P_u(rt) ;&#125;Tree query(int rt, int l, int r)&#123; if (L &lt;= l &amp;&amp; r &lt;= R) return T[rt] ; Tree res, A, B ; if (mid &gt;= R) return query(ls(rt), l, mid) ; if (mid &lt; L) return query(rs(rt), mid + 1, r) ; A = query(ls(rt), l, mid), B = query(rs(rt), mid + 1, r) ; res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ; res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; return res ;&#125;inline void change(int rt, int l, int r, int k)&#123; if (L == l &amp;&amp; L == r)&#123; T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = k ; return ; &#125; if (L &lt;= mid) change(ls(rt), l, mid, k) ; else change(rs(rt), mid + 1, r, k ) ; P_u(rt) ;&#125;int main()&#123; cin &gt;&gt; N ; register int i ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]) ; build(1, 1, N) ; cin &gt;&gt; M ; while (M --) &#123; scanf("%d%d%d", &amp;MArk, &amp;L, &amp;R) ; if (!MArk) change(1, 1, N, R) ; else printf("%lld\n", query(1, 1, N).Sum) ; &#125;&#125; $GSS4$ 区间开根问题$\color{violet}{Link}$ 这个和子段和一点儿关系都没有，顺便整一下233. 就是让你区间开根（向下取整）+查询……这个东西大概就是对于一个$2^{63}$内的数值$N$，我们假设其开根$k$次可以得到$N &lt; 2$——只要$N &lt; 2$之后的计算就会集中在一个紧确的范围$(1,2)$内，向下取整之后永远都会是$1$，所以我们不需要再去考虑。 那么现在，我们致力于去确定$k$的值域。我们不得不承认，$\sqrt n$在$[0,+\infty]$是单调递增的，同理三次方根也是，四次方根也是……所以我们不妨取最大值，考虑$N=2^{63}$时，$k$值的大小。而很显然，此时的$k$应该为$\log _263+1 ≈ 6.978$——这似乎是十分平凡的结论。 总之，我们得出，似乎运算次数的上界就是$k≈7$，所以说我们直接暴力除就好了，聚合分析一下，复杂度的上界似乎是$\Omega(7n)$的样子，无非就是多几个常数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ll N, M, K, i, L, R ; ll base[MAXN], T[MAXN], tot ;inline void p_u(ll rt)&#123; ;&#125;void _Build(ll rt, ll l, ll r)&#123; if (l == r)&#123;T[rt] = base[l] ; return ;&#125; _Build(ls(rt), l, mid) ; _Build(rs(rt), mid + 1, r) ; T[rt] = T[ls(rt)] + T[rs(rt)] ;&#125;inline ll _query(ll rt, ll l, ll r, ll sl, ll sr)&#123; if (l &gt;= sl &amp;&amp; r &lt;= sr) return T[rt] ; ll ret = 0 ; if (mid &gt;= sl) ret += _query(ls(rt), l, mid, sl, sr) ; if (mid &lt; sr) ret += _query(rs(rt), mid + 1, r, sl, sr) ; return ret ;&#125;inline void _Sqrt(ll rt, ll l, ll r, ll sl, ll sr)&#123; if (l &gt;= sl &amp;&amp; r &lt;= sr)&#123; if (T[rt] &lt;= (r - l + 1)) return ; else &#123; if (l == r)&#123; T[rt] = (int)(pow((double)T[rt], 0.5)) ; return ; &#125; &#125; &#125; if (mid &gt;= sl) _Sqrt(ls(rt), l, mid, sl, sr), T[rt] = T[ls(rt)] + T[rs(rt)] ; if (mid &lt; sr) _Sqrt(rs(rt), mid + 1, r, sl, sr), T[rt] = T[ls(rt)] + T[rs(rt)] ;&#125;int main()&#123; while(cin &gt;&gt; N)&#123; ++ tot, printf("Case #%d:\n", tot) ; for (i = 1; i &lt;= N ; ++ i) base[i] = qr() ; _Build(1, 1, N) ; cin &gt;&gt; M ; for (i = 1; i &lt;= M ; ++ i)&#123; K = qr(), L = qr(), R = qr() ; if (L &gt; R) swap(L, R) ; if (K)&#123; printf("%lld\n", _query(1, 1, N, L, R)) ; continue ; &#125; _Sqrt(1, 1, N, L, R) ; &#125; printf("\n") ; &#125; return 0 ;&#125; $\rm{Task2}$ 最长连续问题这个东西其实应该跟最大子段和差不多——要求的都是连续的东西。对于所有包括连续字样的东西，基本的思路大概都是维护一个从左端开始的，维护一个从右端开始的，然后从下向上不断$push_up$即可。 $emmm$在这边整理几道思路不错的题吧： $\rm{USACO}$ 酒店($hotel$)$\color{violet}{Link}$ 初始的一个全零的序列，我们对它准确来说有以下三个操作： 区间置$0$ 区间置$1$ 询问是否有一段长度为$k$的连续的零区间，如果有的话，选取最靠左的，输出其左端点并执行操作② 这个题在我看来，应该算是一个思维题。对于最后一个操作，我十分地懵逼——因为我压根不知道该怎么维护。 但事实上……这就是学数据结构学傻了的后果……毕竟数据结构只会是一个辅助而已。仔细想来，好像除了权值线段树能够维护$\rm{DP}$之外，没做过什么数据结构的好题，都是一些数据结构的裸题……大概这就是学傻了吧，只会专一的一门学科，或者说只会专精一种东西——还是十分蠢笨迟钝地“专精”。 唉，大概检验一个人学没学过数据结构，不是通过他会不会做类似于$NOI2005$维护数列那样的毒瘤裸题，而是看他到底可不可以和其他的东西结合在一起。学习大抵也是同样的道理，不可以把学的东西迁移到其他地方，照样是白学吧。 诶，好像扯了什么奇怪的东西…… 回到正题，我们不考虑直接维护这个东西，而是通过维护区间内的最长连续$0$的个数，达到辅助查找区间的目的。那么我们查找区间的时候，就直接**择最左边的区间优先，并$check$其是否有足够的$0$。 对于查询，我们先查询左区间，再查询中间（左区间的右边与右区间的并集），最后查询右区间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct Tree&#123; int Sum, Len, Lsum, Rsum, tag ; &#125;T[MAXN &lt;&lt; 1] ; int A, B, N, M, MArk, i, t ;inline void push_down(int rt)&#123; if (T[rt].tag == -1) return ; else if (T[rt].tag == 0)&#123; T[ls(rt)].tag = T[rs(rt)].tag = 0 ; T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = 0 ; T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = 0 ; &#125; else&#123; T[ls(rt)].tag = T[rs(rt)].tag = 1 ; T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = T[ls(rt)].Len ; T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = T[rs(rt)].Len ; &#125; T[rt].tag = -1 ;&#125;inline void push_up(int rt)&#123; if (T[ls(rt)].Sum == T[ls(rt)].Len) T[rt].Lsum = T[ls(rt)].Len + T[rs(rt)].Lsum ; else T[rt].Lsum = T[ls(rt)].Lsum ; if (T[rs(rt)].Sum == T[rs(rt)].Len) T[rt].Rsum = T[rs(rt)].Len + T[ls(rt)].Rsum ; else T[rt].Rsum = T[rs(rt)].Rsum ; T[rt].Sum = max(T[ls(rt)].Sum, T[rs(rt)].Sum), T[rt].Sum = max(T[rt].Sum, T[ls(rt)].Rsum + T[rs(rt)].Lsum) ;&#125; void build(int rt, int l, int r)&#123; T[rt].tag = -1, T[rt].Len = T[rt].Lsum = T[rt].Rsum = T[rt].Sum = r - l + 1 ; if (l == r)&#123; return ; &#125; build(ls(rt), l, mid), build(rs(rt), mid + 1, r) ;&#125;void update(int rt, int l, int r, int ul, int ur, int k)&#123; if (ul &lt;= l &amp;&amp; ur &gt;= r)&#123; T[rt].tag = k ; if (k == 0) T[rt].Lsum = T[rt].Rsum = T[rt].Sum = 0 ; else T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].Len ; return ; &#125; push_down(rt) ; if (ul &lt;= mid) update(ls(rt), l, mid, ul, ur, k) ; if (ur &gt; mid) update(rs(rt), mid + 1, r, ul, ur, k) ; push_up(rt) ;&#125;int query(int rt, int l, int r)&#123; push_down(rt) ; if (l == r) return l ; if (T[ls(rt)].Sum &gt;= A) return query(ls(rt), l, mid) ; else if (T[ls(rt)].Rsum + T[rs(rt)].Lsum &gt;= A) return mid - T[ls(rt)].Rsum + 1 ; return query(rs(rt), mid + 1, r) ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; build(1, 1, N) ; while(M --)&#123; scanf("%d", &amp;MArk) ; if (MArk == 2) scanf("%d%d", &amp;A, &amp;B), update(1, 1, N, A, A + B - 1, 1) ; else &#123; scanf("%d", &amp;A) ; if (T[1].Sum &gt;= A) printf("%d\n", t = query(1, 1, N)), update(1, 1, N, t, t + A - 1, 0) ; else putchar('0'), putchar('\n') ; &#125; &#125; return 0 ;&#125; $emmm$这个题码量其实不大，思维含量也不高，但是成功地把做数据结构题做傻了的我拉回了正途。 $\rm{SCOI}$ 序列操作$\color{violet}{Link}$ 对于一个$01$序列，大体是这几种操作： 区间清零 区间置为$1$ 区间全部取非 区间查询$1$的个数 区间查询最长连续的$1$的长度 好的，这道题被我秒了，爽啊……不过秒是秒了，对拍调试法调了好久$233$。 其实对于$1,2,4,5$都好说，只是第$3$个操作，需要再另维护区间最长连续的$0$的长度，如果存在取非标记生效，就交换一下就行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127struct Tree&#123; int OS, OL, OR ; int Sum, Lsum, Len, Rsum, S, tag, t ; //tag = 1 -&gt; 1,tag = 0 -&gt; 0, tag = 2 -&gt; xor&#125;T[MAX &lt;&lt; 1] ; int N, M, MArk, L, R, base[MAX], i ;inline void up(int rt)&#123;// T[rt].S = T[ls(rt)].S + T[rs(rt)].S ; //1 if (T[ls(rt)].S == T[ls(rt)].Len) T[rt].Lsum = max(T[ls(rt)].Lsum, T[ls(rt)].Len + T[rs(rt)].Lsum) ; else T[rt].Lsum = T[ls(rt)].Lsum ; if (T[rs(rt)].S == T[rs(rt)].Len) T[rt].Rsum = max(T[rs(rt)].Rsum, T[rs(rt)].Len + T[ls(rt)].Rsum) ; else T[rt].Rsum = T[rs(rt)].Rsum ; T[rt].Sum = max(T[ls(rt)].Rsum + T[rs(rt)].Lsum, max(T[ls(rt)].Sum, T[rs(rt)].Sum)) ; //0 if (!T[ls(rt)].S) T[rt].OL = max(T[ls(rt)].OL, T[ls(rt)].Len + T[rs(rt)].OL) ; else T[rt].OL = T[ls(rt)].OL ; if (!T[rs(rt)].S) T[rt].OR = max(T[rs(rt)].OR, T[rs(rt)].Len + T[ls(rt)].OR) ; else T[rt].OR = T[rs(rt)].OR ; T[rt].OS = max(T[ls(rt)].OR + T[rs(rt)].OL, max(T[ls(rt)].OS, T[rs(rt)].OS)) ;&#125;inline void down(int rt)&#123;// if (T[rt].tag == -1) return ; if (T[rt].t == 1)&#123; T[ls(rt)].tag ^= 1, T[rs(rt)].tag ^= 1 ; T[ls(rt)].S = T[ls(rt)].Len - T[ls(rt)].S ; T[rs(rt)].S = T[rs(rt)].Len - T[rs(rt)].S ; //l T[ls(rt)].Sum ^= T[ls(rt)].OS ^= T[ls(rt)].Sum ^= T[ls(rt)].OS ; T[ls(rt)].Lsum ^= T[ls(rt)].OL ^= T[ls(rt)].Lsum ^= T[ls(rt)].OL ; T[ls(rt)].Rsum ^= T[ls(rt)].OR ^= T[ls(rt)].Rsum ^= T[ls(rt)].OR ; //r T[rs(rt)].Sum ^= T[rs(rt)].OS ^= T[rs(rt)].Sum ^= T[rs(rt)].OS ; T[rs(rt)].Lsum ^= T[rs(rt)].OL ^= T[rs(rt)].Lsum ^= T[rs(rt)].OL ; T[rs(rt)].Rsum ^= T[rs(rt)].OR ^= T[rs(rt)].Rsum ^= T[rs(rt)].OR ; &#125; if (T[rt].tag == 0)&#123; T[ls(rt)].tag = T[rs(rt)].tag = 0 ; T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = T[ls(rt)].Len ; T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = T[rs(rt)].Len ; T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = 0 ; T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = 0 ; &#125; if (T[rt].tag == 1)&#123; T[ls(rt)].tag = T[rs(rt)].tag = 1 ; T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = 0 ; T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = 0 ; T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = T[ls(rt)].Len ; T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = T[rs(rt)].Len ; &#125; T[rt].tag = -1, T[rt].t = 0 ; &#125;void _change(int rt, int l, int r, int k)&#123;// if (L &lt;= l &amp;&amp; r &lt;= R)&#123; T[rt].tag = k ; if (!k) T[rt].OL = T[rt].OR = T[rt].OS = T[rt].Len, T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = 0 ; else T[rt].OL = T[rt].OR = T[rt].OS = 0, T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = T[rt].Len ; return ; &#125; down(rt) ; if (L &lt;= mid) _change(ls(rt), l, mid, k) ; if (R &gt; mid) _change(rs(rt), mid + 1, r, k) ; up(rt) ; &#125;void _reverse(int rt, int l, int r)&#123;// if (L &lt;= l &amp;&amp; r &lt;= R)&#123; T[rt].t = 1 ; T[rt].Sum ^= T[rt].OS ^= T[rt].Sum ^= T[rt].OS ; T[rt].Lsum ^= T[rt].OL ^= T[rt].Lsum ^= T[rt].OL ; T[rt].Rsum ^= T[rt].OR ^= T[rt].Rsum ^= T[rt].OR ; return ; &#125; down(rt) ; if (L &lt;= mid) _reverse(ls(rt), l, mid) ; if (R &gt; mid) _reverse(rs(rt), mid + 1, r) ; up(rt) ; &#125;inline int Sum(int rt, int l, int r)&#123;// if (L &lt;= l &amp;&amp; R &gt;= r) return T[rt].S ; down(rt) ; int res = 0 ; if (L &lt;= mid) res += Sum(ls(rt), l, mid) ; if (R &gt; mid) res += Sum(rs(rt), mid + 1, r) ; return res ;&#125;inline void build(int rt, int l, int r)&#123;// T[rt].tag = -1 ; T[rt].Len = r - l + 1 ; if (l == r)&#123; if (!base[l]) T[rt].OL = T[rt].OR = T[rt].OS = 1 ; else T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = 1 ; return ; &#125; build(ls(rt), l, mid), build(rs(rt), mid + 1, r), up(rt) ;&#125;inline Tree query(int rt, int l, int r)&#123; if (L &lt;= l &amp;&amp; R &gt;= r) return T[rt] ; Tree res, A, B ; if (mid &gt;= R) return query(ls(rt), l, mid) ; if (mid &lt; L) return query(rs(rt), mid + 1, r) ; A = query(ls(rt), l, mid), B = query(rs(rt), mid + 1, r) ; res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ; res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;base[i]) ; build(1, 1, N) ; while (M --)&#123;// cout &lt;&lt; M &lt;&lt; " " &lt;&lt; "qwerweafasdfsdf" &lt;&lt; endl ; scanf("%d%d%d", &amp;MArk, &amp;L, &amp;R), ++ L, ++ R ; if (MArk == 0) _change(1, 1, N, 0) ; else if (MArk == 1) _change(1, 1, N, 1) ; else if (MArk == 2) _reverse(1, 1, N) ; else if (MArk == 3) printf("%d\n", Sum(1, 1, N)) ; else printf("%d", query(1, 1, N).Sum), putchar('\n') ;// cout &lt;&lt; " qwerweafasdfsdf " &lt;&lt; endl ; &#125;&#125; $push_up$真长啊$233$ 艹完这个题是真的爽啊~ $Task3~$ 总结一下其实这东西和$DP$是一样的吧？你只需要确定你想要维护什么(等价于确定状态)，然后明确父子区间如何向上维护(等价于状态之间如何转移)。 嗯，万物相同。 野马也，尘埃也，生物之以息向吹也。天之苍苍，其正色耶？其远而无所至极耶？ 不知为什么，突然想到了这句话。 $\mathscr{The~End}$]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>奇怪的技巧</tag>
        <tag>数据结构/线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】自适应Simpson法入门]]></title>
    <url>%2F2019%2F03%2F17%2FSimpson1%2F</url>
    <content type="text"><![CDATA[一种很可爱的积分近似法，学的时候顺便看了好多论文qaq $\rm{0x01}$ 前言首先阐明一点，自适应辛普森算法($\rm{Adaptive ~Simpson’s~ rule}$ )是一类近似算法($\rm{Approximation ~algorithm}$)，主要用于求较难反导的函数的积分。大概在信息计算的时候中很常用？ 其思想是利用二次函数来不断拟合($\rm{Overfitting}$)所求曲线，而所谓的$Adapative$（自适应）则是用于优化时间复杂度的方法。 嗝…总之…比较简单？ 表示看了两篇外国学者的论文，感觉好像思路已经比较清晰的样子。 $\rm{0x02}$ $\mathcal{Simpson~Formula}$ 辛普森公式稍等，这个跟算法的关系不大，主要是公式：$$\rm{\int _{l}^{r} f(x) \rm{dx}\approx \frac{f(r) +f(l)+ 4 \cdot f(m)}{6}} \,$$ 事实上吧，求积分的话，大多数都是直接套辛普森公式的。并且这个公式是广泛适用的……只不过误差有点儿人大$233$ 这其实是我们用二次函数不断拟合的结果，推导过程大致如下$^{[1]}$： 因为 $g(x)$ 是用来拟合 $f(x)$ 的，所以有：$$\int\limits_L^Rf(x)dx\approx \int\limits_L^Rax^2+bx+c\space dx$$求 $g(x)$ 的不定积分为：$$\int g(x)dx=\frac13ax^3+\frac12bx^2+cx+C$$然后再带入 R 和 L ：$$\int\limits_L^Rf(x)dx=\frac13a(R^3-L^3)+\frac12b(R^2-L^2)+c(R-L)$$然后提公因式，原式为：$$\frac{R-L}{6}(2a(R^2+LR+L^2)+3b(R+L)+6c)6R−L(2a(R2+LR+L2)+3b(R+L)+6c)$$把里面展开来：$$\frac{R-L}{6}(2aR^2+2aLR+2aL^2+3bR+3bL+6c)$$重新整理一下式子：$$\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+aR^2+aL^2+2aLR+2bR+2bL+4c)$$再整理：$$\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c))$$代换可得：$$aR^2+bR+c\approx f(R)\\\aL^2+bL+c\approx f(L)\\\4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c)\approx 4f(\frac{R+L}{2})$$把这三个式子带回去， 最后我们就得到了$\rm{Simpson}$ 积分公式：$$\int\limits_L^Rf(x)dx \approx \frac{R-L}{6}(f(L)+4f(\frac{L+R}{2})+f(R)))$$ 于是我们就得到了所谓的$\rm{Simpson~Fomula}$。但事实上，对于一段“跌宕起伏”的函数，我们还是无法准确地去用一个二次函数的拟合来刻画。于是—— $\rm{0x03}$ $\mathcal{Adaptive~Simpson~Rule}$ 自适应辛普森法我们考虑，如果把区间们稍微划分地更细一点，那是不是会好呢？答案是一定的。那么我们可以考虑定向二分。但是……定向二分始终存在一个问题，就是它太笨了，笨到如果$[l_1,r_1]$已经满足精度要求了，我们却还要一直分；笨到$[l_2,r_2]$分的次数根本不够用——但我们并不可以得到反馈。 于是考虑自适应。 所谓自适应，说的直白点，无非就是需要多分治几次的地方，多分治几次；不需要的则可以少分治几次 你会发现，其实他节约的就是一个点——时间效率。 举个栗子$^{[2]}$： 比如有这么个函数$\rm{f (x) = 13(x − x^2)e^{\frac{−3x}{2}} }$，我们要求$\int_{0}^{4}f(x) \rm{~dx}$ 并要求精度误差在$1e-5$ 以内。而我们有两种方法去解决： 以固定的比例以及约束二分。 运用自适应策略分配 那么我们首先要知道他真正的$value:$ 看起来好像海星？然后我们用两种方法都试一试： 首先是自适应法，我们发现最后只需要求$20$段区间。表中的$a_k \&amp; b_k$表示左右区间，$S(l,r)$表示$[l,r]$内、运用$0x01$中的公式计算的，$\rm{Error~Bound}$表示误差界，$\rm{Tolerance}$表示计算时需要的误差(程序设计时会讲)。 那么最后算出来的值是$ −1.54878823413$ ，与真实值误差为$0.00000013840 $，一共调用了$79$次函数估值（留个坑，后文会讲）。 那么绘制出来的函数图像大概长这样： 好像很流畅？$233$ 那么第二种方法是定值分段。我们考虑分成区间$[0,4]$分为长度为$0.03125$的$128$段，并运用$0x01$的$Formula$，最后得出的结果为$−1.54878844029$，误差为$0.00000006776$…… 好像是第一个误差的二分之一？听起来好像误差小了，但是却需要$257$次函数估值的调用……相比之下，我们可以获得更优越的性能，而那误差也是不需要考虑的啦的啦～ 但是比起$1e-5$精度来说……这波稳赚啊$233$ $\rm{0x04}$ $\mathcal{About~Code~}$ 代码实现首先是$LuoguP4525$的暴力解法： 12345678910111213141516171819202122232425#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define mid (l + r) / 2using namespace std ;const double Eps = 5e-8 ;double Ans, A, B, C, D, L, R ;inline double F(double x)&#123; return (C * x + D) / (A * x + B) ;&#125;inline double Simp_calc(double l, double r)&#123; return (r - l) / 6 * (F(l) + F(r) + 4 * F(mid)) ;&#125;inline double do_divide(double l, double r)&#123; double Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Simp_calc(l, r) ; if (fabs(t = (Lv + Rv - v)) &lt;= Eps) return Lv + Rv ; return do_divide(l, mid) + do_divide(mid, r) ;&#125;int main()&#123; scanf("%lf%lf%lf%lf%lf%lf", &amp;A, &amp;B, &amp;C, &amp;D, &amp;L, &amp;R) ; Ans = do_divide(L, R) ; printf("%.6lf", Ans) ; return 0 ; &#125; 这…严格意义上讲，不能算是自适应辛普森法——更准确地说，四不像，或者“东施效颦”之类的，都挺合适。这是我在初学这一块儿内容时的写法，他不严格正确，但是……他对的很？ 至于进化版$LuoguP4526$，也是完全可以violently艹过去的：1234567891011121314151617181920212223242526#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define mid (l + r) / 2using namespace std ;const double Eps = 5e-8 ;double Ans, A, B, C, D, L, R ;inline double F(double x)&#123; return pow(x, A / x - x) ;&#125;inline double Simp_calc(double l, double r)&#123; return (r - l) / 6 * (F(l) + F(r) + 4 * F(mid)) ;&#125;inline double do_divide(double l, double r, double Lans)&#123; double Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Lans ; if (fabs(t = (Lv + Rv - v)) &lt;= Eps) return Lv + Rv ; return do_divide(l, mid, Lv) + do_divide(mid, r, Rv) ;&#125;int main()&#123; scanf("%lf", &amp;A) ; L = Eps, R = 23.3 ; if (A &lt; 0) &#123; puts("orz"), cout &lt;&lt; endl ; return 0 ;&#125; Ans = do_divide(L, R, Simp_calc(L, R)) ; printf("%.5lf", Ans) ; return 0 ; &#125; 但是，其真正的实现应该是这样： 123456789101112131415161718192021222324252627282930#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define v Lans#define hps eps * 0.5#define mid (l + r) * 0.5using namespace std ;double Ans, A, L, R ;const double Eps = 1e-7 ;const double Liu = 1.0 / 6 ;inline double F(double x)&#123; return pow(x, A / x - x) ;&#125;inline double Simp_calc(double l, double r)&#123; return (r - l) * Liu * (F(l) + F(r) + 4.0 * F(mid)) ;&#125;inline double do_divide(double l, double r, double Lans, double eps)&#123; double Lv, Rv, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r) ; if (fabs(t = (Lv + Rv - v)) &lt;= eps * 15) return Lv + Rv + t / 15 ; return do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ; //据说eps×15来自于Wiki……&#125;int main()&#123; scanf("%lf", &amp;A) ; L = Eps, R = 30 ; if (A &lt; 0) &#123; puts("orz"), cout &lt;&lt; endl ; return 0 ;&#125; Ans = do_divide(L, R, Simp_calc(L, R), Eps) ; printf("%.5lf", Ans) ; return 0 ; &#125; 然后我们发现这就可以跟文章上面$0x03$中的例子呼应了：每次分治时计算两次，总共分治了$39$次，最终一共计算了$78+1=79$次，而二分则是一棵有$128$个叶子节点的递归树，总共计算了$256 +1=257$次。 好的，终于要扯正题了。算法的实现其实简单，我们用拟合性算法不断$check\&amp;calc$, 而$check$的方式也很简单，只需要判断一下两段子区间的函数值之和与整个区间的函数值之和的差值是否在精度要求范围之内，之后如果满足精度误差就直接$return$，否则对于这段区间继续递归下去。 而这个地方有个要求，就是对于$eps$，你需要不断$half$他，原因很简单，对于一整段区间$U$，要求他的返回值的$|eps(U)| \leq k$的话，那么对于其作为子集两个连续区间$A,B$，当$A \bigcup B = U$时，必须要满足$|eps(A)| \leq \frac{k}{2}, |eps(B)| \leq \frac{k}{2}$，才能保证$|eps(U) = eps(A) + eps(B)| \leq k$，所以要： 123#define hps eps * 0.5....................return do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ; 好了，唯一的问题在于有句话迷的很： 1if (fabs(t = (Lv + Rv - v)) &lt;= eps * 15) return Lv + Rv + t / 15 ; 这个$\leq 15 \cdot eps$是什么意思？ 好吧，笔者也不清楚，但是有个结论是长这样的： 什么？你说推什么倒？小小年纪整天想着推倒学姐可不好啊$233$ 什么？你还想看推倒的过程？啧啧啧，左转知乎感情专区蟹蟹～ 好的，以上两段是瞎扯的，推导过程十分诡异，大家自己食用好了…… 于是结束，撒花花…（不是撒笔者x） $\rm{Referance}$ $[1]$ :$NaCly_Fish$的$blog$ $^{^{[\nearrow]}}$ $[2]$ :某篇论文 $^{^{[\nearrow]}}$ 对于第二篇$refer$，借鉴的比较多（读书人的事……咳咳……），但是改了一个数据，就是$81 \to 79$，因为代码需要$233$ $Ps:$史上最不正经的$reference$诞生了……]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学/积分/积分近似</tag>
        <tag>计算几何/Simpson积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【题解】一类树上距离的计算]]></title>
    <url>%2F2019%2F03%2F16%2FCal-on-Tree1%2F</url>
    <content type="text"><![CDATA[好的，今天整理一类较为简单的树上针对边权的修改、查询、操作题。 问题大概有两类：只有查询$\&amp;$修改查询都有 $\mathscr{Task1}$普通的查询问题大概问题就类似于这个典型的$XOR$问题 其实说白了，这个题的解法十分简单——$LCA$ 但其实……我一开始考虑$LCA$，没有细致考虑，只是觉得如果从$u,v$分别向$LCA$跳，这并不可以提前处理或者提前维护，所以和暴力没有区别，于是就弃疗。 但是这个地方，$LCA$的作用十分巧妙——我们试图去拓展这个题。我们定义$D(\bigodot,r,u)$表示在运算$\bigodot$下，从根$r$到某一固定点$u$的边权运算结果，其中限定了运算$\bigodot$必须为可逆运算，比如说异或、加法、减法——注意，此时的可逆运算，可以是自可逆（自己对自己运算是逆运算，比如$A~XOR ~A = 0$）或者他可逆（即存在另一种运算，是这种运算的逆运算，比如加法之于减法），那么我们就可以很方便地得出它的一般形式$$D(\bigodot,u,v) = D(\bigodot,r,u) \bigodot D(\bigodot,r,v) ~\bigoplus ~(~2 \cdot D(\bigodot,r,LCA(u,v)~)~)$$ ，其中我们假设运算$\bigodot$与$\bigoplus$互逆。树上前缀和大抵上就是这个意思。 那么回到这个题，我们对于每一个点的$D$，都是十分方便计算的，因为无权时，$D(r,t) = depth[t]$是一个相当平凡的结论；有权时，则直接$dfs$一遍即可。每次查询是$log$级别的，所以时间复杂度的渐进上界就是比较显然的$O(\max(m \log_2n,n))$。 代码大概是这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354il int qr()&#123; int k = 0; char c = getchar() ; while(!isdigit(c)) c = getchar() ; while(isdigit(c)) k = (k &lt;&lt; 1 )+ (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;il void add(int u, int v, int w)&#123; e[++cnt].t = v ; e[cnt].next = head[u] ; e[cnt].v = w ; head[u] = cnt ; e[++cnt].t = u ; e[cnt].next = head[v] ; e[cnt].v = w ; head[v] = cnt ;&#125;void _build(int deep, int now, int f, int _xor)&#123; fa[now][0] = f, dep[now] = deep, XOR[now] = _xor ; for(int k = head[now]; k ;k = e[k].next)&#123; if(e[k].t == f) continue ; _build(deep + 1, e[k].t, now, _xor ^ e[k].v) ; &#125;&#125;il void init()&#123; Up = log(N) / log(2) + 1 ; for(i = 1; i &lt;= Up; i ++) for(j = 1; j &lt;= N; j ++) fa[j][i] = fa[fa[j][i - 1]][i - 1] ;&#125;il int LCA(int u, int v)&#123; if(dep[u] &lt; dep[v]) swap(u, v) ; pre = dep[u] - dep[v] ; for(j = 0; j &lt;= Up; j ++) if((1 &lt;&lt; j) &amp; pre) u = fa[u][j] ; if(u == v) return u ; for(j = Up; j &gt;= 0; j --) if(fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j] ; return fa[v][0] ;&#125;int main()&#123; N = qr() ; for(i = 1; i &lt; N; i ++)&#123; in1 = qr(), in2 = qr(), in3 = qr(); add(in1, in2, in3) ; &#125; M = qr() ; _build(1, 1, 0, 0), init( ); for(i = 1; i &lt;= M; i ++)&#123; in1 = qr(), in2 = qr() ; f1 = LCA(in1, in2) ; int t = XOR[in1]^XOR[f1]^XOR[in2]^XOR[f1] ; cout &lt;&lt; t &lt;&lt; endl ; &#125; return 0 ;&#125; $\mathscr{Task~2}$带有修改的查询问题：之后我们紧接着尝试去探讨一类带有修改边权的树上操作，大概题目就是某年国家集训队的板子题和一道经典的边权修改启蒙题 我们考虑，纷繁的操作，此时好像树剖比较合适些。但无论怎样，树剖是剖点的，不是剖边的。所以我们自然而然地想到要去把边权转移到点权上面。转移到哪儿去呢？显然只能转移到深度大的点上，因为在树这种结构里面，一对多决定了每个节点如果想要只保留一个属性（权值），就不能让父节点保留边权——否则父节点就会同时保有许多属性，并且叶子结点会没有属性，导致逻辑关系十分混乱。 所以，我们就应该把边权放到深度大的节点上，对节点进行操作。事实上，此处唯一需要注意的问题就是，我们在操作的时候要忽略$LCA(u,v)$，这是显然的。关于这一点，我们的方法是把之前树剖里面的这一句： 12_query(1, 1, N, Id[u], Id[v]) ; _update(1, 1, N, Id[u], Id[v], d) ; 改成 12_query(1, 1, N, Id[u] + 1, Id[v]) ; _update(1, 1, N, Id[u] + 1, Id[v], d) ; 即可。 而对于如何边权转点权，我用的总时间复杂度大约$O(n)$的区间赋值函数，好像比较方便： 1234567for (i = 1 ; i &lt; N ; ++ i) n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;dfs1(1, 1), dfs2(1, 1), _build(1, 1, N) ;for (i = 1 ; i &lt; N ; ++ i)&#123; if (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v); _change(1, 1, N, Id[n[i].v], Id[n[i].v], n[i].c);&#125; 嗯，题解好啊 那么上面两个题就比较简单了： $\mathscr{T1 ~\text{の} ~code}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162struct Node&#123; int u, v, c ;&#125;n[MAX &lt;&lt; 1] ;struct Edge&#123; int v, next, to ;&#125;e[MAX &lt;&lt; 1] ; int Id[MAX], M, N, tot, A, B, C, i ; char STR[50] ;int Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX], head[MAX] ;int Max[MAX &lt;&lt; 1], Min[MAX &lt;&lt; 1], S[MAX &lt;&lt; 1], T[MAX &lt;&lt; 1], cnt ;inline int qr()&#123; int res = 0, f = 1 ; char c = getchar() ; while (!isdigit(c)) &#123;if (c == '-') f = -1 ; c = getchar() ;&#125; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res * f ;&#125;inline void _Add(int u, int v, int c)&#123; e[++ cnt].v = c, e[cnt].to = v ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].v = c, e[cnt].to = u ; e[cnt].next = head[v], head[v] = cnt ;&#125;void dfs1(int F, int now)&#123; Sum[now] = 1, Fa[now] = F, Dep[now] = Dep[F] + 1 ; for (int k = head[now] ; k ; k = e[k].next)&#123; if (e[k].to == F) continue ; dfs1(now, e[k].to) ; Sum[now] += Sum[e[k].to] ; if (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ; &#125;&#125;void dfs2(int now, int Tp)&#123; Id[now] = ++ tot, Top[now] = Tp ; if (Son[now]) dfs2(Son[now], Tp) ; for (int k = head[now] ; k ; k = e[k].next)&#123; if (e[k].to == Fa[now] || e[k].to == Son[now]) continue ; dfs2(e[k].to, e[k].to) ; &#125;&#125;inline void P_u(int rt)&#123; Max[rt] = max(Max[Rs(rt)], Max[Ls(rt)]) ; Min[rt] = min(Min[Rs(rt)], Min[Ls(rt)]) ; S[rt] = S[Ls(rt)] + S[Rs(rt)] ;&#125;inline void P_d(int rt, int L, int R)&#123; if (T[rt])&#123; int t1 = Max[Ls(rt)], t2 = Max[Rs(rt)] ; T[Ls(rt)] ^= 1, T[Rs(rt)] ^= 1 ; Max[Ls(rt)] = -Min[Ls(rt)], Max[Rs(rt)] = -Min[Rs(rt)] ; Min[Ls(rt)] = -t1, Min[Rs(rt)] = -t2, S[Ls(rt)] = -S[Ls(rt)], S[Rs(rt)] = -S[Rs(rt)] ; T[rt] = 0 ; &#125;&#125;void _build(int rt, int L, int R)&#123; if (L == R) return ; _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + 1, R) ; P_u(rt) ;&#125;void _change(int rt, int L, int R, int l, int r, int k)&#123; if (l &lt;= L &amp;&amp; R &lt;= r)&#123; S[rt] = Max[rt] = Min[rt] = k, T[rt] = 0 ; return ; &#125; P_d(rt, L, R) ; if (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ; if (Mid &lt; r) _change(Rs(rt), Mid + 1, R, l, r, k) ; P_u(rt) ;&#125;void _update(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r)&#123; int t = Max[rt] ; Max[rt] = -Min[rt], Min[rt] = -t ; T[rt] ^= 1, S[rt] = -S[rt] ; return ; &#125; P_d(rt, L, R) ; if (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r) ; if (Mid &lt; r) _update(Rs(rt), Mid + 1, R, l, r) ; P_u(rt) ; &#125;int _query(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r) return Max[rt] ; P_d(rt, L, R) ; int Maxxxxx = -Inf ; if (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ; if (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + 1, R, l, r)) ; return Maxxxxx ;&#125;int __query(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r) return Min[rt] ; P_d(rt, L, R) ; int Minnnnn = Inf ; if (Mid &gt;= l) Minnnnn = min(Minnnnn, __query(Ls(rt), L, Mid, l, r)) ; if (Mid &lt; r) Minnnnn = min(Minnnnn, __query(Rs(rt), Mid + 1, R, l, r)) ; return Minnnnn ;&#125;int ___query(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r) return S[rt] ; P_d(rt, L, R) ; int Ssssss = 0 ; if (Mid &gt;= l) Ssssss += ___query(Ls(rt), L, Mid, l, r) ; if (Mid &lt; r) Ssssss += ___query(Rs(rt), Mid + 1, R, l, r) ; return Ssssss ;&#125;inline void _Update(int u, int v)&#123; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; _update(1, 1, N, Id[Top[u]], Id[u]) ; u = Fa[Top[u]] ; &#125; if (Dep[u] &gt; Dep[v]) swap(u, v) ; _update(1, 1, N, Id[u] + 1, Id[v]) ;&#125;inline int Get_Max(int u, int v)&#123; int ret = -Inf ; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; ret = max(ret, _query(1, 1, N, Id[Top[u]], Id[u])) ; u = Fa[Top[u]] ; &#125; if (Dep[u] &gt; Dep[v]) swap(u, v) ; ret = max(ret, _query(1, 1, N, Id[u] + 1, Id[v])) ; return ret ;&#125;inline int Get_Min(int u, int v)&#123; int ret = Inf ; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; ret = min(ret, __query(1, 1, N, Id[Top[u]], Id[u])) ; u = Fa[Top[u]] ; &#125; if (Dep[u] &gt; Dep[v]) swap(u, v) ; ret = min(ret, __query(1, 1, N, Id[u] + 1, Id[v])) ; return ret ;&#125;inline int Get_Sum(int u, int v)&#123; int ret = 0 ; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; ret += ___query(1, 1, N, Id[Top[u]], Id[u]) ; u = Fa[Top[u]] ; &#125; if (u == v) return ret ; if (Dep[u] &gt; Dep[v]) swap(u, v) ; ret += ___query(1, 1, N, Id[u] + 1, Id[v]) ; return ret ;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt; N ; ++ i) n[i].u = qr() + 1, n[i].v = qr() + 1, n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ; dfs1(1, 1), dfs2(1, 1), _build(1, 1, N) ; for (i = 1 ; i &lt; N ; ++ i)&#123; if (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v); _change(1, 1, N, Id[n[i].v], Id[n[i].v], n[i].c); &#125; cin &gt;&gt; M ; for (i = 1 ; i &lt;= M ; ++ i)&#123; scanf("%s", STR) ; if (STR[0] == 'N') A = qr() + 1, B = qr() + 1, _Update(A, B) ; if (STR[0] == 'S') A = qr() + 1, B = qr() + 1, printf("%d\n", Get_Sum(A, B)) ; if (STR[0] == 'M' &amp;&amp; STR[1] == 'A') A = qr() + 1, B = qr() + 1, printf("%d\n", Get_Max(A, B)) ; if (STR[0] == 'M' &amp;&amp; STR[1] == 'I') A = qr() + 1, B = qr() + 1, printf("%d\n", Get_Min(A, B)) ; if (STR[0] == 'C') A = qr(), B = qr(), n[A].c = B, _change(1 ,1, N, Id[n[A].v], Id[n[A].v], B) ; &#125; return 0 ;&#125; 这个题有一个取相反数的操作，遇到这种正反都需要考虑的，$tag$一定是异或而不是覆盖 ……是一个坑点 $\mathscr{T2 ~\text{の} ~code}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132using namespace std ;struct Node&#123; int u, v, c ;&#125;n[MAX &lt;&lt; 1] ;struct Edge&#123; int v, next, to ; //0 = Change, 1 = Add .&#125;e[MAX &lt;&lt; 1] ; char STR[50] ; int A, B, C ;int Rec[MAX], Id[MAX], Aft[MAX] ;int N, tot ;int M[MAX &lt;&lt; 1], T[MAX &lt;&lt; 1][2], head[MAX], cnt, i ;int Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX];inline int qr()&#123; int res = 0, f = 1 ; char c = getchar() ; while (!isdigit(c)) &#123;if (c == '-') f = -1 ; c = getchar() ;&#125; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res * f ;&#125;inline void _Add(int u, int v, int c)&#123; e[++ cnt].v = c, e[cnt].to = v ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].v = c, e[cnt].to = u ; e[cnt].next = head[v], head[v] = cnt ;&#125;void dfs1(int F, int now)&#123; Sum[now] = 1, Fa[now] = F, Dep[now] = Dep[F] + 1 ; for (int k = head[now] ; k ; k = e[k].next)&#123; if (e[k].to == F) continue ; dfs1(now, e[k].to) ; Sum[now] += Sum[e[k].to] ; if (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ; &#125;&#125;void dfs2(int now, int Tp)&#123; Id[now] = ++ tot, Top[now] = Tp ; if (Son[now]) dfs2(Son[now], Tp) ; for (int k = head[now] ; k ; k = e[k].next)&#123; if (e[k].to == Fa[now] || e[k].to == Son[now]) continue ; dfs2(e[k].to, e[k].to) ; &#125;&#125;inline void P_u(int rt)&#123;M[rt] = max(M[Rs(rt)], M[Ls(rt)]) ;&#125;void P_d(int rt, int L, int R)&#123; if(L == R) return; if (T[rt][0] != -1)&#123; M[Ls(rt)] = T[rt][0], M[Rs(rt)] = T[rt][0] ; T[Rs(rt)][0] = T[rt][0], T[Ls(rt)][0] = T[rt][0]; T[rt][0] = -1, T[Rs(rt)][1] = 0, T[Ls(rt)][1] = 0 ; &#125; if (T[rt][1])&#123; M[Ls(rt)] += T[rt][1], M[Rs(rt)] += T[rt][1] ; T[Rs(rt)][1] += T[rt][1], T[Ls(rt)][1] += T[rt][1] ; T[rt][1] = 0 ; &#125;&#125;void _build(int rt, int L, int R)&#123; T[rt][0] = -1 ; if (L == R) &#123;M[rt] = 0 ; return ;&#125; _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + 1, R) ; P_u(rt) ;&#125;void _change(int rt, int L, int R, int l, int r, int k)&#123; if (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][0] = M[rt] = k, T[rt][1] = 0 ; return ;&#125; P_d(rt, L, R) ; if (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ; if (Mid &lt; r) _change(Rs(rt), Mid + 1, R, l, r, k) ; P_u(rt) ;&#125;void _update(int rt, int L, int R, int l, int r, int k)&#123; if (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][1] += k, M[rt] += k ; return ;&#125; P_d(rt, L, R) ; if (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r, k) ; if (Mid &lt; r) _update(Rs(rt), Mid + 1, R, l, r, k) ; P_u(rt) ; &#125;int _query(int rt, int L, int R, int l, int r)&#123; if (l &lt;= L &amp;&amp; R &lt;= r) return M[rt] ; P_d(rt, L, R) ; int Maxxxxx = -1 ; if (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ; if (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + 1, R, l, r)) ; return Maxxxxx ;&#125;inline void _Update(int u, int v, int d)&#123; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; _update(1, 1, N, Id[Top[u]], Id[u], d) ; u = Fa[Top[u]] ; &#125; if (u == v) return ; if (Dep[u] &gt; Dep[v]) swap(u, v) ; _update(1, 1, N, Id[u] + 1, Id[v], d) ;&#125;inline int Get_Max(int u, int v)&#123; int ret = -1 ; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; ret = max(ret, _query(1, 1, N, Id[Top[u]], Id[u])) ; u = Fa[Top[u]] ; &#125; if (u == v) return ret ; if (Dep[u] &gt; Dep[v]) swap(u, v) ; ret = max(ret, _query(1, 1, N, Id[u] + 1, Id[v])) ; return ret ;&#125;inline void _Cover(int u, int v, int d)&#123; while(Top[u] != Top[v])&#123; if(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ; _change(1, 1, N, Id[Top[u]], Id[u], d) ; u = Fa[Top[u]] ; &#125; if (u == v) return ; if (Dep[u] &gt; Dep[v]) swap(u, v) ; _change(1, 1, N, Id[u] + 1, Id[v], d) ;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt; N ; ++ i) n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ; dfs1(1, 1), dfs2(1, 1), _build(1, 1, N) ; for (i = 1 ; i &lt; N ; ++ i)&#123; if (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v); _change(1, 1, N, Id[n[i].v], Id[n[i].v], n[i].c); &#125; cin &gt;&gt; STR ; while(STR[0] != 'S')&#123; if (STR[0] == 'A') A = qr(), B = qr(), C = qr(), _Update(A, B, C) ; if (STR[0] == 'M') A = qr(), B = qr(), printf("%d\n", Get_Max(A, B)) ; if (STR[0] == 'C' &amp;&amp; STR[1] == 'o') A = qr(), B = qr(), C = qr(), _Cover(A, B, C) ; if (STR[0] == 'C' &amp;&amp; STR[1] == 'h') A = qr(), B = qr(), n[A].c = B, _change(1 ,1, N, Id[n[A].v], Id[n[A].v], B) ; scanf("%s", STR) ; &#125; return 0 ;&#125; 这个题也有一个坑点，不过我似乎注意到了，就是它实际上有两种需要下传的标记，一种是赋值，一种是加，在算标记的时候注意一下就好了 。 与树形$\mathbb{DP}$ 的巧妙结合这个地方其实说的是一类问题。。。比如一道我根本不会的 经典题： $\rm Description$ 一棵带权树，$n$个点$q$次询问，每次询问一个点的$\sum dis_{odd}$和$\sum dis_{even}$。 $\mathcal{Solution}$ 其实这个题的题目意思是让我们求： $R$君想知道对于每个点来说，到这个点是距离奇数的节点的距离和，与到这个点距离是偶数的节点的距离和。 那么我们不妨先从一个比较简单的问题开始考虑：如何求一个点到它子树的距离和呢？ 这个东西比较简单，因为我们可以直接$dfs$。 那么如果是求所有点到所有点的距离和呢？ 换句话说，我们可以把刚才这个十分简单的问题，升华成为一个稍微困难一些的问题：对于每个点$u$，求所有点与它的距离之和，距离依边权而定。 我首先忽略边权，令边权都是$1$，那么我们思考，我们根据已知条件，很容易知道的是什么呢？我们可以通过上一个问题知道根节点到所有点的距离之和，同时我们也可以知道每个节点子树内的边权之和，那么如何利用这些呢？ 我们会发现，此时我们知道的量，同一般的树形$DP$或者说树形结构不同，我们现在已经知道了每一个子树的根节点的讯息；而平常的树形结构，我们知道的则是子节点的讯息$or$子树的讯息，这一点提示我们：反向$DP$ 我们不妨设$dp_u$表示$\sum \limits_{i \in T}^{}{dist(i,u)}$ 那么我们思考如何构造相邻两层的状态转移方程： 首先，我们已经决定反向$DP$，换句话说就是用父亲推出儿子；并且我们了解到，对于某一个点$u$，他的所有子节点到他的距离要比到他的父亲的距离少$1$（假设边权$=1$），同时所有除其子树之外的所有点到他的距离会多$1$.那么转移方程旧顺水推舟地： $$dp_v = dp_u - subsize_v + (n - subsize_v), v \in son_u$$ 那么接下来我们思考，当边权不为$1$的时候呢？我们可以稍微魔改一下上式，于是就得到 $$dp_v = dp_u - 2 \cdot pre_v \cdot subsize_v + N \cdot pre_v$$ 其中$pre_i$表示节点$i$的上行边，即父亲与它相连的那条边。 那么以上简单版本的代码： 123456789101112131415161718192021222324252627282930313233using namespace std ;struct Edge&#123; int to, next ;&#125;E[MAX] ; int head[MAX], cnt ; int N, A, B, i, j, dp[MAX], sub[MAX], Pre[MAX] ; inline void _Add(int u, int v)&#123; E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;&#125;void build(int now, int f)&#123; sub[now] = 1 ; for (int k = head[now] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; build(to(k), now) ; sub[now] += sub[E[k].to], dp[1] += sub[E[k].to] ; &#125; return ;&#125;void fwork(int now, int f)&#123; for (int k = head[now] ; k ; k = E[k].next)&#123; if (E[k].to == f) continue ; dp[E[k].to] = dp[now] - 2 * sub[E[k].to] + N ; fwork(to(k), now) ; &#125;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt; N ; ++ i) scanf("%d%d", &amp;A, &amp;B), _Add(A, B) ; build(1, 0) ; fwork(1, 0) ; for (i = 1 ; i &lt;= N ; ++ i) printf("%d\n", dp[i]) ;&#125; 唯一值得注意的地方就是其中$dp_1$或者说$dp_{root}$的处理。那么其实这个地方我们只需要不断加$size$即可。 高端版本的问题，代码类似： 12345678910111213141516171819202122232425262728293031struct Edge&#123; int to, next, v ;&#125;E[MAX &lt;&lt; 1] ; int head[MAX], cnt, i ;int N, Sub[MAX], Pre[MAX], dp[MAX], Sum, A, B, C ;void build(int now, int f)&#123; Sub[now] = 1 ; for (int k = head[now] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; build(to(k), now) ; Pre[to(k)] = E[k].v ; Sub[now] += Sub[to(k)], dp[1] += Pre[to(k)] * Sub[to(k)] ; &#125; return ;&#125;void dp_work(int now, int f)&#123; for (int k = head[now] ; k ; k = E[k].next)&#123; if (to(k) == f) continue ; dp[to(k)] = dp[now] - 2 * Pre[to(k)] * Sub[to(k)] + N * Pre[to(k)] ; dp_work(to(k), now) ; &#125;&#125;inline void Add(int u, int v, int w)&#123; E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ; E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;&#125;int main()&#123; cin &gt;&gt; N ; for (i = 1 ; i &lt; N ; ++ i) scanf("%d%d%d", &amp;A, &amp;B, &amp;C), Add(A, B, C) ;; build(1, 0) ; dp_work(1, 0) ; for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; dp[i] &lt;&lt; endl ;&#125; 那么回归到我们的问题，我们要求的是奇数距离$\&amp;$偶数距离，很简单，再加一维即可。 我们致力于维护这样一个东西：对于每个$u \in T$， 我们试图确定除$u$及其子树外，到$u$点距离是奇数的点的个数$S0$$\&amp;$距离是偶数的点的个数$S1$，以便于状态转移时，作为第二部分。那么平均树高下，直接在$dfs/bfs$里面来回赋值即可。但是还是有需要注意的地方——比如说边为奇数的时候，父子节点的两个值需要$swap$一下，并且边权为奇数的时候，是交叉转移的（奇数状态转移给偶数状态）： $$dp[to(k)][0] = dp[now][1] - Sub[to(k)][0] Pre[to(k)] \ dp[to(k)][1] = dp[now][0] - Sub[to(k)][1] Pre[to(k)] ，\ dp[to(k)][0] += S0 Pre[to(k)] , \ dp[to(k)][1] += S1 Pre[to(k)] ;$$ 其中$to(k) \in son_{now}$ 而偶数的时候，显然不是交叉转移的（奇数状态转移给奇数状态）： $$dp[to(k)][1] = dp[now][1] - Sub[to(k)][1] Pre[to(k)] ;\ dp[to(k)][0] = dp[now][0] - Sub[to(k)][0] Pre[to(k)] ;\ dp[to(k)][1] += S1 Pre[to(k)],\ dp[to(k)][0] += S0 Pre[to(k)] ;$$ 于是就结束了。其实这个地方转移方式十分的多，但是关键的装套转移方程其实就是一句： $dp_v = dp_u - 2 \cdot pre_v \cdot subsize_v + Count \cdot pre_v$其中$Count$表示某种神秘的计数。。。。 那么其实这种问题还可以拓展到“求对于每一个点$u$，$dist(u,v) \mod n =k$的点的个数，其中$k \in [0,k-1]$，我感觉做法应该会类似吧（但是我肯定不会做因为根本不可能调的出来） 结语 没啥好说的，只觉得第三模块的例题十分难调！十分难调！！！并且……我一开始没用$S0$或者$S1$，直接用的根节点的$sub_0$和$sub_1$，最后才法案根本不和逻辑。。。但他居然过样例了。。。 转移的时候还是需要有一个清醒的思路再code啊！ $DP$好啊！]]></content>
      <categories>
        <category>题解</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>树模型</tag>
        <tag>动态规划-树形DP</tag>
        <tag>轻重链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】线性规划入门]]></title>
    <url>%2F2019%2F03%2F15%2F%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[许久之前开始学的算法了…今天终于学完了。主要参考的材料是董克凡的$2016$集训队论文和$\rm{Candy?}$的代码整理，在此处致以敬意。 $\rm{0x01\quad Preface}$线性规划主要解决的问题是： $$\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)$$不失一般性的，我们定义最大化的函数为目标函数($\rm{Aim-Func}$) ，定义约束函数的集合为约束函数集($\rm{Constraint-Set}$)。那么朴素的线性规划可以看求一组向量{$x_1,x_2\cdots x_n$}，使之既可以做约束函数的因变量，又满足其目标函数的值为$max$。 同时，规定所有的$x$均满足$x&gt;0$。 当然，存在一种更加赏心悦目的矩阵表示方式：$$\text{最大化}\quad \boldsymbol{c^Tx} \\\text{满足约束} \quad A\boldsymbol{x\leq b} \\\\it{\qquad \qquad \quad} \boldsymbol {x} \geq 0$$其中$\boldsymbol{c,x,b}$均为一维向量，$A$为系数矩阵。 那么我们在高中数学必修五里面运用的智障做法是，通过每个约束确定一个凸包，再用目标函数不断平移以求得与凸包的切点/切线来达到最大值，但是这样的做法通常不具有一般性。所以需要引入一种更常用的方法来解决这类问题。 $\rm{0x02\quad}$ 松弛型矩阵与$\rm{Pivot}$操作我们考虑一种更加友好的线性规划方式——松弛型矩阵，即将原来的矩阵添加几个无实际作用的新变量$x_i$，使之换一个样子：$$\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} \quad (i = 1,2,3\cdots m) \\ \qquad\quad x_j \geq 0\quad (j=1,2,3\cdots n+m)$$两种表示是等价的，但是我们更倾向于松弛型这种简洁的表述方式。 同时我们规定以下： $1.$基变量：在松弛型约束中，等式左边的变量。 $2.$非基变量：在松弛型约束中，等式右边的变量。 那我们定义一次转轴操作$(pivot)$为将一个基变量换进等式右边，换出一个非基变量的过程。 假设我们在第$i$组约束中，有一个变量$x_k~(k&gt;n)$是基变量，我们要换出一个非基变量$x_p~(1\leq p\leq n)$，那么就会由：$$x_k= b_i -\sum \limits_{j=1}^{n} a_{i,j}x_{j}$$变成$$x_p = \frac{b_i - \sum \limits_{j\neq p}a_{i,j}x_j -x_k}{a_{i,p}}$$而单纯性做法的本质就是通过不断转轴，实现目标函数不断变大。 看上去似乎比较抽象？我们考虑对一次转轴操作，我们需要在转轴之后将原来目标函数里的非基变量代入，即用$(b_i - \sum _{j\neq p}a_{i,j}x_j -x_k)/a_{i,p}$这个东西去替换掉$x_p$，那么其中的常数项$\frac{b_i}{a_{i,p}}$就可以作为目标函数中的一个常数值，当$x_i~(i=1,2,3\cdots n)$均为$0$时，目标函数的值即为此。那么转轴操作就是通过这样的操作使得目标函数里的常数值不断增大，达到最优解。 注意，转轴之后的得到的$x_p$的表达式，不仅要代入目标函数，也要代入其余的约束。 $\rm{0x03}\quad \rm{Simplex}$那么接下来，我们考虑单纯性做法的完整过程。 不失一般性的，我们假设所有$b_i\geq 0$ 首先，我们对于转轴操作结束，回代一次之后，会发现目标函数中肯定会有至少一项系数变为负值，即转进来的前·基变量$x_k$，那么增大$x_k$一定会让结果目标函数变小。所以我们可以断言，当目标函数里的所有变量系数均为负值时，目标函数的最优值就会是现在目标函数中的常数值——因为我们在前文已经假定$x_i\geq 0$了。 同样，我们每次转轴操作需要保持原来线性规划的不变性，换句话说就是我们每次转轴时都需要找一个对与某个非基变量限制最紧的约束，将其换出。原因是我们考虑目标函数中的$x_i$，当其系数$\geq 0$时，$\rm{Aim }\propto x_i$，所以我们需要找一个最紧的约束遏止$x_i$的增长(即使我们不想)。 那么伪代码如下，$A,\boldsymbol{b,c}$的定义一开始已给出： Simplex(A, b, c){$\qquad$ initialization(A,b,c) ; $\qquad$ while $∃e$ that $c_e&gt;0${$\qquad$$\qquad$find the index $l$ that $A_{l,e}$ $&gt; 0$ and minimizes $b_l/A_{l,e}$$\qquad$$\qquad$if $∀l, A_{l,e} ≤ 0$$\qquad$$\qquad$$\qquad$return Unbounded ;$\qquad$$\qquad$else$\qquad$$\qquad$$\qquad$pivot(A, b, c, l, e)；} 值得注意的是，如果在寻找完最紧约束后，存在一个$A_{l,e} \leq 0$，那么我们在这组约束里无论怎么增大$x_e$都会使得目标函数增大，所以直接return Unbounded。 此时我们还需要进行额外的操作，即初始化。因为我们转轴操作的目的是使目标函数增大，所以我们需要保证所有的$b_i\geq 0$，但一开始给定的$b_i$很可能不满足这一约束，所以我们需要进行一次初始化。那么对于初始化，我们的思想是做另一次线性规划。鬼知道那些发明这玩意儿的神仙怎么构造出的这个线性规划。 我们考虑一个这样的线性规划：$$\text{最大化}\quad -x_0 \\\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} +x_0\quad (i = 1,2,3\cdots m)\\\it{\qquad \qquad \qquad \quad x_j} \geq 0\quad (j=0,1,2,3\cdots n)$$首先，无论怎样，先思考他会不会对原来的线性规划产生什么影响——答案是：不会。因为我们考虑当$-x_0$最大时，一定是$x_0=0$的时候。所以对于约束中的$x_{n+i}$，大小不会变化。 那么我们考虑这种初始化方式的正确性。我们考虑每次都将$x_0$作为换入变量(即我们一开始将$x_0$视作非基变量)，那么$pivot$之后就会有$$x_0 = -b_i+x_{i+n}+\sum\limits_{j=1}^{n}a_{i,j}x_j$$由于我们一定找的时限制最小的，那么$b_i&lt;0\Longrightarrow-b_i &gt;0$，这组约束合法。 对于其余的约束，我们考虑代入之后，会有：$$x_{n+k}= b_k-b_i+\sum\limits_{j=1}^{n}(a_{k,j}-a_{i,j})x_j+x_{i+n}$$由于$b_i$最小，那么$b_k\geq b_i \Longrightarrow b_k-b_i\geq 0$。任务完成。 那么就可以愉快地上代码辣(≧▽≦)/！题目来自于$\rm{UOJ179}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#define MAXN 1010using namespace std ;const double eps = 1e-8, INF = 1e15 ;int N, M, T, Id[MAXN], i, j ; double A[MAXN][MAXN], Get[MAXN] ;void Pivot(int l, int e)&#123; swap(Id[N + l], Id[e]) ;//交换两个变量 double t = A[l][e] ; A[l][e] = 1.0 ; for(i = 0 ; i &lt;= N ; ++ i) A[l][i] /= t ;//类似于高斯消元的第一步，把这一项挪到等式右边，所以要先都除以系数 for(i = 0 ; i &lt;= M ; ++ i) if(i != l &amp;&amp; fabs(A[i][e]) &gt; eps) for(t = A[i][e], A[i][e] = j = 0 ; j &lt;= N ; ++ j) A[i][j] -= A[l][j] * t ;//此处则是代换。而由于代数式中肯定不会出现我们的A_&#123;i,e&#125;(毕竟是换到了等式右边)，所以对于这一项的系数要特殊处理成0&#125;bool Init()&#123; while(true)&#123; int e = 0, l = 0 ; double t = -eps ; for (i = 1 ; i &lt;= M ; ++ i) if (A[i][0] &lt; t) l = i, t = A[i][0] ; if(!l) return 1 ;//找系数最小的负值项 for (j = 1 ; j &lt;= N ; ++ j) if (A[l][j] &lt; -eps &amp;&amp; (!e || (rand() &amp; 1))) e = j ; if (!e) return puts("Infeasible"), false ; Pivot(l, e) ; &#125;//不合法的线性规划，因为我们假设全部的系数都为正，且我们前面已经假定了全部x_i为正，那么不可能满足标准型里面的小于b_l——此时b_l为负值。 return 1 ;&#125;bool Simplex()&#123; while(1)&#123; int l = 0, e = 0 ; double MAX = INF ; for(j = 1 ; j &lt;= N ; ++ j) if (A[0][j] &gt; eps) &#123; e = j ; break ; &#125; if(!e) break ; for(i = 1 ; i &lt;= M ; ++ i) if (A[i][e] &gt; eps &amp;&amp; A[i][0] / A[i][e] &lt; MAX) MAX = A[i][0] / A[i][e], l = i ;//选个最紧的约束 if (!l) return puts("Unbounded"), false ; Pivot(l,e) ; &#125; return 1 ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; T ; srand(19260817) ; for (i = 1 ; i &lt;= N ; ++ i) Id[i] = i ; for (i = 1 ; i &lt;= N ; ++ i) cin &gt;&gt; A[0][i] ; for (i = 1 ; i &lt;= M ; cin &gt;&gt; A[i ++][0]) for (j = 1 ; j &lt;= N ; ++ j) cin &gt;&gt; A[i][j] ; if (!(Init() &amp;&amp; Simplex())) return 0 ; printf("%.8lf\n", -A[0][0]) ; if(T)&#123; for(i = 1 ; i &lt;= M ; ++ i) Get[Id[N + i]] = A[i][0] ; for(i = 1 ; i &lt;= N ; ++ i) printf("%.8lf ",Get[i]) ; &#125; return 0 ;&#125; 然鹅事实上这份代码只有$97pts$…好像剩下3分就几乎没有人得过，除了kcz和std…… 至于中间的srand，是由于我们随便$pivot$一个$e$就好，于是就听长者的。 $\rm{0x04}\quad Afterwords$一直想学，一直没有机会学。 说起来确实有点儿小激动。第一次写单纯型的代码是前不久的一次周末，早上点起来之后头昏脑涨地扑向Candy?的博客，学了起来。在那之后才发现原来线性规划并不常考，甚至说，不考。但是我挺喜欢这种感觉，感觉自己仿佛比出题人会的还多 $\rm{Reference}$ $[1]$ :$Candy?$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· $^{^{[\nearrow]}}$ 提取码：vua4]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线性规划</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想六 · 难]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard%2F</url>
    <content type="text"><![CDATA[最近心绪颇不宁静。 《随想》系列目次表：$Link$ $\text{Part0}$不知道为什么，最近的心绪颇不宁静。 那是一种说不出来的痛苦与寂寞，或许夹杂着一些爽快。省选将近，我不知道自己会有什么样的下场。我只知道自己码力依旧很弱、脑子依旧很笨。比起几个月之前退役之后萎靡不振的自己，没有什么长进。 我更是知道，我原本的想法是多么的幼稚。或许我一直在骗自己吧，骗自己“省选之前的一两个月，拼一拼、挤一挤时间，或许就能怎样怎样”——原来$\rm{NOIP}$爆锤我的人，不止比我聪明，还比我勤奋，还比我认真，还比我努力。我有什么资本去同台竞技呢？到最后，省选对我来说，也不过只是个笑话吧。 这些天我一直觉得自己已经足够努力了，但是发现永远都是“远远不够”。就好比我想要触及$\infin$，而我每天就算是以$100$、$1000$、$10000$…… 的速率增长，也永远没有抵达的那一天。 毕竟啊，上苍的笔下，早已经写下了规则：无论$1$后面多少个$0$，都至多是一个十分大的常数而已。 就好像我自己，无论多么努力，努力到感动自己，也至多是一个笑话而已。 $\text{Part1}\cdot Her$“她”是谁？ 我曾在$qq$空间中发过一篇说说，调侃我们奥赛生不能放假，但是主体部分却是与假期毫无关系： 头一次清晨在无人的校园里闲逛，耳畔是青鸟在歌唱着礼赞，以及夹杂在清风中的徐徐回音，眼前是澄碧色的天空，远处仿佛降下一道若隐若现的天上虹。一切都慢下来了，我可以看到流云在舒张、卷缩，又舒张，我可以听到渺茫的歌声，我甚至可以想到你的模样——那在暖阳下熠熠闪光的细框眼镜和清亮的眸子，以及如桃花一样绯红的面颊。好像整个世界都停下来了，只有我和在烟雾中幻化出神形的你，和身旁枝梢上的青鸟，以及指尖流掠的清风与阳光—— 最后一句本来是但是这TM跟我只能待在学校不能回家并且你们在家里嗨没有任何关系，毕竟是为了逗乐，我也不想被当成什么为感情烦恼的愣头青。但是在我看来，主体部分应该是上面引用框里的内容。 我曾经觉得只要奥赛拿了耀眼的成绩，就可以十分骄傲地去追求我想要的。但就现在的情况而言，不是很乐观。 我不想让她知道这件事，因为这世界上无疾而终的事情太多了，或许这就是下一件。但其实思来想去，似乎这份薄薄的感情并不那么重要，因为比起这事儿来，我需要担心的东西还有太多太多——明天跑操会不会很累？文化课会不会继续跪？文化课跪完班主任是否会丧失对我的最后一点信任？我的OI终点到底是什么？…… 以前从没觉得做人这么难。但我并不想说“我成长了”这种自我满足式的话语，我更想对我自己说： 大概是只有弱者才会觉得人生艰难吧。你看你灰暗的眼眸中的对岸，正有个青年，眼里全是山水诗画。可惜那个青年，不是你。 她学习成绩很好，毕竟不学奥赛，有大把的时间去搞文化课。而我或许只是班级角落里一个喜欢标新立异的弱者吧。 $\rm{Part3}$我很烦。 机房里去年省一的小伙伴们似乎并不是多在意省选，就只有我在拼得头昏脑胀。 我好不爽啊，凭什么我如此珍视的东西，他们可以胡乱蹂躏、浪费、玷污——况且迄今为止这个机会对于去年NOIP考挂的我，还不一定有这个机会去省选。这就好像我的女神不属于我，但是却被另一个人又杀又剐——我怎能不生气+寒心呢？ 好在这个精神状态持续了两天就好转了——主要原因是我得知$SD$的省选政策，只是限制了基准线而已——或许还有机会？我不知道，因为我的智商在所有的$Oier$里面，大概算是个中下，所以我即使拼尽全力也不能保证强过谁——况且我根本不可以拼尽全力啊… 最近一直在翘考试、翘美术音乐课……各种翘，我估计班主任马上就要通过对我的不信任案了…… $\rm{Part4}$不得不说这篇随想比之前的随想水多了……于是糊一篇我在知乎上的回答吧。当时有个题主问，如果从高一下学期左右开始，每天学奥赛几个小时，能不能拿金牌。 其实本来是无所谓的——于我而言无所谓。因为他志向宏大是一件好事，至于能否成真，我也没有评论的权利。但是我确乎是发现，他心里一直是觉得“我还有两把刷子的”，“只是时运不济罢了”。不知怎的，突然我就有了想多说两句的欲望： 我给你讲，目标跟眼界和实力有关。眼界越大、实力越强，目标越小。 同时，我可以很负责任的跟你讲：你绝对不知道的接下来你面临的是什么。 如果说你准备提高组的考试之前，有什么题不会看题解，理解起来的痛苦程度是1的话，那么你想继续向上走、想去省选、想去NOI，理解起来的痛苦程度将会是1e5以上。 没错，10万倍——如果你想自学的话。相信我，NOIP级别的考试，只是考代码素质/程序设计能力，根本不考察理解能力。 保送——是的，这是奥赛的终极目标之一。但是向来不会有人主动谈起这件事，即使他再NB。你现在还可以提出这个问题，只是说明你还不了解行情。抱歉，如果你现在觉得你自己很有天分，你觉得你现在可以拿“啊…我当时只是因为某些跟我自己没有关系的原因失败了”这种幼儿园智商的理由来骗自己——我只能跟你说，你不知道其它人有多厉害，说得难听些，就是井底之蛙—— 你知道全中国有无穷无尽的智商可以吊打你的人，他们每天可以有大半天的时间学OI吗？ 你知道每年有多少初中生在NOIp中碾压高中生吗？ 你不知道。 每天几个小时？ 做学问最需要的是谦卑，给自己找理由、沉浸在“我应该多么多么厉害”的幻想里终究会失败。 你相信我，我说的都是切实的体会。你体会不到是因为你不知道你所在四川到底有多么恐怖——基本是成都七中制霸；NOIP全省前40人均460+，全省前90人均400+。 我知道我没有很厉害，所以我的话你不会信多少。但是如果说奥赛给了我什么，最大的收获就是在学术上面的虔诚——做学问就好好做学问，不去追求附加价值，以及在学术上永远谦卑的态度。 看起来似乎我很刚的样子，但是这样做不是毫无缘由的——我其实，也是在对自己说吧。 为什么会这么难呢？我不知道啊。 我只知道我的机会确乎是不多了。 今年省选还有没有戏呢？我也不知道。 我只知道我的时间不多了。 不知怎的，眼前仿佛有一条宽阔的大河，浩荡无际。我无论做什么，都只能在上面溅起一圈窄窄的波纹而已。我在小小的沙洲上伫立着，远望是另一个小小的沙丘，上面站着她。我无法丈量出我们彼此之间的距离，好像很近，近到我能看清她的一颦一簇，可以看清她眉上新添的露珠；好像也很远，因为我不知道她在想什么、她要做什么。 呵，才记起来曾经有一部时下较火的剧里，称“暗恋”或者“单相思”，是最省钱的恋爱。我确乎是记住这一点了。但是我更想说，它不仅是最省钱的，也是最美的、最富有变化的、最梦幻的。 这是一片无垠的朦胧，夜幕中遥遥的，仿佛闪着两颗摇曳的星。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想四 · 故人]]></title>
    <url>%2F2019%2F03%2F01%2F%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 最近初三的小朋友们生龙活虎地来了，虽然没有什么深入的交流，但是其身上洋溢着的青春，确是我辈所比不了的。 是啊，一年了啊。 去年这个时候，我们也是这样意气风发的吧？听说今年的“小班”（初三来的实验班），信竞有12个人，和去年一样。换句话说，和我们一样，只不过他们这一级女生有四个，我们只有一个而已。 真像啊。 $0$其实这一篇很早很早就有了，但当时感触也并不多么深刻，或许也就只是黛玉葬花的那种梨花带雨一场罢了。以下是以前写的： $\rm{0x01}$ 结束 比我想象的要早，早好多，好多好多。 我退役了，虽然是本赛季退役。 我仿佛从来没有考虑过这件事情，18年的2月、3月、4月……甚至一直到8月，我都一直以我仍然初三、仍然未升上高中而自豪。我们是有生力量里面最年轻的一代，我们开口$Splay$、网络流、$Tarjan$，闭口莫队、$A-star$、替罪羊，我们研究各种奇妙的算法，我们刷各种三倍经验，我们酒入豪肠酿成三分月光，我们春风得意马蹄疾—— 我们年轻啊。 恍如隔世，考完$Noip$或许才真正知道自己几斤几两。 我悔恨，我懊恼，我痛苦，我不甘。我终于也变成了只能孤注一掷在高二出成绩的老年人。我或许什么都没少，只不过少了一次计划；但我或许已经一无所有——我的时间没有了。 我曾经认为考省一应该不算多难，结果现实重重地给了我一闷棍，厉喝道：这就是现实的力量。 或许几个月之前，或者说，从考完Noip到现在，我的所有负面情绪表现出来的都是消极、沉默、颓废，而直到今天，我看着窗外空旷的操场、不燥的微风，我看着天边徘徊的流云——我只想哭，声嘶力竭地、歇斯底里地哭。 我只想哭。 现在看来不禁感慨当时自己的脆弱，唏嘘当时的迷茫。现在已是八月的尾巴了，又拿出这篇文章来——经历了这么多有的没的，会不会有什么新的感慨呢？ 外面依稀的是看不清的星点，屏幕右上角的时间已是02:03，但我仍无倦意。 $1$嗯，先从身边的人说起吧。掰着指头数一数，实验班刚入学时意气风发的12个人，现在只剩8+1个人了，8个人还是计划未变，还有1个人早已把精力集中在文化课上了。 看一眼其他奥赛，境况也差不多。生物党们一开始是25人，从高一开学到今年联赛之后，陆陆续续的就变成了12个人；物理党只走了两三个吧，那也是因为他们一次联赛也没有考的原因——今年九月之后，或许就真的没有多少人了，估计会比生物的还少。一直被嘲讽人少的信息学竞赛之CSP（大雾）看起来终于缩小了差距。 说到底，现在我最担心的还是自己，不知道这个赛季自己能不能更好一些，达到自己的预期，所以也没有什么很闲的心思去操其他人的闲心。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】扩展的BSGS]]></title>
    <url>%2F2019%2F02%2F22%2FexBSGS%2F</url>
    <content type="text"><![CDATA[$\rm{0x01\quad Preface}$$emmm$严格来讲，不应该被算到一个模板里面。因为在我看来模板是人构造出来的，但是这个算法应该是一个解决问题的$process$…更像是在解一道数学题，如果$BSGS$是定理的话，$exBSGS$更像是一个不断转化的过程233（手动@lxa并且溜 $\rm{0x02\quad Algorithm~Process}$今天才发现原来$\rm{BSGS}$有两种写法……并且觉得剩下的题解讲的都讲的不是很全的样子233。 其实本质上，当$p$不为素数时，我们无法进行朴素$\rm{BSGS}$的原因是我们的欧拉定理$a^{\varphi(p)} \equiv b(\bmod p)$ 只能处理$(a,p)=1$的情况。那么我们知道，朴素的$\rm{BSGS}$的关键在于，可以保证最小解是有界的——$x$一定在$[1,\varphi(p)]$中。所以最后$BSGS$的复杂度才会是$\Theta(\sqrt{\varphi(p)})$ 的——比如说比较常见的$p$是素数的情况下，时间复杂度为$\Theta(p)$。 那么也就是说，我们只需要进行一些操作，保证$(a,p)=1 $即可$^{[1]}$。 我们思考，对于同余式$a^x\equiv b (\bmod p)$而言，我们先假定$(a,p)&gt;1 $。而此时如果有$((a,p), b)=1$，那么说明此式只有可能在$x=0,b=1 $的时候有解——这个结论是平凡的。因为假设我们把它展开成$a\cdot a^{x-1} +kp=b $的形式，必须要有$(a,p) | b$的情况下，才能保证$a^{x-1}$和$k $都是整数。 那么对于$(a,p)&gt;1$且$(a,p) | b $，我们令原式变成 $$a^{x-1}\cdot \frac{a}{(a,p)} \equiv \frac{b}{(a,p)} (\bmod \frac{p}{(a,p)})$$的样子，如果此时$(a^{x-1},\frac{p}{(a,p)})=1$ 的话，我们就直接解 $$a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }(\bmod \frac{p}{(a,p)})$$这个方程即可。否则我们继续分解直至$(p’,a)=1$。 那么此时有个问题需要注意，就是如果们在解这个方程时，出现了 $$(a^{x-1}, \frac{p}{(a,p)})\nmid \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }$$的情况，那我们需要特判并return -1 ；另一种情况，如果我们出现了 $$a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} } \equiv1(\bmod \frac{p}{(a,p)})$$的情况，也需要特判并输出此$k$（此时同余式左边是$a^{x-k}$，因为$a^{x-k}\equiv1~(\bmod p)$所以直接输出$k$），不过也有可能不需要，完全看你写的$BSGS$能不能判断$x=0$的情况……一般情况下不能。 此时由于$\boldsymbol{p}$不再是素数，所以不能用费马小定理，需要我们用$exgcd$的方法求逆元，包括但不限于$\frac{b}{(a,p)}$的逆元和$a^{-im}$。 以下是完整版代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#define ll long longusing namespace std ; unordered_map&lt;ll, int&gt; H ;int N, M, P, ans ; // N ^x = M (mod P)inline ll gcd(ll a, ll b)&#123; if (!b) return a ; return gcd(b, a % b) ;&#125;inline ll expow(ll a, ll b, ll mod)&#123; ll res = 1 ; while (b) res = ((b &amp; 1)?res * a % mod : res), a = a * a % mod, b &gt;&gt;= 1 ; return res ;&#125;inline ll exgcd(ll &amp;x, ll &amp;y, ll a, ll b)&#123; if (!b)&#123; x = 1, y = 0 ; return a ; &#125; ll t = exgcd(y, x, b, a % b) ; y -= x * (a / b) ; return t ;&#125;inline ll BSGS(ll a, ll b, ll mod, ll qaq)&#123; H.clear() ; ll Q, p = ceil(sqrt(mod)), x, y ; exgcd(x, y, qaq, mod), b = (b * x % mod + mod) % mod, Q = expow(a, p, mod), exgcd(x, y, Q, mod), Q = (x % mod + mod) % mod ; for (ll i = 1, j = 0 ; j &lt;= p ; ++ j, i = i * a % mod) if (!H.count(i)) H[i] = j ; for (ll i = b, j = 0 ; j &lt;= p ; ++ j, i = i * Q % mod) if (H[i]) return j * p + H[i] ; return -1 ;&#125;inline ll exBSGS()&#123; ll qaq = 1 ; ll k = 0, qwq = 1 ; if (M == 1) return 0 ; while ((qwq = gcd(N, P)) &gt; 1)&#123; if (M % qwq) return -1 ; ++ k, M /= qwq, P /= qwq, qaq = qaq * (N / qwq) % P ; if (qaq == M) return k ; &#125; return (qwq = BSGS(N, M, P, qaq)) == -1 ? -1 : qwq + k ;&#125; int main()&#123; while(cin &gt;&gt; N)&#123; scanf("%d%d", &amp;P, &amp;M); if (!N &amp;&amp; !M &amp;&amp; !P) return 0 ; N %= P, M %= P, ans = exBSGS() ; if (ans &lt; 0) puts("No Solution") ; else cout &lt;&lt; ans &lt;&lt; '\n' ; &#125;&#125; $\rm{0x03\quad Afterword}$今天才知道原来$BSGS$有两种写法qaq $zyf2000$好像和我写的$BSGS$对“大步”和“小步”的定义不是很一样…于是最后还是自己$\rm{yy}$的233 $\rm{Reference}$ $[1]$ :$zyf2000$的$blog$ $^{^{[\nearrow ]}}$]]></content>
      <categories>
        <category>学习笔记</category>
        <category>BSGS</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】拆系数FFT]]></title>
    <url>%2F2019%2F02%2F19%2FFFT2%2F</url>
    <content type="text"><![CDATA[上一篇多项式：多项式1·普通的FFT $\rm{0x01\quad Preface}$今天是$Feb.19^{th}$，开学前一天，现在是北京时间下午$10:05$，我还剩除了英语物理的所有作业没做 … 耶，真开心。 由于特殊原因嘛，我暂时不会写的特别详细——毕竟还有作业没有做抄完，所以就先整理地仓促一点。 首先，为什么要拆系数？这是一个问题——直接$FFT$之后判个精度再取模不就得了？很喜闻乐见的是，这个题中的$value_{max}$到达了$1e9\cdot1e9 \cdot 1e5 = 1e23$的级别，不可以直接long long爆艹。 $\rm{0x02~Normal-Coefficient-Spliting~FFT}$首先是最朴素的拆系数法。其原理简单得很，就是选择一个$M$，把$A(x)$和$B(x)$的各项系数表示成$$A_i = a_iM+b_i~(0\leq b_i &lt;a_i) \\B_i = c_iM+d_i~(0\leq d_i &lt;c_i)$$的形式。然后我们做乘法的话，会有$$A_i\cdot B_i = a_ic_iM^2+(a_id_i+c_ib_i)M+b_id_i$$那么我们考虑，对于第一部分$a_ic_iM^2$我们可以通过一次$DFT$、一次$IDFT$算出来，；对于第二部分$(a_id_i+c_ib_i)M$ 我们可以通过两次$DFT$分别算出$a_id_i$、$c_ib_i$然后合并，之后一次$IDFT$求出来；对于最后一部分则只需要一次$DFT$、一次$IDFT$求出。所以算法流程一共$7$次$FFT$。 那我们考虑估计一下范围，此处不甚严谨地使用$\Theta$作为同阶的符号$^{[1]}$ $$b_i\cdot d_i \approx \Theta(M^2)$$ $$a_i\cdot c_i =\lfloor \frac{P}{M}\rfloor \cdot \lfloor \frac{P}{M}\rfloor = \Theta(\lfloor \frac{P^2}{M^2}\rfloor)$$ $$(a_id_i + c_ib_i)\cdot M =\Theta( M \cdot \lfloor \frac{P}{M}\rfloor) $$ 那么我们取$M = \Theta(\sqrt P)$级别的，可以保证三个值的阶为$\Theta(P)$，大概是$1e9 \cdot 1e5 = 1e14$级别的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 423333#define rr register #define rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;const long double Pi = acos(-1) ;int R[MAXN], L, x ; long long Ans[MAXN] ;struct node&#123; long double x, y ; node (long double xx = 0, long double yy = 0)&#123; x = xx, y = yy ; &#125;&#125;A[MAXN], B[MAXN], C[MAXN], D[MAXN], F[MAXN], G[MAXN] ;node H1[MAXN], H2[MAXN], H3[MAXN] ; int L1, L2, P, N, M ;node operator + (node J, node Q)&#123; return node(J.x + Q.x , J.y + Q.y); &#125;node operator - (node J, node Q)&#123; return node(J.x - Q.x , J.y - Q.y); &#125;node operator * (node J, node Q)&#123; return node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x) ; &#125;void FFT(node *J, int flag)&#123; rr int i, j, k, l ; for(i = 0; i &lt; N; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ; for(j = 1; j &lt; N; j &lt;&lt;= 1)&#123; node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; N; k += (j &lt;&lt; 1) )&#123; node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123; node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ; &#125; &#125; &#125; if (flag &lt; 0) for (i = 0 ; i &lt;= N ; ++ i) J[i].x = J[i].x / N + 0.5 ;&#125;inline int qr()&#123; rr int k = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;signed main()&#123; rr int i, t ; cin &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P, M = 32767 ; N = 1, t = L1 + L2 ; for (i = 0 ; i &lt;= L1 ; ++ i) x = qr(), A[i].x = x / M, B[i].x = x % M ; for (i = 0 ; i &lt;= L2 ; ++ i) x = qr(), C[i].x = x / M, D[i].x = x % M ; while(N &lt;= t) N &lt;&lt;= 1, ++ L ; rep(i, 0, N) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; FFT(A, 1), FFT(B, 1), FFT(C, 1), FFT(D, 1) ; rep(i, 0, N) H1[i] = A[i] * C[i], H2[i] = B[i] * D[i], H3[i] = A[i] * D[i]+ C[i] * B[i] ; FFT(H1, -1), FFT(H2, -1), FFT(H3, -1) ; for (i = 0 ; i &lt;= N ; ++ i) Ans[i] = ((long long)H1[i].x * M % P * M % P + (long long)H2[i].x % P + (long long)H3[i].x * M % P) % P ; for (i = 0 ; i &lt;= L1 + L2 ; ++ i) printf("%lld ", Ans[i]) ; return 0 ;&#125; 所以最终的复杂度是$\boldsymbol{O(7\cdot P(n) \cdot n \log n)}$，其中$P(n)$是$FFT$自带的、大到不可忽略的常量因子。 但是……好像这个常数有点大诶，算上常数的话已经是$O(n \log^2n)$的级别了，于是—— $\rm{0x03~Conjugate~Optimization}$源自毛啸的《再探快速傅立叶变换》。 我们思考这样两个多项式$\boldsymbol{P, Q} \in \mathbb{C}$$$\rm{P(x) = A(x) + iB(x)} \\\rm{Q(x) = A(x) - iB(x)}$$我们不妨令$P’[k]$和$Q’[k]$为其$\text{DFT}$之后的序列，即$P’[k] =P(\omega_n^k),Q’[k] =Q(\omega_n^k) $。 同时，令$\text{conj(x)}$表示对$x$取共轭。 那么会有$^{[5]}$：$$\begin{align}P’[k] &amp;= A(\omega_{n}^{k}) + i B(\omega_{n}^{k}) \\&amp; = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} + i B_{j} \omega_{n}^{jk} \\&amp; = \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\&amp; = \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{kj}\\Q’[k] &amp;= A(\omega_{n}^{k}) - i B(\omega_{n}^{k}) \\&amp; = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} - i B_{j} \omega_{n}^{jk} \\&amp; = \sum_{j=0}^{n-1} (A_{j} - i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\&amp; = \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) - i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{-2 \pi jk}{n}\right) - B_{j} \sin \left(\frac{-2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{-2 \pi jk}{n}\right) + B_{j} \cos \left(\frac{-2 \pi jk}{n}\right)\right) \right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{-2 \pi jk}{n}\right) + i \sin \left(\frac{-2 \pi jk}{n}\right)\right)\right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{-jk} \right) \\&amp; = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{(n-k)j} \right) \\&amp; = \text{conj} \left( P’[n-k] \right)\end{align}$$好吧我承认这段推导过程的代码甚是壮观，于是并不是我自己写的qwq。 那么我们发现其中$A(x)$和$B(x)$可以通过$P,Q$推出来：$$A’[k] = \frac{P’[k] + Q’[k]}{2} \\B’[k] = \frac{P’[k] - Q’[k]}{2i}$$哦，对了，当$k=0$时，由于不存在这一项，所以我们需要特判一下。并且由于我们的$P(x)$和$Q(x)$的实部和虚部都可以利用，所以我们对于七次$DFT$可以优化到$4$次$DFT$. 以下是共轭优化$FFT$的初号机： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 423333#define rr register #define rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;int f[MAXN], g[MAXN] ;int R[MAXN], Len, x, Ans[MAXN] ;const long double Pi = acos(-1) ;struct node&#123; long double r, i ; inline node (long double xx = 0, long double yy = 0)&#123; r = xx, i = yy ; &#125; inline node Conj() &#123; return node(r, -i); &#125;&#125;A[MAXN], B[MAXN], w[MAXN], t1[MAXN], t2[MAXN] ;node H1[MAXN], H2[MAXN], H3[MAXN] ; int L1, L2, P, N, M ;node operator + (node J, node Q)&#123; return node(J.r + Q.r , J.i + Q.i); &#125;node operator - (node J, node Q)&#123; return node(J.r - Q.r , J.i - Q.i); &#125;node operator * (node J, node Q)&#123; return node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;inline int qr()&#123; rr int k = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;void FFT(node *J, int flag)&#123; rr int i, j, k, l ; for(i = 0; i &lt; N; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ; for(j = 1; j &lt; N; j &lt;&lt;= 1) for(k = 0; k &lt; N; k += (j &lt;&lt; 1)) for(l = 0 ; l &lt; j; ++ l)&#123; node T = w[N / j * l] ; T.i *= flag ; node Nx = J[k + l], Ny = T * J[k + j + l] ; J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ; &#125;&#125;inline void Init(int L)&#123; rr int i ; while (N &lt;= L) N &lt;&lt;= 1, ++ Len ; for (i = 0 ; i &lt; N ; ++ i) A[i] = node(f[i] &amp; 32767, f[i] &gt;&gt; 15) ; for (i = 0 ; i &lt; N ; ++ i) B[i] = node(g[i] &amp; 32767, g[i] &gt;&gt; 15) ; for (i = 0 ; i &lt; N ; ++ i) w[i] = node(cos(Pi * i / N), sin(Pi * i / N)) ; for (i = 0 ; i &lt; N ; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (Len - 1)) ;&#125;void MTT()&#123; node ia, ib, a1, a2, b1, b2 ; rr int i, k, t = L1 + L2, q1, q2, q3 ; Init(t) ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ; FFT(A, 1), FFT(B, 1) ; for (i = 0 ; i &lt; N ; ++ i)&#123; k = (N - i) &amp; (N - 1), ia = A[k].Conj(), ib = B[k].Conj() ;//(ia,ib) = Q a1 = (ia + A[i]) * node(0.5, 0), a2 = (A[i] - ia) * node(0, -0.5) ; b1 = (ib + B[i]) * node(0.5, 0), b2 = (B[i] - ib) * node(0, -0.5) ; t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(0, 1), t2[i] = a2 * b2 ; &#125; FFT(t1, -1), FFT(t2, -1) ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; w[i].r &lt;&lt; " "; cout &lt;&lt; endl ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ; // for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ; for (i = 0 ; i &lt; N ; ++ i)&#123; q1 = (long long)(t1[i].r / N + 0.5) % P, q2 = (long long)(t1[i].i / N + 0.5) % P ; q3 = (long long)(t2[i].r / N + 0.5) % P, Ans[i] = ((((long long)q3 &lt;&lt; 30) % P + ((long long)q2 &lt;&lt; 15) % P + q1) % P + P) % P ; &#125;&#125;signed main()&#123; rr int i ; cin &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P ; N = 1 ; for (i = 0 ; i &lt;= L1 ; ++ i) f[i] = qr() % P ; for (i = 0 ; i &lt;= L2 ; ++ i) g[i] = qr() % P ; MTT() ; for (i = 0 ; i &lt;= L1 + L2 ; ++ i) printf("%d ", Ans[i]) ; return 0 ;&#125; $\rm{0x04\quad}$拼命卡常好的，首先我们可以欣赏一下最初的版本（用小号交的拆系数$FFT$ + $O2$） 然后是大号的共轭优化$FFT$（不加$O2$，即上方代码）： 特别的，以下是无共轭优化的拆系数$FFT$，不开$O2$: 好吧，他看起来没有快多少。毕竟都是同阶的复杂度，好像后者的常数更大那么一点…… 于是考虑对共轭优化的进行大力卡常： 多次使用的非全局变量。使用register修饰符。 将$double$转换成为$long~double$ 。 减少取模次数。 从yjk那里偷来的$\rm{fread/fwrite}$ 一番操作之后，我们成功地卡到了第五页上…… 最后奉上最快的代码qwq： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// luogu-judger-enable-o2#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#include &lt;bits/stdc++.h&gt;#define MAXN 102333#define MAXM 272333#define rr register #define ll long long#define rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;namespace IO&#123; const int ch_top=4e7+3; char ch[ch_top],*now_r=ch-1,*now_w=ch-1; inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x; &#125; inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w=' '; &#125;&#125;int R[MAXM], Len, x, Ans[MAXN &lt;&lt; 1] ;const double Pi = acos(-1) ;struct node&#123; double r, i ; inline node Conj() &#123; return node(r, -i); &#125; inline node (double xx = 0, double yy = 0)&#123; r = xx, i = yy ; &#125;//定义的Complex型是用来进行复数运算的 &#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM] ; int L1, L2, P, N, M ;inline node operator + (const node &amp;J, const node &amp;Q) &#123; return node(J.r + Q.r , J.i + Q.i); &#125;inline node operator - (const node &amp;J, const node &amp;Q) &#123; return node(J.r - Q.r , J.i - Q.i); &#125;inline node operator * (const node &amp;J, const double &amp;Q) &#123; return (node) &#123;J.r * Q, J.i * Q&#125; ; &#125;inline node operator * (const node &amp;J, const node &amp;Q) &#123; return node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;inline void FFT(node *J)&#123; rr node t ; rr int i, j, k, l ; for(i = 0; i &lt; N; i ++) if(i &lt; R[i]) t = J[i], J[i] = J[R[i]], J[R[i]] = t ; for(j = 1; j &lt; N; j &lt;&lt;= 1) for(k = 0; k &lt; N; k += (j &lt;&lt; 1)) for(l = 0 ; l &lt; j; ++ l)&#123; rr node T = w[N / j * l] ; rr node Nx = J[k + l], Ny = T * J[k + j + l] ; J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ; &#125;&#125;inline void IFFT(node *J)&#123; reverse(J + 1, J + N), FFT(J) ; rr int i ; rr double qwq = 1.0 / N ; rep(i, 0, N - 1) J[i] = J[i] * qwq ;&#125;using namespace IO ;int main()&#123; fread(ch,1,ch_top,stdin); rr int i, k, t ; rr node ia, ib, a1, a2, b1, b2 ; t = ((L1 = read()) + (L2 = read())), P = read(), N = 1 ; while (N &lt;= t) N &lt;&lt;= 1, ++ Len ; for (i = 0 ; i &lt;= L1 ; ++ i) x = read(), A[i] = node(x &amp; 32767, x &gt;&gt; 15) ; for (i = 0 ; i &lt;= L2 ; ++ i) x = read(), B[i] = node(x &amp; 32767, x &gt;&gt; 15) ; for (i = 0 ; i &lt; N ; ++ i) w[i] = node(cos(Pi * i / N), sin(Pi * i / N)), R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (Len - 1)) ; FFT(A), FFT(B) ; for (i = 0 ; i &lt; N ; ++ i)&#123; k = (N - i) &amp; (N - 1), ia = A[k].Conj(), ib = B[k].Conj() ;//(ia,ib) = Q a1 = (ia + A[i]) * node(0.5, 0), a2 = (A[i] - ia) * node(0, -0.5) ; b1 = (ib + B[i]) * node(0.5, 0), b2 = (B[i] - ib) * node(0, -0.5) ; t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(0, 1), t2[i] = a2 * b2 ; &#125; IFFT(t1), IFFT(t2) ; for (i = 0 ; i &lt;= t ; ++ i) write(((ll)(t1[i].r + 0.5) + ((ll)(t1[i].i + 0.5) % P &lt;&lt; 15) + ((ll)(t2[i].r + 0.5) % P &lt;&lt; 30)) % P) ; fwrite(ch,1,now_w-ch,stdout); return 0 ;&#125; 实践证明，以上代码不加任何优化（不开$\rm{O2/3/fast}$）甚至可以快$4ms$！ $\rm{0x00\quad Afterword}$嗯，其实按道理来讲，不是特别难。但是这跟$HLPP$一样，都是打死都不会考的算法，所以学这些只是为了娱乐……听起来挺苍凉？ 但似乎，从一开始就不应该把应付考点作为OI的初衷吧，虽然如果没有获利，没有多少人会去学，但是不沾染功利的OI，似乎可爱了那么几分呢…… 并且在学的过程中顺便认识了一个巨佬CMXRYNP，嘿嘿，也算不亏啦。 本篇文章真实完稿时间是$2019/3/17$，因为太懒+太忙，鸽了一个月$\rm{qaq}$. $\rm{Reference}$ $[1]$ :$lvzelong2014$的$blog$ $^{^{[\nearrow ]}}$ $[2]$:无梦之梦的$blog$ $^{^{[\nearrow ]}}$ $[3]$:$Cyhlnj$的$blog$ $^{^{[\nearrow ]}}$ $[4]$:$litble$的$blog$ $^{^{[\nearrow ]}}$ $[5]$:$CMXRYNP$的$blog$ $^{^{[\nearrow ]}}$ $[6]$ :2016国家集训队论文《再探快速傅里叶变换》毛啸· $^{^{[\nearrow]}}$ 提取码：vua4]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】从单位根到FFT]]></title>
    <url>%2F2019%2F02%2F19%2FFFT1%2F</url>
    <content type="text"><![CDATA[$\rm{0x01\quad Preface}$这篇文章初写于$7/1/2018$，是在陪同好友$yjk$与$wx$以及学长$rqy$一起去参加省队集训时写的。今天突然来了兴致，打算重新复习一遍$FFT$并且写$MTT$，于是便有了这篇文章。 其实一开始我是不情愿把这篇文章搬到这儿来的——这好像是一个时代的缩影，那个时代的orchidany特别喜欢扮演老师，每天仿佛来到奥赛室只是为了“为人师”的：心性浮躁，学习功利。但现在我则是想沉下心来，认真做学问。 但无论如何，我希望这篇原本冗杂繁长的文章可以更短、更新颖、从更高的角度审视一些问题。 $\rm{0x02\quad Convolution}$卷积$\boldsymbol{(Convolution)}$，准确来说是一种通过两个函数$\boldsymbol f$ 和$\boldsymbol g$ 生成第三个函数的一种数学算子. 而广义上其定义为：$$\boldsymbol{h(x) = \int _{- \infty} ^{\infty}g(\tau) \cdot f(x - \tau)} \rm{d\tau}$$ 我们称$h(x)$是$g(x)$与$f(x)$的卷积。 而此处我们讨论的是整次多项式域，那么就把其定义划归进多项式，得到 $$A(x) \cdot B(x) =\sum\limits_{i = 0}^{n} \sum\limits_{j=0}^{i}{a_jb_{i-j}} $$其中$A(x)$和$B(x)$均为$N-1$次多项式比较显然的是，在我们合并同类项的情况下，最终卷出来的结果应该有$2n+1$项。 $\rm{0x03\quad Dot~Method}$我们知道，原本的多项式是系数表示法，现在我们将其转化为点值表示法$(\boldsymbol{dot~method} )$。即我们可以把多项式$F(x)$转化为多项式函数$f(x)$，那么这个$n$阶函数就可以由$n+1$个点唯一确定。即$$f(x)\Longleftrightarrow{(x_0,y_0),(x_1,y_1),(x_2,y_2)….(x_n,y_n)}$$那么$$\forall k,y_k = f(x_k)$$这是很显然的，并且这$n+$个点是随意选取的——只要求它们相异即可。 $\rm{Advanced~Trick~Point}$ $\color{red}{1}$ $\rm{Multiplication}$ 假设我们有两个关于$x$的$n+1$次多项式$A(x)$和$B(x)$，我们要对它的点值表达式进行乘法操作。由于结果有$2n+1$项，我们考虑补上一堆项，并对$$A(x) = {(x_0,y_0),(x_1,y_1)….(x_{2n},y_{2n})}$$ $$B(x) = {(x_0,y_0’),(x_1,y_1’)….(x_{2n},y_{2n})}$$ 做乘法可得 $$A(x)B(x) = {(x_0,y_0y_0’),(x_1,y_1y_1’)(x_{2n},y_{2n}y_{2n}’)}$$ 我们观察点乘法，它的时间复杂度达到了$\Theta(n)$，完全可以接受。那么不妨先看一下算法的大体思路： 对于每个因子多项式，选取$n+1$个点，得出点值表达式（复杂度$\Theta(n^2)$） $\longrightarrow$点乘法(时间复杂度$\Theta(n)$)——&gt;将得出来的$C(x)$的点值表达式再转换成系数表达式(复杂度$\Theta(n^2)$) 这就是$FFT$的大体流程。转化之后怎么没多快常数还大了 虽然其余部分的时间复杂度还是很麻烦的$O(n^2)$，但是都是可以优化成$O(nlogn)$的。 本质上的$FFT$包含$\boldsymbol{DFT}$（离散傅立叶变换）和$\boldsymbol{IDFT}$（逆离散傅立叶变换）实际上，$DFT$对应着的就是把系数表达式映射到点值表达式的过程，$IDFT$对应着的就是我们把点值表达式映射到系数表达式的过程。 $\rm{0x04~Base ~of~Optimization}$因为实际上，我们的第一步——求值（系数转点值）和我们的第三步（点值转系数）都是可以做到$nlogn$的，那么总的时间复杂度，渐进意义下就是$O(nlogn)$的。 下面就让我们来看看如何优化： $\rm{Advanced~Trick~Point}$ $\color{red}{2}$ $\rm{Unit ~Complex ~Root}$ $n$次单位复根是满足$\omega^n = 1$ 的复数$\omega$，其中我们可以由复数的运算法则（辐角相加，模相乘）很简单地得出$n$次单位根有$n$个这个结论——亦或者是用代数基本定理证，都可以。而又因为复数$\omega^n$在复数平面上的模都是一，所以相乘之后还会是一，那么所有的$\omega_i,1 \leq i \leq n$就会均匀分布在单位圆上，类似当$n = 8$时它是这样的： 我们考虑欧拉公式： $$e^{ix} = cosx + isinx$$ 我们取$x =2\pi$，可以得到如下关系式：$$e^{2 \pi i} = 1 = \omega^n \Longleftrightarrow \omega = e^{\frac{2\pi i}{n}}$$ 们把此时的单位根称之为主次单位根，记作$$\omega_n = e^{\frac{2\pi i}{n}} $$ 那么对于其他的单位根，记作$$\omega_n^k=e^{\frac{2\pi ik}{n}},0 \leq k &lt; n$$都是主次单位根的整次幂，也就是上图中的一圈。 诶，这个有啥用啊$QAQ$? 那是因为单位根们有一堆特别好用的性质，让我们可以将数据规模不断折半，使得其达到$nlogn$的复杂度…… 那么我们先来看其支持其规模减半的引理： $\frak{Elimination ~Lemma\quad}$消去引理 引理：对任何整数$n \geq 0,k \geq 0,d &gt;0$,有$$\omega_{dn}^{dk} = \omega_n^k$$ $\mathcal{Proof.}$ 这个好像很好证的样子……代入定义可以获得$$\omega_{dn}^{dk} = \omega^{\frac{2\pi dk}{dn}} = e^{\frac{2\pi ik}{n}} = \omega_n^k$$$\mathcal{Q.E.D.}$ $\frak{Binary~Lemma\quad}$ 折半引理 引理：对于任何大于$0$的偶数$n$，都有$n$个$n$次单位复根的平方的集合，等于$\frac{n}{2}$个$\frac{n}{2}$次单位复根的集合。 $\mathcal{Proof.}$ 我们可以由消去引理得到$$(\omega _n^k)^2 = \omega^{2k}_n=\omega_{n/2}^k$$那么 $$(\omega_n^{k + \frac{n}{2}})^2 = \omega_n^{2k + n} \Longrightarrow \omega_n^{2k} \cdot \omega_n^n \Longrightarrow \omega_n^{2k} = (\omega_n^k)^2$$ $\mathcal{Q.E.D.}$ 那么接下来，如果对所有的$n$次单位跟平方一下，我们会发现$\frac{n}{2}$次单位根每个都恰好出现了两次——也就是说，在$n$个$n$此单位复数根的集合（朴素的集合，即不可重集）里，只有$\frac{n}{2}$个元素。我们参考上面那张图，它的意义就在于方向相对的两只向量，其平方相等。 那么把所有$n$单位根的平方画到一个数列上就是这样。 这个引理直接保证了我们求值的复杂度为$\Theta(n \log n)$ 而我们在代码实现中，不能直接得到$e$或者虚数$i$，所以这个时候求单位根的任务就交给了我们上文中提到过的欧拉公式。 $\frak{Sum~Lemma\quad}$求和引理 引理：对于任意$n&gt;0$且$k$不能整除$n$，我们都有$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = 0$$ $Proof.$ 由几何级数的求和公式（等比数列求和公式)$$\sum\limits_{j = 0}^{n}{x^j} = \frac{x^{j +1} -1}{x -1}$$可得$$\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = \frac{(\omega_n^k)^n -1}{\omega_n^k -1} \Longrightarrow \frac{(\omega_n^n)^k -1}{\omega_n^k -1} = \frac{(1)^k -1}{\omega_n^k -1}$$由于保证了$k$不可整除$n$所以分母一定不为$0.$ $\mathcal{Q.E.D}$ $\rm{0x05\quad DFT \to FFT}$那么我们在了解完单位复数根之后，便可以正式地对$DFT$给出定义与操作方案了。 $DFT$ 对于我们已知的一个多项式$$A(x) = \sum\limits_{i =0}^{n - 1}{a_ix^i}$$在$\omega_n^0,\omega_n^1,\omega_n^2 \cdots \omega_n^{n-1}$处的取值，我们可以假定$n$是$2$的幂，因为即使它本身不是$2$的幂，我们也可以通过向高次幂补值为$0$的项来解决这个问题。而补足$2$的幂的目的，就是为了在$FFT$分治的过程中，使之可以一直分治下去且每次分治得出的两半可以进行运算。 那我们现在会有一个$A$的向量组$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$，对于$k = 0, 1, 2, \cdots n -1$，定义$y_k$如下：$$y_k = A(\omega_n^k)=\sum\limits_{j =0}^{n -1}{a_j \cdot \omega_n^{kj}}$$，那么向量$$\vec{y} = {y_0, y_1, y_2 \cdots y_{n-1}}$$就称作系数向量$\vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}}$的离散型傅立叶变换（$\boldsymbol{Discrete Fourier Transformation}$）。 嗯，这个离散型我们可以由点乘法联想意会一下：本来$A(x)$是一个优美的多项式，转变成函数之后是一条优美的曲线（优美只是定语……不是重要内容$qwq$），结果你突然把它拆成了一堆离散的点，把它用点值法表示，故称之曰：“离散型” 。 $FFT$优化$DFT$ 在上文中我们分析过，将系数表达式转化为点值表达式需要的时间复杂度为$O(n^2)$，这是朴素算法。而我们只需要用一种被称作快速傅立叶变换（$\boldsymbol{Fast Fourier Transformation}$）的方式，就可以将其时间复杂度压缩成$O(nlogn)$。而在这里我们就用到了刚才证明的引理——折半引理。 我们考虑将原来的多项式$$A(x) = a_0+a_1x+ a_2x^2 \cdots +a_{n-1}x^{n-1}$$重定义成两个次数为$\frac{n}{2}$的小多项式$A^{[0]}(x)$和$A^{[1]}(x)$： $$A^{[0]}(x) = a_0 + a_2x+a_4x^2 \cdots +a_{n-2}x^{\frac{n}{2} - 1}$$ $$ A^{[1]}(x) = a_1 + a_3x+a_5x^2 \cdots +a_{n-1}x^{\frac{n}{2} - 1}$$ 那么也就是说，$A^{[0]}(x)$存储的是所有偶数位（二进制位最后一位是$0$），而$A^{[1]}(x)$存储的是所有的奇数位（二进制位最后一位是$1$），那么有下式：$$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$$那我们求$A(x)$在单位根们$\omega_n^0,\omega_n^1,\omega_n^2 \cdots ,\omega_n^{n-1}$处的值，就变成了先求出$A^{[0]}(x^2)$和$A^{[1]}(x^2)$的值，然后根据上式进行合并即可。 而显然的是，根据折半引理，我们根本不需要$O(n)$求，而是通过数据规模不断减小使之成为$O(\log n)$。于是，我们成功通过$FFT$优化了求值的复杂度。 那么同时对于另一边，我们可以根据 $$A(\omega_n^{k+\frac{n}{2}}) = A^{[0]}(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}A^{[1]}(\omega_n^{2k+n}) \Longrightarrow A^{[0]}(\omega_n^{2k}\cdot \omega_n^{n})-\omega_n^{k}A^{[1]}(\omega_n^{2k}\cdot \omega_n^{n})$$ 得到 $$A(\omega_n^{k+\frac{n}{2}})=A^{[0]}(\omega_n^{2k})-\omega_n^{k}A^{[1]}(\omega_n^{2k})$$ 从而有伪代码： 1234567891011121314151617181920212223int Lim = 1, N, M ;function FFT(int lenth, complex *A, int flag)&#123; IF (Lim == 1) return ; complex A0[lenth &gt;&gt; 1], A1[lenth &gt;&gt; 1] ;//分成两部分 for(int j : 0 to lenth by_grow 2) A0[j &gt;&gt; 1] = A[j], A1[j &gt;&gt; 1] = A[j + 1] ; FFT(lenth &gt;&gt; 1, A0, flag) ; FFT(lenth &gt;&gt; 1, A1, flag) ; complex Wn = unit(,) , w = (1, 0) ;//Wn是单位根，w用来枚举幂，即我们令主次单位根不变，由于其余单位根都是其整次幂，所以可以用一个w来记录到第几次幂 /*此处求单位根的时候会用到我们的参数flag……嗯没错就用这一次，并且flag的值域为(-1, 1)……是的，只会有两个值*/ for(int j : 0 to (lenth &gt;&gt; 1) by_grow 1 with w = w * Wn)&#123; A[i] = A0[i] + A1[i] * w ;//应用公式，下同 A[i + (lenth &gt;&gt; 1)] = A0[i] - A1[i] * w ; //顺便求出另一半，由折半引理可显然。 &#125; &#125; function Main&#123; input(N), input(M) ; for(i : 0 to N by_grow 1) =&gt; input(A) ; for(i : 0 to M by_grow 1) =&gt; input(B) ; while(Lim &lt; N + M) Lim &lt;&lt;= 1 ;//Lim为结果多项式的长度（暂时），化为2的幂的便于分治（二分） FFT(Lim, A, 1) ;//两遍FFT表示从系数化为点值 FFT(Lim, B, 1) ; for(i : 0 to Lim by_grow 2) =&gt; A[i] *= B[i] ;//点乘法，此处需要重定义乘号，因为每一项现在表示的是一个点，有x和y两个属性qwq &#125; 以上是基于$pks$标准下的伪代码你可以试试在c++标准下运行，其中$for$循环部分，$grow$表示当前循环变量的单次增量，之后带有$with$表示每次循环结束都会进行的运算（下同 嗯，这就是求值的方法，好像很$nice$地达到了$O(n \log n)$ $FFT$优化$IDFT$ 上文中我们曾经提及过的范德蒙德矩阵可以放到这儿用： $\begin{vmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \newline 1 &amp; \omega_n &amp; \omega_n^2 &amp; \cdots &amp; w_n^{n-1} \\newline1 &amp; \omega_n^2 &amp; \omega_n^4 &amp; \cdots &amp; \omega_n^{2(n-1)} \newline \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline 1 &amp; \omega_n^{n-1} &amp; \omega_n^{2(n-1)} &amp; \cdots &amp; \omega_n^{(n-1)(n-1)} \newline \end{vmatrix}$ $\begin{vmatrix} a_0 \newline a_1 \newline a_2 \newline \vdots \newline a_{n-1} \end{vmatrix}$ = $\begin{vmatrix} y_0 \newline y_1 \newline y_2 \newline \vdots \newline y_{n-1} \end{vmatrix}$ 那为了求出我们的$\vec{a} = {a_0, a_1 \cdots ,a_{n-1}}$我们应该让刚刚求值算出的$\vec{y}$乘上我们$\vec{V}^{~-1}$（$\vec{V}$的逆矩阵）即可。但是桥豆麻袋~~~不需要用什么高消啊…余子式啊…我们只需要以下： 推论：对于$j,k = 0,1, 2 \cdots n-1,V_n^{-1}$的$(j, k)$处的值为$\omega_n^{-kj}/n$ $Proof.$ 我们考虑反向证明，已知$V_n’$是一个$(j,k)$处值为$\omega_n^{-kj}/n$的、与$V$形态相同的矩阵，那我们只需要证明$V’ \cdot V = I_n$即可，其中$I_n$是$n$阶单位矩阵，即主对角线都是$1$，其余位置上是$0$的矩阵。 那么我们考察$V’ V$中的元素$(i, j)$，有如下的式子$$V’V = \sum\limits^ {n-1}_{k=0}{(\omega_n^{-ki}/n)} \cdot {\omega_n^{kj}} = \frac{1}{n} \sum\limits^ {n-1}_{k=0}{\omega_n^{k(j-i)}}$$ 由求和引理当且仅当$i=j$时其值为一，其余的时刻均为零，所以有$V’V = I_n$ $\mathcal{Q.E.D}$ 那么我们把我们刚刚求出来的逆矩阵$V^{-1}$美化一下，提出每一项所除的$n$，可以得到$IDFT$可以如此计算：$$IDFT_n(y) = \frac{1}{n}\sum\limits_{k = 0}^{n-1}{y_k\omega_n^{-kj}},j\in [0,n-1]$$诶，这个好像……跟我们求值时的公式差不多？没错，除了带个负号，其余的都差不多。所以我们可以考虑打个标记：当$flag=1$时，他是正向$DFT$；当它等于$-1$时，它是逆向的$ IDFT$。这可以让我们通过这一个函数解决两个过程。我们只需要用$y$替换$a$，用$\omega_n^{-1}$替换$\omega_n$，其余的没什么差别，于是……时间复杂度还是$O(n \log n)$的! 123456789101112131415161718192021void FFT(int Lim,complex *A,int flag)&#123; if(Lim == 1) return ; complex A0[Lim &gt;&gt; 1], A1[Lim &gt;&gt; 1] ; for(int i = 0; i &lt;= Lim ; i += 2) A0[i &gt;&gt; 1] = A[i], A1[i &gt;&gt; 1] = A[i+1] ; FFT(Lim &gt;&gt; 1, A0, flag) ; FFT(Lim &gt;&gt; 1, A1, flag) ; complex unit = (complex)&#123;cos(2.0 * Pi / Lim) , flag * sin(2.0 * Pi / Lim)&#125;, w = complex(1, 0) ;//欧拉公式 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; A[i] = A0[i] + w * A1[i] ; A[i + (Lim&gt;&gt;1)] = A0[i] - w*A1[i]; &#125;&#125;int main()&#123;......................FFT(A, 1), FFT(B, 1) ;for(i = 0; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;FFT(A, -1) ;......................&#125; 好的，现在嘛……可以考虑撒花花啦！因为我们的$FFT$实际上已经结束了！$But$，这个递归版本的$FFT$由于牵扯到$sin/cos$的运算、$double$、递归时的入栈出栈（底层），所以常数特别的大$emmmmm$，那么—— $\rm{0x06~Iterative~ Optimization}$我们现在要引出的就是迭代版的$FFTqwq$ · $\rm{Advanced~Trick~Point}$ $\color{red}{3}$ $\rm{The~Butterfly ~Operation}$$emmm$先上一个不是特别卡常数的优化。我们观察之前的代码中，有这么一步：1234 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; a[i] = A0[i] + w * A1[i] ; a[i + (Lim&gt;&gt;1)] = A0[i] - w*A1[i];&#125; 我们会发现……$\omega \cdot A^{[1]}[i]$被执行了两次，所以我们不妨用个变量记录它：12345 for(int i = 0;i &lt; (Lim &gt;&gt; 1) ; i ++, w = w * unit) &#123; int temp = w * A1[i] ; a[i] = A0[i] + t ; a[i + (Lim&gt;&gt;1)] = A0[i] - t ;&#125; 嗯，这就是全部的优化啦！那么，FFT，完！ $qwq$这分明是骗小孩子的啦……如果单单这一步就可以卡常数的话，那这个世界该多么美好$\mathcal{QAQ}$。好吧，说这个的原因，只是为了引出我们关于蝴蝶操作的定义： 我们定义$\omega_n^k$为旋转因子，那么每一次我们先将$y_k^{[1]}$与旋转因子的乘积存储在一个变量$t$里，并在$y_k^{[0]}$增加、减去$t$的操作称为一次蝴蝶操作。 说白了，蝴蝶操作是一次$O(2)$的求出$A^{[0]}_k$与$A^{[1]}_k$的操作。 我们首先考虑按照递归的思路，将$FFT$的分治流程刻画一下： 我们会发现，其实我们是可以对它进行反向迭代的。以上面的迭代树为例，我们的步骤大体如下： $step 1$ 成对地取出儿子节点，用蝴蝶操作计算出其$DFT$。$step 2$ 用这一步的$DFT$替换之前的；$step 3$ 直到我们迭代到根节点为止，否则返回$step 1$ 而反向迭代似乎有规律可循。我们发现只要我们用迭代的过程模拟出回溯的过程即可。那么思路便有了：三层$for$，先枚举区间长度（1，2，4，8……），第二层枚举长度为$j*2$的每个区间的起点——意图为同时枚举两个相邻区间，便于相邻区间之间$DFT$的合并，第三层负责遍历每段区间，运用蝴蝶操作逐个合并： 12345678910for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123;//枚举区间长度，从小区间到大区间依次合并。 node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123;//两段区间两段区间的枚举，用于合并 node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123;//枚举k所枚举的两个区间内的值，并进行蝴蝶操作。 node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ;//一次蝴蝶操作 &#125; &#125; &#125; 嗯，好像……海星？哈，思维不严谨的我们漏了一个地方：我们在$DFT$的时候，为了保证时间复杂度是$\Theta(\log n)$，我们曾经进行过一次$A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2)$的操作，所以我们需要自动调整顺序。通俗一点，就是我们原来的序列顺序是$0,1,2,3,4,5,6,7$，但是迭代版的$FFT$却需要的顺序应该跟叶子结点的顺序吻合，即$0, 4, 2, 6, 1, 5,3,7$。所以—— · $\rm{Trick~Point}$ $\color{red}{4}$ $\rm{The~Butterfly ~Law}$ 这个嘛……我们可以选择打个表观察：原来的序号 $0 1 2 3 4 5 6 7$现在的序号 $0 4 2 6 1 5 3 7$原来的二进制表示 $000 001 010 011 100 101 110 111$现在的二进制表示 $000 100 010 110 100 101 011 111$ 诶，二进制好像是反序的嗷~~这便是我们的最后一个$trick$，蝴蝶定理。而因为我们观察到的蝴蝶定理是满足一一对应性的，所以我们在$FFT$之前$swap$一遍即可。 嗯，然后我们可以将这个反序存在一个数组里面。类似这样求出来：1for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; 呃，这个二进制计算自己推一下就好。 那么我们可以看到，这就简化了很多冗余的步骤，并让我们脱离递归的大常数。真开森啊 最后附迭代版的代码(我写的常数好像有点儿大$QAQ$) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define il inlineusing namespace std ;int N, M, K ;const int MAXN = 3000100 ;const double Pi = acos(-1.0) ;int i, j, k, l, Lim = 1, L, R[MAXN] ; struct node&#123; double x, y ; node (double xx = 0, double yy = 0)&#123; x = xx, y = yy ; &#125;&#125;A[MAXN], B[MAXN] ;node operator * (node J, node Q)&#123; return node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);&#125;node operator + (node J, node Q)&#123; return node(J.x + Q.x , J.y + Q.y);&#125;node operator - (node J, node Q)&#123; return node(J.x - Q.x , J.y - Q.y );&#125;il int qr()&#123; int k = 0, f = 1 ; char c = getchar() ; while(!isdigit(c))&#123;if(c == '-') f = -1 ;c = getchar() ;&#125; while(isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48 ,c = getchar() ; return k * f ;&#125;void FFT(node *J, int flag)&#123; for(i = 0; i &lt; Lim; i ++) if(i &lt; R[i]) swap(J[i], J[R[i]]) ;//前面的if保证只换一次 for(j = 1; j &lt; Lim; j &lt;&lt;= 1)&#123; node T(cos(Pi / j), flag * sin(Pi / j)) ; for(k = 0; k &lt; Lim; k += (j &lt;&lt; 1) )&#123; node t(1, 0) ; for(l = 0 ; l &lt; j; l ++, t = t * T)&#123; node Nx = J[k + l], Ny = t * J[k + j + l] ; J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ; &#125; &#125; &#125;&#125;int main()&#123; N = qr(), M = qr() ; for(i = 0; i &lt;= N; i ++) A[i].x = qr() ; for(i = 0; i &lt;= M; i ++) B[i].x = qr() ; while(Lim &lt;= N + M) Lim &lt;&lt;= 1, L ++ ; for(i = 0; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)) ; FFT(A, 1), FFT(B, 1) ; for(i = 0; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ; FFT(A, -1) ; for(i = 0; i &lt;= N + M; i ++) printf("%d ", (int)(A[i].x / Lim + 0.5)) ;//我们推过的公式里面有一个1/n这一项，最后输出的时候添上即可 return 0 ;&#125; 啊……那就撒花花吧！！ $\rm{0x00\quad Afterword}$以下是原尾语，保留了下来： 嗯……怎么说呢，现在看这个算法，真是简单的一匹啊……代码这么短这么容易背过。但是当时理解起来却花了很大心思呢！这篇博客我写了整整三天$qwq$，由于要培训和考试，所以拖拖沓沓地写了三天，一边写一边感叹自己理解的简直太浅显了。每一个证明、每一个引理、甚至每一个符号，我都需要去和其他$DALAO$比对审核、或者缠着$rqy$问个没完；每次一讲到原理，我都发现自己原来并不理解那些，于是不得不推倒重来。这篇博客会持续更新，补充语意不明、证明难以理解的地方。 以下是温馨提示： 好多自己当初不理解的地方在代码里就只有半行qaq 三个引理中，只有消去引理跟算法的实现没有关系——消去引理主要是用来证明其他引理的 真 · 结束语： 其实没什么好说的，今天重新复习了一遍，发现自己以前有好多内容虽然如原尾语所言，看上去现在看这个算法，真是简单的一匹啊，但实际上忽略了好多东西。我想大概只有一遍一遍地钻研才能了解完全一件事情吧。 $\rm{Reference}$ $[1]$ :$rvalue$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :算法导论 $^{^{[\nearrow]}}$ 提取码: txs2 [3]*：鸣谢rqy $\mathfrak{writter:pks}$]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想五 · 手中没有红玫瑰]]></title>
    <url>%2F2019%2F02%2F14%2F%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82%2F</url>
    <content type="text"><![CDATA[“随想”系列索引：戳我 今天下了一天的雪。 我是隔着窗户望的，直到现在我还没有真正触摸到久违的雪花。一年多了？或许吧。我轻度近视，但是白天在窗边的书桌旁习作时，不戴眼镜的，还是能看到纷飞的白絮——虽然有些模糊。它们经常想我挥手致意，我也满足了。 “情人节呢…”我想着。当然，人类在思考一件事的时候不可避免的要联想，我联想到的是什么呢？是我没写完也压根不想写的作业，是如果有了恋人之后老师们的竭力反对、在同学中显得鹤立鸡群以及在学业与处理恋爱关系的漩涡交叉中抽不开身——大抵就是这些吧。我不敢想了，因为我想到一桩美好的事情，仿佛就会联想到十件、上百件令人不寒而栗的事情——这让我感到恐惧。 雪真美啊。 早恋？ “严打！”， “好孩子不早恋！”， “早恋肯定没戏，好好学习吧”，“什么年龄就该干什么年龄该干的事儿”…… 说真的，我很难启齿，哪怕是在要好的朋友面前——当我说出我对哪个女孩子有好感的时候，我都是怯怯的。 直到刚刚看到了这样一篇文章，是一个网络作家苏见祈写的，挺早的一篇文章了： 小学五年级的时候，我喜欢班上的一个女孩子。那时候想的很多。比如有一天看电视剧，男主扑过来替女主挡了一枪，挂了。那天我辗转反侧了一夜，质问自己如果有人用枪指着我喜欢的小女孩，我敢不敢扑过去赴死。这犹豫让12岁的我非常羞愧。我觉得这样自私的我，不配喜欢她。我开始质疑自己，我自以为的喜欢是不是真的像大人说的那样，只是不懂事的小孩闹着玩。 如今我知道这自责毫无必要。在感情里闹着玩，这事儿在大人的世界里要流行的多。 我想得多还体现在了别的方面。比如老师说好好学习，可我一直不明白为什么。他们的那些理由，比如找个好工作啊，出人头地啊，听起来就很无聊，何必呢。 于是从初一开始，原本三好学生的我成绩一落千丈，勉强只能上个末流高中。家长老师全都急死了，或威逼利诱，或苦口婆心，我一概油盐不进。当然现在的我知道了读书的理由，可是叛逆期的少年什么也不想听。 后来初三开学，我收到了一封信。来自那个小学时候喜欢的女孩子。信的末尾有一句话：我准备报考X中，你要不要一起？ 我的手不受控制地颤抖。烈焰在灵魂的深处燃起，灼人的热浪席卷了全身每一个细胞。 为什么要读书呢？16岁的我获得了唯一的答案——为了和喜欢的人在一起。我开始疯了一样地复习，恶补这两年落下的知识点。书桌边上放了一盆水，困了就用水泼自己的脸。对于我一夜之间的剧变，大人们一个个喜笑颜开，说孩子终于懂事了。是啦，他们总以为自己很懂。 很多人说，小孩子不要谈感情，因为反正不会有结果。是，的确不会有结果。就像哪怕后来我如愿考上了X中，这依然不是柯景腾沈佳宜那样的故事。从始至终，我都没能在女孩的人生里扮演过哪怕一个配角。 可是如今我站在时间的彼端回望，如果那个十几岁的孩子没有爱上过什么人，那么他之后的人生，将无法挽回地滑入深渊。爱过一个人，是我少年时最大的幸运。 所以，当所有大人视早恋为洪水猛兽的时候，我完全不敢苟同。而当他们言之凿凿地说“谈恋爱影响学习”的时候，我更只能报以白眼。是，谈恋爱影响学习。只是很多时候，这“影响”可以被称为“激励”。 有可能影响学习的东西很多，电视剧可以，小说可以，糟糕的老师和不合格的父母更加可以。而在所有的因子里，恋爱最有可能把叛逆的少年变成更好的人。结果所有的大人，偏偏用尽所有力气，揪着这柄双刃剑纠缠不清。 我甚至怀疑，比起那些高大上的“为你好”，他们只是恐惧另一个人成为自己孩子的精神寄托，恐惧孩子脱离自己的掌控——和婆婆刁难媳妇的心理相同。 他们轻蔑地说，小孩子懂什么恋爱。好，那我们来看看大人们有多么懂爱情。相亲的男女将各自的筹码摆上天平，房，车，行业，家庭，收入，像一场等价交换的生意。夜场里乐声震耳欲聋，男人在刚认识半小时的女人耳边大喊，明天上午我送你回学校好吗。夫妻二人坐在沙发的两端玩着各自的手机，一晚上都懒得抬头看对方一眼。 所以我一直无法理解，成年人在孩子的爱情面前，那份优越感到底从何而来。他们趾高气扬地说着“小孩懂什么恋爱”，却不拿镜子照照自己的一地鸡毛。难道以上这些画面，比穿着校服的女孩假装路过球场，只为偷看一眼喜欢的男生打球，更能称为爱情？ 还有一种比较温和的反对，说起来语重心长：“你们还年轻，别着急，谈恋爱以后有的是机会。”仔细回想，这种过来人现身说法的方式，对孩子的确很有说服力。孩子总是相信美好的，相信久别重逢，相信姻缘一线，相信十年之后我们至少还是朋友。 可是，请如今已经长大的大家问问自己，当年魂牵梦萦的那个人，如今还在吗？你们是真的有的是以后，还是早已离散在人海？而后来遇到的那些人，真能模糊了十六岁留在心里的眉眼吗？ 很久以后我们终于知道，大人都在说谎。少年的错过是一生的求不得，是哪怕功成名就和富可敌国都无法挽回的遗憾。或许未来的你风光无限，可你永远无法逆转时间。没有什么“有的是机会”，错过此刻，就是错过一生。 如果有还在上学的读者看到这里，请记住，人生没有那么多以后。有喜欢的人就去追，你不追上ta，分离就会追上你，没有例外。当然啦，为了你们的手能牵得久一些，成绩一定不能落下。 至于那些义正辞严棒打鸳鸯的长辈……相信我，十年后他们不会理会你的遗憾和怅惘，他们会催你随便找个人结婚，并且丝毫不觉得在打自己的脸。 我有个有点儿丧的朋友，叫小怪。关于少年的爱恋他说过一段话，我觉得我不能说得更好了，借花献佛送给大家。 ” 很多人即使只见过一面，已经算见过了最后一面。“ 十八岁前不早恋，这辈子都来不及早恋。你的人生看起来很长，每一秒都无法挽回。 虽然不排除有“站着说话不腰疼”的嫌疑，但是我觉得这或许提醒了我什么。 我今天在这里可以开诚布公地跟各位讲我所谓的”感情经历“，”心路历程“。 当然，也是给我自己讲。 关于这件事，我一直纠结的很。因为身旁或许有了喜欢的女生，但是或因为她有男朋友了，或因为别的什么原因，我不能很顺利地实现。是坚持呢，还是不坚持呢？我不知道。以前在初中，遇到一个女孩就痴痴地觉得可以携手一生，但最后却是连牵手的机会都没有。 现在不一样了吧，一生，多长啊。 我是在担心这个吗？我也不知道。大概是从来没有什么人支持过我，包括我自己，也从来没有支持过我自己。 没提起这件事，遇见她，总会感觉内心无比纠结，会因为她一颦一簇心里翻腾好久，也会因为其他的原因感到略略压抑。好像我已经把她当成了什么洪水猛兽。因而我也常常纠结不已。 等会儿，难道每天纠结的要死就是我想要的吗？理性分析一下，我想要她成为我的恋人是我喜欢她的必然结果，但是这两种状态我真的可以权衡的很好吗？换句话说，我关于她的的喜怒哀乐还是因为我喜欢她吗？ 不，我觉得不是。 我是在亵渎一种感情，是在侮辱一个人。 爱从来都是无私地付出，而不是拼命的占有啊。 我仿佛把她当做了一种商品，一种十分想得到手的商品。我现在会展现给自己、也展现给其他人一副十分渴求、十分真诚的面孔，或许也不过是希望得到她的一种手段。当我们真正属于彼此后，我不能保证在那层皮撕开之后，我还会一如既往地珍惜这份情愫，你也不能保证，同样，她也不能保证。 你看，就这么点儿事情我纠结了这么长的篇幅。什么纠结啊，占有啊，真爱啊，一生啊， 都不过是拼命地想被爱而已。 不知道现在看到这儿的你是否和我一样孤独？孤独并不是每个人都有的情感，有些人，很多人从来都不会感到孤独——我多羡慕他们啊…… 孤独，或许也是另一种程度上的纯粹。我至今仍觉得我有着最纯粹的感情，是少年一样的感情，不是向垂暮老人一样的、只可独自怀念的情感。这种感情是热切的、生动的。 我很喜欢一首合唱曲目，叫做”我喜欢“。歌词十分动人，旋律优美动听，松弛恰到好处。 下面是歌词： 我喜欢暖冬的太阳我喜欢初春的青草我喜欢午后的庭院和一旁发呆的秋千我喜欢仲夏的冰沙我喜欢清秋的明月良宵的夜空 漫天星辰我喜欢雨后的青蛙我喜欢山前的杏我喜欢周三的傍晚被霞光亲吻的水族馆我喜欢成群的野我喜欢凌乱的书架清风的露台远处的灯海我喜欢 走在无人的九十六号公路我喜欢 木村拓哉长长的头发我喜欢 无尽田野上奔跑的麋鹿我喜欢 外婆门前的榕树我喜欢母亲的便当喜欢父亲的胡渣我喜欢八月的夜晚还在营业的游乐场我喜欢放学的铃铛我喜欢停电的夜晚点一对蜡烛 在幽静的玄关我喜欢 城市尽头那远远的青山我喜欢 热气球飞上西边的天空我喜欢 清晨的石板路雾腾腾的早餐店 阿公的桂花糕我喜欢 每一朵暮云 每一株绿树我喜欢你，你应该，也知道我喜欢你，你应该，也知道 优美的旋律，配上最后两句甜甜的告白。或许我们开来，似乎有点扭捏——扯这么多只为了表达最后两句—— 我喜欢你，你应该，也知道. 我喜欢你，你应该，也知道。 很平常？确实很平常。但是我认为这两句恰到好处。前面大段大段的铺垫，叙述了许许多多美好、恬静的事物，但是这一切或许都比不过你。 你可以想象，在一片动人的夕阳下，天空中是大片大片的奶茶红，一个憨憨的大男孩，突然叫住你，红着脸跑到你面前，拿着皱皱巴巴的稿子，颤颤地朗诵着这些——他实在太动情了，念着念着突然声调放高，声音变大——他是打心眼里喜欢你，越读越有感情，越读他越自信——但是突然他又畏缩起来，声音低低地向你说出了最后一句最动人的话：”我喜欢你，你应该，也知道“。 有可能你没有什么特殊的感觉，但在我心里，这就是最纯粹的东西——是不奢求的朴实的爱，是不考虑物质只拿捏感情的爱，是无语凝噎但心中重复千千万万次的爱，是真挚的爱——这是属于我们这个年纪最美好的东西，虽然有学业繁忙等诸多因素阻挠，无法完整地得到——但或许只是一片、两片这样的有着亮暖色调的枫叶，就可以点亮一整片枯败的枫林。 我大概在听这首歌之前，从来没有真正知道原来”喜欢“这个已经烂大街的词、这个现如今可以随便说出口又可以随便忘记的词、这个在我上过的所有学校里从来没有人敢光明正大说出来的词、这个现在在芸芸众生中已经被玷污的、被人们认为还没有一块钱来的实在的词，竟然如此的可爱，竟然如此的值得人们尊敬，竟然可以在冰冷的寒夜散发出如此耀眼的光芒。 我喜欢你，你应该，也知道。 var ap = new APlayer({ element: document.getElementById("aplayer-JGABKxFG"), narrow: false, autoplay: false, showlrc: false, music: { title: "我喜欢", author: "彩虹合唱团", url: "我喜欢.flac", pic: "/2019/02/14/随想五·情人节/wxh.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 心在流浪的人啊，在这华灯遍街的情人节，你是否也跟我一样，跟自己的灵魂形影相吊呢？ 如果你已经有了心上人，我祝福你；如果你已经有了打算携手一生的人，我也祝福你。唯有那些都市里最角落的孤独者，我们的邂逅或许是一种缘分吧，或许我们素未谋面，或许我们并不熟识，但在这流光掠影的漆黑夜空下，我希望你能跨过一切，跨过时间——看这篇文章时的你，伸出你的右手，或许就可以跟在这一晚伏案沉思写下这篇文章的我，轻轻击掌，感受对方的体温与灵魂。 我伸出手了啊，你呢？嗯…抱歉啦，我手中今天没有红玫瑰可以送你。这翩飞的雪花，就当做是我送你最好的礼物吧。 相信我，这个世界上绝对有人偷偷地爱着你，即使你觉得自己很不堪。比如你班里的某个人，比如你对门，比如你同事，比如你的后桌，比如，我。 $19/2/14$ 本来打算这篇水文就这么结束，留下一个温馨鸡汤结尾，挺好的。但突然想了想，自古以来能给人留下印象的从来不是喜剧结尾，短暂的欢愉会让人忘记。 那么就补一个深沉一点的结尾吧。 我一直不知道我现在有好感的那个人，究竟是自己意识流强加的，还是真的发自内心的喜欢。我纠结。我无法知道将来是否会遇到一见钟情的人——我希望这样，而不是为了捕获爱情而去捕获得来的感情。我惶恐。 但其实没准所谓一见钟情+修成正果一直是文学作品里面用来抓读者眼球的工具而已，大家或许都不可能找到自己的“最爱”，只能找到一个“差不多”，进而不断地磨合，直至磨成“最爱”。但这样的情节，说什么都不会让人满意吧…… 路在哪呢？彼岸又在哪呢？我已经受够一个人形影相吊的孤独生活了，但在这浩如烟海的求学之旅中，似乎接受孤独、体味孤独、并最终热爱孤独才是最好的法子吧。 可是面对着无奈的明天的我，什么都不能做。 雪，终于停了啊。现在已经午夜了，街上一个人都没有，天空在积雪的映照下，是让人着迷的紫红色。 var ap = new APlayer({ element: document.getElementById("aplayer-LActJVQo"), narrow: false, autoplay: false, showlrc: false, music: { title: "遇见", author: "孙燕姿", url: "遇见.flac", pic: "/2019/02/14/随想五·情人节/yj.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想三 · NOIP2018游记]]></title>
    <url>%2F2019%2F02%2F14%2F%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP%2F</url>
    <content type="text"><![CDATA[我不想退役。 “随想”系列索引：戳我 他看着眼前的屏幕，静静地发呆。 他不知道迎接他的将会是什么，后天的$\rm{NOIp}$终究是个谜。 刚刚给机房里其他人讲完期望的他，打心底觉得自己没有讲好，但效果似乎还可以。 “希望别考期望吧，嘿嘿……”他心里这么想着。 晚上，他一直在补他出的题的锅。鸽了这么久，也该写一写题解了啊。 他不知道是否该向身旁的同僚们一样继续打板子——上午打的板子让他很满意，虽然都是很简单的东西，但是他却觉得自己写的很精彩，都是一遍$AC$。大概这样，他觉得似乎没什么问题。 从下午就开始有空调暖风了，这倒是让他十分欣喜。前几天，或者说昨天，在机房穿着厚厚的羽绒服，手颤抖着，脑袋十分昏沉地打代码，他不愿意再回想起这些。 早上十分着急地买了早饭，之前吃学校里的羊汤都吃的是羊杂汤，今天决定尝试一下贵三块钱的羊肉汤的他感到很失望——羊肉又肥又腻又膻腥。他一点没吃，买了一块脆香米就走出了食堂。去奥赛室收拾了一下东西，本来还想离线下来几集最近在追的番剧，才发现原来$\rm{Bilibili}$没有$\rm Mac$版，连硕鼠也不能用了，便只得作罢。 终于要走了。踏上去昌邑一中的车的前一刻，他回头看了一眼学校。他记得那个开朗的、但是实际上并不是很熟的女孩在听课之前为他助威的场景；他记得他自己计划的是，$NOIP$好好考，参加完冬令营，签一个清北约，带着还算不错的成绩迎接寒假，然后在寒假里去找他的女神——高中新认识的、一个爱笑的、努力的、可爱的女生，撩她出去玩儿，最好是能在一起吧——但是学校规则是不会允许的吧。不过他认为，只要彼此都在学校里数一数二，只要彼此都能比较轻松地上清北，学校或许会睁一只眼闭一只眼。他似乎对将来他们一起努力的场景充满了信心。 “大概只需要400分，或者以上？总之不是特别难吧。”他这么想着，眼里发出晶蓝色的光，或许是反射的太阳光吧。 看了看天空，他上了大巴车。 ”昌邑一中真大啊“这是他到这儿后的第一想法。 到达昌邑一中已经是中午。饭菜比较可口，在他心里大概比日照一中的饭菜$better$几倍。下午原本想出去找同僚们蹭一下网，把板子打完，但谁知道一睡就睡到了四点。匆匆忙忙地看完考场位置，在路上遇到了同僚和前同僚。瞎侃了几句之后发现到饭点儿了，于是就只能选择去吃晚饭了。晚饭给他的感觉似乎没有午饭那么惊艳，“或许是太累了吧”，他这么想。吃饭的时候和$rqy$瞎侃，感觉海星。 宿管说$6$点以后来电，结果咕咕咕。我们于是就用空调插头接上插排凑活了一晚上。 他十二点左右才睡下——虽然他知道这么晚睡不行，但是没有办法，板子没打完的话，心中像是有什么负担一样——当初他执着于补一晚上自己的锅而不是去打板子大概也是这个缘由。他想放心地进入考场，这是他考试的习惯。 $\rm{Day~1}$突然不让坐电梯，六楼让他气喘吁吁。“该减肥了……不过现在或许不是想这个的时候”。 考场在六楼，昨晚试机的时候，他写了一个$dijkstra$，写了个$ST$表又写了个暴力$n^2 ~\rm{RMQ}$ ，并写了个对拍。都是一次成功。让他感觉很好。 入场了，他带了两块橡皮糖，两小块脆香米，都是早先从学校买好的。 $T1$他觉得似曾相识，大概是什么积木大赛还是积木大会啥的，他记不清了。考场的时候他一走神就会不自觉地去想最后一个字到底是什么，但就是想不起来。最后他写了一个复杂度$n\log^2n$的线段树和一个$n\log n$的$ST$表，又写了个对拍啥的让他俩拍，此时已经$9:15$了。 $T2$他从第一眼开始就已经输了。他觉得应该是什么数学题或者结论题，花了$10min$写了个暴力，过不了大样例的最后一个点，又想了$10min$他才发现原来不止可以由两个推出新的，可能是三个或者更多。$DP$这个想法在他脑子里一闪而过，他没有选择捕捉。最终他居然只写了一个暴力+骗分。 $T3$大概只会求直径——但是他只记得是什么两遍$dfs$或者$bfs$，因为他从没做过求直径的题。考试之前$qbxt$的时候，他甚至让别人给他推荐几道直径的题，但终究是没来得及做。他很后悔。最终写了一个暴力骗分。 期望得分$100pts + random(0,100)+random(10,20) $ $Luogu$数据$100pts + 65pts + 15pts = 180pts$ 听说今天三道题都是原题，他很愤懑，希望没准可以让$CCF$重考一下之类的。但是这根本是无稽之谈。 下午他和同僚去逛了逛昌邑一中，并且买了三本东野圭吾的书，店主对他不错，给他打了七折。 考挂了，他想到。 这世界上似乎就他一个不会$\rm T2$的人。 他对好多人的言行感到厌烦：有人说“完了，大众分160”，接着便有人回驳他“明明大众分220”，但接着又有人大声地说“大众分明明255好吧”。 虽然大家平常都互%，但是总感觉那些弱小的人是多么的无助啊——他们只会感到虚伪、无助、绝望。像我一样。 或许他期望着明天能翻盘？ 晚上他彻底颓废了，要求熄灯后，他用同学的热点看了《青春期猪头少年XXXX》的最新三集，感到海星。依旧睡得不早。$11：30$左右吧。 $\rm{Day~2}$今天他没有带什么吃的。 $T1$只会$60$分，转眼去看$T2$ 写了好长时间的暴力并且调了好久，在考试结束前$30min$他写好了爆搜，找出了规律，$65pts$左右。 $T3$连想的时间都没有。 退役了。 他很伤心。 回家之后他和其他省市的$Oier$交流之后发现大概都挂了。无奈的世界。 他本来不想期中考试，但是却又想不出什么理由来不去考试。毕竟刚考完$NOIp$的其他人都照常期中考试。 他觉得自己语文发挥的一般，物理发挥的正常，除了物理的某个傻狗填空题让保留一位小数自己眼瞎了而已。 其余的都考炸了。 初回文化课，班里的人并不陌生。语文老师似乎对他的这个语文课代表的回归感到很高兴。 他一开始也并不怎样，没啥感觉。 直到那天下午。 他兴高采烈地去奥赛室看民间测试数据的成绩。中午高二的某个学长告诉他的，他考了全校第四，接近$400$分。虽然可信度不高，毕竟自己什么逼数他自己心里清楚。不过还是期待了一下午。 兴奋的他去奥赛室看成绩。 学长看错了。 他的两个同僚都是$370/380+$的样子。 只有他不到. 其他人的分数也比他高。 他大概全校第十几吧。 他感到了绝望。 本来以为的三人行（三个人一起参加过两届省队集训），其实是不包括他的两人行。 他注定是失败者。 他伤心极了。 他开始愈发消沉，晚自习看了一晚上的文学素材荟萃那种东西，都是些鸡汤之类的蠢文章。但他什么都不想干。他想在学校读那几本从昌邑买回来的书，但是怕被抓只好作罢。 他觉得一年来，他一事无成。 或许进实验部只是个错误。但他是不会退出的。即使是为了面子也不会。 他原本计划好的一切都没有成功。现在最后一次机会，他依旧失败了。人生输家，大抵就是这样。他不愿意去面对他的奥赛同僚们。他大概就像是$EDG$——国内赛如同战神一般，一到国际比赛就死。 他的女神越开心，他越寒心。倒不是因为别的，只是他的女神越可爱，他越觉得曾经做白日梦的自己是个不曾认清现实的傻$B$，他越发感到落差的不可逾越。他绝望了。 期中考试成绩发下来了，他从停课之前的班里第五，年级第二十滑到了班里第四十，年级第$289$。这次他们班考得很好。年级前四，他的班里有三个；年级前20有10个，年级前400有46个。年级共有1640左右的人。 这似乎是实验部该有的成绩。可是跟他没有关系。 特别的，他的女神考了年级28，班里第13。他比她差十倍。虽然停课了一段时间没上好像是个不错的理由，但他依旧觉得，自己太失败了。 太失败了。 太失败了。 大休回家，现在是$11.17$晚，我用第三人称说完了这个故事，感觉……并没有什么感觉。 我发现我现在心情虽然很沉重，但是同样很放松。我大概不会再参加什么$OI$了吧——这让我感到轻松无比。不需要面对其他很强的人而有心理负担，不必面对教练主任去承受他们的“高目标”，不必每次fake时还会纠结我自己到底强不强，不必再去争强好胜。虽然最终免不了被当做反面教材说个$OI$的学弟们，虽然免不了是要主任被批一顿并且让你总结个什么傻逼错因或者感悟并让你声泪俱下地去反省并且保证以后好好学$OI$，但，我轻松的很。 这真是从未有过的轻松的感觉。 或许我本来没有什么天赋，只是在靠个人素质硬刚而已。也许信竞给我的终究是除了成功之外的一切，比如毅力，比如做人。 我感到无比的轻松。 以后大概不会学信竞了吧。毕竟压根没有什么转机。路的话，边走边想吧。 我现在十分地想学$CNAO$，之前由于要准备$NOIp$，从图书馆借来的书没来得及看。现在终于有时间了。 嗯，大概天文才是我真正喜欢的吧。以前每次为了$OI$奋斗的时候总要想想自己到底是不是真正喜欢$OI$，其实说不上喜欢吧，毕竟没有真的从骨子里喜欢这东西。 但是其实山东没有开展$AO$的，不过我想当这个第一人。 我突然很感激这一切，感激曾经的失败与成功、收获与感动。君与我之恩，毕生难忘。 到了说再见的时候了，哈，我的作业还没写呢。我可要学好文化课，做的滴水不漏才能去学$AO$啊，虽然这是一段未知的旅程，但是我乐意去闯。 在成绩单上看到了好多山东的巨佬……曾经在我看来与我水平差不多的人，大概都以压倒性的优势击败了我吧。 没准学$OI$的时候，如果我一直是为了功名利禄而学，为了获得进入某两所大学的机会而学，终究是肯定不会成功的吧——到不是说一定要去喜欢这门奥赛，只是在奋斗的时候，还是只为了奋斗而奋斗比较好吧。 我该说什么？强大的理解能力或者推理能力，终是不是OI的核心素养——创造力才是。当然啦，数学有够好+强大的理解能力=rqy这个等式也是成立的。 当然，不属于我啦。 虽然现在很不甘……但是没有办法，大概这就是人生吧。 如果说……退役后的几天感觉怎么样……还好吧，没我想象的痛苦。只不过之前一直憧憬的所谓“妹子”也好，“女神”也好，原来一直有男朋友只不过我不知道；只不过干起什么事情来都力不从心而已；只不过重新燃起的希望之火又被浇灭了而已吧，也没有什么必要去为之伤心——这才是人生吧。 听说你谷有个OIer自杀了……不知道这个传闻是真是假，毕竟也没法去确认。我只是为此感到伤心而已——无论到底有没有自杀，我只想用那句话来评论“实力如果强到独步天下，想怎么学就怎么学；否则只能毫无保留地、纯粹地去努力，而不是为了去获得功名、封佛封神 —— 不忘初心在什么时候都是最重要的。”所以，心无旁骛，什么时候都是最重要的。 总之呢，我把这篇文章称之为“启示录”，只是希望后来的Oier或可以从我的这一些杂悟里获得些什么： 做什么事情，都要先从自己的灵魂出发，而不是从利益出发。之类的吧。 我想引用一句（段）话，来自《本杰明巴顿奇事》： 有些人，注定可以于河边闲坐。有些人被闪电击中过七次。有些人对音乐有着非凡的天赋。有些人是艺术家。有些人是游泳健将。有些人懂得制作纽扣。有些人懂莎士比亚。有些人是妈妈。还有些人，是舞者。我们注定要失去我们所爱的人，要不然我们怎么知道他们对我们有多么的重要。 后会有期。 $\mathscr{THE\quad END….?}$]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【赛题整理】CF#536Div2の题解(E&F)]]></title>
    <url>%2F2019%2F02%2F08%2FCF-536Div2%E3%81%AE%E9%A2%98%E8%A7%A3-E-F%2F</url>
    <content type="text"><![CDATA[春节前的一场$CF$～名字很$nice$的说～ ⑧说别的啦，新年好那个新年好qwq! $0x01~~Preface$$emmm$这次CF本身打的很顺畅，但是居然unrated了……咕咕咕咕 这是头一次CF有比赛我全部题目都做了……可喜可贺可喜可贺233 简单总结一下前面四道题$\color{red}{Link}$： A题：sb题，$O(n^2)$枚举的红题（或许都不到），但是我$check$的时候太粗心WA了一次身败名裂XD B题：sb题，一个模拟，需要一个可以处理优先级的数据结构（其实就是堆但是我一开始想的是线段树） C题：sb题，一个贪心（其实是数学上可proof的数学题但被我当贪心题做了XD），大概就是你胡乱排个序之后胡搞一下就好。 D题：水题，思考一下可得，我们只需要写一个BFS+一个优先队列即可，因为无向图+随便走=胡搞八搞 下面两道题就好像不是那么水了qaq $0x02~~E\cdot \text{Lunar New Year and Red Envelopes}$$\color{red}{Link}$简单来说就是给$k$个区间，每个区间一个左端点$s$一个右端点$e$，同时还有一个蜜汁·右端点$t$。顺着时间线$1$~$n$，可以从$s_i$到$e_i$的时间内选择获得$w_i$的收益，但同时下次的选择必须在$t_i$之后。 最大化收益的思路下，有$m$次机会让选择者在某个时间点啥都不干。求最小的收益。 $\mathfrak {Solution}$呃，其实比较容易的发现就是个时间线$DP$。根据”$n$不大就DP$n$”的是指导思想（瞎扯的），我们应该按时间$DP$。那么第一步就是把每个区间的信息映射到时间线上去。这个时候有一个比较妙的$idea$。首先我们给每个区间的$s$和$e+1$在时间线上分别打上不同的标记，之后我们考虑沿时间线从前向后扫描每一段区间，每当遇到一个区间的$s$时就丢到一个$multiset$里面，反之遇到$e+1$时就$erase$。然后这样我们只顺便乱搞一下就可以得出每个时间点最优的方案。 之后？之后就直接$nm$的DP啊，毕竟$nm$只有$20million$那么大。 Ps:由于STL中multiset一删删一串的zz性质，改用map惹qaq 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXM 233#define MAXN 100010using namespace std ;struct time_node&#123; int mark, d, w ; bool operator &lt; (const time_node &amp;T) const &#123; return w &gt; T.w || (w == T.w &amp;&amp; d &gt; T.d); &#125;&#125; base[MAXN] ; map &lt;time_node, int&gt; M_set ; vector&lt;time_node&gt;Time[MAXN] ; long long Ans ;int N, M, K, A, B, C, D, i, j ; long long dp[MAXN][MAXM] ; int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K ; memset(dp, 63, sizeof(dp)) ; for (i = 1 ; i &lt;= K ; ++ i)&#123; scanf("%d%d%d%d", &amp;A, &amp;B, &amp;C, &amp;D), Time[A].push_back((time_node)&#123;1, C, D&#125;) ; Time[B + 1].push_back((time_node)&#123;2, C, D&#125;) ; &#125; for (i = 1 ; i &lt;= N ; ++ i)&#123; register int tot = Time[i].size() ; for (j = 0 ; j &lt; tot ; ++ j) if (Time[i][j].mark == 1) ++ M_set[Time[i][j]] ; else M_set[Time[i][j]] &gt; 1 ? M_set[Time[i][j]] -- : M_set.erase(Time[i][j]) ; if (M_set.size()) base[i] = (*M_set.begin()).first ; else base[i] = (time_node)&#123;0, i, 0&#125; ; &#125;dp[0][0] = 0, Ans = dp[1][1] ; for (i = 1 ; i &lt;= N ; ++ i)&#123; for (j = 0 ; j &lt;= M ; ++ j)&#123; j &gt; 0 ? dp[i][j] = min(dp[i - 1][j - 1], dp[i][j]) : 1 ; dp[base[i].d][j] = min(dp[base[i].d][j], dp[i - 1][j] + base[i].w) ; &#125; &#125; for (i = 0 ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][i]) ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $0x03~~F\cdot \text{Lunar New Year and a Recursive Sequence}$$Link$ 简单来说就是给你一个序列$F_x$的$k$项的递推法则（幂次积式递推），在认定前$k-1$项都满足$F_x=1$的基础上给定$F_n$，让你倒推出$F_k$来。 $\mathfrak {Solution}$恕我直言…这道题我考场上是不可能会的…（已扑街 首先我们观察一般形式： $$F_x = \begin{cases}1 , &amp;\rm{x&lt;k} \newline ? , &amp; \rm{x = k} \newline \prod\limits_{j=1}^kF_{x-j}^{b_j} , &amp; \rm{x&gt;k}\end{cases} (\mod 998,244,353)$$ 大体上这个式子是没法做的，因为毕竟是乘积+幂次方递推的形式。但是这个地方有个我没想出来、想出来也不会用的$Idea$，就是我们既然要把乘积转化成求和的形式，那就只能在指数上乱搞。换句话说，我们可以考虑把它的每一项都写成同一个数的幂次，那么递推的时候只需要做加法就可以了。 次我们选择$998,244,353$的原根作为底数。因为原根有一个很优美的性质，就是$p$的原根的幂次可以遍历$p$的简化剩余系。而由$NTT$里得到的经验，这个模数的最小原根是$3$。 原根的基本定义：设$g$为$p$的一个原根，则满足：$$𝑔^{𝑝−1} \equiv 1(\mod p)$$$$∀1≤𝑘&lt;𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)$$ 之后呢？之后我们就找一个函数$q(x)$，令$$g^{q(x)} \equiv x(\bmod p)$$ 目的是为了构造一个$l_x = q(F_x)$，使得等式$$g^{l_x} \equiv \prod \limits_{i=1}^{k}g^{b_il_{x-i}}( \mod p)$$成立。而比较特殊的是，因为$F_1$~$F_{k-1}$都为$1$，所以$l_i=0\quad(1 \leq i &lt;k)$ 。那么也就是说对于指数上的$l_x$满足$$l_x \equiv \sum\limits_{i=1}^{k}b_il_{x-i}( \mod p-1)$$这就是一个线性递推的形式了。 此处有个小$trick$，就是我们为了防止$l_x$过大，我们需要对它取模，此时直接依据费马小定理，取$p-1$做模数即可。 接下来是一个十分巧妙的$Idea$，我们虽然不知道$l_k$，但是我们可以知道$l_k$到$l_n$是如何变化的。观察题目性质，$$l_j = \omega_j l_k \mod(p-1)$$其中的$\omega_j$是一个关于$b_k$的常量因子。证明也比较简单，因为$l_i=0\quad(1 \leq i &lt; k) $是显然的。 那么我们只需要做一下矩阵快速幂——幂次上是$n-k$——就可以得出$\omega_n$来。而我们的$l_n$是可以通过对原根$g$求$BSGS$解得的。那么现在就是$$l_k\omega_n = l_n \mod (p-1)$$移个项可以得到$$l_k \omega_n + t(p-1)= l_n$$由于原题让求的是最小的正整数解，所以应用一下$exgcd$判一下是否有解就解决了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXN 108#define LL long long#define Mod 998244353using namespace std ;map&lt;LL, LL&gt; Hash ;int N, T, base[MAXN] ;LL Ft, Hn, Xs, Ans, X, Y, G ; struct Matrix&#123; LL M[MAXN][MAXN] ; void clear() &#123; memset(M, 0, sizeof(M)) ;&#125; void reset() &#123; clear() ; for (int i = 1 ; i &lt;= N ; ++ i) M[i][i] = 1 ; &#125; Matrix friend operator *(const Matrix&amp;A, const Matrix &amp;B)&#123; Matrix Ans ; Ans.clear() ; for (int i = 1 ; i &lt;= N; ++ i) for (int j = 1 ; j &lt;= N ; ++ j) for (int k = 1 ; k &lt;= N; ++ k) Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % (Mod - 1) ; return Ans ; &#125; Matrix friend operator +(const Matrix&amp;A, const Matrix &amp;B)&#123; Matrix Ans ; Ans.clear() ; for (int i = 1 ; i &lt;= N; ++ i) for (int j = 1 ; j &lt;= N ; ++ j) Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % (Mod - 1) ; return Ans ; &#125;&#125; ; inline Matrix expow(Matrix T, LL P)&#123; Matrix Ans ; Ans.reset() ; while (P)&#123; if (P &amp; 1) Ans = Ans * T ; T = T * T, P &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline LL bsgs(LL x, LL y, LL p)&#123; LL P = ceil(sqrt(p - 1)), Q = expow(x, -P + 2 *(p - 1), p) ; for (LL i = 1, j = 0 ; j &lt;= P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i)) return Hash[i] + j * P ;&#125;inline LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if(!b) &#123;x = 1, y = 0 ; return a ;&#125; LL t = exgcd(b, a % b, y, x) ; y -= a / b * x ; return t ;&#125;inline LL qr()&#123; register LL k = 0, p = 1 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') &#123; c = getchar() ; if (c == '-') p = -1 ;&#125; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k * p ;&#125;int main()&#123; cin &gt;&gt; N ; register int i ; for (i = 1 ; i &lt;= N ; ++ i) base[i] = qr() ; cin &gt;&gt; T &gt;&gt; Ft ; Matrix lab ; lab.clear() ; for (i = 2 ; i &lt;= N ; ++ i) lab.M[i][i - 1] = 1ll ; for (i = 1 ; i &lt;= N ; ++ i) lab.M[i][N] = 1ll * base[N -i + 1] ; lab = expow(lab, T - N), Hn = bsgs(3,Ft, Mod), Xs = lab.M[N][N] ; G = exgcd(Xs, Mod - 1, X, Y) ; if (Hn % G) return puts("-1"), 0 ; X = (X % (Mod - 1) * (Hn / G) % (Mod - 1) + Mod - 1) % (Mod - 1) ; Ans = expow(3, X, Mod) ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ;&#125; $0x00\quad$后记说实话，这是第一次做整套CF的题目…确实，千里挑一的题目就是比你谷上随便找几道题做来劲。$A$~$E$都还好，但是$F$实在是……看题解都要想半天的那种……尤其是这个解离散方根的东西……哇塞恶心死了从没听说过还有这东西qaq rqy说$F$题是省选一轮的难度——虽然没说是$D$几$T$几，但我感觉他的语气不像是在说一道很难的题…… 完了，要跪了。 奥赛文化课两爆炸，省选进队进你ma，指望着将来没学上，还不如收拾好铺盖早回家 。 ​ ——（pks《春日绝句》）]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
        <tag>动态规划-普通DP</tag>
        <tag>数学/线性代数/矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】拉格朗日插值法]]></title>
    <url>%2F2019%2F02%2F07%2FLagrange-Formula%2F</url>
    <content type="text"><![CDATA[好像初三的时候看选修4-6的课本看的一脸懵，这东西似乎是为数不多印象深刻的233 $\rm{0x01~~} Preface$插值($Interpolaton$) 在多项式域中可以看做是求值$(Evaluation)$的逆运算，即给定$n$组确定的本质不同的二元组$(x_i, y_i)$，满足$F(x_i) = y_i$，可以逆向求出原$n$次多项式。 而其实，拉格朗日插值公式本身是标准的$\Theta(n^2)$算法——或者不能称其为算法，运算过程$\Theta(n^2)$或许会更准确一些。$Indeed$，该公式是构造出来的，所以没有多么繁琐的证明—— $\rm{0x02}~~\rm{Proof}$$\rm Proof ~of~Existence$我们定义$F(x)$为一在实数域上的平凡$n-1$次多项式。 首先我们需要构造一个对于第$i$个二元组的特殊多项式$L_i(x)$，满足$$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \newline 0, &amp; \rm{i \neq j}\end{cases}$$ 那么我们所求的多项式$F(x)$就可以写作$$F(x) = \sum L_i(x_i)\cdot y_i$$这个式子保证了我们对应的$n$个二元组，$F(x)=y$恒成立。 那么对于$L_i(x)$，我们考虑由我们对$L_i(x)$的定义可以得出$$L_i(x) = k_i(x-x_1)(x-x_2)\cdots(x-x_n)$$其中不包含$x-x_i$这一因式。而由$L_i(x_i)=1$可知我们的比例系数$$k_i=\frac{1}{(x_i-x_1)(x_i-x_2)\cdots(x_i - x_{i-1})(x_i - x_{i+1})\cdots(x_i-x_n)}$$那么$$L_i(x) = \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}$$从而$$F(x)=\sum L_i(x)\cdot y_i(x) = \sum y_i \cdot \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}$$ $\mathcal{Q.E.D.}$ $\rm Proof~of~Uniqueness^{[1]}$​ 我们接下来要证明的是多项式$L_i(x)$的唯一性 ​ 我们假设同时有两个实数域上的$n-1$次多项式$L_1(x),L_2(x)$满足$L_i(x_j) = \begin{cases}1, &amp;\rm{i=j} \ 0, &amp; \rm{i \neq j}\end{cases}$，那么我们由作差法可以得出多项式$L_{\Delta} = L_1 - L_2$在取所有的$x_i$时，其值均为$0$。那么一定会有多项式$$L’(x) = \prod\limits_{i=1}^{n}(x - x_i)$$满足$$L’|L_{\Delta}$$ 其中$|$表示多项式整除。但是我们知道，对于$L’$这个多项式，其次数为$n-1$；而对于我们所定义的$L_i(x)$，均为$(n-2)$次的，从而$L_{\Delta}$也是$n-2$次多项式。所以我们可以得出$$L_{\Delta} = 0$$从而有$$L_1=L_2$$ $\mathcal{Q.E.D.}$$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$1234567891011121314151617181920212223242526272829303132333435363738题号：Luogu4781#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 2020#define LL long long#define Mod 998244353using namespace std ; LL Ans, xs ;int N, i, j ; LL T, t, xv[MAXN], yv[MAXN] ;inline LL expow(LL A, LL B)&#123; LL res = 1 ; while (B)&#123; if (B &amp; 1) (res *= A) %= Mod ; B &gt;&gt;= 1, (A *= A) %= Mod ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%lld%lld", &amp;xv[i], &amp;yv[i]) ; for (i = 1 ; i &lt;= N ; ++ i)&#123; t = 1 ; for (j = 1 ; j &lt;= N ; ++ j)&#123; if (i == j) continue ; (t *= (xv[i] - xv[j] + Mod)) %= Mod ; &#125; t = expow(t, Mod - 2) ; for (j = 1 ; j &lt;= N ; ++ j)&#123; if (i == j) continue ; (t *= (T - xv[j] + Mod)) %= Mod ; &#125; (t *= yv[i]) %= Mod, (Ans += t) %= Mod ;// cout &lt;&lt; Ans &lt;&lt; endl ; &#125; printf("%lld", Ans) ; return 0 ;&#125; $0x04$ 一道水题题意大概就是给出连续的一段$x_0$和$y_0$，算出多项式$F(x)$在一个特定值$x_0’$时的值。 我们注意到$40 \%$的数据可以直接高消，列出$n+1$个方程。 同时，我们还可以用朴素的拉格朗日插值法插出$80pts$的好成绩。 而对于$100 \%$的数据，$n$是$1e5$级别的，所以考虑预处理出一些东西。 我们观察拉格朗日插值公式的一般形式：$$F(x) = \sum \limits _{i=0}^{N} y_i \cdot \prod \limits_{i \neq j} \frac{x -x_j}{x_i-x_j}$$ 我们发现首先分子可以$O(n)$预处理，而分母由于$x_j$是连续的，所以$$\rm{\prod \limits _{i \neq j} x_i - x_j}= fac(i) \cdot fac(N-i) \cdot evenmark(N-i)$$其中$fac$表示求阶乘，$\rm{evenmark}$是符号函数，当$N-i$是偶数时返回$1$，否则返回$-1$。 于是我们就可以得出一个式子： $$\rm F(x) = \sum \limits_{i=0}^{N}{y_i \cdot}\frac{\frac{Pre}{x-i}}{fac(i) \cdot fac(N-i) \cdot evenmark(N-i)}$$其中$\frac{Pre}{x-i}$的缘由可以参考我的代码。 取模啥的就小费马搞一搞即可，最终复杂度$\Theta(n \log n)$ 12345678910111213141516171819202122232425inline LL expow(LL A, LL B)&#123; LL res = 1 ; while (B)&#123; if (B &amp; 1) (res *= A) %= Mod ; B &gt;&gt;= 1, (A *= A) %= Mod ; &#125; return res % Mod ;&#125;inline LL get_symbol(LL x)&#123; return (!x ? 1 : Mod - 1) ; &#125;int main()&#123; cin &gt;&gt; N ; Fac[0] = qwq = 1 ; for (i = 0 ; i &lt;= N ; ++ i) scanf("%lld", &amp;base[i]), (Fac[i + 1] = Fac[i] * (i + 1)) %= Mod ; cin &gt;&gt; T ; Ans = 0 ; if (T &lt;= N) return printf("%lld\n", base[T]) ; for (i = 0 ; i &lt;= N ; ++ i) (qwq *= (T - i + Mod)) %= Mod ; for (i = 0 ; i &lt;= N ; ++ i)&#123; M = (N - i) &amp; 1, _qwq = qwq * expow((T - i), Mod - 2) % Mod ; t = expow(Fac[i] * Fac[N - i] % Mod, Mod - 2) % Mod ; t = t * (get_symbol(M) * _qwq % Mod) % Mod, t = (t * base[i]) % Mod ; (Ans += t) %= Mod ;// cout &lt;&lt; Ans &lt;&lt; endl ; &#125; printf("%lld\n", Ans) ; return 0 ;&#125; $\rm{Reference}$ $[1] $:Angel_Kitty的$blog$《拉格朗日插值法》 $^{^{[\nearrow ]}}$ $\mathfrak{writter:pks}$]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【摸鱼笔记】群论入门]]></title>
    <url>%2F2019%2F02%2F06%2F%E7%BE%A4%E8%AE%BA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[⑧说别的了，抽代赛高！ 群$1~)~$群的定义比较简单的来讲，所谓群$(\rm{group})$指的是一类特殊的集合，这个集合包含一组元素和大于等于一个的运算，比如乘法群救记作$(G,\cdot)$。那么平凡来讲，群满足下列几个性质： 我们假定一个平凡的群$G$支持$\color{purple}{qwq}$这种运算： $Property1~~$封闭性$\forall a\in G, b\in G, a~\color{purple}{qwq}~b \in G$$Property2~~$运算的结合性$(a~\color{purple}{qwq}~b) ~\color{purple}{qwq}~ c=a~\color{purple}{qwq}~ (b ~qwq~ c)$$Property3~~$存在单位元（幺元）满足以下定义：$\exists e\in G, s.t. \forall a\in G, e~\color{purple}{qwq}~ a=a~\color{purple}{qwq}~e=a$$Property4~~$对于每个元素，存在逆元，即满足 $\forall a\in G, \exists b\in G, s.t. a~\color{purple}{qwq}~ b=b~\color{purple}{qwq}~a=e$那么也就是说的直白点吧，对所有的元素，做完该群所带有的带有结合律的运算之后，所得结果仍然属于该群且一定存在单位元，对于每个元素存在运算逆元。 那我们不妨定义一些其他的： 阿贝尔群$(Abel~ Group)$：即交换群——运算满足交换律的群。 半群：满足封闭性和结合律的群。 有限群$(Finite~Group)$：元素个数有限的群称为有限群,而有限群的元素个数称作有限群的阶 结合几个例子来解释一下： 比如以下是几个乘法群 $$ (Q\setminus{0}~,~\cdot)$$ $$(R\setminus{0}~, ~\cdot)$$$$ (C\setminus{0}~,~\cdot)$$ 他们都不能包括$0$这个元素，因为这个元素显然是没有逆元的。 或者一个好玩儿的乘法群$$((1, -1)~~, ~~\cdot)$$或者是所有非奇异的$n$阶矩阵也可以组成一个乘法群。 或者是$$(Z~,~+)$$这个群比较经典$233$，其中我们借助这个来练习一下如何判断是否成群,首先思考，这个东西一定是封闭的，因为最后会收敛于$\pm \inf$所以一定封闭，其次运算是一定符合结合律的，然后单位元肯定就是$0$，最后逆元的话，对于$n$那就一定是$-n$了（紧扣定义即可）。 $Extra Things :$ 以下是两种复合抽代数据结构（名字自己起的$233$）： 环：定义在两个运算上，$(G,+,\cdot)$其中$(G,+)$是阿贝尔群，$(G,\cdot)$是半群举例子：$Z$, $R[x]$，即整数环和$R$上的所有多项式的集合。 域：同样定义在两个运算上，$(F,+,\cdot)$其中$(F,+)$是阿贝尔群，$(F\setminus{0},\cdot)$是阿贝尔群举例子 ：$Q,R,C$即有理数域、实数域和复数域。 好的，那我们尝试证明两个命题： $Proposition1~~~~$一个群中的单位元唯一设有两个单位元$e_1,e_2$ 那么$e_1=e_1e_2=e_2$，其实是一个$233$ $Proposition2~~~~$群中元素的逆元唯一以乘法群为例，假设$a$有两个逆元$b,c$，那么一定会有$$b = b \cdot(a \cdot c) = (b \cdot a) \cdot c = c$$ 显然也是同一个。 那么此时我打算整理一个群的共性特征：$$(ab)^{-1}=b^{-1}a^{-1}$$ 很显然，证明如下：$$ab(b^{-1}a^{-1})=b^{-1}a^{-1})ab=e$$ 提这个的目的就是，我们发现在矩阵的相关内容里面也有这件事儿~所以就很开心 那么之后我们讨论周期 对于一个元素$a \in G$而言，我们记$a$的周期是$o(a)$ $o(a)$表示最小正整数，使得$a^{o(a)}=e$ $2~)~$子群及衍生本节所指“群”没有特别说明便均为有限群 不妨先给出子群的浅显版定义： 如果对于一个群$(G, C)$ ，其中$H\subseteq G$,，且 $(H,C)$是群，那么我们称在运算$C$下，$H$是$G$的子群，用$H\leq G$表示那么从而我们可以定义生成子群这个东西： 生成子群：若$S \subseteq G$， 并且对于运算$C$而言，$(G,C)$也是一个群，那么就称$G$为集合$S$在运算$C$下的生成子群。集合$S$的生成子群用$&lt;$$S$$&gt;$表示 这之后我们就可以定义陪集这个概念 陪集一般上包含左陪集和右陪集。 左陪集：如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ah=x}$为$H$的与元素$a$左陪集。右陪集： 如果$H \leq G$，对于$a \in G$，定义集合$H_a = {x\in G~|~ \exists h\in H, ha=x}$为$H$的右陪集。$233$也可以叫做傍集或者旁系之类的~ 那么我们这个地方先只研究右陪集$233$ $Lemma1:$我们首先证明一点：$|H|=|H_a|$，其中长得像绝对值符号的竖线表示的是有限群的群中元素数量。 这个其实比较显然，因为事实上群都是定义在非可重集上面的。 较为严谨的证明如下： $Proof.$ 对于$H \leq G$，如果$h_1\neq h_2 \in H$，那么$h_1a\neq h_2a$ 反证：若$h_1a=h_2a$，$h_1aa^{-1}=h_2aa^{-1},~h_1=h_2$矛盾 对于不同的$h$，$ha$互不相同，因此$|H_a|=|H|$ $Lemma2:$之后我们再证明一些好玩儿的： 命题：$H_a=H_b$当且仅当$ab^{-1}\in H$ 看起来好像不是那么好玩…… $Proof.$ 若$H_a=H_b$，则$ea\in H_a$，即$a\in H_b$，那么$\exists h\in H,~a=hb$,那么$ab^{-1}=h$ 若$ab^{-1}\in H$，那么$ha=ha(b^{-1}b)=(hab^{-1})b\in Hb$，因此$H_a\subseteq H_b$ $hb=hb(a^{-1}a)=h(ab^{-1})^{-1}a\in H_a$，故$H_b\subseteq H_a$ 因此$H_a=H_b$ 那么我们还可以有一个推论： 若$H_a\neq H_b$，那么$H_a\cap H_b = \emptyset$ $Proof.$ 假设$x\in H_a\cap H_b$， 则$\exists h_1,h_2\in H$，$h_1a=h_2b=x$ ， 那么$ab^{-1}=h_1^{-1}h_2\in H$，那么$H_a=H_b$，矛盾 从而还可以有个定理（$Lagrange$定理）： 由于$\forall g\in G$， $g\in Hg$，所以$G$中每个元素都在某个傍集中。用$[G:H]$表示不同的傍集数，那么 $$|G|=|H|\cdot [G:H]$$ 也就是说$|H|$是$|G|$的约数。 这个其实很显然，因为不同元素的傍集如果不同就不会有交集，如果相同就不会被考虑到$[G:H]$里面。所以结论平凡。 但是其实这是个很伟大的定理$233$ 好的，那么从而就会有一些神奇的推论： 推论一 ： 对于一个元素$a \in G$，$G$是一个群，那么$o(a) | |G|$ $Proof.$ 因为$o(a) = |$$&lt;$$a$$&gt;$$|$，由我们刚刚证明的定理可以得出$o(a) | |G|$ 推论二：对任意的$a \in G,a ^{|G|} = e$ $Proof.$ 比较显然，由推论一可知。 推论三：若$|G|$为素数，则$G$是循环群 $Proof.$ 若$a \neq e$，那么会有$|$$&lt;$$a$$&gt;$$|$整除$|G|$。而由于$|G|$是个素数，所以只有可能$|G| = |$$&lt;$$a$$&gt;$$|$ ，所以$G$是个循环群。 接下来我们真的要去做些好玩的了~ 定理$1$·$Fermat$小定理如果$p$为素数，那么存在$a^{p-1} \equiv 1 (\mod p) $ $Proof. $考虑质数$p$，考虑群$G=${$1,2,\dots,p-1$}，群的运算定义为对$p$取模的乘法，那么由$Lagrange$可知： $$\forall a\in G, a^{p-1}=1(\mod p)$$ 定理2·$Euler$定理$a^{\phi(n)}=1 (\mod n)$ $Proof.$考虑$n\in N^{+}$，考虑群$G=$ {$1\leq x\leq n~|~gcd(x,n)=1$ },群的运算定义为对$n$取模的乘法 那么会有$|G|=\phi(n)$，从而有： $$\forall a\in G, a^{\phi(n)}=1 (\mod n)$$ 没错，证明十分的简洁美观。 作者被这种神奇的证明给折服了$stO$.]]></content>
      <categories>
        <category>学习笔记</category>
        <category>抽象代数</category>
      </categories>
      <tags>
        <tag>数学/抽象代数/群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】BSGS算法初探]]></title>
    <url>%2F2019%2F02%2F06%2FBSGS-junior%2F</url>
    <content type="text"><![CDATA[一类解决$a^x\equiv b(~\bmod~p)$，且$p$为$prime$的同余式的算法。 $\rm{0x01}$ $\mathcal{Preface}$$\rm{BSGS}(Baby~Step~Giant~Step)$, 大步小步法。当然也会被叫做拔山盖世、北上广深算法……咳，这并不重要。形式化地讲， $\rm{BSGS}$算法主要用来解决以下问题 : 给定质数$p$, 整数$a, b$, $(a, p)=1$.求最小的非负整数$x$, 使得$a^x≡ b~(\mod p)$ 而首先我们知道的，是由欧拉定理$a ^{\varphi(p)} ≡ 1 ~(\mod p)$，并且我们还知道$a^0=1≡1 ~(\mod p)$，所以我们可以得出一个断言： 如果方程$a^x≡ b~(\mod p)$有最小非负整数解，那么最小非负整数解一定在$[0, \varphi(p))$中 $\qquad \qquad(1) $ 此处肉眼可以看出其循环节为$\varphi(p)$，不再证明。 之后我们将以此为基础进行类似分块的操作—— $\rm{0x02~~Baby~Step~Giant~Step}$首先我们记$n=\sqrt {\varphi(p)}$，那么$\forall x \in [0, \varphi(p))$, $x = i\times m+j$, $i \leq \lfloor \frac{p−1-m}{m} \rfloor,~~ 0≤j &lt;m$ 。那么对于原方程我们可以把其改为：$$a^{i\cdot n+j}≡ b~(\mod p)$$移一下项就可以变成$$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$$那么现在我们的策略是算出所有$a^j$来，在$\mod p$ 意义下观察是否有一个$i$使得$a^j ≡b \cdot a^{-i\cdot n} (\mod p)$。我们称左边枚举$a^j$叫做小步$(\rm{Baby~Step})$， 称右边枚举$b \cdot a^{-i\cdot n}$叫做大步$~(\rm{Giant~Step})$。 那么其实算法流程很明晰了，我们只需要循环两次、第一次记录的$a^j$用哈希表（$STL$自带$unordered$_ $map$）记录一下即可。 123456789101112131415161718inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline void bsgs(LL x, LL y, LL p)&#123; P = ceil(sqrt(p)), Hash.clear(), Q = expow(x, -P + 2 *(p - 1), p) ; //a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ; for (LL i = 1, j = 0 ; j &lt; P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; // Push them into hash_table for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i))&#123; cout &lt;&lt; Hash[i] + j * P &lt;&lt; endl ; return ; &#125; cout &lt;&lt; "-1" &lt;&lt; endl ;&#125; 其中细节还是有的： 计算sqrt时要上取整。 我们在求$a^{-i\cdot n}$时用的底变量需要由费马小定理求快速幂得出。但是此时指数上可能为负数，所以我们选择加上一个模数，不影响结果。 两次循环枚举的边界要注意有的是$\leq$有的是$&lt;$ 算法还没开始时，要判断本身$a$是否可以被$P$整除。如果不特判这种情况的话，我们上面代码中的Q就会=0，从而在下面的第二个循环处出错——我们的hash[i]和j不能同时为$0$，从而输出错误的答案。 $\rm{0x03}$ 例题$T1~$$LuoguP4028$ 裸题，但是有很多坑……或者说上面列举的细节都涵盖了qaq 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include&lt;tr1/unordered_map&gt;#define LL long longusing namespace std ; using namespace tr1 ; int T ;LL A, B, M, P, Q ; unordered_map &lt;LL, LL&gt; Hash ;inline LL expow(LL a, LL b, LL p)&#123; LL res = 1 ; while (b)&#123; if (b &amp; 1) (res *= a) %= p ; (a *= a) %= p, b &gt;&gt;= 1 ; &#125; return res % p ;&#125;inline void bsgs(LL x, LL y, LL p)&#123; P = ceil(sqrt(p)), Hash.clear(), Q = expow(x, -P + 2 *(p - 1), p) ; //a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ; for (LL i = 1, j = 0 ; j &lt; P ; ++ j, (i *= x) %= p) if (!Hash.count(i)) Hash[i] = j ; // Push them into hash_table for (LL i = y, j = 0 ; j &lt;= P ; ++ j, (i *= Q) %= p) if (Hash.count(i))&#123; cout &lt;&lt; Hash[i] + j * P &lt;&lt; endl ; return ; &#125; cout &lt;&lt; "Couldn't Produce!" &lt;&lt; endl ;&#125;inline LL qr()&#123; LL res = 0 ; char c = getchar() ; while (!isdigit(c)) c = getchar() ; while (isdigit(c)) res = (res &lt;&lt; 1) + (res &lt;&lt; 3) + c - 48, c = getchar() ; return res ;&#125;int main()&#123; cin &gt;&gt; T ; while (T --)&#123; M = qr(), A = qr(), B = qr() ; if ((!(A % M == 0 &amp;&amp; B))) bsgs(A, B, M) ; else cout &lt;&lt; "Couldn't Produce!" &lt;&lt; endl ; &#125; return 0 ;&#125; $T2~$ $TJOI2007~Cute~Prime$ 最裸最裸的、无特判的题……可以水一下双倍经验。 $\mathfrak{writter: pks}$]]></content>
      <categories>
        <category>学习笔记</category>
        <category>BSGS</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】LCT初步]]></title>
    <url>%2F2019%2F02%2F04%2FLCT-s-Junior-Intro%2F</url>
    <content type="text"><![CDATA[一种以$\rm Splay$作为辅助树的、动态维护连通性的算法。 $\rm{0x01}$ 闲话 · $LCT$的用途以及具体思路咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得$LCT$其实就是一个用来维护森林连通性的。 嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，LCT是更加全能的树剖。 但其实吧……$LCT$打板子是很简单的，但是真正理解却一点儿也不简单。因为本身$splay$就很麻烦了，况且$splay$之前一直用于维护数列。要知道，此处的$splay$可是作为辅助树，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转$Luogu3391$，在$LCT$里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是，$LCT$虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与$FFT$一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。 也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完$LCT$，网上的每一篇博客都包教包会。但是我今天要整理的，是对于$LCT$真正的理解。希望各位看到这篇拙作的人可以获得一些什么。 $\rm{0x02}$ 闲话 · 关于$\rm{splay}$道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？后宫佳丽三千我该翻谁的牌子呢 历史的重任最后落到了$\rm{splay}$的身上。然后$\rm{splay}$他居然： 他甚至还： …… 好吧，由于某些rqy也不知道的原因，如果不用$\rm{splay}$的话，复杂度是均摊$\Theta(\rm{nlog^2n})$, 而用$\rm{splay}$就可以做到均摊$\Theta(\rm{nlogn})$ ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合$LCT$ $\rm{0x03}$ $LCT$的思路和基础操作一 主要思路主要思路嘛……大概是基于实链剖分的操作。 朴素的树剖是重链剖分，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到$log$级别。而遗憾的是$LCT$维护的是森林的连通性，所以只能采用实链剖分。 而实链剖分大体上就是把边分为虚边和实边。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。 实链剖分的好处呢？在于实链剖分是一种动态剖分，他可以随意改变边的虚实属性。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。 那么接下来我们来看一个$LCT$是如何定义的: 1、首先，一棵$LCT$管控的是一对分散的点，点以几棵分散的$splay$的形式聚集。起初整棵$LCT$是没有任何联系的，各自为战，各自为根。我们接下来会看到的$access$、$makeroot$等操作，都是在自己的联通块儿内部进行的操作。换句话讲，$LCT$维护的是有根森林，即组成森林的每个联通块都有其唯一的根。 2、实边串联起一个联通块，同一组实边存在、且仅存在于一棵$\rm{splay}$中。$\rm{splay}$和$\rm{splay}$之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。但是两种边都没有用到显式存储，都是通过splay中的$Son$数组和$Fa$数组访问的。但虚边和实边的存储有区别： 3、虚边是认父不认子，即如果$Fa[x]==y$，那么$y$不存$x$这个儿子，但是$x$存$y$这个父亲。这样做是为了可以$Access$——因为其实在$Access$的子函数$splay$里，发挥作用的实际上是$Fa$指针。 4、实边是完整的双向存储。 5、显然的是，$\rm{splay}$中维护的是一条从存储上到下按在原树中深度严格递增的路径，且中序遍历$\rm{splay}$得到的每个点的深度序列严格递增。换句话讲，一个$\rm{splay}$里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵$\rm{splay}$中，键值就是原树中的深度。 6、如果$x$是它所在$splay$的最左边的点，那么它在原森林里的父亲是$x$所在$splay$的根的$fa$, 否则就是$x$在$splay$上的前驱. 二 基础操作$emm$所谓基础操作大概就是每个用到$LCT$的题几乎都要用到的操作。我们把$n$以实边相连的儿子记作实儿子。而由于只考虑实边不考虑虚边是一坨森林，算上虚边之后就成为了一棵树，所以我们把这棵实虚相见的树的根记为$root$ $\rm{1}$ $Access$ 这个操作有着很迷的性质，其时间复杂度是均摊$\log n$的。而这个操作的目的是$Access(n)$表示从$root$向$n$打通一条实链，并以$n$点为最深度最大的点、$root$为深度最小的点形成一棵$\rm{splay}$。 不难看出，这个操作其实就是把原来$splay$的割据给改变了。 我们思考，如果此时我们$Access$完点$n$之后，理论上来讲，$n$点应该不再有实儿子了——显然，如果有实儿子的话，$splay$中是应该包含这个实儿子的——而这就不符合$n$是$\rm{splay}$中深度最大的点的性质了。而因为在splay中，点是以深度为键值的，所以我们要每次砍掉$\rm{splay}$中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的$\rm{splay}$连上。 1234inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125; 然后这就是$Access$了。 $2 ~~Make~ Root~$ $make\text{_}root$先从$root$向$n$打通一条路径，然后$splay$上去，最后$reverse$一下。此处由于一开始$n$的深度最大，$splay$之后深度依旧最大，但此时$n$是$splay$的根，所以$reverse(n)$就相当于翻转了整条树上的链，那么翻转之后，$n$的深度就变成了最小，于是就是这个联通块儿的根节点了。 12345678910111213141516171819#define lc T[x].Son[0]#define rc T[x].Son[1]struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; inline void splay(int x) ;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void splay(int x)&#123; int qwq = x ; stk.push(qwq) ; while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ; while(!stk.empty()) push_down(stk.top()), stk.pop() ; while(check(x))&#123; int fa = T[x].F, g_fa = T[fa].F ; if (check(fa)) rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ;&#125; 此处$splay$中由于要下放标记，需要保证树的形态是正确的，所以我们用一个$stack$存一下，顺序下放标记。 $3 ~Merge~$ 此处的$Merge(x, y)$的意义是，拉起$x,y$中间的链，形成一个$splay$。这里就直接$Mkroot$一遍，然后$Access$即可。让哪个点当根应该都可以，只不过多$splay$几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。 upd：此处$splay$还有深层次的意图，就是可以保证现在$x$和$y$是相邻的，这样在cut的时候就会很方便了。 1inline void Merge(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125; $4~~Link~\&amp;~Cut$ 如果保证$Link$和$Cut$都是合法的操作的话，$Link$直接连，$Cut$直接删即可。 12inline void Link(int x, int y)&#123; Rooten(x) ; T[x].F = y ;&#125;inline void Cut(int x, int y)&#123; Merge(x, y) ; T[x].F = T[y].Son[0] = 0 ;&#125; 此处$Link$必须先$Mkroot$一下，否则树链就断了。连的是虚边（因为连实边就会改变原来$splay$的割据）；$Cut$必须先$split$一下，保证两个点之间在同一棵$splay$中，加之我们的$Merge$操作中，一开始把$x$给$mkroot$了，再把$y$点$splay$上去，直接导致了现在$x$应该是$y$的孩子——于是就很开心的，可以直接$cut$了。 但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致$GG$，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作…… 1、$New-Link$ 12inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125; 此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。$Find$就是无比普通的$Find$。。。。233 但要注意啊，$Find$找的是原树中的根，不是$splay$。由于原树中根的深度一定最小，所以应该是$splay$中最靠左的点……所以不断找左儿子。 多$BB$一句，这个地方一定注意啊！$Find$只改变了$splay$的形态，$mkroot$改变的是原树中的根 2、$New-Cut$ 12345inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125; 此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵$splay$中的体现，要克服两个问题，第一是要判断是否连通，还是$Find$操作。 之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的$x$比$y$在原树位置靠上（$Rooten$了$x$），在$splay$中靠左，那么如果$y$有左儿子的话，说明一定有$$Depth(x) &lt; Depth(y\text{的左儿子们}) &lt; Depth(y)$$其中$Depth$表示原树深度。那么此时原树中$x$和$y$之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当$T[y].Son[0]$不指向$Null$时，$x$和$y$之间没有一条边，不能直接$Cut$。 剩下的就很简单了，$T[y].F$应该是$x$，否则也不是直接相连。 5 $~Rotate$中的坑点 呃……其实就一处而已。就是： 1234567inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void rotate(int x) &#123; int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ; if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ; T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125; 这个地方$splay$双旋判断祖父的时候，不再用$\rm{if(g\text{_}fa)}$，而是用$\rm{if(check(fa))}$。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的$splay$ 剩下的……大概就没了吧…… 于是—— $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 300233#define lc T[x].Son[0]#define rc T[x].Son[1]#define rep(a, b, c) for(a = b ; a &lt;= c ; ++ a)using namespace std ;struct LCT&#123;int F, Son[2], R, S ;&#125;T[MAXN] ; stack &lt;int&gt; stk ;int base[MAXN], N, M, A, B, C, i ;inline int Find(int x) ;inline void splay(int x) ;inline void push_down(int x) ;inline void update(int x) &#123; T[x].S = T[lc].S ^ T[rc].S ^ base[x] ;&#125;inline void reverse(int x) &#123; lc ^= rc ^= lc ^= rc, T[x].R ^= 1 ;&#125;inline bool check(int x)&#123; return T[T[x].F].Son[0] == x || T[T[x].F].Son[1] == x ; &#125;inline void Access(int x) &#123; for (int qwq = 0 ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;inline void rotate(int x) &#123; int fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[1] ; if (check(fa)) T[g_fa].Son[T[g_fa].Son[1] == fa] = x ; T[x].F = g_fa ; T[fa].Son[W] = T[x].Son[W ^ 1], T[T[x].Son[W ^ 1]].F = fa, T[fa].F = x, T[x].Son[W ^ 1] = fa, update(fa), update(x) ;&#125;inline void splay(int x)&#123; int qwq = x ; stk.push(qwq) ; while(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ; while(!stk.empty()) push_down(stk.top()), stk.pop() ; while(check(x))&#123; int fa = T[x].F, g_fa = T[fa].F ; if (check(fa)) &#123; rotate((T[g_fa].Son[1] == fa) == (T[fa].Son[1] == x) ? fa : x) ; rotate(x) ; &#125;&#125;inline void Rooten(int x) &#123; Access(x), splay(x), reverse(x) ; &#125;inline void split(int x, int y) &#123; Rooten(x), Access(y), splay(y) ; &#125;inline void Link(int x, int y)&#123; Rooten(x) ; if(Find(y) != x) T[x].F = y ;&#125;inline int Find(int x)&#123; Access(x), splay(x) ; while(lc) push_down(x), x = lc ; splay(x) ; return x ;&#125;inline void push_down(int x) &#123; if (!T[x].R) return ; T[x].R = 0 ; if (lc) reverse(lc) ; if (rc) reverse(rc) ; &#125;inline void Cut(int x, int y)&#123; Rooten(x) ; if (Find(y) != x || T[y].Son[0] || T[y].F != x) return ; T[y].F = T[x].Son[1] = 0, update(x) ; &#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M ; rep(i, 1, N) scanf("%lld", &amp;base[i]) ; rep(i, 1, M)&#123; scanf("%d%d%d", &amp;A, &amp;B, &amp;C) ; if (A == 0) split(B, C), printf("%d\n", T[C].S) ; else if (A == 1) Link(B, C) ; else if (A == 2) Cut(B, C) ; else splay(B), base[B] = C ; &#125; return 0 ;&#125; $\rm{0x00}$ 后记和参考可写完了……嗝……打个肥宅嗝犒劳犒劳自己 怎么说呢，自从我开始学$LCT$到我写完这篇$blog$为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的$LCT$，想当然地、草率地理解了理解，就开始打板子，对$LCT$一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨…… 写博客真是一个陶冶情操的过程啊……包括做表情包 加油吧，$pks$！ $\rm{Reference}$ $[1]$ :$Flash\text{_}Hu$的$blog$ $^{^{[\nearrow ]}}$ $[2]$ :某篇论文，结合食用效果显著 $^{^{[\nearrow]}}$ $\mathfrak{writter:pks}$]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】左偏树]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%B7%A6%E5%81%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[只会写不会用系列.jpeg 嗯…就当作是复习了233…时隔好几个月（其实就两个月）才想起来要整理。 $\rm{0x01}$ 关于左偏树首先是整理自己想出来的几个梗 $\mathcal{To~be~(left) ~or~not ~to~be~(left), this~is ~a~question}$ 左偏还是右偏，这是个问题。（哈姆雷特梗） $Hell~!~Where~is~my~Left~Leaning~Tree?$ 该死，我的左偏树向右偏了。 左偏树是1个log，右偏树也是1个log，那我左右都偏是不是就会更快！（恭喜你建出了一棵满二叉树） 讲个鬼故事：每棵树都是下偏树。 其实，左耳离心脏更近，所以甜言蜜语麻烦合并到左偏树里吧。（《左耳》梗）好吧我承认不是很好笑 呐，下面进入正题。左偏树，一种可以合并的堆状结构，支持$insert/remove/merge$等操作。稳定的时间复杂度在$\Theta(\log n)$的级别。对于一个左偏树中的节点，需要维护的值有$dist$和$value$。其中$value$不必多说，$dist$记录这个节点到它子树里面最近的叶子节点的距离，叶子节点距离为$0$。 首先，他有以下几个喜闻乐见的性质： 一个节点的$value$必定（或小于）左、右儿子的$value$ （堆性质）一个节点的左儿子的$dist$不小于右儿子的$dist$ （左偏性质）一个节点的距离始终等于右儿子$+1$ 那么这就可以推出以下性质： 推论：任何时候，节点数为$n$的左偏树，距离最大为$\log (n+1)-1$ $$\mathcal{Proof.}$$对于一棵距离为定值$k$的树，点数最少时，一定是一棵满二叉树。这是显然的。因为对于每个节点，如果想要有最少的儿子，那么起码要做到左儿子的数量等于右儿子的数量。那么对于他的逆命题也是成立的——“若一棵左偏树的距离为$k$，则这棵左偏树至少有$2^{k+1}-1$个节点。”所以会有$$n \geq 2^{k+1}-1\\ \log_2{(n+1)} \geq k+1\\ \log_2{(n+1)}-1 \geq k$$$$\mathcal{Q.E.D}$$ $emmm$这可是一个很美妙的性质啊。 $\rm{0x02}~~$基本操作 $Merge$ 这是整个左偏树的重头戏，时间复杂度稳定在一个$log$，其主要思想就是不断把新的堆合并到新的根节点的右子树中——因为我们的右子树决定“距离”这个变量，而距离又一定保证在$~\log~$的复杂度内，所以不断向右子树合并。 大体思路（以小根堆为例），首先我们假设两个节点$x$和$y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了。 合并了$x$的右子树和$y$之后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护性质二，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x = dist_{rson(x)}+1$. 123456inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ; rs = Merge(rs, y) ; if (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + 1 ; return x ;&#125; 我们观察，我们是不断交替拆分右子树，由推论可得我们的距离不会大于$\Theta(\log(n_x+1))+\Theta(\log(n_y+1))-2 =O(\log n_x+ \log n_y) $ 这个地方比较喜闻乐见的是需要存$root$，即需要路径压缩。不路径压缩的话，寻一次$rt$就是$\Theta(n)$的了，复杂度是不对的但似乎Luogu的模板，不路径压缩会更快 $Pop$ ……$pop$的话，乱搞就好了$233$ 1inline void Pop(int x)&#123; S[x].val = -1, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125; 然后就是总代码： 1234567891011121314151617181920212223242526272829struct Tree&#123; int dis, val, Son[2], rt ;&#125;S[MAXN] ; int N, T, A, B, C, i ;inline int Merge(int x, int y) ; int my_swap(int &amp;x, int &amp;y)&#123; x ^= y ^= x ^= y ;&#125;inline int Get(int x)&#123; return S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;inline void Pop(int x)&#123; S[x].val = -1, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ; rs = Merge(rs, y) ; if (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + 1 ; return x ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; S[0].dis = -1 ; for (i = 1 ; i &lt;= N ; ++ i) S[i].rt = i, scanf("%d", &amp;S[i].val) ; for (i = 1 ; i &lt;= T ; ++ i)&#123; scanf("%d%d", &amp;A, &amp;B) ; if (A == 1)&#123; scanf("%d", &amp;C) ; if (S[B].val == -1 || S[C].val == -1) continue ; int f1 = Get(B), f2 = Get(C) ; if (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ; &#125; else &#123; if(S[B].val == -1) printf("-1\n") ; else printf("%d\n", S[Get(B)].val), Pop(Get(B)) ; &#125; &#125;&#125; $\rm{0x03}$ 一点问题问题大概就是路径压缩…… $LuoguP3377$很不负责任地处了数据，导致以下这份代码可以过： 12345678910111213141516171819202122232425262728293031using namespace std ;struct Tree&#123; int dis, val, F, Son[2] ;&#125;S[MAXN] ;int N, T, A, B, C, i ;inline int Merge(int x, int y) ; int my_swap(int &amp;x, int &amp;y)&#123; x ^= y ^= x ^= y ;&#125;int Get(int x)&#123; while(S[x].F) x = S[x].F ; return x ; &#125;inline void Pop(int x)&#123; S[x].val = -1, S[ls].F = S[rs].F = 0, Merge(ls, rs) ; &#125;inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ; rs = Merge(rs, y), S[rs].F = x ; if (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[x].dis = S[rs].dis + 1 ; return x ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; S[0].dis = -1 ; for (i = 1 ; i &lt;= N ; ++ i) scanf("%d", &amp;S[i].val) ; for (i = 1 ; i &lt;= T ; ++ i)&#123; scanf("%d%d", &amp;A, &amp;B) ; if (A == 1)&#123; scanf("%d", &amp;C) ; if (S[B].val == -1 || S[C].val == -1 || B == C) continue ; int f1 = Get(B), f2 = Get(C) ; Merge(f1, f2) ; &#125; else &#123; if(S[B].val == -1) printf("-1\n") ; else printf("%d\n", S[Get(B)].val), Pop(Get(B)) ; &#125; &#125; return 0 ;&#125; 一切都很正常，但问题在于他复杂度不对： 1int Get(int x)&#123; while(S[x].F) x = S[x].F ; return x ; &#125; 这显然是个上界为$O(n)$的函数……不寒而栗…… 所以他是不对的，这组数据可以很好的卡掉（由巨佬小粉兔制作）。 所以应该用一个并查集维护。而我们在路径压缩之后，必须要在$pop$后，给$pop$掉的点一个指针指向新的根，所以： 123inline int Get(int x)&#123; return S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;inline void Pop(int x)&#123; S[x].val = -1, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125; 于是最后的代码： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#define MAXN 150010#define swap my_swap#define ls S[x].Son[0]#define rs S[x].Son[1]using namespace std ;struct Tree&#123; int dis, val, Son[2], rt ;&#125;S[MAXN] ; int N, T, A, B, C, i ;inline int Merge(int x, int y) ; int my_swap(int &amp;x, int &amp;y)&#123; x ^= y ^= x ^= y ;&#125;inline int Get(int x)&#123; return S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;inline void Pop(int x)&#123; S[x].val = -1, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ; rs = Merge(rs, y) ; if (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + 1 ; return x ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; T ; S[0].dis = -1 ; for (i = 1 ; i &lt;= N ; ++ i) S[i].rt = i, scanf("%d", &amp;S[i].val) ; for (i = 1 ; i &lt;= T ; ++ i)&#123; scanf("%d%d", &amp;A, &amp;B) ; if (A == 1)&#123; scanf("%d", &amp;C) ; if (S[B].val == -1 || S[C].val == -1) continue ; int f1 = Get(B), f2 = Get(C) ; if (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ; &#125; else &#123; if(S[B].val == -1) printf("-1\n") ; else printf("%d\n", S[Get(B)].val), Pop(Get(B)) ; &#125; &#125; return 0 ;&#125; $\rm{0x04}$ 一道水题无论怎么说，单独用一篇博客来整理板子题实在是太$Low$了（尤其是显得笔者很没品位），于是就直接拼到一起吧qwq [LuoguP1456]Monkey King 链接 这玩意儿真tm水爆啊…直接存个代码证明我做过这道题吧qaq： 等会儿，突然想起来这道题的坑点来。就是原来的板子题，都是维护序列那种感觉，一个元素pop掉之后又就不用管它了。但是这道题是一道应用题，所以不应该删完不管，应该清空qwq。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAXN 200010#define lc T[x].Son[0]#define rc T[x].Son[1]#define rep(a, i, b) for(i = a ; i &lt;= b ; ++ i)using namespace std ;struct Heap&#123; int val, dis, Son[2], rt ;&#125;T[MAXN] ; int N, M, A, B, i ;inline int get(int x)&#123; if (x == T[x].rt) return x ; return T[x].rt = get(T[x].rt) ;&#125;inline int Merge(int x, int y)&#123; if (!x || !y) return x + y ; if (T[x].val &lt; T[y].val) x ^= y ^= x ^= y ; rc = Merge(rc, y) ; if (T[lc].dis &lt; T[rc].dis) lc ^= rc ^= lc ^= rc ; T[lc].rt = T[rc].rt = T[x].rt = x, T[x].dis = T[rc].dis + 1 ; return x ; &#125;int main()&#123; while (~scanf("%d", &amp;N))&#123; memset(T, 0, sizeof(T)) ; rep(1, i, N) T[i].rt = i, scanf("%d", &amp;T[i].val) ; cin &gt;&gt; M ; rep(1, i, M)&#123; scanf("%d%d", &amp;A, &amp;B) ; int rt1, rt2 ; int f1 = get(A), f2 = get(B) ; int ff1, ff2 ; if (f1 == f2) &#123; puts("-1") ; continue ; &#125; T[f1].val &gt;&gt;= 1, T[f2].val &gt;&gt;= 1 ; rt1 = Merge(T[f1].Son[0], T[f1].Son[1]) ; T[f1].Son[0] = T[f1].Son[1] = T[f1].dis = 0 ; rt2 = Merge(T[f2].Son[0], T[f2].Son[1]) ; T[f2].Son[0] = T[f2].Son[1] = T[f2].dis = 0 ; ff1 = Merge(f1, rt1), ff2 = Merge(f2, rt2) ; T[ff2].rt = T[ff1].rt = Merge(ff1, ff2), printf("%d\n", T[get(T[ff1].rt)].val) ; &#125; &#125; return 0 ;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>左偏树</category>
      </categories>
      <tags>
        <tag>可并堆/左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】HLPP+丧心病狂的优化]]></title>
    <url>%2F2019%2F01%2F11%2FHLPP%2F</url>
    <content type="text"><![CDATA[#define $u$的伴点集合 与$u$相隔一条边的且$u$能达到的点的集合 $0x00~ {}~Preface$ $HLPP(Highest~Label~Preflow~Push)$最高标签预流推进算法是处理网络最大流里两种常用方法——增广路&amp;预流推进中，预流推进算法的一种。据传由$tarjan$发明怎么又是他 ，并被其他科学家证明了其复杂度是紧却的$O(n^2\sqrt m)$。在随机数据中不逊色于普通的增广路算法，而在精心构造的数据中无法被卡，所以是一种可以替代$Dinic$的方法（随我怎么说，代码又长又难调，所以还是$Dinic$好啊$\rm{TAT}$） 但无论怎样，$wiki$里面已经承认$HLPP$是现在最优秀的网络流算法了。 那么预流推进这个大门类里面，思想都差不多。大抵上就是我们对每个点记录超额流($Extra~Flow$) ，即允许流在非源点暂时存储，并伺机将超额流推送出去。不可推送的，就会流回源点。那么最终答案显然存储在$Extra[T]$里面。 但同时这也有一个问题，就是会出现两个点相互推送不停的情况。为了防止这样，我们采用最高标号的策略，给每个点一个高度，对于一个点$u$以及它的伴点集合${v}$，当且仅当$h_u = h_v + 1$ 时才可以推送流。并且我们对于源点$S$，设置$h_S = N$，并对于$S$实行无限制推送。那么最后的答案就保存在$Extra[T]$里面 。 但有时，我们发现有个点是”谷“，即周围点的高度都比它高，但是它有超额流。那么我们此时考虑拔高它的高度，即重贴标签($relabel$)操作。 $0x01\quad$ 初步的算法流程以下我们用$Extra_u$表示$u$的超额流，$h_u$表示$u$的高度，用$f_k$表示边$k$的容量。 首先把所有的$h_i$都置为零，并把$h_s$置为$N$（点数）。 将$S$的流推送到每个与$S$相邻的点，同时把他们加入一个以高度为键值得大根堆，所以每次取出的应该是高度最高的、且超额流不为零的点，并执行推送操作。 对于点$u$推送过程中，如果$Extra_u$减到了$0$，就立即退出（优化一） 对于每条出边$k$，推送的流量$F = min(f_k,Extra_u)$并执行两个点（$u,v$）的超额流增减。如果$v$不在堆里面，要把$v$放到堆里面。 如果推送完毕$Extra[u]$不为零，那么从他的伴点集合选取一个高度最小的点并记录它的高度$h_{min}$，则新的$h_u = h_{min}+1$，并把$u$入堆。 好的，然后就可以撒花了……可是等等，他怎么这么慢$qaq$ 接下来我们发现，重贴标签的过程似乎与$ISAP$有点点像……所以我们不妨通过一个$Gap$数组来记录”断层情况“：即如果对于一个点$u$来说，他的伴点集${v}$已经不存在$h_u = h_v + 1$的点了，并且也不存在一个点$j$使得$h_j = h_u$那么这个地方就是一个断层$(Gap)$ ，那么也就是说，对于所有$h_i&gt; h_u$的点来说，它们把流推送到$h_u$的高度就不能继续推送了，所以我们直接$h_i = N + 1$，让他们回流到源点。（优化二） 接下来这个优化，亲测可以提速$4000ms$，平均每个测试点提速$700$ ~ $800ms$，去掉数据最小的点，每个点平均提速$1000ms$。这就是——$BFS$! 我们不妨一开始就倒着$BFS$一遍，搜出每个点离汇点的最短距离作为初始高度而不是把零作为初始高度（源点高度还是$N$。嗯，$Mr_Spade$大佬实在太强了$qwq$ 对了，代码实现方面，需要好多判断不是源点和汇点的小细节……无路赛无路赛无路赛$&gt;_&lt;$！ $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·1$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;//省略某些部分#define Inf, MAXN, MAXM, to(k)struct state&#123; int num, h ; bool operator &lt;(const state &amp; now) const&#123; return h &lt; now.h ; &#125;&#125; ; priority_queue &lt;state&gt; heap ; BFS init ;int N, M, S, T, cnt = -1, A, B, C, D, t, min_h ;int head[MAXN], Extra[MAXN], H[MAXN], Gap[MAXN], node ;inline void Preflow_Push()&#123; register int i, k ; for (i = 1 ; i &lt;= N ; ++ i) if(H[i] &lt; Inf) ++ Gap[H[i]] ; for(k = head[S]; k != -1 ; k = E[k].next) if((t = E[k].f))&#123; E[k].f -= t, E[k ^ 1].f += t, Extra[S] -= t, Extra[to(k)] += t ; if(to(k) != T &amp;&amp; !vis[to(k)]) heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = 1 ; &#125; while(!heap.empty())&#123; vis[node = heap.top().num] = 0, min_h = Inf, heap.pop() ; for(k = head[node] ; k != -1 ; k = E[k].next)&#123; if(E[k].f &amp;&amp; H[node] == H[to(k)] + 1)&#123; t = min(Extra[node], E[k].f) ; E[k].f -= t, E[k ^ 1].f += t, Extra[node] -= t, Extra[to(k)] += t ; if(!vis[to(k)] &amp;&amp; to(k) != S &amp;&amp; to(k) != T) heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = 1 ; &#125; if (E[k].f) min_h = min(min_h, H[to(k)]) ; if (!Extra[node]) break ; &#125; if(Extra[node]) &#123; if (!--Gap[H[node]]) for(i = 1; i &lt;= N ; ++ i) if(i != S &amp;&amp; i != T &amp;&amp; H[i] &gt; H[node] &amp;&amp; H[i] &lt; N + 1) H[i] = N + 1 ; H[node] = Inf; H[node] = min_h + 1 ; heap.push((state)&#123;node, H[node]&#125;), vis[node] = 1, ++ Gap[H[node]] ; &#125; &#125;&#125;inline int read() &#123;fast;&#125;int main()&#123; Input() ; for (i = 1 ; i &lt;= N ; ++ i) head[i] = -1, H[i] = Inf ; while(M --)&#123;Add; &#125; q.push(T), H[T] = 0 ; while(!q.empty())&#123; int now = q.front() ; q.pop() ; for(k = head[now] ; k != -1 ; k = E[k].next) if (H[to(k)] &gt; H[now] + 1) H[E[k].to] = H[now] + 1, q.push(E[k].to) ; &#125; if (H[S] == 0) &#123;cout &lt;&lt; 0 &lt;&lt; endl ; return 0 ;&#125; H[S] = N, Preflow_Push() ; cout &lt;&lt; Extra[T] &lt;&lt; endl ;&#125; 看起来我们加上下面这一句话的毒瘤卡常就可以有$4000ms$左右的好成绩，但事实上，这个速度依旧慢的要死。 注意！这个写法是经典写法，其时间复杂度是紧却的$\boldsymbol{\rm{\Theta(n^2mlogn)}}$的，也就是说在$\boldsymbol{n=1200}$时会带一个$\boldsymbol{10}$倍的常数 怎么优化呢—— $\boldsymbol{0x02~~Optimization}$各位，你们将会见到迄今为止OI界最丧心病狂的优化（之一）…… 来，我们首先思考思考普通的HLPP到底会慢在哪里： $STL$支持的$heap$（比如优先队列）实在是太太太…太慢了！ 每次$Gap$优化，我们的时间复杂度是紧确的$\Theta(n)$。的这显然不合算，因为假设我当前的$\boldsymbol{gap}$（断层）正好位于倒数第一高的点和倒数第二高的点，那么也就相当于我单次会浪费$\boldsymbol{\Theta(n)}$的时间。 事实上…普通的$HLPP$代码并不长，主要问题就是这两个。 我们考虑，如果不用堆的话怎么做呢？ 呃…不用堆的意思并不是我们不从高度最大的点开始推送。这个地方需要一个$idea$——在$HLPP$中，高度函数$\boldsymbol{H(x)}$和点数集大小$\boldsymbol{N(x)}$是广义同阶的。 换句话说，我们可以考虑从高度入手。 换句话说，我们原来是通过节点编号访问节点以及其高度，现在我们如果从高度入手，再去访问节点，我们就可以做到$\boldsymbol{O(n)}$而不是$\boldsymbol{\rm{O(nlogn)}}$ 。 那么由于同一高度的节点或许有很多，直接开一个$vector$。在这个地方我们用$vector$而不用二维数组建立二维关系的原因，主要是我们初始化麻烦得很，如果套用$memset$或者$fill$的话，常数之大可想而知。 那么这两个问题就顺理成章地解决了。但这个地方还有一个优化，就是虽然$vector$和$list$都是线性容器，但是$list$的本质是双向链表，频繁处理插入删除操作时会具有更优秀的表现。 也就是说，原来的$Gap$数组我们可以直接用$list$做，以图更小的常数。那么这时存在一个问题，就是虽然本质上删除是容易的，但是你怎么知道要删同一高度下的哪个元素(=@__@=)？就算你知道，$list$也不知道啊2333 hhh不皮了，其实我们记录一下位置就好，即记录一下每个节点在$list$中的位置，单独开一个$Iterator$类型的$vector$记录即可。 好了，现在我们获得了$10$倍$+$的常数优势qwq，撒花花… 哦对，还有几点我debug的时候被坑死的点： 那个$Iterator$类型的$vector$对象是点的编号不是高度！ 注意你的下标！下标！再说一遍，下标！因为STL自带左闭右开的性质wrnm，所以一定要注意，如果你是$[1,n]$选手，注意你的$assign$函数！ $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·2$ (我觉得写的很难看但是有注释qaq)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//writter:Orchidany(pks)#include &lt;bits/stdc++.h&gt;#pragma GCC target("avx")#pragma GCC optimize(3)#pragma GCC optimize("Ofast")//sb毒瘤优化#define MAXN 10030#define min my_min#define BG begin()#define gc getchar#define rr register #define Iter iterator#define INF 2147483647#define rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)using namespace std ;typedef list&lt;int&gt; List ; int step;struct Edge&#123; int to, f, next ; Edge(int to,int f,int next):to(to),f(f),next(next)&#123;&#125;//没有人发现正下方这句注释前半句和后半句都是三个音节的吗qaq&#125; ; vector &lt;int&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;//list，就是快（//q:队列，H:高度，Extra：每个点的超额流，Set:…就是那个经典版HLPP里的堆，高度做第一维int Ans, N, M, S, T, max_H, now_H ; vector &lt;Edge&gt; E[MAXN] ; /*vector存边（据说会快）*/vector&lt;List::iterator&gt; Era_pos ; //辅助定位+删除inline void eggs() &#123; ;&#125;//for free~inline int my_min(int a, int b)&#123;return a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~ (a - b) &gt;&gt; 31) ;&#125;//黑科技inline void Add(int f, int v, int u)&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; &#125;inline int qr()&#123; rr int k = 0 ; char c = gc() ; while (!isdigit(c)) c = gc() ;while (isdigit(c)) k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = gc() ; return k ; &#125;inline void Init_label()&#123;//等价于一开始的那个BFS，只执行一次 rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; H.assign(N + 1, N + 1) ; H[T] = 0 ; q[t ++] = T ;//从T（高度小的）向前标号 while (h &lt; t)&#123;//队列……BFS……真熟悉啊……嗝…… rr int now = q[h] ; ++ h ; for (vector &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k) if (H[k-&gt;to] == N + 1 &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = H[now] + 1, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ; &#125; rep(i, 0, N + 1) Set[i].clear(), Gap[i].clear() ;//还是清空一下比较好吧 rep(i, 0, N) if (H[i] &lt;N + 1) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), //疑似insert函数的返回值是一个指针qaq (Extra[i]&gt;0) ? Set[H[i]].push_back(i) : eggs() ;//这个彩蛋（eggs）是因为，三目运算符":"两边类型需要形同… max_H = now_H = H[q[-- t]] ; //更新，BFS的性质，最后一个元素一定高度最大（除了源点）&#125;inline void Push(int x, Edge &amp;e)&#123;//单独写出来的push函数，好像很方便？ rr int now_flow = min(Extra[x], e.f) ; Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ; if (Extra[e.to] &gt; 0 &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ; // push it into "heap"&#125;inline void _Push(int x)&#123; rr int i, x_h = N, t = H[x] ; for (vector &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k) if (k-&gt;f &gt; 0)//如果可以流 if (H[k-&gt;to] == H[x] - 1) &#123; Push(x, *k) ; if (!Extra[x]) return ;&#125; else x_h = min(x_h, H[k-&gt;to] + 1) ; if (cnt[H[x]] &lt;= 1)&#123;//如果出现断层了 for(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i)//这个gap的for肯定比O(n)优秀 for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; /*断层以上的高度都没用了*/return ; &#125; -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; //重贴标签操作，为当前点删除原来的高度 ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;//增添新的高度&#125;inline int HLPP()&#123; rr int i, now ; H.assign(N, 0) ; H[S] = N ; Era_pos.resize(N) ; rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt.assign(N, 0), cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] =- INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ; //下面源点要单独拿出来推送，因为源点推送时高度差不需要=1. Init_label() ; //初始化（BFS） while (now_H &gt;= 0) //正式开始HLPP（泪目） if (Set[now_H].empty()) now_H -- ; //高度递减，实现一个堆的效果 else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ; return Extra[T] + INF ;&#125;int main()&#123; N = qr(),; rr int i ;//下面的++N是为了日后好操作qaq rep(i, 1, M) Add(qr(), qr(), qr()) ; ++ N, Ans = HLPP() ; cout &lt;&lt; Ans &lt;&lt; endl ; return 0 ; &#125; 下面是个$fread$卡常版本$qaq$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#pragma GCC target("avx")#pragma GCC optimize(3)#pragma GCC optimize("Ofast")#define MAXN 1202#define min my_min#define BG begin()#define rr register#define swap my_swap #define Iter iterator#define INF 2147483647#define rep(i, a, x) for(i = a ; i &lt;= x ; ++ i)using namespace std ;typedef list&lt;int&gt; List ; int step;const int ch_top=4e7+3;char ch[ch_top],*now_r=ch-1,*now_w=ch-1;inline int read()&#123; while(*++now_r&lt;'0'); register int x=*now_r-'0'; while(*++now_r&gt;='0')x=x*10+*now_r-'0'; return x;&#125;inline void write(int x)&#123; static char st[20];static int top; while(st[++top]='0'+x%10,x/=10); while(*++now_w=st[top],--top); *++now_w='\n';&#125;struct Edge&#123; int to, f, next ; Edge(int to,int f,int next):to(to),f(f),next(next)&#123;&#125;&#125; ; vector &lt;int&gt; q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;int Ans, N, M, S, T, max_H, now_H ; vector &lt;Edge&gt; E[MAXN] ; vector&lt;List::iterator&gt; Era_pos ; inline void eggs() &#123; ;&#125;//for free~inline int my_min(int a, int b)&#123;return a &amp; ((a - b) &gt;&gt; 31) | b &amp; ( ~ (a - b) &gt;&gt; 31) ;&#125;inline void Add(int f, int v, int u)&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; &#125;inline void Init_label()&#123; rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; rr int qaq = N + 1 ; H.assign(qaq, qaq) ; H[T] = 0 ; q[t ++] = T ; while (h &lt; t)&#123; rr int now = q[h], qwq = H[now] + 1 ; ++ h ; for (vector &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k) if (H[k-&gt;to] == qaq &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = qwq, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ; &#125; rep(i, 0, N - 1) Set[i].clear(), Gap[i].clear() ; rep(i, 0, N - 1) if (H[i] &lt; N) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), (Extra[i] &gt; 0) ? Set[H[i]].push_back(i) : eggs() ; max_H = now_H = H[q[-- t]] ; &#125;inline void Push(int x, Edge &amp;e)&#123; rr int now_flow = min(Extra[x], e.f) ; Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ; if (Extra[e.to] &gt; 0 &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ; // push it into heap&#125;inline void _Push(int x)&#123; rr int i, x_h = N, t = H[x] ; for (vector &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k) if (k-&gt;f &gt; 0) if (H[k-&gt;to] == H[x] - 1) &#123; Push(x, *k) ; if (!Extra[x]) return ;&#125; else x_h = min(x_h, H[k-&gt;to] + 1) ; if (cnt[H[x]] &lt;= 1)&#123; for(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i) for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; return ; &#125; -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;&#125;int HLPP()&#123; rr int i, now ; H.assign(N, 0) ; H[S] = N ; cnt.assign(N, 0) ; Era_pos.resize(N) ; rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] = -INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ; Init_label() ; while (now_H &gt;= 0) if (Set[now_H].empty()) now_H -- ; else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;return Extra[T] + INF ;&#125;int main()&#123; fread(ch,1,ch_top,stdin); N = read(), M = read(), S = read(), T = read() ; rr int i ; rep(i, 1, M) Add(read(), read(), read()) ; ++ N, Ans = HLPP() ; write(Ans) ; fwrite(ch,1,now_w-ch,stdout) ;&#125; 撒fa~ $0x03~~$后记 这道题的经典版本好几个月之前我写了一天……然后今天又翻出来，发现了巨佬KevinYu抛了一个玉，我就打算优化一波……毒瘤啊，什么$vector$存边、$list$我都是第一次用呜呜…… 不得不说…某些大佬的码风真是不可看啊…都写题解了怎么还这么…这么…（虽然自己的也不咋地qaq） 最后，人艰不拆，人艰不拆… $\boldsymbol{\mathfrak{writter:Orchidany(pks)}}$]]></content>
      <categories>
        <category>学习笔记</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流-最大流</tag>
        <tag>目测用不到的算法之HLPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习笔记】Dinic&费用流]]></title>
    <url>%2F2018%2F08%2F20%2Fnet-work-flow%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[$0x00~ {}~Preface$$2333$这是好久之前学的了，不过一直在咕咕咕咕。 一般来讲，正常的网络流笔记一开始都是要给网络流图下定义的。那么我们不妨也来先进行一波这种操作。 那么网络流图，类似于有向图，边上带权，但是这个权值变成了“容量”。那么，我们定义容量为$c(u,v) \in E ? c(u,v) : 0$。在整张图中有一个源点和一个汇点，且对于每个点来说有$$\sum F_{in} = \sum F_{out}$$并且我们人为的将$S$的$F_{in}$设置为$0$，$F_{out}$设置为$+\infty$。$T$正好相反。当然，如果非说不合适的话，可以将源点和汇点看做同一个点233. 通过线性规划我们可以证明的是最大流等价于最小割，而博主现在对线性规划还只是一知半解，等什么时候“贯通了”再整理博客吧233 好的，窝觉得定义什么的可以不说了，我们直接上$EK$ $0x01~$ 不知道可以用来干啥的$EK$其实，$EK$身为大家眼中的$basis$算法，他居然是比$Dinic$晚发表的……$233$ 全程是$Edmond-Karp$ ,由两位科学家一起发表的，复杂度上界大约在$\Theta(nm^2)$左右，是个比较没用的算法 他的原理就是，我们通过两个杀器来实现最大流： $Killer1:$增广路 这个东西就是我们不断寻找从源点到汇点的可行路径，不断流直到不能流为止，也没有什么技巧可言，毕竟网络流是线性规划而不是动态规划，图集与解是单射的逻辑关系而不是一对多的非映射关系。 $Killer2:$ 反向边 虽然图集与解是单射的逻辑关系，即虽然对于同一张图$G(U, V)$无论怎么走，最优解（最大流）总是一个定值，但是我们在执行算法的时候可能会因为选择了错误的增广路经而导致算法的错误。所以此时我们考虑建立反向边。其实这就是一个小小的反悔操作。这个正确性在于我们建立了反向边，对于执行反悔操作并没有什么问题，对于执行正常的增广操作也不会影响什么结果，因为毕竟是反向边——是从$T$连向$S$的，等同于原来没反向边时的情况。 嗯，那么我们程序实现的时候，大概就是这样 12345678910111213141516171819202122232425bool BFS()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, 0) ; q.push(S), dis[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if(e[k].v &amp;&amp; !dis[e[k].to])&#123; dis[e[k].to] = dis[now] + 1 ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; q.push(e[k].to) ; &#125; &#125; &#125; return dis[T] != 0 ;&#125;void _EK()&#123; while(BFS())&#123; now = T, MAX_F += _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125; 其中$Last$记录前驱，$dis$就是个$mark$，$_F$数组记录增广路上最大的流量 。 那我们接下来分析复杂度。值得注意的是，$EK$由于采用$BFS$，所以每次找的一定是最短路。而在最短路不变的一段时间内一条边和它的反向边不可能都被增广（如果增广反向边的话，$dis_{min}++$），所以在每条边都作为残量最小值增广一次之后（至多$m$次）最短路就会增加。而最短路最多从$2$增到$n$，所以最多增广$n \times m$次。而每次$bfs$至多是$\Theta(m)$的，所以总复杂度上界是$\Theta(nm^2)$ 但事实上，随机的数据大多数情况下是要远远小于这个复杂度上界的，所以$EK$可以解决朴素的最大流问题。 全部的代码存档： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010#define Inf 1926081700using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v ;&#125;e[MAX &lt;&lt; 1] ;int MAX_F, i ;int head[MAX], cnt = -1, pre[MAX], now ;int A, B, C, Last[MAX], _F[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], head[v] = cnt ;&#125;bool BFS()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, 0) ; q.push(S), dis[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if(e[k].v &amp;&amp; !dis[e[k].to])&#123; dis[e[k].to] = dis[now] + 1 ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; q.push(e[k].to) ; &#125; &#125; &#125; return dis[T] != 0 ;&#125;void _EK()&#123; while(BFS())&#123; now = T, MAX_F += _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), add(A, B, C) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt; endl ; return 0 ;&#125; $0x02$ 据说可以拯救世界的$Dinic$那么接下来我们说$Dinic$，这个算法是由$Dinic$教授创造的$qwq$ 然后$Dinic$在$EK$的基础上，采用了两个新的优化方案： $Case1:$分层图 每次我们选择用$bfs + dfs$去增广一张“增广网”，大体上就是我们记录深度（或者说是离源点的最小距离），然后我们用$dfs$遍历这张增广网。 $Case2:$当前弧 我们依仗的是这一段（句）代码： 1for(int &amp;i=cur[now];i!=-1;i=line[i].nxt) 其中比较重要的是引用符号，此处引用的目的是不断更新$cur$，达到不重复枚举的目的。 那么整体代码就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;queue&gt; #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v ; &#125;e[MAX &lt;&lt; 1] ; int A, B, C, i ;int head[MAX], cnt = -1, now, cur[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], head[v] = cnt ;&#125;bool bfs()&#123; queue&lt;int&gt; q ; fill(dis, dis + N + 23, 0) ; q.push(S), dis[S] = 1 ; while (!q.empty())&#123; now = q.front() ; q.pop() ; for (int k = head[now]; k != -1 ; k = e[k].next)&#123; if (!dis[e[k].to] &amp;&amp; e[k].v) dis[e[k].to] = dis[now] + 1, q.push(e[k].to) ; &#125; &#125; return dis[T] ? 1 : 0 ;&#125;int dfs(int St, int Aim, int Flow)&#123; if (St == Aim || !Flow) return Flow ; int Fl, res = 0 ; for (int &amp;k = cur[St] ; k != -1; k = e[k].next) if (dis[e[k].to] == dis[St] + 1 &amp;&amp; (Fl = dfs(e[k].to, Aim, min(Flow, e[k].v))))&#123; res += Fl, e[k].v -= Fl, e[k ^ 1].v+= Fl ; Flow -= Fl ; if (!Flow) break ; &#125; return res ;&#125;int Dinic()&#123; int res = 0 ; while(bfs())&#123; for(i = 1; i &lt;= N; ++ i) cur[i] = head[i] ; res += dfs(S, T, 0x7fffffff) ; &#125; return res ;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), add(A, B, C) ; cout &lt;&lt; Dinic() ; return 0 ;&#125; 嗯，那么我们不难看出$cur$其实就是为了防止我们不断重复枚举边。因为对于一次$dfs$，在同一张分好层次的图上执行，不会出现重复用一条边的情况——我们认为每条边已经流满。那么当前弧可以保证不会重复走。而复杂度没有变，但是确实会更快。 那么接下来证明一下$Dinic$的时间复杂度。 根据分层图而言，$t$的层次是单调增长的——因为每次增广完毕之后对于每条可行的增广路，都总会有至少一条边容量为零，所以最多会有$n$次重新分层。而对于每次在增广网上的操作，至多有$m$条增广路（每条边至多有一次机会置零），每条增广路要回溯+搜索总共$O(2n)$的操作。那么渐进意义上复杂度就是$\Theta(n^2m)$的。 很显然，这在随机数据的情况下也是跑不满的。而加了当前弧优化，复杂度理论上还是不变的，或者说，在跑满的情况下，复杂度更接近上限复杂度$\Theta(n^2m)$ 。 据说随机图上跑个$1 \cdot 1e4$~$5 \cdot 1e4$是没什么问题的。 最后我们来说一下费用流。 $0x03$ 费用流（最小费用最大流）其实费用流……常见的，就是在最大流的前提下费用最小。那么我们直接把$EK$的$bfs$换成$SPFA$就行了233 至于为什么不能$dinic$，很显然是因为没法分层啊……$hhh$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// luogu-judger-enable-o2#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100010#define Inf 1926081700using namespace std ;int N, M, S, T ;struct edges&#123; int to, next, v, c ;&#125;e[MAX &lt;&lt; 1] ;bool mark[MAX] ; int MAX_F, MAX_C, i ;int head[MAX], cnt = -1, pre[MAX], now ;int A, B, C, D, Last[MAX], _F[MAX], dis[MAX] ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void add(int u, int v, int w, int c)&#123; e[++ cnt].to = v, e[cnt].v = w ; e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ; e[++ cnt].to = u, e[cnt].v = 0 ; e[cnt].next = head[v], e[cnt].c = -1 * c, head[v] = cnt ;&#125;bool SPFA()&#123; queue&lt;int&gt; q ; fill(_F, _F + N + 1, Inf) ; fill(dis, dis + N + 1, Inf) ; fill(mark, mark + N + 1, 0) ; q.push(S), dis[S] = 0, mark[S] = 1, pre[T] = -1; while (!q.empty())&#123; now = q.front() ; q.pop() ; mark[now] = 0 ; for (int k = head[now]; k != -1 ; k = e[k].next) if (dis[e[k].to] &gt; dis[now] + e[k].c &amp;&amp; e[k].v)&#123; dis[e[k].to] = dis[now] + e[k].c ; _F[e[k].to] = min(e[k].v, _F[now]) ; pre[e[k].to] = now, Last[e[k].to] = k ; if(!mark[e[k].to])&#123; q.push(e[k].to) ; mark[e[k].to] = 1 ; &#125; &#125; &#125; return dis[T] != Inf;&#125;void _EK()&#123; while(SPFA())&#123; now = T, MAX_F += _F[T], MAX_C += dis[T] * _F[T] ; while(now != S) e[Last[now]].v -= _F[T], e[Last[now] ^ 1].v += _F[T], now = pre[now] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ; fill (head + 1, head + N + 1, -1) ; for (i = 1; i &lt;= M; ++ i) A = qr(), B = qr(), C = qr(), D = qr(), add(A, B, C, D) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt;" "&lt;&lt; MAX_C &lt;&lt; endl ; return 0 ;&#125; 但是$SPFA$他，他他他他他已经死在了$NOI2018$…… 那么我们考虑是否能用$dijkstra$来做。那我们要考虑的就是负权边，因为我们建的反向边是要把代价也跑回去的啊，所以我们致力于解决负权边问题。$rqy$当时是这么给我们讲的： 考虑给每个点加一个“势”$h$ 。一条$u$ → $v$ 的费用为 $c$ 的边变成一条$u$→$v$费用是$c−h_v+h_u$ 的边。 那么我们从点$S$到点$B$点的距离便从$dis_B$变成了$dis_B + h_s- h_B$，我们最后只需要把原来的势函数减去即可。 下面我们思考到底要选取什么作为势函数呢？ 我们考虑将上次求出的最短路作为势函数，为什么呢？$rqy$是这么说的： 这为什么是对的呢? 考虑一条边 $u→v$ ，费用为 $c$ 。 如果它上一次增广时残量不为 $0$ ，那么根据最短路的性质有$dis_u + c ≥ dis_v$ (不然的话说明最短路求错了)。 如果它上次增广时残量为 $0$ 而现在不为 $0$ ，那说明它的反向边被增广了。而增广的路径是最短路径，反向边是 $v → u$，费用 $−c$ 。所以$dis_v$ =$dis_u −c$ ，也就是说 $-c+dis_u −dis_v = 0$ 也是非负的，那么$w+h_u −h_v$就是非负的。 于是我们现在可以用 $Dijkstra$ 增广，很快而且更难卡( 至于代码，大概长这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX 100010#define Inf 192608170using namespace std ;struct edge&#123; int to, next, c, f ;&#125;e[MAX &lt;&lt; 1] ; int H[MAX], S ;int dist[MAX], _F[MAX], Pre[MAX], i, k ;int N, M, A, B, C, D, cnt = -1, x1, x2, head[MAX] ;struct node&#123; int dist, num ; bool operator &lt;(const node &amp; now) const&#123;return dist &gt; now.dist ; &#125;&#125;; priority_queue&lt;node&gt; q ; bool vis[MAX] ; int Last[MAX], MAX_F, MAX_C, t, ww ;inline int qr()&#123; int k = 0 ; char c = getchar() ; while (c &lt; '0' || c &gt; '9') c = getchar() ; while (c &lt;= '9' &amp;&amp; c &gt;= '0') k = (k &lt;&lt; 1) + (k &lt;&lt; 3) + c - 48, c = getchar() ; return k ;&#125;inline void Add(int u, int v, int f, int c)&#123; e[++ cnt].to = v, e[cnt].f = f ; e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ; e[++ cnt].to = u, e[cnt].f = 0 ; e[cnt].next = head[v], e[cnt].c = -1 * c, head[v] = cnt ;&#125;bool dijkstra()&#123; for (i = 1 ; i &lt;= N; ++ i) dist[i] = _F[i] = Inf, vis[i] = 0 ; q.push((node)&#123;0, S&#125;) ; dist[S] = 0 ; while(!q.empty())&#123; node now = q.top() ; q.pop() ; while(vis[now.num]&amp;&amp;!q.empty()) now = q.top(), q.pop(); x1 = now.num, x2 = now.dist ; if(vis[x1]) continue ; vis[x1] = 1 ; for(k = head[x1] ; k != -1 ; k = e[k].next) if (e[k].f &gt; 0 &amp;&amp; !vis[e[k].to] &amp;&amp; dist[e[k].to] &gt; x2 + e[k].c + H[x1] - H[e[k].to])&#123; int T = e[k].to ; dist[T] = x2 + e[k].c + H[x1] - H[T] ; _F[T] = min(_F[x1], e[k].f), Pre[T] = x1, Last[T] = k, q.push((node)&#123;dist[T], T&#125;) ; &#125; &#125; return dist[t] &lt; Inf ;&#125;inline void _EK()&#123; while(dijkstra())&#123; ww = t, MAX_F += _F[t], MAX_C += (dist[t] - H[S] + H[t]) * _F[t] ; while(ww != S) e[Last[ww]].f -= _F[t], e[Last[ww] ^ 1].f += _F[t], ww = Pre[ww] ; for (i = 1 ; i &lt;= N ; ++ i) H[i] += dist[i] ; &#125;&#125;int main()&#123; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; t ; for (i = 0 ; i &lt;= N ; ++ i) head[i] = -1 ; for (i = 1 ; i &lt;= M ; ++ i) A = qr(), B = qr(), C = qr(), D = qr(), Add(A, B, C, D) ; _EK() ; cout &lt;&lt; MAX_F &lt;&lt; " " &lt;&lt; MAX_C &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流-最大流</tag>
        <tag>网络流-费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想二 · 丘吉尔]]></title>
    <url>%2F2018%2F08%2F08%2F%E9%9A%8F%E6%83%B3%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一点功利的遐想？ “随想”系列索引：戳我 啊……还有几十天就$NOIp$了啊…… 现在是下午四点，机房。 比我弱的都在颓废，比我强的都在做题。 唯独我在写博客。 我在想些什么呢？ 我是$pks$，没错，我不敢称自己为$Flower_pks$，不敢称自己为“花”，因为这跟我实力不符——我不是那个在$Luogu$这个$OJ$上小有名气的大佬，不是那个题解写得十分详细的作者，更不是$SD$集训里面排的上号的人。 没错，我不配啊。 上午$rqy$出题，大概是被全方面碾压了吧。省队培训时虽然也考不多好，但是在学校里被平日里玩的很好的朋友碾压却是更加痛苦——我看不见路。 旁边的窗帘紧紧地闭着、贴着窗户，多云的日子里，挤进来阳光总是给人一种异样的感觉，洒在我的右肩上。 撇过头来看键盘上发着光的$w$键，突然有种想哭的欲望。 我是真弱啊。 $NOIp$现在省一都不稳吧，也就会写几个省选才会考到的板子了；板子也不怎么可以打出来吧，毕竟没有很强的记忆力——天生就是个弱者啊。 我总是特别羡慕别人敏锐的反应能了，羡慕独到的数学天赋，羡慕稳重的答题习惯，羡慕…… 但我什么也没有。我也不是个富有毅力的人。 我一直极其富有自尊，十分的自尊。所以我会拼了命地学别人不会的算法，并且十分不喜欢别人善意的和我共同进步，毕竟因为我太弱太弱。 我发现我这个人好诡异啊……其余走$OI$路的人都没有这种心理波动，只有我会把时间放在这上面吧。 估计是我什么都不适合吧。 其实我不是特别喜欢去接近那些很强的人，因为他们总是凭着自己的实力不顾别人的感受。大概在这样的教育制度下，学习好、得了银牌或者怎样，才会有发言权吧。 这种人强到让我厌恶。也让我悲哀。 好啦好啦你强好啦……我滚粗好了吧…… 我并不是很服气，但是现实却总是不尽人意。 过去我一直能依靠着的、可以包容我的人已经与我一别两宽了， 估计以后也只能靠自己了吧。 我并不知道为什么我要选择承受这么多，大概是天性使然吧。 我把丘吉尔的一句话当作人生的信条——当然不是唯一的信条。 二战结束后的一天，年老的丘吉尔来到英国下议院，坐在一个年轻的议员旁边，突然问道：“年轻人，你知道是什么东西支撑我在各方面都取得了如此巨大的成就吗？”这个年轻的一员用非常渴望的眼神等待着这位德高望众的伟大人物的教诲，他说：“我非常想知道。”“虚荣心！强烈的虚荣心！”丘吉尔大声说道，随即哈哈大笑，起身而去。 路在哪呢……]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随想一 · 山丘]]></title>
    <url>%2F2018%2F08%2F02%2F%E9%9A%8F%E6%83%B3%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Hello，World！ “随想”系列索引：戳我 我是花，来自山东，今时今日写下这一篇，只是为了给并肩的$Oiers$一个不算多美的故事，为了给后来的$Oiers$一个对未来有所期望的愿景。 看着眼前发黄的电脑屏幕，不知道该说些什么。 现在的我即将高一，有着比较厉害的学长，和什么都不会的教练，每天来机房就是刷题-&gt;不会-&gt;刷题-&gt;不会。 大概我马上就要习惯了吧。 闷热的八月让人有一种说不出的惆怅，大概是初中毕业旧事未了，或者是即将$NOIp$但却并没太大信心，或者是教练总是给出不尽人意的安排打乱计划。 我捏着手边新换上的眼镜腿儿，默默地想到。 我依稀记得几个月前的快乐场景：每天都在学新算法、不亦乐乎地学、废寝忘食地学。最讨厌做模拟题、玛丽题或者搜索题。最喜欢去学习新的算法，所以导致我整天刷模板题：线段树、$Splay$、$LCA$……偶尔会兴致盎然地发几篇题解，也总是会用最生动的语言，盯着$luogu$的$markdown$那方小小的编辑框，一个字一个字地码着。二月的培训让我觉得是最有意义的一次培训了，大多数精致的$blog$都出自那时。一般都是回到宾馆后，开始联机颓废，等到半夜凌晨开始写博客，写到鱼肚泛白或者困意袭来才罢休。 可真是让人高兴的回忆啊…… 回想这几个月，变化是日新月异的——就如同把一颗小小的石子扔进一池静水，起初不见多大声势，静候才可见其早已涤荡了半池——是波纹展开了。一开始来这儿，是实力悬殊的——初中有人努力、也有人不努力；初中时都挺聪明，在班里都名列前茅；初中时上奥赛几乎等于颓废，因为没多少人真正地在做题…… 可惜时光不容许保留原来的模样。 主任盯得紧，教练怂主任从而也盯得紧；大多数人都因为外力的因素必须要努力，但也有根本不想努力的人；以前可以骄傲的资本、譬如文化课，现在早就变成了一纸空谈——作为所谓“奥赛负责人”的我，看到来到实验部第一次的月考成绩时，看到级部前二十（这一级实验部一共$116$个人）充斥着数学物理化学生物奥赛的人、却又跟信息学奥赛没有任何关系时，我不知道该怎么做。 于是我便开始加大压力：组织学生定期讲课、定期比赛。用这种空泛的压榨时间的行为来压榨效率无疑是可笑的，但是也起了一部分好的效果：几个$NOIp$内容都没会熟练的家伙开始跃跃欲试地学习$Splay$、学习网络流……我不知道这样做是否真的好，就如同我不知道我学习新东西是否会在十月、甚至十一月之前压垮所有人的神经——学完新东西、反过头来发现基础却根本不牢固——就如同为了学新知识，而去学新知识。这种功利让我不知道现在在走着一条怎样的路。 终于，差距出来了。经过几个月训练、实力强劲的人自然涌了上来，也有根本不行的人光辉逐渐黯淡。二月时的能力局面现在早就会焕然一新，有人选择走，有人选择苟活。我不清楚原来那些充满骄傲的、惬意的脸庞如今去了哪里，我只知道我给他们定的目标是今年全部省一、我只知道来到实验部之后，只能选择负重前行。 看着机房里其他人的变化，就宛如翻完了一部小说一般，跌宕而符合逻辑。 告别了初中，留下了什么呢？或许是由于自身意气用事而破坏了原本纯洁的友情，但是我不能——真的不能仅仅把$Ta$当作一个不世出的好朋友。但当我跨越了自身的那一步之后才发现原来无人等候，才发现我只能把一些事情抛撒在风里，然后安慰自己“没事”。 我喜欢李宗盛，喜欢他的歌里面唱出的人间无奈。而最喜欢的是他的《山丘》: 给自己随便找了个理由， 向情爱的挑逗，命运的左右。 不自量力地还手，直至死方休—— 越过山丘——虽然已白了头； 喋喋不休——时不我予的哀愁； 还未如愿见着不朽 就把自己先搞丢—— 越过山丘——才发现无人等候； 喋喋不休——再也唤不回了温柔； 为何记不得上一次是谁给的拥抱 在什么时候。 大概是能唱出柳永“杨柳岸晓风残月”几分意味的吧。 $2018/8/4$]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
</search>
