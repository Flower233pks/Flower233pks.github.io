<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>随想 · 目次表</title>
    <url>/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p>
<a id="more"></a>
<p>我是花，一个不理智的$\rm{Oier}$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p>
<p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p>
<p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>

        <div id="aplayer-yVUqccdI" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-yVUqccdI"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "花",
              author: "Hello Nico",
              url: "Hello Nico-花.flac",
              pic: "/2050/12/31/随想·目次表/qwq.png",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<p>以下是目录：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">篇目</th>
<th style="text-align:center">链接（点击即可）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">随想一 · 山丘</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想二 · 丘吉尔</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想四 · 故人</td>
<td style="text-align:center"><a href="[https://www.orchidany.cn/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/](https://www.orchidany.cn/2019/03/01/随想四·故人/">$Link$</a>)</td>
</tr>
<tr>
<td style="text-align:center">随想五 · 手中没有红玫瑰</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想六 · 难</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想七 · 言叶之庭</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想八 · 逃吧</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/06/11/8/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想九 · 意义</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/07/18/Nine/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">随想十 · 繁星</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/08/20/10/">$Link$</a></td>
</tr>
</tbody>
</table>
</div>
<p>第一篇大概是开始？</p>
<p>第二篇大概是在老校机房写的。当时自己和周围人的关系并不好。</p>
<p>第三篇就是2018考完NOIP写的啦。</p>
<p>第四篇由于个人十分喜爱回忆往事，所以是比较重要的一篇，但现在还没有更完。（因为要说的太多了</p>
<p>第五篇是谈感情的啦，似乎是比较出名的一篇(?)</p>
<p>第六篇大概是瞎写的。如果每次觉得很难都要写一篇，那估计只有专职作家才能写完。</p>
<p>第七篇大概是看完《言叶之庭》就立即在机房写的，代表的大概是我理想中爱情的模样吧。</p>
<p>第八篇也很重要，我的全部压抑情绪都会写进去。当然，和第四篇一样，要说的话太多了，所以写不完/kk</p>
<p>第九篇大概是「奇异人生」的读/观后感？</p>
<p>最后一篇…是秘密！</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【公告】关于这个blog</title>
    <url>/2050/02/05/%E3%80%90%E5%85%AC%E5%91%8A%E3%80%91%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
<p><del>恭喜你来到了没有知识的荒原.</del></p>
<p>这篇文章已经移步到侧边栏的「<code>Navigation</code>」里啦！还不去看看？</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】从零开始的数位DP生活</title>
    <url>/2020/04/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E6%95%B0%E4%BD%8DDP%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不跟各位吹的，这些东西我是真的一点也不会。之前是真的一点没看过这块的内容…</p>
<p>冲冲冲！</p>
<a id="more"></a>
<h1 id="Luogu4317-花神的数论题"><a href="#Luogu4317-花神的数论题" class="headerlink" title="[Luogu4317] 花神的数论题"></a>[Luogu4317] 花神的数论题</h1><blockquote>
<p>话说花神这天又来讲课了。课后照例有超级难的神题啦…… 我等蒟蒻又遭殃了。 花神的题目是这样的：设  $\text{sum}(i)$  表示  $i$  的二进制表示中  $1$  的个数。给出一个正整数  $N$  ，花神要问你  $\prod_{i=1}^{N}\text{sum}(i)$ ，也就是  $\text{sum}(1)\sim\text{sum}(N)$  的乘积。</p>
<p>对于 100% 的数据，$N≤10^{15}$ 。</p>
</blockquote>
<p><del>为什么花神出的题花不会呢，为什么为什么</del> 。</p>
<h1 id="LuoguP1822-魔法指纹"><a href="#LuoguP1822-魔法指纹" class="headerlink" title="[LuoguP1822] 魔法指纹"></a>[LuoguP1822] 魔法指纹</h1><blockquote>
<p>对于任意一个至少两位的正整数 $n$，按如下方式定义 $magic(n)$ ：将 $n$ 按十进制顺序写下来，依次对相邻两个数写下差的绝对值。这样，得到了一个新数，去掉前导 $0$，则定义为 $magic(n)$。若 $n$ 为一位数，则 $magic(n)=n$。</p>
<p>对任意一个数 $n$，序列 $n,magic(n),magic(magic(n)),…$ 迟早会变成一个一位数。最后的这个值称为数 $n$ 的 $magic$ 指纹。</p>
<p>对 $100\%$ 数据，$0&lt;A≤B≤1,000,000,000$ 。</p>
</blockquote>
<h1 id="loj10165-Windy数"><a href="#loj10165-Windy数" class="headerlink" title="[loj10165] Windy数"></a>[loj10165] Windy数</h1><blockquote>
</blockquote>
<p>咕咕咕</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>动态规划/数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】简单题选做·第3季</title>
    <url>/2020/04/26/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC3%E5%AD%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>终于！终于不是UVA了！</del></p>
<p>主要整理一下之前做过的有意思的题目，也算是巩固基础了吧。</p>
<p>争取一句话题解…这一弹大概有 $25$ 道题左右吧。 </p>
<a id="more"></a>
<h1 id="HNOI2011-数学作业"><a href="#HNOI2011-数学作业" class="headerlink" title="[HNOI2011]数学作业"></a>[HNOI2011]数学作业</h1><blockquote>
<p>给定正整数 $n,m$，要求计算 $\text{Concatenate}(n) \bmod  m$  的值，其中 $\text{Concatenate}(n)$ 是将 $1 \sim n$ 所有正整数 顺序连接起来得到的数。</p>
<p>$1\le n \le 10^{18}$，$1\le m \le 10^9$。</p>
</blockquote>
<p>…考虑递推，那自然是 $f_{i}=(f_{i-1}\cdot T+i)\bmod m$ 。其中 T 是根据不同的数字位数而变的这么一个计数器。于是就是分段矩乘即可。 </p>
<h1 id="Luogu5110-块速递推"><a href="#Luogu5110-块速递推" class="headerlink" title="[Luogu5110]块速递推"></a>[Luogu5110]块速递推</h1><blockquote>
<p><script type="math/tex">a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1</script> 。</p>
<p>求这个数列第 $n$ 项模 $10^9+7$ 的值，一共有 $T$ 组询问。</p>
<p>$1\leq T\leq 5\times 10^7,1\leq n\leq 10^{18}$ 。</p>
</blockquote>
<p>朴素的矩乘是 $8\cdot \log n$ 的样子。这样算出来复杂度是 $O(8\cdot T\cdot \log n)$ ，好像很慢的样子。</p>
<p>于是考虑预处理一点东西。比较常见的方法当然就是分块来做，预处理 $a^{1},a^{2},a^{3}\cdots a^{\sqrt n},a^{2\cdot \sqrt n},a^{3\cdot \sqrt n}\cdots$ 这些。那么复杂度度转化成了 $O(\sqrt n\log\sqrt n+8\cdot T)$。</p>
<p>注意到可以借助扩展欧拉定理 $a^b\equiv a^{b\bmod \varphi(m)+\varphi(m)}\pmod{m}$ 使得复杂度变成 $O(\sqrt{Mod}\log\sqrt{Mod}+8\cdot T)$ 。信仰一波就过了。</p>
<h1 id="USACO13JAN-Seating-G"><a href="#USACO13JAN-Seating-G" class="headerlink" title="[USACO13JAN]Seating G"></a>[USACO13JAN]Seating G</h1><blockquote>
<p>有一排 $n$ 个座位，$m$ 次操作。</p>
<p>A操作：将 $a$ 名客人安置到最左的连续 $a$ 个空位中，没有则不操作。</p>
<p>L操作：$[a,b]$ 的客人离开。</p>
<p>求A操作的失败次数。</p>
<p>$n,m,10^5$ 。</p>
</blockquote>
<p>这…大概就是维护区间最长连续和然后再直接线段树上二分吧…发现自从领悟了线段树上二分之后，好多奇怪的线段树题也就都这么回事了…</p>
<h1 id="APIO2012-派遣"><a href="#APIO2012-派遣" class="headerlink" title="[APIO2012]派遣"></a>[APIO2012]派遣</h1><blockquote>
<p>在这个帮派里，有一名忍者被称之为 Master。除了Master以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。</p>
<p>现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。</p>
<p>你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。</p>
<p>写一个程序，给定每一个忍者 $i$ 的上级 $B_i$ ，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$ ，输出在预算内满足上述要求时顾客满意度的最大值。</p>
<p><strong>简化版题面：给定一棵树，求</strong> </p>
<script type="math/tex; mode=display">
\max_{u\in T}\{L_u\cdot t_u\}</script><p><strong>其中设</strong> $s$ <strong>是以</strong> $u$ <strong>为根的子树中的某个点集，</strong>$\mathrm{card}$ <strong>表示集合的元素个数， 则</strong></p>
<script type="math/tex; mode=display">
t_u=\max_s\{\mathrm{card}(s)\cdot [ \sum_{i\in s} c_i\leq m]\}</script><p>$1\leq n\leq 10^6$ 。</p>
</blockquote>
<p>读题读半天系列x</p>
<p>…发现是暴力，暴力选每个点当根，然后拿一个支持快速合并的数据结构对子树内的点进行合并，选出重量最小的那几个即可。注意到暴力合并的话似乎是要二分…这样一般而言复杂度就变成两个 $\log$ 了。但是如果每次插入完之后，统计答案时选择不断删掉当前 $c_i$ 最大的元素，这样就可以在保证正确性的同时降低询问的复杂度。发现可以直接拿左偏树来维护。复杂度 $O(n\log n)$ 。</p>
<h1 id="Luogu1858-多人背包"><a href="#Luogu1858-多人背包" class="headerlink" title="[Luogu1858]多人背包"></a>[Luogu1858]多人背包</h1><blockquote>
<p>01背包的前 $k$ 优解。</p>
<p>$k\le 50,m\le 5000,n\le 200$ .</p>
</blockquote>
<p>考虑暴力做并不简单，一个直观的想法就是再记一维 $k$ ，即 $f_{i,v,k}$ 表示考虑了前 $i$ 个物品，总体积为 $v$ 的 $k$ 优解是多少。考虑转移。通过观察单调性，可以发现当 $p&gt;q$ 时， $i-1,v$ 时的 $p$  优解是不会对 $i,v+w_i$ 时的 $q$ 优解产生贡献的，也就是说对于一个状态 $f_{i,v,k}$ ，都是从某个 $f_{i-1,v,j}$ 或者 $f_{i-1,v-w_i,j}+v_i$ 转移过来的。于是考虑直接把这两个状态集归并排序一下即可。复杂度 $O(n\cdot m\cdot k)$ 。</p>
<h1 id="SCOI2016-萌萌哒"><a href="#SCOI2016-萌萌哒" class="headerlink" title="[SCOI2016]萌萌哒"></a>[SCOI2016]萌萌哒</h1><blockquote>
<p>一个长度为 $n$ 的大数，用 $s_1s_2s_3 \cdots s_n$表示，其中 $s_i$ 表示数的第 $i$ 位， $s_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串$s_{l_1}s_{l_1+1}s_{l_1+2} \cdots s_{r_1}$与$s_{l_2}s_{l_2+1}s_{l_2+2} \cdots s_{r_2}$完全相同。</p>
<p>求本质不同的大数个数。</p>
<p>$1\le n\le 10^5$，$1\le m\le 10^5$ 。</p>
</blockquote>
<p>（以下默认并查集的复杂度是 $O(\log n)$ ，实际上这是一个很松的上界）</p>
<p>考虑暴力做当然是对每个位置开一个并查集，然后对于每个修改暴力 <code>for</code> 过去，这样最后答案就是 $9\cdot 10^{cnt-1}$ ，其中 $cnt$ 是不同的集合数量。这样做是 $O(nm\log n)$ 修改、$O(n\log n)$ 查询的。发现这样做的复杂度十分不平衡。考虑将复杂度向查询倾斜，即优化修改操作的复杂度。</p>
<p>考虑二进制拆分。对每个位置 $i$ 维护 $i\sim i+2^k-1$ 的连通状态，这样每次修改就是 $\log ^2n$ 的了。之后考虑对于一个长为 $2^k$ 的区间，可以push_down成两个长为 $2^{k-1}$ 的子区间再分别连边。于是查询的时候就可以直接查询了。</p>
<p>总复杂度 $O(m\log ^2n+n\log ^2 n)$ 。</p>
<h1 id="SCOI2010-生成字符串"><a href="#SCOI2010-生成字符串" class="headerlink" title="[SCOI2010]生成字符串"></a>[SCOI2010]生成字符串</h1><blockquote>
<p>lxhgww 最近接到了一个生成字符串的任务，任务需要他把 $n$ 个 $1$ 和 $m$ 个 $0$ 组成字符串，但是任务还要求在组成的字符串中，在任意的前 $k$ 个字符中，$1$ 的个数不能少于 $0$ 的个数。现在 lxhgww 想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？</p>
<p>$1\leq m,n\leq 10^6$ 。</p>
</blockquote>
<p>这…理论上如果没有个数限制的话就是卡特兰数了吧。</p>
<p>考虑一个转化，从 $(0,0)$ 开始出发，设当前点为 $(x,y)$ 每次如果遇到 $1$ 就走到 $(x+1,y-1)$ ，每次遇到 $0$ 就走到 $(x+1,y+1)$，那么最终就是走到 $(n+m,m-n)$ 的、不跨过直线 $x=0$ 方案数。这…似乎是一个十分经典的组合问题了。大概就是考虑把走到 $y=1$ 这条直线以下的那些路径全都翻转到 $y=1$ 以下（做镜像对称），那么就可以看做是从 $(0,2)$ 走到 $(n+m,m-n)$ 的方案数。所以答案就是两者相减。</p>
<p>考虑怎么算这两部分。发现本质上从 $(0,0)$ 走到 $(n+m,m-n)$ 、每次向右下或者右上走的方案数。一种比较简单的理解就是从 $n+m$ 步里面选出 $n$ 步向右下走的方案数，所以答案是 $\binom{n+m}{m}-\binom{n+m}{m-1}$ ，因为从 $(0,2)$ 开始走相当于把其中向上走的某一步魔改成了成了向下走的，所以 $m$ 要减一。</p>
<h1 id="SP19148-Kill-them-All"><a href="#SP19148-Kill-them-All" class="headerlink" title="[SP19148]Kill them All"></a>[SP19148]Kill them All</h1><blockquote>
<p>$n$ 只怪兽，每一次可让 Digo 杀或 Sharry 杀。求在每杀掉一只怪物后，Digo 的击杀数都比 Sharry 的击杀数多的方案数。</p>
<p>$1\leq n\leq 10^6$ 。</p>
</blockquote>
<p>回顾历史的时候顺便发现了这道题…</p>
<p>大概就是上个题把 $\geq $ 换成了 $&gt;$ 。考虑首先让 $1$ 号怪兽必须被 <code>Digo</code> 干掉，那么就变成了从 $(1,0)$ 出发，走 $n-1$ 步，途中不能碰到 $y=0$ 的方案数。考虑最后走到的地方只会是 $(n,\lceil\frac{n}{2}\rceil),(n,\lceil\frac{n}{2}\rceil+1)\cdots (n,n)$，那么不妨对这些东西分别计数，那么答案就是</p>
<script type="math/tex; mode=display">
1+\sum_{i=1}^{\lceil\frac{n}{2}\rceil-1}\left(\binom{n-1}{i}-\binom{n-1}{i-1}\right)</script><p>其中第一个 $1$ 是全部被 <code>Digo</code> 干掉的方案数。那么可以知道…这个式子里面前面的都被消掉了，最后只剩一个 $1+\binom{n-1}{\lceil\frac{n}{2}\rceil-1}-\binom{n-1}{0}=\binom{n-1}{\lceil\frac{n}{2}\rceil-1}$ 。 然后就没有然后了。</p>
<h1 id="UVA11149-Power-of-Matrix"><a href="#UVA11149-Power-of-Matrix" class="headerlink" title="[UVA11149]Power of Matrix"></a>[UVA11149]Power of Matrix</h1><blockquote>
<p>给定整数 $k$ 和一个 $n$ 阶矩阵 $A$ ，求 </p>
<script type="math/tex; mode=display">
A+A^2+A^3+A^4+\cdots+A^k</script><p>$n\leq 100,k\leq 10^6$ 。</p>
</blockquote>
<p>这题其实有两种做法。一种做法是 $O(n^3\log k)$ 的，另一种也是 $O(n^3\log k)$ 的，只不过会多一个 $8$ 的常数。</p>
<h2 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑对着这个找规律（雾），大概是考虑分块做，发现原来的式子可以写成：</p>
<script type="math/tex; mode=display">
A+A^2+A^3+\cdots +A^{\sqrt k}+A^{\sqrt k}\times (A+A^2+A^3+\cdots +A^{\sqrt k})+A^{2\cdot\sqrt k}\times (A+A^2+A^3+\cdots +A^{\sqrt k})\cdots</script><p>那么就可以预处理再做了。这样复杂度是 $O(n^3\sqrt k)$ 的，好像大概是 $10^9$ 的复杂度…过不去。</p>
<p>不过既然分块可以，那倍增应该也可以。具体的，可以这么化：</p>
<script type="math/tex; mode=display">
A^1+A^1\cdot A^1 + A^2\times (A^1+A^2)+A^4\times(A^1+A^2+A^3+A^4)</script><p>那么这样就可以先预处理出 $n^3\log k$ 个 $A,A^2,A^4\cdots$ ，然后就可以再用 $n^3\log k$ 的时间预处理出 $s_1,s_2,s_4\cdots$ 其中 $s_i=\sum{A^i}$ 。之后就可以直接二进制拆分了。总复杂度 $n^3\log k$ 。</p>
<h2 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>考虑直接对所有矩阵的和进行递推。计 $A^u$ 为当前矩阵的 $u$ 次幂，那么不妨构造一个复合矩阵</p>
<script type="math/tex; mode=display">
\begin{bmatrix} A^k\\ s_k \end{bmatrix}</script><p>其中</p>
<script type="math/tex; mode=display">
s_i = \sum \limits_{j = 1}^{i}A^i</script><p>发现它可以这么转移：</p>
<script type="math/tex; mode=display">
\begin{bmatrix} A^k\\ s_k \end{bmatrix} = \begin{bmatrix}A^{k-1}\\s_{k-1}\end{bmatrix}\cdot \begin{bmatrix}A &0\\I_n&I_n\end{bmatrix}</script><p>其中 $I_n$ 表示 $n$ 阶单位矩阵。然后就没有然后了。注意到这样做矩阵其实是升阶了，所以会带一个常数。</p>
<h1 id="SDOI2011-打地鼠"><a href="#SDOI2011-打地鼠" class="headerlink" title="[SDOI2011]打地鼠"></a>[SDOI2011]打地鼠</h1><blockquote>
<p>打地鼠是这样的一个游戏：地面上有一些地鼠洞，地鼠们会不时从洞里探出头来很短时间后又缩回洞中。玩家的目标是在地鼠伸出头时，用锤子砸其头部，砸到的地鼠越多分数也就越高。</p>
<p>游戏中的锤子每次只能打一只地鼠，如果多只地鼠同时探出头，玩家只能通过多次挥舞锤子的方式打掉所有的地鼠。你认为这锤子太没用了，所以你改装了锤子，增加了锤子与地面的接触面积，使其每次可以击打一片区域。如果我们把地面看做 $m\times n$ 的方阵，其每个元素都代表一个地鼠洞，那么锤子可以覆盖 $r\times c$ 区域内的所有地鼠洞。但是改装后的锤子有一个缺点：每次挥舞锤子时，对于这的区域中的所有地洞，锤子会打掉恰好一只地鼠。也就是说锤子覆盖的区域中，每个地洞必须至少有 $1$ 只地鼠，且如果某个地洞中地鼠的个数大于 $1$，那么这个地洞只会有 $1$ 只地鼠被打掉，因此每次挥舞锤子时，恰好有$r\times c$ 只地鼠被打掉。由于锤子的内部结构过于精密，因此在游戏过程中你不能旋转锤子（即不能互换 $r$ 和 $c$）。</p>
<p>你可以任意更改锤子的规格(即你可以任意规定 $r$ 和 $c$ 的大小)，但是改装锤子的工作只能在打地鼠前进行(即你不可以打掉一部分地鼠后，再改变锤子的规格)。你的任务是求出要想打掉所有的地鼠，至少需要挥舞锤子的次数。</p>
<p>Hint：由于你可以把锤子的大小设置为 $1\times 1$，因此本题总是有解的。</p>
<p>$1\leq m,n\leq 100$。</p>
</blockquote>
<p>以下是翻车现场，这题根本没有「行列无关」的性质：</p>
<blockquote>
<p>一道十分经典的行列无关技巧普及题目。但这题行列无？关比较的深刻。</p>
<p>考虑如果暴力枚举的话，复杂度大概是枚举 $r\times c$ 之后再一个一个打，这样复杂度是 $O(n^6)$，实现的好一点就可以 $O(n^4\log^2 n)$ 。但是，如果这题满足行列无关的话，就可以 $r$ 和 $c$ 分别枚举。准确来说，对于另一维设为 $1$，那么可以只去找这一维的最大值。考虑这么做判断的复杂度就是 $O(n^3)$，枚举的复杂度是 $O(n)$ 。那么最后总复杂度就是 $O(n^4)$ 。</p>
<p>那么唯一的问题在于如何证明行列无关在这题里面是对的。考虑对于所枚举的锤子大小所覆盖的某个区域，其中有两个点 $(a,b)$ 和 $(c,d)$ ，不同行也不同列，但是可以知道 $(a,b)$ 和 $(c,b)$ 的确定关系，$(c,d)$ 和 $(c,b)$ 的确定关系。即我断言，如果 $(a,b)$ 和 $(c,b)$ 满足同时合法，$(c,d)$ 和 $(c,b)$ 也同时合法，那么这三个点就可以同时合法，反之则不可以。</p>
<p>考虑这个断言为什么合理。发现每次如果以 $(c,b)$ 为量度去砸，那么 $(c,d)$ 和 $(a,b)$ 被砸的次数都只会与 $(c,b)$ 的地鼠数量有关，因为 $(c,b)$ 必须被精确砸完……</p>
<p><del>编不下去了，就当记结论了</del></p>
</blockquote>
<p>然后就是一个二维差分，然后就没了。</p>
<h1 id="UVA11134-Fabled-Rooks"><a href="#UVA11134-Fabled-Rooks" class="headerlink" title="[UVA11134]Fabled Rooks"></a>[UVA11134]Fabled Rooks</h1><blockquote>
<p>在一个 $n\times n$（$1\leq n\leq 5000$）的棋盘上放置 $n$ 个车，每个车都只能在给定的一个矩形( $x_{l_i},x_{r_i},y_{l_i},y_{r_i}$) 里放置，使其 $n$ 个车两两不在同一行和同一列，判断并给出解决方案。</p>
</blockquote>
<p>又是一道考察行列无关知识的题目。</p>
<p>考虑放每个车时行与列显然是无关的，所以就可以分开做。那就是给定一堆区间，每个区间内选一个点使之不被放在同一个位置。贪一波就完了。</p>
<h1 id="NOI2005-瑰丽华尔兹"><a href="#NOI2005-瑰丽华尔兹" class="headerlink" title="[NOI2005]瑰丽华尔兹"></a>[NOI2005]瑰丽华尔兹</h1><blockquote>
<p>舞厅是一个 $N$ 行 $M$ 列的矩阵，矩阵中的某些方格上堆放了一些家具，其他的则是空地。钢琴可以在空地上滑动，但不能撞上家具或滑出舞厅，否则会损坏钢琴和家具，引来难缠的船长。每个时刻，钢琴都会随着船体倾斜的方向向相邻的方格滑动一格，相邻的方格可以是向东、向西、向南或向北的。而艾米丽可以选择施魔法或不施魔法：如果不施魔法，则钢琴会滑动；如果施魔法，则钢琴会原地不动。</p>
<p>艾米丽是个天使，她知道每段时间的船体的倾斜情况。她想使钢琴在舞厅里滑行的路程尽量长，这样 1900 会非常高兴，同时也有利于治疗托尼的晕船。但艾米丽还太小，不会算，所以希望你能帮助她。</p>
<p>$1\leq N$, $M \leq 200$，$K \leq 200$，$T\leq 40000$。K是时间段的数量，T 是总时间。</p>
</blockquote>
<p>考虑最朴素的 $dp$ 就是 $f_{t,i,j}$ 表示时刻 $t$ 时在位置 $(i,j)$ 结尾的最长路径。转移时 $O(1)$ 的。但由于状态数太高导致不得不放弃。发现本质上每段时间内，转移的方向唯一。所以可以按段来 $dp$ ，$f_{k,i,j}$ 表示经过了 $k$ 段之后，结尾于位置 $(i,j)$ 的最长路径。这样状态数就是 $O(nmk)$ 的、转移是 $O(\max\{n,m\})$ 的了。发现由于每一段决策区间单调，且决策点彼此之间存在单调性，于是可以拿单调队列优化到均摊 $O(1)$ 转移。</p>
<h1 id="BalticOI2008-Elect"><a href="#BalticOI2008-Elect" class="headerlink" title="[BalticOI2008]Elect"></a>[BalticOI2008]Elect</h1><blockquote>
<p>$n$ 个政党要组成一个联合内阁，每个党都有自己的席位数。 </p>
<p>现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好。 </p>
<p>对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的。</p>
<p>求最大席位并构造一组解。</p>
<p>$1\leq n\leq 300,1\leq m\leq 10^5$ 。</p>
</blockquote>
<p>大概是长个经验？</p>
<p>发现倒着贪心并不是对的…虽然观察数据范围发现 $O(nm)$ 可过，但是一般情况下很难想到要去背包，因为有一个「多余」的限制…</p>
<p>但是发现如果从大到小排完序之后再背包，当前加进去的东西一定是最小的。此时如果出现把这个东西拿出来，剩下的都一定比这个大。所以不难理解这么更新的正确性。</p>
<p>考虑如何记录方案。可以对于每种权值都开一个 <code>bitset</code>，对于每种权值，第一次更新的时候顺便更新 <code>bitset</code>（根据单调性这样一定是最合法的那个）。那么最后的复杂度就是 $O(nm+\frac{nm}{w})$。注意到这么写的意义在于，通过聚和分析可以得知，对于每个权值 $m$ 至多会与其他的价值 $or$ 一次，所以本质上是 $O(\frac{nm}{w})$ 而不是 $O(\frac{n^2m}{w})$（虽然也能过就是了）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[MAXM] ;</span><br><span class="line"><span class="keyword">int</span> half, sum ;</span><br><span class="line"><span class="keyword">int</span> i, v, ans, n ; </span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; b[MAXM] ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; b)</span></span>&#123; <span class="keyword">return</span> a.fr &gt; b.fr ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n ; f[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i].fr) ;</span><br><span class="line">		sum += base[i].fr, base[i].sc = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, cmp) ; half = sum &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (v = sum ; v &gt;= base[i].fr ; v --)&#123; </span><br><span class="line">			<span class="keyword">if</span> (!f[v] &amp;&amp; f[v - base[i].fr])</span><br><span class="line">				b[v] = b[v - base[i].fr], b[v].<span class="built_in">set</span>(base[i].sc), f[v] = <span class="number">1</span> ;    </span><br><span class="line">			<span class="keyword">if</span> (v &gt; half &amp;&amp; f[v] &amp;&amp; v - base[i].fr &lt;= half) ans = max(ans, v) ; </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b[ans].count() &lt;&lt; <span class="string">'\n'</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (b[ans][i]) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LuoguP1531-鬼子进村"><a href="#LuoguP1531-鬼子进村" class="headerlink" title="[LuoguP1531]鬼子进村"></a>[LuoguP1531]鬼子进村</h1><blockquote>
<p>县城里有 $n$ 个用地道相连的房子，第 $i$ 个只与第 $i-1$ 和第 $i+1$ 个相连。这时有 $m$ 个消息依次传来：</p>
<ol>
<li><p>若消息为 <code>D x</code>：鬼子将 $x$ 号房子摧毁了，地道被堵上。</p>
</li>
<li><p>若消息为 <code>R</code> ：村民们将鬼子上一个摧毁的房子修复了。</p>
</li>
<li><p>若消息为 <code>Q x</code>：有一名士兵被围堵在 $x$ 号房子中。</p>
</li>
</ol>
<p>李云龙收到信息很紧张，他想知道每一个被围堵的士兵能够到达的房子有几个。</p>
<p>$1\leq n,m\leq 5\times 10^4$。</p>
</blockquote>
<p><del>降智题，说实话我第一眼觉得那必然是 LCT；又觉得可达性不好统计，然后就懵了 1min</del></p>
<p>其实是有两种方法的：</p>
<h2 id="Sol-1-1"><a href="#Sol-1-1" class="headerlink" title="Sol 1"></a>Sol 1</h2><p>考虑暴力线段树维护，修复和拆毁都是单点修改。查询的话自然是查询一个点左边第一个 $0$ 的位置、右边第一个 $0$ 的位置。首先这显然是可以外层二分，内层区间查询来做到 $\log ^2$ 的（其实也可以不线段树维护，用分块技巧，$O(1)$ 查询区间和、 $O(\sqrt n)$ 单点加的分块，也可以通过本题，同时虽然插入删除都是 $O(\sqrt n)$ 的，但是询问变成了 $\log$ 的）；或者直接在线段树上二分，做到一个 $\log$ 。</p>
<h2 id="Sol-2-1"><a href="#Sol-2-1" class="headerlink" title="Sol 2"></a>Sol 2</h2><p>发下有一个性质并没有很好利用起来<del>(虽然本身就是一个很没用的性质)</del>。每次删除的点一定是之前插入的点。所以考虑对于所有炸毁的点维护一棵平衡树，以 $pos$ 作为键值，那么每次查询本质上就是询问前驱和后继。</p>
<p>……还有要注意可能本身就被炸了，判一下就好了。这种方法也是 $1$ 个 $\log$ 的。</p>
<h1 id="AT3741-String-Problem"><a href="#AT3741-String-Problem" class="headerlink" title="[AT3741] String Problem"></a>[AT3741] String Problem</h1><blockquote>
<p>给出两个字符串S和T. 通过执行以下操作，判断是否可以将字符串S转换为字符串T.</p>
<ul>
<li>操作 A：删除S中任意位置的字母 A .</li>
<li>操作 B：在S的任意位置插入一个字母 B .</li>
</ul>
<p>S 和 T 的字符都为大写字母，并且 S 和 T 的长度 $\le 1000$ 。</p>
</blockquote>
<p>……其实是水题，不过发生了一些奇妙的事情，然后就打算整理一下我的做法？感觉其他人的做法都一毛一样…</p>
<p>大概就是首先根据样例解释的提示，可以想出一个「先加 B 再删 A」的思路，然后发现前半部分就是一个魔改的 LCS，后半部分就只需要记录一下最少要用多少个 B，看看 s 比 t 多的那些字符是否全是 A 就好了。</p>
<h1 id="Luogu3795-钟式映射"><a href="#Luogu3795-钟式映射" class="headerlink" title="[Luogu3795]钟式映射"></a>[Luogu3795]钟式映射</h1><blockquote>
<p>设集合 $N=M=\left\{x|x\in N_+,x\leq k,k\in N_+\right\}$ 。设 $f$ 为 $N$ 到 $M$ 的映射。求满足 $f[f(x)]=x$ 的不同的映射 $f$ 的个数。</p>
<p>$k\leq 10^{8}$ 。</p>
</blockquote>
<p>说实话…我遇到这种题就会战术后仰然后不会…类似于什么置换啊、复合映射啊，我就蒙圈的很。</p>
<p>考虑新加入一个元素。对于一个 $x$，要么 $f(x)=x$，要么就会有一个 $y$ 和 $x$ 配对。所以有</p>
<script type="math/tex; mode=display">
g_i=g_{i-1}+g_{i-2}\cdot (i-1)</script><p>然后就递推即可。</p>
<p>感觉这个式子本质上和错排可能会有点类似。考虑一个 $n-$完全错位排列 的方案数。假设 $n$ 号元素排到了 $k$ 号位置上，$k$ 号元素恰好也排在了 $n$ 号位置上，那么就是 $(n-1)\cdot g_{n-2}$ ；否则 $k$ 号元素随便错排，那么就是 $(n-1)\cdot g_{n-1}$。那么就是</p>
<script type="math/tex; mode=display">
g_{i}=(i - 1)\cdot(g_{n-1}+g_{n-2})</script><p>感觉递推思想方面是有类似的吧…自己还是…太不聪明了啊</p>
<p>别找那些理由，就是泥萌的不努力！</p>
<h1 id="UVA1451-Average"><a href="#UVA1451-Average" class="headerlink" title="[UVA1451]Average"></a>[UVA1451]Average</h1><blockquote>
<p>给定一个长度为 $n$ 的 $01$ 串，选一个长度至少为 $L$  的连续子串，使得子串中数字的平均值最大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号为 $1$ ~ $n$，因此 $[1,n]$ 就是完整的字符串。</p>
<p>$1\le n\le 100000,1\le L\le 1000$。</p>
</blockquote>
<p><del>又到了复习斜率优化的时间了，斜率优化，常读常新。</del></p>
<p>考虑前缀和一下就转化成了对每个 $i$ 找到一个 $j&lt;i$ 使得 $\frac{s_i-s_j}{i-j}$ 最大。发现这就是在求最大的斜率。考虑本质上 $x$ 坐标和 $y$ 坐标都是不降的，所以为了斜率单增，要维护一个下凸壳。于是拿一个单调栈维护斜率就好了。复杂度线性。</p>
<h1 id="HNOI2008-玩具装箱"><a href="#HNOI2008-玩具装箱" class="headerlink" title="[HNOI2008]玩具装箱"></a>[HNOI2008]玩具装箱</h1><blockquote>
<p>P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。</p>
<p>P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。</p>
<p>为了方便整理，P教授要求：</p>
<ul>
<li><p>在一个一维容器中的玩具编号是连续的。</p>
</li>
<li><p>同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。</p>
</li>
</ul>
<p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。</p>
<p>对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$</p>
</blockquote>
<p>大概是斜率优化板板题？考虑方程：</p>
<script type="math/tex; mode=display">
f_{i}=\min_{j=1}^{i-1}\{f_{j}+(i-j+s(i)-s(j)-L)^2\}</script><p>然后考虑拆一下，并且令 $p(i)=s(i)+i,q(i)=s(i)+i+L$ ，那么：</p>
<script type="math/tex; mode=display">
f_{i}=f_{j-1}+(p(i)-q(j))^2=f_{j-1}+p(i)^2-2\cdot p(i)\cdot q(j)+q(j)^2</script><p>那么证明斜率优化可行的基本讨论就是找一个 $j$ 和一个 $k$ 来比大小：</p>
<p>若 $j&gt;k$ 且 $j$ 比 $k$ 优，那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{j-1}-2\cdot p(i)\cdot q(j)+q(j)^2&<f_{k-1}-2\cdot p(i)\cdot q(k)+q(k)^2\\
2\cdot p(i)\cdot q(k)-2\cdot p(i)\cdot q(j)&<f_{k-1}-f_{j-1}+q(k)^2-q(j)^2
\end{aligned}</script><p>设 $X_i=q(i),Y_i=f_{i-1}-q(i)^2$，那么有</p>
<script type="math/tex; mode=display">
2\cdot p(i)>\frac{Y_{k}-Y_{j}}{X_{k}-X_{j}}</script><p>也就说当这个式子满足的时候，存在 $j&gt;k$ 且 $j$  比 $k$ 优。</p>
<p>所以对此可以直接采用斜率优化。注意到 $X$ 单增的同时，斜率本身不降；同时据此可以知道应该维护一个上凸壳，所以可以直接取到队首进行转移的元素。复杂度线性。</p>
<h1 id="HAOI2008-硬币购物"><a href="#HAOI2008-硬币购物" class="headerlink" title="[HAOI2008]硬币购物"></a>[HAOI2008]硬币购物</h1><blockquote>
<p>共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$。</p>
<p>某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚 $i$ 种硬币，想购买 $s$ 的价值的东西。请问每次有多少种付款方法。</p>
<p>$1 \leq c_i, d_i, s \leq 10^5$，$1 \leq n \leq 1000$。</p>
</blockquote>
<p>比较常规的容斥题目。考虑由于硬币个数的限制，大概是要做一个多重背包计数，这样复杂度是 $O(4\cdot n\cdot s)$，大概是 $4e8$ 的级别，如果常数小的话没准信仰一波也是可以过的。</p>
<p>考虑更加正经一点的做法。发现虽然硬币个数很多，但是种类很少，同时发现不限制使用次数的方案数是很好计算的，于是考虑容斥。$f_v$ 表示不考虑硬币个数，用四种面值凑出 $v$ 的方案数。那么考虑如何统计不合法的方案数。考虑对于一种硬币 $(c_i,d_i)$，看上去，所有他的不合法方案应该是 </p>
<script type="math/tex; mode=display">
\sum_{j=d_i+1}^{+\infty} f_{s-c_i\cdot j}</script><p>但是发现背包模型在计算方案时，状态本身具有简并性。 也就是对于任何一个状态 $f_{i,k}$ 都是被更小的 $f_{i,k-t\cdot c_i}$ 给拼插起来的。所以方案数应该为</p>
<script type="math/tex; mode=display">
f_{s-c_i\cdot (d_i+1)}</script><p>于是容斥一下即可。复杂度 $O(4\cdot s+16\cdot n)$ 。</p>
<h1 id="CF933A-A-Twisty-Movement"><a href="#CF933A-A-Twisty-Movement" class="headerlink" title="[CF933A]A Twisty Movement"></a>[CF933A]A Twisty Movement</h1><blockquote>
<p>给定一个序列 A，你可以翻转其中的一个区间内的数，求翻转后的序列的最长不下降子序列的长度。（$|A|\le 2000,1\le a_i \le 2$ ）</p>
<p>$1\leq n\leq 10^3$。</p>
</blockquote>
<p>自己想了一个暴力做法。大概是对于每个位置 $s$ ，可以比较方便地维护出 $s$ 之前以 $0/1$ 结尾的最长上升子序列，同时也可以维护出 $s$ 之后以 $0/1$ 开头结尾的最长上升子序列，这一部分不是那么直观，但是考虑对于一个位置 $p$ ，一定是有某个位置 $q&gt;p$ 使得 $p+1\sim q$ 之间只选 $0$，$q+1\sim n$ 之间只选 $1$ 。这个东西倒着预处理似乎可以 $poly(\log)$ 或者线性，但是由于数据范围所以可以直接暴力。然后每次枚举两个端点暴力即可。中间可能要进行一下玄学的 dp。</p>
<p>……但其实是可以直接暴力 $dp$ 的。考虑最后选取的一定是一个形如 $1…2….1…2…$ 的子序列，于是就可以设状态 $f_{i,0/1/2/3/4}$ 表示分成了 $0/1/2/3/4$  后的、形如这样的子序列。转移的话就是相邻状态转移即可。复杂度线性。</p>
<p>当然这题也存在一个闲的胃疼的高级做法，就是线段树上分别维护 $1 \rightarrow 1,1 \rightarrow 2,2 \rightarrow 1,2 \rightarrow 2$ 的最长上升子序列，然后暴力枚举每个区间，复杂度 $O(n^2\log n)$ 。</p>
<p>emmm 启发了一个 Idea 但是自己不会做，惨惨。</p>
<h1 id="LuoguP6435-「EZEC-1」数列"><a href="#LuoguP6435-「EZEC-1」数列" class="headerlink" title="[LuoguP6435] 「EZEC-1」数列"></a>[LuoguP6435] 「EZEC-1」数列</h1><blockquote>
<p>给你一个正整数 $n$，有数列 $\{a_n\}:1,2,3,…,n$。</p>
<p>分别求相邻两项中左边一项的 $a$ 倍与右边一项的 $b$ 倍的和再加上 $c$，得到一个有 $n-1$ 项的新数列：</p>
<p> $1\times a+2\times b+c,2\times a+3\times b +c,…,(n-1)\times a+n\times b+c$。</p>
<p>对这个新数列重复上述操作得到若干数列，最后的数列只有一项，求最后这个项对 $p$ 取模的值。</p>
<p>$1\le n\le 10^{18}$，$1\le p \le 10^{14}$，$1 \le a,b\le 10^9$，$0\le c \le 10^9$ 。</p>
</blockquote>
<p>…比较有意思的题目？本质上数学题。</p>
<p>考虑直接递推。设 $f_k$ 表示经历完 $k$ 次操作之后的第一项。那么考虑最开始 $a_2-a_1$ 的值是 $1$ ，之后每次会变成原来的 $(a+b)$ 倍，那么也就是有：</p>
<script type="math/tex; mode=display">
f_{i}=a\cdot f_{i-1}+b\cdot (f_{i-1}+(a+b)^{i-2})+c</script><p>那么也就是</p>
<script type="math/tex; mode=display">
f_i=(a+b)\cdot f_{i-1}+b\cdot(a+b)^{i-2}+c</script><p>考虑高中数学技巧</p>
<script type="math/tex; mode=display">
\frac{f_i}{(a+b)^i}=\frac{f_{i-1}}{(a+b)^{i-1}}+\frac{b}{(a+b)^2}+\frac{c}{(a+b)^i}</script><p>那么可以通过差分得到</p>
<script type="math/tex; mode=display">
f_i=(i-1)\cdot b\cdot (a+b)^{i-2}+(a+b)^{i-1}+c\cdot \sum_{j=0}^{i-2}(a+b)^j</script><p>发现前面很好算，后面是一个等比数列的形式。由于不保证 $p$ 是素数，所以不能直接求逆元。于是考虑分治乘法。具体的，对于一个 $\sum_{i=1}^n(a+b)^i$ 可以这么算：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n(a+b)^i=
\begin{cases}(a+b)^{\frac{n}{2}}\cdot \sum_{i=1}^{\frac{n}{2}}(a+b)^i+\sum_{i=1}^{\frac{n}{2}-1}(a+b)^i&\mathrm{if}~(n~\mathrm{is~even}) \\
(a+b)^{\lfloor \frac{n}{2}\rfloor }\cdot \sum_{i=1}^{\lfloor \frac{n}{2}\rfloor }(a+b)^i+\sum_{i=1}^{\lfloor \frac{n}{2}\rfloor -1}(a+b)^i + (a+b)^n &\mathrm{otherwise}\end{cases}</script><p>然后就可以分治做下去了。复杂度 $\rm poly(\log )$ 。</p>
<h1 id="LuoguP5007-DDOSvoid-的疑惑"><a href="#LuoguP5007-DDOSvoid-的疑惑" class="headerlink" title="[LuoguP5007] DDOSvoid 的疑惑"></a>[LuoguP5007] DDOSvoid 的疑惑</h1><blockquote>
<p>给定一棵以 1 为根的有根树，定义树的一个毒瘤集为一个集合，并且集合中任意两个元素之间不存在祖先与后代关系。</p>
<p>定义一个毒瘤集的毒瘤指数为集合内所有元素的价值之和</p>
<p>要求给定树的所有毒瘤集的毒瘤指数之和，答案对 $10^8+7$ 取模。</p>
<p>但这个问题太难了，所以我们考虑化简。</p>
<p>因为点的编号跟它毒瘤指数密切相关，所以我们将会再给出一个整数 T，T = 1 表示 i 号点的毒瘤指数为 i，T = 0，表示所有点的毒瘤指数都是 1。</p>
<p>$1\leq n\leq 10^6$ 。</p>
</blockquote>
<p>不难发现这个可以以子树为状态来转移。</p>
<p>咕咕咕咕咕。咕是不可能不咕的。咕与不咕，这篇没写完的文章都在这里，不离、不弃。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>技巧/分块</tag>
        <tag>思维题/找性质</tag>
        <tag>技巧/倍增</tag>
        <tag>数学/扩展欧几里德</tag>
        <tag>思维题/容斥</tag>
        <tag>贪心</tag>
        <tag>动态规划/树形DP</tag>
        <tag>动态规划/单调队列</tag>
        <tag>数学/线性代数/矩阵</tag>
        <tag>数据结构/线段树</tag>
        <tag>动态规划/背包模型</tag>
        <tag>单调队列/单调栈</tag>
        <tag>数据结构/左偏树</tag>
        <tag>暴力,brute-force</tag>
        <tag>动态规划/状态合并</tag>
        <tag>技巧/行列无关</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】[NOIonline Round2] C~F题解</title>
    <url>/2020/04/26/NOIOL-Round-2-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>依旧是按照个人做题时认为的难度排序…</p>
<p>打比赛的时候严重翻车，比赛经验还是太差劲了啊！</p>
<p><del>于是这篇文章就变成了游记+翻车实录</del></p>
<a id="more"></a>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>作为苏打绿死忠的我…觉得普及这个 T1 题目背景and题目名称都很赞！</p>
<h1 id="C-涂色游戏"><a href="#C-涂色游戏" class="headerlink" title="C 涂色游戏"></a>C 涂色游戏</h1><blockquote>
<p>你有 $10^{20}$ 个格子，它们从 $0$ 开始编号，初始时所有格子都还未染色，现在你按如下规则对它们染色：</p>
<ol>
<li>编号是 $p_1$ 倍数的格子（包括 $0$ 号格子，下同）染成红色。</li>
<li>编号是 $p_2$ 倍数的格子染成蓝色。</li>
<li>编号既是 $p_1$ 倍数又是 $p_2$ 倍数的格子，你可以选择染成红色或者蓝色。</li>
</ol>
<p>其中 $p_1$ 和 $p_2$ 是给定的整数，若格子编号是 $p_1$ 或 $p_2$ 的倍数则它必须要被染色。在忽略掉所有未染色格子后，你不希望存在 $k$ 个连续的格子颜色相同，因为你认为这种染色方案是无聊的。现在给定 $p_1$, $p_2$, $k$，你想知道是否有一种染色方案不是无聊的。</p>
<p>对于所有测试点：$1 \leq T\leq 10^6$，$1\leq p_1,p_2,k\le 10^9$。</p>
</blockquote>
<p>以下是做题时凌乱的内心活动</p>
<blockquote>
<p>先开题…嗯，混乱地读了半天题，觉得大概是问是否存在一个 $x$ 和一个 $y$ 使得 $p_1&gt;p_2$ 时</p>
<script type="math/tex; mode=display">
y\cdot p_1\leq x\cdot p_2\leq (x+k-1)\cdot p_2\leq (y+1)\cdot p_1</script><p>然后发现似乎很难处理编号是 $[p_1,p_2]$ 及其倍数的情况。然后就开始摸。摸了一会儿之后发现几个性质：</p>
<p>1、最多只用考虑 <code>yxyxy</code> 这种分布，即最多算上一个 $x$ 和 $y$ 的公倍数。因为如果存在连续两个 $x$ 和 $y$ 的公倍数之间，没有单独的 $y$ 的倍数，那么就说明 $x|y\cdot t,x|y\cdot (t+1)$，也就证明了 $x|y$ ，而这种情况是显然 <code>Yes</code> 的； </p>
<p>2、大概是每 $\rm lcm$ 一次循环…然后…</p>
</blockquote>
<hr>
<p>然后，读了半天题，才发现读题读反了…这题是要你去 <code>check</code> 是否对于任意一个 $y$ 都存在一个 $x$ 使得</p>
<script type="math/tex; mode=display">
y\cdot p_1< x\cdot p_2< (x+k-1)\cdot p_2< (y+1)\cdot p_1</script><p>同时也不用考虑 $\rm lcm$ 的问题了，因为遇到 $\rm lcm$ 肯定会涂 $p_1$ 色。所以上式直接换成了拟序。</p>
<p>那么也就是考虑是否满足</p>
<script type="math/tex; mode=display">
p_1-1\geq (k-1)\cdot p_2</script><p>其中为什么是 $p_1-1$ 呢？因为不考虑 $\rm lcm$ 时这就是最近的界。但是注意到这个界有点宽，当且仅当 $(p_1,p_2)=1$ 的时候，存在这种最劣的情况，即式子 $bp_2-ap_1=1$ 存在整数解。</p>
<p>然后大概就是个代换，发现同时除以 $(p_1,p_2)$ 之后与原结果是等价的。然后就没了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !y ? x : gcd(y, x % y) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, k, g ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        n = qr(), m = qr(), k = qr() ; </span><br><span class="line">        g = gcd(n, m), n /= g, m /= g ;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">"No"</span>) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ll)(k - <span class="number">1</span>) * min(n, m) &lt; max(n, m) - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"No"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-建设城市"><a href="#D-建设城市" class="headerlink" title="D 建设城市"></a>D 建设城市</h1><blockquote>
<p>球球是一位建筑师。一天，他收到市长的任务：建设城市。球球打算建造 $2n$ 座高楼。为了保证城市美观，球球做出了如下计划：</p>
<ul>
<li><p>球球喜欢整齐的事物。他希望高楼从左向右排成一行，编号依次为 $1\sim 2n$。</p>
</li>
<li><p>球球喜欢整数，他要求每座高楼的高度都是正整数。</p>
</li>
<li><p>由于材料限制，高楼的高度无法超过 $m$。</p>
</li>
<li><p>球球喜欢中间高，两边低的造型。他要求前 $n$ 座高楼的高度不下降，后 $n$ 座高楼的高度不上升。</p>
</li>
<li><p>球球打算选两座编号为 $x,y$ 的高楼作为这座城市的地标。他认为只有当这两座高楼高度相等时，才会让城市变得美观。</p>
</li>
</ul>
<p>球球把自己的想法告诉了市长。市长希望得知所有建设城市的方案数。两种方案不同，当且仅当某座高楼的高度在两个方案中不同。这个问题可难倒了球球。球球找到了你，希望你能帮他算出答案。由于答案可能很大，你只需要给出答案对 $998244353$ 取模后的结果。</p>
</blockquote>
<p>下午 vp 这道题的时候是真的降智…首先先上已经写好的题解吧：</p>
<hr>
<p>首先考虑不加 $a_x=a_y$ 的限制，单纯计算一个不递减序列的方案数。</p>
<p>发现本质上是这么一个问题：从 $(0,1)$ 开始走，每一步可以向右走，或者向右上走（此处右上指的是 $(x,y)\to(x+1,y+k)\quad k&gt;0$ 的走法），最终走到 $(n,1),(n,2),(n,3)\cdots (n,m)$ 的方案数。那么不难发现，本质上是在对于两个楼之间的高度差进行拼插。若令 $h_0=0,d_{i}=h_{i}-h_{i-1}$ 的话， 那么本质上就是在解一个如下的方程：</p>
<script type="math/tex; mode=display">
d_1+d_2+\cdots+d_n=m</script><p>本质上就是在求这个式子中非负整数解得个数…然而并不是。由于 $1$ 号楼必然高度 $\geq 1$ ，所以差分之后， 需要保证 $d_1&gt;0$ 。</p>
<p>考虑做一个容斥，用 $d_1\geq 0$ 的答案减去 $d_1=0$ 时的答案。对于 $d_1\geq 0$ ，本质上就是一个 $n$ 元一次不定方程非负整数解计数。那么答案就是 $\binom{n+m-1}{m}$ 。$d_1=0$ 时，相当于用 $n-1$ 个未知元凑出 $m$ 来，方案数就是 $\binom{n+m-2}{m}$ 。所以可知如果不考虑 $x$ 和 $y$ 的限制，答案应该为 $\left(\binom{n+m-1}{m}-\binom{n+m-2}{m}\right)^2$ 。</p>
<p>考虑加上 $x$ 和 $y$ 的限制。那么需要分类讨论。</p>
<p>1、考虑如果 $x$ 和 $y$ 在同侧，那么可以都转化到 $1\leq x\leq y\leq n$ 的情况来做。那么 $x,y$ 之间的数都要相等假设此时 $x$ 和 $y$ 均等于 $z$，那么 $1\sim x$ 的方案数就是 $\binom{x+z-1}{z}-\binom{x+z-2}{z}$ ，$y\sim n$ 的方案数就是 $\binom{n-y+z}{z}$，因为此时相相当于有 $n-y+1$ 个未知元，和为 $z$ 的非负整数解个数。最后把这两部分拼插一下即可。</p>
<p>2、考虑如果 $x$ 和 $y$ 在异侧，那么两者本质上就没有关系了。于是考虑分别处理 $1\sim x,1\sim y,x\sim n,y\sim n$ 的答案，最后拼插一下即可。</p>
<p>于是复杂度线性。</p>
<hr>
<p>然后是花絮…这题说实话我做了很久很久…以下事情按时间线排布：</p>
<ul>
<li>看了这题，觉得 $60$ 分很 ez，然后就在想 $100$ 分怎么搞。因为上次 NOIonline 给我的经验是，生成函数是可以进普及组的，于是觉得这个 100 一定是个生成函数。</li>
<li>wqy 说是 xxs 组合题。我想了一会儿觉得大概可以转化成从 $(0,1)$ 走到 $(n,m)$ ，每一步可以平着走或者飞到右边一列一个更高的高度上。算了一波，觉得可能跟 $m$ 的 $n$ 元可含 $0$ 有序拆分有关…觉得不太行。</li>
<li>wqy 说是插板法。我觉得自己是个弱智。因为「 $m$ 的 $n$ 元可含 $0$ 有序拆分」 本质上就是 $n$ 元一次不定方程组 <script type="math/tex; mode=display">
x_1+x_2+\cdots +x_n=m</script></li>
</ul>
<p>的非负整数解组数。于是觉得枚举 $x$ 的高度然后做就很稳，遂开始写代码。</p>
<ul>
<li>写了半天，恍惚中觉得应该对 $\binom{n+m-1}{m}$ 这东西做一个前缀和，因为 $x$ 的高度如果是 $h$ ，那么 $x-1$ 的高度似乎可以是 $0\sim h$ …【注意！这个地方是有两个bug！！</li>
<li>连写带调试过了好久，发现自己是弟弟，前缀和压根不对。因为枚举的是 $x$ 的高度，所以对于每个 $x$ 的高度，$[1…x-1]$ 的不同方案已经被准确计数了…发现自己的思路乱的很。</li>
<li>又写了很久，还是不对，心情郁闷。冷静了一下发现 $1$ 号位置，即 $x_1$ ，取值不能为 $0$ 。想了想，觉得容斥一下就好了。</li>
<li>最后发现 $70$ 分。下了数据之后思考了一下，发现是 <code>case1</code> 里面，如果 $x$ 和 $y$ 都在另一侧，那么转过来应该是 $y&lt;x$…</li>
</ul>
<p>写完之后感觉自己花了这么多时间，十分弟弟。总结一下问题：</p>
<p>1、平时深入思考的情况比较少，遇到这种需要认真思考的东西，思路就会很乱很乱。</p>
<p>2、自己思维方式一直存在很大问题，加上草稿打的十分乱，就让人做题的时候内心不安静。</p>
<p>要抓紧改正啊。<del>虽然我觉得可能是我太困了</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> num[N] ;</span><br><span class="line"><span class="keyword">int</span> fac[N] ;</span><br><span class="line"><span class="keyword">int</span> inv[N] ;</span><br><span class="line"><span class="keyword">int</span> numx[N] ;</span><br><span class="line"><span class="keyword">int</span> numy[N] ;</span><br><span class="line"><span class="keyword">int</span> xnum[N] ;</span><br><span class="line"><span class="keyword">int</span> ynum[N] ;</span><br><span class="line"><span class="keyword">int</span> m, n, x, y ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret = (ll)ret * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binom</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//\binom&#123;x&#125;&#123;y&#125;</span></span><br><span class="line">    <span class="keyword">return</span> (ll)fac[x] * inv[y] % P * inv[x - y] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; x &gt;&gt; y ; ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m + n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = (ll)fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">    inv[m + n + <span class="number">1</span>] = expow(fac[m + n + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        inv[i] = (ll)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="keyword">if</span> (!((n - x &gt;= <span class="number">0</span>) ^ (n - y &gt;= <span class="number">0</span>)))&#123;</span><br><span class="line">        x = x &lt; n ? x : n - (x - n) + <span class="number">1</span> ;</span><br><span class="line">        y = y &lt; n ? y : n - (y - n) + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; y) swap(x, y) ; numx[<span class="number">0</span>] = numy[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numy[i] = binom(n - y + i, i) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numx[i] = decn(binom(x + i - <span class="number">1</span>, i), binom(x + i - <span class="number">2</span>, i)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) num[i] = addn(num[i - <span class="number">1</span>], decn(binom(n + i - <span class="number">1</span>, i), binom(n + i - <span class="number">2</span>, i))) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) add(ans, (ll)numx[i] % P * numy[m - i] % P) ;</span><br><span class="line">        ans = (ll)ans * num[m] % P ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    y = n - (y - n) + <span class="number">1</span> ;</span><br><span class="line">    xnum[<span class="number">0</span>] = ynum[<span class="number">0</span>] = numx[<span class="number">0</span>] = numy[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numx[i] = decn(binom(x + i - <span class="number">1</span>, i), binom(x + i - <span class="number">2</span>, i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) numy[i] = decn(binom(y + i - <span class="number">1</span>, i), binom(y + i - <span class="number">2</span>, i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) xnum[i] = binom(n - x + i, i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ynum[i] = binom(n - y + i, i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        add(ans, (ll)numx[i] % P * numy[i] % P * ynum[m - i] % P * xnum[m - i] % P) ; <span class="comment">//, cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-简单子序列问题"><a href="#E-简单子序列问题" class="headerlink" title="E 简单子序列问题"></a>E 简单子序列问题</h1><blockquote>
<p>给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。</p>
<p>现在，请你求出 </p>
<script type="math/tex; mode=display">
\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2</script><p>由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。</p>
<p>对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。</p>
</blockquote>
<p>这题似乎是普及题，但是我不知道为什么，就把这题转化到了这个题的对称问题上…导致这题做了很久很久很久…</p>
<p>以下是题解：</p>
<hr>
<p>我来说一个很不正常的解法…不正常在他特别麻烦…特别难调…</p>
<p>我的做法是先算出全部区间的贡献：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=i}^n(j-i)^2=\sum_{i=1}^n(1^2+2^2+3^2+\cdots +(n-i)^2)</script><p>也就是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\frac{(n-i)(n-i+1)(2\times (n-i)+1)}{6}</script><p>然后考虑减掉那些不合法的。具体的，预处理出每个位置左边最近的那个相同颜色的下标 $pre_x$ 。那么 $x$ 和 $pre_x$ 会对左端点在 $1\sim pre_x$ ，右端点在 $x+1\sim n$ 的区间产生贡献。贡献怎么算呢？</p>
<p>考虑假设一个区间长为 $L$ 。那么第一组 $(pre_x,x)$ 出现时，会有</p>
<script type="math/tex; mode=display">
L^2\to (L-1)^2=L^2-2L+1=L^2-(2L-1)</script><p>第二组出现时：</p>
<script type="math/tex; mode=display">
(L-1)^2\to (L-2)^2=(L-1)^2-2(L-1)+1=(L-1)^2-(2L-3)</script><p>以此类推，当一个区间存在 $t$ 个重复颜色时（即假设某种颜色的数量为 $c$，那么这种颜色的「重复颜色数」为 $c-1$），他需要减去 $(2\cdot t\cdot L-t^2)$ 的贡献。</p>
<p>考虑拆成两半做：</p>
<p>1、$2\cdot t\cdot L$</p>
<p>需要枚举每个位置 $i$ ，设 $j=pre_i$ 。记 $p=\max\{(n-i+1),i\},q=\min\{i,(n-i+1)\}$ 。即 $p$ 是左右两边较长的那个区间，$q$ 是较短的那个。同时记当前区间长度为 $d$，即 $d=i-pre_i$ 。以下默认省略前面的系数 $2$ 。</p>
<p>那么需要再分三类讨论会被产生贡献的区间长度 $L$ ，以下在计算 $L$ 时，用 $d+\Delta$ 来代替：</p>
<blockquote>
<p>（1）$d+1\leq L\leq q+d$ </p>
<p>对于每个这样的 $L$ ，会存在 $L-d$ 个区间产生合法贡献，所以这部分贡献就是</p>
</blockquote>
<script type="math/tex; mode=display">
\sum_{L=d+1}^{q+d}L\cdot i=\sum_{i=1}^{q}(d+i)\cdot i</script><blockquote>
<p>可以通过预处理 $\sum i$ ，$\sum i^2$ 快速计算。</p>
<p>（2） $q+d+1\leq L\leq p+d$ </p>
<p>对于每个这样的 $L$ ，由于不能全部取到，所以至多会有 $q$ 个。所以这部分贡献是：</p>
</blockquote>
<script type="math/tex; mode=display">
\sum_{L=q+d+1}^{p+d}L\cdot q=\sum_{i=q+1}^{p}(d+i)\cdot q</script><blockquote>
<p>这部分比较好算。</p>
<p>（3） $p+d+1\leq L\leq n$</p>
<p>对于每个这样的 $L$ ，发现最多只能取到 $n-L+1$ 次。所以这部分贡献是</p>
</blockquote>
<script type="math/tex; mode=display">
\sum_{L=p+d+1}^{n}L\cdot (n-L+1)=\sum_{i=p+1}^{n-d}(n-d-i+1)\cdot (d+i)</script><blockquote>
<p>这一部分同样可以通过预处理来快速计算。</p>
</blockquote>
<p>综上，这一部分的复杂度是排序外线性。</p>
<p>2、$-t^2$ </p>
<p>设 $i$ 右边第一个和 $i$ 同颜色的元素为 $r_i$ 。</p>
<p>也就是现在把问题转化成了「{区间内重复出现的数字个数 $-1$ 的平方和」。考虑扫描线。一开始将所有的数都加进线段树。从左开始，每次都删掉一个最左边的元素 $i$。如果这个元素的颜色依旧出现在后面的序列中，那么可以知道对于所有右端点 $\geq r_i$ 的区间，都会少掉一个 $(i, r_i)$ 组成的 <code>pair</code>，也就是会少掉一个重复颜色的元素。所以就是后缀减 $-1$ and 询问后缀的平方和，线段树维护即可。</p>
<p>这一部分复杂度 $O(n\log n)$ 。   </p>
<p>如何卡常：</p>
<p>1、不要用 <code>map</code> .</p>
<p>2、(mayaohua 在 uoj 群里的高论)发现中间，一段区间内部的平方的和本质上是不会爆 <code>long long</code> 的，所以可以减少取模次数。</p>
<hr>
<p>心路历程：</p>
<ul>
<li>A 完 T1 之后，发现这题「不就是记一下上次出现的位置，然后减掉左端点在 $[1,pre_x]$、右端点在 $[x,n]$ 内的贡献吗？妥了妥了！」<del>期间甚至嘲讽了一波这题很套路</del></li>
<li>算了一下发现…这个平方和好像很难算。一波拆分之后，觉得应该分成两半做。比较难的似乎是后面的 $t^2$(很久很久的以后我才发现不是这样)。</li>
<li>然后开始写写写，期间由于思路混乱(D里面提到的缺点集中展现)，于是写了一会儿才写完(但此时，我只想到了前两部分，没有考虑第三部分)。</li>
<li>写完之后才意识到…我似乎把这个问题转化到了一个和原问题等难的问题上…就很降智。然后决定先写 $50pts$ 的暴力做法。</li>
<li>写完暴力才意识到原来扫描线就好了…于是开始写线段树。</li>
<li>这个线段树我写的就…就很梦幻…我不记得我写过这么梦幻的线段树。大概就是 bug 满天飞…体验极差…</li>
<li>最终总算是调完了，和 $50pts$ 暴力对着拍了几组觉得很稳。</li>
<li>因为总觉得自己第一部分推的有问题，所以写了个 $n^3$ 暴力。写完才发现挂惨了…</li>
<li>冷静了很久，发现是自己推挂了。于是推了推第三部分，发现展开之后式子很长。然后 <code>main</code> 函数中间的那个 <code>for</code> 就写了很长…</li>
<li>最后在谷上测发现自己 TLE+取模挂了，于是把 <code>map</code> 改成 <code>sort+lower_bound</code> 就 A 掉了…</li>
</ul>
<p>…技不如人，技不如人。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(T &amp;x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; x = x &gt;= mod ? x - mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">dec</span><span class="params">(T &amp;x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; x = x &lt; <span class="number">0</span> ? x + mod : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">addn</span><span class="params">(T x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x += y ; <span class="keyword">return</span> (x = x &gt; mod ? x - mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">il T <span class="title">decn</span><span class="params">(T x, T y, ll mod = P)</span></span>&#123;</span><br><span class="line">    x -= y ; <span class="keyword">return</span> (x = x &lt; <span class="number">0</span> ? x + mod : x) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"></span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll t[N * <span class="number">3</span>] ;</span><br><span class="line">ll tg[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        s[rt] = val[l]  ;</span><br><span class="line">        t[rt] = s[rt] * s[rt] ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(ls, l, mid) ;</span><br><span class="line">    build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">	s[rt] = s[ls] + s[rs] ;</span><br><span class="line">	t[rt] = t[ls] + t[rs] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (tg[rt])&#123;</span><br><span class="line">        ll p = tg[rt] * tg[rt] % P ;</span><br><span class="line">        ll pr = r - ((l + r) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">        ll pl = ((l + r) &gt;&gt; <span class="number">1</span>) - l + <span class="number">1</span> ;</span><br><span class="line">        tg[ls] += tg[rt], tg[rs] += tg[rt] ;</span><br><span class="line">        dec(t[ls], decn(<span class="number">2l</span>l * s[ls] * tg[rt] % P, p * pl)) ;</span><br><span class="line">        dec(t[rs], decn(<span class="number">2l</span>l * s[rs] * tg[rt] % P, p * pr)) ;</span><br><span class="line">        dec(s[ls], tg[rt] * pl % P) ; dec(s[rs], tg[rt] * pr % P) ; tg[rt] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        dec(t[rt], decn(<span class="number">2l</span>l * s[rt] % P, <span class="number">1l</span>l * (r - l + <span class="number">1</span>))) ;</span><br><span class="line">        dec(s[rt], <span class="number">1l</span>l * (r - l + <span class="number">1</span>)) ; tg[rt] += <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(ls, l, mid, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rs, mid + <span class="number">1</span>, r, ul, ur) ;</span><br><span class="line">    s[rt] = s[ls] + s[rs] ; t[rt] = t[ls] + t[rs] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur) <span class="keyword">return</span> t[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; ll res = <span class="number">0</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) res += query(ls, l, mid, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) res += query(rs, mid + <span class="number">1</span>, r, ul, ur) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line">ll res ;</span><br><span class="line">ll sum1[N] ;</span><br><span class="line">ll sum2[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> nxt[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line">ll fuck[M][M] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Inv6 = <span class="number">166666668l</span>l ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> len ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		base[i] = tmp[i] = qr() ;</span><br><span class="line">	sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">	len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lb(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (buc[base[i]]) pos[i] = buc[base[i]] ; buc[base[i]] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        sum1[i] = addn(sum1[i - <span class="number">1</span>], i) ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		sum2[i] = addn(sum2[i - <span class="number">1</span>], i * i)  ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        add(ans, (i + <span class="number">1</span>) * i * (<span class="number">2l</span>l * i + <span class="number">1l</span>l) % P) ;</span><br><span class="line">    ans = ans * Inv6 % P ;</span><br><span class="line">    ll q, maxx, minx, m, p, len1, len2, d ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!pos[i])</span><br><span class="line">			<span class="keyword">continue</span> ;</span><br><span class="line">		q = n - i + <span class="number">1</span> ;</span><br><span class="line">        maxx = q, minx = pos[i] ;</span><br><span class="line">        p = i - pos[i], m = n - p ;</span><br><span class="line">        d = decn(sum1[m], sum1[maxx]) ;</span><br><span class="line">        <span class="keyword">if</span> (minx &gt; maxx) swap(minx, maxx) ;</span><br><span class="line">        len2 = m - maxx, len1 = maxx - minx ;</span><br><span class="line">      	<span class="comment">//part1</span></span><br><span class="line">        add(res, sum2[minx]) ;</span><br><span class="line">        add(res, sum1[minx] * p) ;</span><br><span class="line">      	<span class="comment">//part2</span></span><br><span class="line">        add(res, p * minx * len1) ;</span><br><span class="line">        add(res, minx * decn(sum1[maxx], sum1[minx], P) % P) ;</span><br><span class="line">        <span class="comment">//part3</span></span><br><span class="line">        dec(res, <span class="number">2l</span>l * p * d % P) ;</span><br><span class="line">        dec(res, p * p * len2 % P) ;</span><br><span class="line">		add(res, <span class="number">1l</span>l * (n + <span class="number">1</span>) * d % P) ;</span><br><span class="line">		dec(res, decn(sum2[m], sum2[maxx])) ;</span><br><span class="line">        add(res, <span class="number">1l</span>l * (n + <span class="number">1</span>) * p * len2 % P) ;</span><br><span class="line">        dec(ans, <span class="number">2l</span>l * res % P) ; res = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">           	fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">                buc[base[j]] ++ ;</span><br><span class="line">                fuck[i][j] = fuck[i][j - <span class="number">1</span>] + (buc[base[j]] &gt; <span class="number">1</span>) ;</span><br><span class="line">                add(ans, fuck[i][j] * fuck[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        nxt[i] = buc[base[i]] ? buc[base[i]] : n + <span class="number">1</span>, buc[base[i]] = i ;</span><br><span class="line">    fill(buc, buc + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        buc[base[i]] ++, val[i] = val[i - <span class="number">1</span>] + (buc[base[i]] &gt; <span class="number">1</span>) ;</span><br><span class="line">    build (<span class="number">1</span>, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        add(ans, query(<span class="number">1</span>, <span class="number">1</span>, n, i, n) % P) ;</span><br><span class="line">        <span class="keyword">if</span> (nxt[i] &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, nxt[i], n) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-游戏"><a href="#F-游戏" class="headerlink" title="F 游戏"></a>F 游戏</h1><blockquote>
<p>小 A 和小 B 正在玩一个游戏：有一棵包含 $n=2m$ 个点的有根树（点从 $1\sim n$ 编号），它的根是 $1$ 号点，初始时两人各拥有 $m$ 个点。游戏的每个回合两人都需要选出一个自己拥有且之前未被选过的点，若对手的点在自己的点的子树内，则该回合自己获胜；若自己的点在对方的点的子树内，该回合自己失败；其他情况视为平局。游戏共进行 $m$ 回合。</p>
<p>作为旁观者的你只想知道，在他们随机选点的情况下，第一次非平局回合出现时的回合数的期望值。</p>
<p>为了计算这个期望，你决定对于 $k=0,1,2,\cdots,m$，计算出非平局回合数为 $k$ 的情况数。两种情况不同当且仅当存在一个小 A 拥有的点 $x$，小 B 在 $x$ 被小 A 选择的那个回合所选择的点不同。</p>
<p>由于情况总数可能很大，你只需要输出答案对 $998244353$ 取模后的结果。</p>
<p>$n\leq 5000$ 。</p>
</blockquote>
<p><del>第一眼看到「期望」字样其实我是想弃的。</del></p>
<p>不算十分有趣的题，比较中规中矩地考察了<del>我没有的</del>硬实力。</p>
<p>考虑因为是随机选点，先要计算一个 $f_{i,j}$ 表示子树 $i$ 内凑出 $j$ 个不同的「非平局点对」的方案数。转移考虑两部分:</p>
<p>1、子树之间的贡献：就是普通的树上背包那么转移。注意到如果界定的好是可以 $n^3\to n^2$ 的。</p>
<p>2、根与子树之间的贡献：加法原理一波带走即可。</p>
<p>然后考虑 $f_{1,i}$ 就是整棵树凑出 $i$ 个不合法对，也就是不平局 $i$ 次的方案数。考虑利用这个东西，本质上还是很难求出共非平局 $k$ 次的方案数，因为无法快速统计剩下那些平局的贡献。但是考虑，可以快速计算出非平局 $\geq k$ 次的方案数，就是 $f_{1,k}\cdot (\frac{n}{2}-k)! $ 。至于为什么呢…可以理解为剩下 $n-2\cdot k$ 个人，固定住一半个人，剩下一半的人随便找一个匹配，那么方案数就是剩下一半人的全排列，即 $(\frac{n-2\cdot k}{2})!$ 。</p>
<p>那么考虑令 $f_i$ 表示至少非平局 $i$ 次的方案数，设 $g_i$ 为恰好平局 $i$ 次的方案数，那么根据二项式反演有 </p>
<script type="math/tex; mode=display">
f_i=\sum_{j=i}^{m}g_j\binom{j}{i}\cdot (-1)^{j-i}</script><p>于是复杂度 $O(n^2)$，略卡常数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll F[N] ;</span><br><span class="line">ll G[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll tmp[N] ;</span><br><span class="line">ll f[N][N] ;</span><br><span class="line"><span class="keyword">int</span> suma[N] ;</span><br><span class="line"><span class="keyword">int</span> size[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line">ll comb[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    size[x] = <span class="number">1</span> ; f[x][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa)</span><br><span class="line">			<span class="keyword">continue</span> ; do_dp(to(k), x) ;</span><br><span class="line">		fill(tmp, tmp + size[to(k)] + size[x] + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = min(size[x], n / <span class="number">2</span>) ; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line">			<span class="keyword">if</span> (f[x][i])&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = min(size[to(k)], n / <span class="number">2</span> - i) ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">        	        <span class="keyword">if</span> (f[to(k)][j])</span><br><span class="line">						add(tmp[i + j], f[x][i] * f[to(k)][j] % P, P) ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= size[x] + size[to(k)] ; ++ i) f[x][i] = tmp[i] ;</span><br><span class="line">        suma[x] += suma[to(k)] ; size[x] += size[to(k)] ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; x &lt;&lt; " &amp; " ; debug(f[x], 0, 10) ;</span></span><br><span class="line">	<span class="keyword">if</span> (!base[x])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(suma[x], size[x] - suma[x]) ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            add(f[x][i], f[x][i - <span class="number">1</span>] * (ll)max(suma[x] - i + <span class="number">1</span>, <span class="number">0</span>) % P, P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(suma[x], size[x] - suma[x]) ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            add(f[x][i], f[x][i - <span class="number">1</span>] * (ll)max(size[x] - suma[x] - i + <span class="number">1</span>, <span class="number">0</span>) % P, P) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; x &lt;&lt; " &amp; " ; debug(f[x], 0, 10) ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(".in", "r", stdin) ;</span></span><br><span class="line">    <span class="comment">//freopen(".out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n, fac[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fac[i] = (ll)i * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i]), suma[i] = base[i] ;</span><br><span class="line"><span class="comment">//	debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//	debug(suma, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        u = qr(), v = qr(), add_e(u, v) ; do_dp(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//	debug(base, 1, n) ;</span></span><br><span class="line"><span class="comment">//	debug(suma, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i) comb[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            comb[i][j] = addn(comb[i - <span class="number">1</span>][j], comb[i - <span class="number">1</span>][j - <span class="number">1</span>], P) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n / <span class="number">2</span> ; ++ i)</span><br><span class="line">        F[i] = f[<span class="number">1</span>][i] * fac[n / <span class="number">2</span> - i] % P ;</span><br><span class="line"><span class="comment">//	debug(f[1], 0, n) ; debug(F, 0, n) ; debug(fac, 1, n) ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n / <span class="number">2</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= n / <span class="number">2</span> ; ++ j)</span><br><span class="line">            (!(j - i &amp; <span class="number">1</span>)) ? add(G[i], F[j] * comb[j][i] % P, P) : dec(G[i], F[j] * comb[j][i] % P, P) ;</span><br><span class="line">    debug(G, <span class="number">0</span>, n / <span class="number">2</span>, <span class="string">'\n'</span>, <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还是太弱啊…不过打这一场比赛确实很浪费精力，毕竟一道线段树+一道 xxs 组合加起来我能调 $7h$ 也是相当弱菜了…</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>好多好多细节</tag>
        <tag>思维题/容斥</tag>
        <tag>动态规划/树形DP</tag>
        <tag>数据结构/线段树</tag>
        <tag>组合计数/有技巧的计数</tag>
        <tag>动态规划/背包模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】[NOIonline Round1] A~F题解</title>
    <url>/2020/04/24/NOIOLRound1-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>场上打的一点也不好…场后复盘了一下，其实六道题都不算难。自己缺乏比赛经验、基础不扎实、想题不认真、不专注等问题都十分影响发挥…</p>
<p>于是就打算整理一下这六道题。感觉…还是有点东西的吧。</p>
<p>题目难度按我自己心目中的升序排序。</p>
<blockquote>
<p>心不摇于死生之变，气不夺于宠辱利害之交，则四者之胜败自然洞见。</p>
</blockquote>
<a id="more"></a>
<h1 id="A-文具订购"><a href="#A-文具订购" class="headerlink" title="A 文具订购"></a>A 文具订购</h1><blockquote>
<p>小明的班上共有 $n$ 元班费，同学们准备使用班费集体购买 $3$ 种物品：</p>
<ol>
<li>圆规，每个 $7$ 元。</li>
<li>笔，每支 $4$ 元。</li>
<li>笔记本，每本 $3$ 元。</li>
</ol>
<p>小明负责订购文具，设圆规，笔，笔记本的订购数量分别为 $a,b,c$，他订购的原则依次如下：</p>
<ol>
<li>$n$ 元钱必须正好用光，即 $7a+4b+3c=n$。</li>
<li>在满足以上条件情况下，成套的数量尽可能大，即 $a,b,c$ 中的最小值尽可能大。</li>
<li>在满足以上条件情况下，物品的总数尽可能大，即 $a+b+c$ 尽可能大。</li>
</ol>
<p>请你帮助小明求出满足条件的最优方案。可以证明若存在方案，则最优方案唯一。</p>
<p>对于全部的测试点，保证 $0 \leq n \leq 10^5$。</p>
</blockquote>
<p>考虑贪心。发现大概是 $14$ 元一套，于是就从 $\lfloor\frac{n}{14}\rfloor$ 枚举到 $0$ 。如果钱数不是 $14$ 的倍数，当然是把剩下的用来买 $3$ 和 $4$ 最合理。于是就模拟一遍即可，同时再去找 $a+b+c$ 的最大值。大概是 div2B 的难度？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    ans = n / <span class="number">14</span> ;</span><br><span class="line">    <span class="keyword">while</span> (ans &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        outp = <span class="number">0</span> ;</span><br><span class="line">        a = b = c = ans ;</span><br><span class="line">        pq = a * <span class="number">14</span>, res = n - pq ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= res / <span class="number">3</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> ((res - i * <span class="number">3</span>) % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                outp = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">3</span> * ans + i + (res - i * <span class="number">3</span>) / <span class="number">4</span> &gt; a + b + c)</span><br><span class="line">                    b = ans + (res - i * <span class="number">3</span>) / <span class="number">4</span>, c = ans + i ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (outp)</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, a, b, c) ;</span><br><span class="line">        <span class="keyword">else</span> ans -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-冒泡排序"><a href="#B-冒泡排序" class="headerlink" title="B 冒泡排序"></a>B 冒泡排序</h1><blockquote>
<p>给定一个 $1 ∼ n$ 的排列 $p_i$，接下来有 $m$ 次操作，操作共两种：</p>
<ol>
<li>交换操作：给定 $x$，将当前排列中的第 $x$ 个数与第 $x+1$ 个数交换位置。</li>
<li>询问操作：给定 $k$，请你求出当前排列经过 $k$ 轮冒泡排序后的逆序对个数。</li>
</ol>
<p>对一个长度为 $n$ 的排列 $p_i$ 进行一轮冒泡排序的伪代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i &#x3D; 1 to n-1:</span><br><span class="line">  if p[i] &gt; p[i + 1]:</span><br><span class="line">    swap(p[i], p[i + 1])</span><br></pre></td></tr></table></figure><br>对于所有测试点：$2 \leq n,m \leq 2 \times 10^5$，$t_i \in \{1,2\}$，$1 \leq x &lt; n$，$0 \leq k &lt; 2^{31}$。</p>
</blockquote>
<p>这题在考场上写了神必线段树…复杂度也不对…就很弱智。</p>
<p>大概就是首先要去洞见冒泡排序的一个性质。每轮冒泡排序会让每个元素排到他后面第一个比他大的元素之前，把最大的元素移到序列最后。假设这是一对 $(i,j)$ ，$j$ 是 $i$ 后面第一个大于 $i$ 的元素。那么考虑这个操作使得， $i$ 移动到 $j$ 前面一个位置，同时所有 $x$ 之间不会彼此交换。</p>
<p>回顾这一过程，发现 $i+1\le x\le j-1$ 的所有 $x$ 的逆序对(此处特指 $x$ 与 $1\sim x-1$ 形成的逆序对)数量都会向前移动一位且不变(中间只会进行跟 $i$ 有关的操作)，且由于本质上 $i$ 与前面构成的逆序对数量等于 $j$ 与前面构成的逆序对数量 (因为此时并不存在一个比 $i$ 小的 $k$ 满足 $a_k&gt;a_i$ ，因为根据冒泡排序这会让 $a_i$ 被 $a_k$ 换掉成为前面某个「对」的 $x’$) ，所以此时 $j$ 的逆序对数为 $0$，那么 $i$ 的逆序对数也为 $0$ 。</p>
<p>更进一步，本题相当于需要维护一个序列 $\{p_n\}$，支持：</p>
<p>1、单点加/减（维护初始逆序对数</p>
<p>2、询问</p>
<script type="math/tex; mode=display">
\left(\sum_{p_i>k} p_i\right)-\left(\sum_{p_i > k} k\right)</script><p>考虑这东西就拿一个树状数组维护一下权值就好了。复杂度 $m\log n$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v ;</span><br><span class="line">    <span class="keyword">int</span> p ;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(a x, a y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.v &lt; y.v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(a x, a y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.p &lt; y.p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= n ; p += low(p)) b[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += b[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll t[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> c1, <span class="keyword">int</span> c2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        s[rt] += c1 ;</span><br><span class="line">        t[rt] += c2 ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, c1, c2) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, c1, c2) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    t[rt] = t[rt &lt;&lt; <span class="number">1</span>] + t[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ; <span class="keyword">int</span> mid = (l + r)  &gt;&gt;  <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret += ask1(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) ret += ask1(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> t[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ; <span class="keyword">int</span> mid = (l + r)  &gt;&gt;  <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) ret += ask2(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) ret += ask2(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> t, c ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i].v), base[i].p = i ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        res[base[i].p] = ask(base[i].p) ;</span><br><span class="line">        ans += res[base[i].p] ; add(base[i].p, <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		update(<span class="number">1</span>, <span class="number">1</span>, n, res[i], res[i], <span class="number">1</span>) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp2) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;c) ;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>)&#123;</span><br><span class="line">            swap(res[c], res[c + <span class="number">1</span>]) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c], -res[c], <span class="number">-1</span>) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c + <span class="number">1</span>], -res[c + <span class="number">1</span>], <span class="number">-1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (base[c].v &lt; base[c + <span class="number">1</span>].v) </span><br><span class="line">				res[c + <span class="number">1</span>] ++ ; <span class="keyword">else</span> res[c] -- ;  </span><br><span class="line">            swap(base[c], base[c + <span class="number">1</span>]) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c], res[c], <span class="number">1</span>) ;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, res[c + <span class="number">1</span>], res[c + <span class="number">1</span>], <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll ret ;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= n - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>) ;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ret = ask1(<span class="number">1</span>, <span class="number">1</span>, n, c + <span class="number">1</span>, n) ;</span><br><span class="line">                ret -= (ll)c * ask2(<span class="number">1</span>, <span class="number">1</span>, n, c + <span class="number">1</span>, n) ;</span><br><span class="line">				<span class="comment">//cout &lt;&lt; c &lt;&lt; " " &lt;&lt; ask1(1, 1, n, c + 1, n) &lt;&lt; " " &lt;&lt; ask2(1, 1, n, c + 1, n) &lt;&lt; endl ;</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ret) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>最后还是写的线段树，略略略</del></p>
<h1 id="C-跑步"><a href="#C-跑步" class="headerlink" title="C 跑步"></a>C 跑步</h1><blockquote>
<p>小 H 是一个热爱运动的孩子，某天他想给自己制定一个跑步计划。小 H 计划跑 $n$ 米，其中第 $i(i \geq 1)$ 分钟要跑 $x_i$ 米（$x_i$ 是正整数），但没有确定好总时长。</p>
<p>由于随着跑步时间增加，小 H 会越来越累，所以小 H 的计划必须满足对于任意 $i(i &gt;1)$ 都满足 $x_i \leq x_{i-1}$。</p>
<p>现在小 H 想知道一共有多少个不同的满足条件的计划，请你帮助他。两个计划不同当且仅当跑步的总时长不同，或者存在一个 $i$，使得两个计划中 $x_i$ 不相同。</p>
<p>由于最后的答案可能很大，你只需要求出答案对 $p$ 取模的结果。 </p>
<p>对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq p &lt; 2^{30}$。</p>
</blockquote>
<p>发现就是整数拆分问题。分拆数问题本质上是 $n$ 也无标号的第二类斯特林数问题（第二类斯特林数是 $n$ 有标号但是 $k$ 无标号）。</p>
<p>那么对于这个问题，考虑两种 $dp$.</p>
<ul>
<li>1、令 $f_{i,j}$ 表示对于 $i$ 拆分成若干个不大于 $j$ 的数的方案数。则有转移：</li>
</ul>
<script type="math/tex; mode=display">
f_{i,j}=f_{i,j-1}+f_{i-j,j}</script><p>后面一项 $f_{i-j,j}$ 可以看成一个背包一样，后面的状态对前面的状态有天然的累加效应，所以只需要考虑丢掉一个 $j$ 的情况；而前面一项则把我们转移从后一项的<strong>等于</strong> $j$ 升级成为<strong>不大于</strong> $j$ 。</p>
<ul>
<li>2、令 $g_{i,j}$ 表示对于 $i$ 拆分成 $j$ 个数的方案数。则有转移：</li>
</ul>
<script type="math/tex; mode=display">
g_{i,j}=g_{i-1,j-1}+g_{i-j,j}</script><p>前面一项表示新拆出一个 $1$ 来，还是背包的那种“累加”思想，所以只需要考虑拆出一个 $1$ 的情况；后面一项则表示不拆，而是把拆出的数全体都 $+1$，即本来的 $5=3+1+1$ 转移到 $8=4+2+2$ 。注意此处不会存在“部分拆出来的数加了但是剩下的没加”或者“加的不一样”，因为这两个状态都是可以归约到 $i$ 较小的 $g$ 上去所以不需要额外转移。</p>
<p>ps：似乎某硬币xx的容斥题就用到了这个思想来着。。。实际上就是个背包吧qaq</p>
<p>但是上述做法是 $n^2$ 的。总结两个 $dp$ 的优劣，发现如果采用根号分治的策略，对于 $f$ 只转移 $&lt; \sqrt n$ 的，对于 $g$ 只转移 $\geq \sqrt n$ 的，那么两者均只需要 $n\sqrt n$ 的时空代价（因为大于 $\sqrt n$ 的数不会用超过 $\sqrt n$ 个）。</p>
<p>具体的，考虑对先用 $f$ 求出来 $j&lt; \sqrt n$ 的方案数，再魔改一下 $g$，让 $g$ 只转移那些 $\geq \sqrt n$ 的数字：就是第一维把 $\sqrt n$ 当作步长转移即可。</p>
<p>之后考虑如何合并答案。发现 $f,g$ 对于同一个 $n$，计数的部分互斥且互补，那么就可以直接乘法原理解决。合并是个卷积状物，但由于本题只需要求第 $n$ 项，所以直接算即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">403</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, p ;</span><br><span class="line"><span class="keyword">int</span> f[N][B] ;</span><br><span class="line"><span class="keyword">int</span> g[N][B] ;</span><br><span class="line"><span class="keyword">int</span> X[N], Y[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p ;</span><br><span class="line">    S = n / B + <span class="number">1</span> ; X[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; B ; ++ i) f[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; B ; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) f[i][j] = f[i][j - <span class="number">1</span>] ;</span><br><span class="line">            f[i][j] = (f[i - j][j] + f[i][j - <span class="number">1</span>]) % p ;</span><br><span class="line">            X[i] = f[i][j] ; <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; X[i] &lt;&lt; endl ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    g[B][<span class="number">1</span>] = <span class="number">1</span> ; Y[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S &amp;&amp; j &lt;= i ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= B) (g[i][j] += g[i - B][j - <span class="number">1</span>]) %= p ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) (g[i][j] += g[i - j][j]) %= p ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= S ; ++ j)</span><br><span class="line">            (Y[i] += g[i][j]) %= p ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        (ans += <span class="number">1l</span>l * X[i] * Y[n - i] % p) %= p ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-序列"><a href="#D-序列" class="headerlink" title="D 序列"></a>D 序列</h1><blockquote>
<p>小 D 有一个长度为 $n$ 的整数序列 $a_{1 \dots n}$，她想通过若干次操作把它变成序列 $b_i$。</p>
<p>小 D 有 $m$ 种可选的操作，第 $i$ 种操作可使用三元组 $(t_i,u_i,v_i)$ 描述：若 $t_i=1$，则她可以使 $a_{u_i}$ 与 $a_{v_i}$ 都加一或都减一；若 $t_i=2$，则她可以使 $a_{u_i}$ 减一、$a_{v_i}$ 加一，或是 $a_{u_i}$ 加一、$a_{v_i}$ 减一，因此当 $u_i=v_i$ 时，这种操作相当于没有操作。</p>
<p>小 D 可以以任意顺序执行操作，且每种操作都可进行无限次。现在给定序列与所有操作，请你帮她判断是否存在一种方案能将 $a_i$ 变为 $b_i$。题目保证两个序列长度都为 $n$。若方案存在请输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
<p>对于所有测试点：$1 \le T \le 10$，$1 \le n,m \le 10^5$，$1 \le a_i,b_i \le 10^9$，$t_i \in \{1,2\}$，$1\le u_i,v_i \le n$。</p>
</blockquote>
<p>被教育了，我大概并查集这方面就是白痴中的战斗机了。</p>
<p>考虑大概能琢磨出这么几个没啥用的性质：1、如果 $a,b$ 和 $b,c$ 两对之间分别被 $1$ 相连，那么相当于 $a$ 和 $c$ 被 $1$ 相连；2、如果 $a,b$ 之间 $0$ 相连，$b,c$ 之间 $0$ 相连，那么可以知道 $a$ 和 $c$ 就相当于有一条 $1$ 边。</p>
<p>然后…大概就可以搞一个边带权并查集了。同一个集合内部如果只有 $1$ 边，那么总和可以随意分配；如果某个集合内部向自己连了 $1$ 边和 $0$ 边，那么就可以让某两个元素同时加减，只要和是偶数即可。</p>
<p>其实也不难吧…还是自己过于弱菜啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line">ll f[N] ;</span><br><span class="line"><span class="keyword">int</span> A[N] ;</span><br><span class="line"><span class="keyword">int</span> B[N] ;</span><br><span class="line"><span class="keyword">int</span> D[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> fa[x] ;</span><br><span class="line">    <span class="keyword">int</span> dad = find(fa[x]) ;</span><br><span class="line">    val[x] ^= val[fa[x]] ;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = dad ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = find(x) ;</span><br><span class="line">    <span class="keyword">int</span> f2 = find(y) ;</span><br><span class="line">    <span class="keyword">if</span> (f1 == f2)</span><br><span class="line">		res[f1] |= val[x] ^ val[y] ^ c ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		val[f1] = val[x] ^ val[y] ^ c ;</span><br><span class="line">        fa[f1] = f2 ; res[f2] |= res[f1] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_sign</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x ? <span class="number">-1</span> : <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">		<span class="keyword">int</span> t, u, v, ans = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            val[i] = f[i] = res[i] = <span class="number">0</span> ;</span><br><span class="line">			fa[i] = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]), D[i] = A[i] - B[i] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;t, &amp;u, &amp;v) ;</span><br><span class="line">			<span class="keyword">if</span> (t &gt; <span class="number">1</span>) t -= <span class="number">2</span> ; merge(t, u, v) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = find(i) ;</span><br><span class="line">			<span class="keyword">if</span> (p == i) &#123;</span><br><span class="line">				f[i] += D[i] ;</span><br><span class="line">				<span class="keyword">continue</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			f[p] += get_sign(val[i]) * D[i] ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = find(i) ;</span><br><span class="line">			<span class="keyword">if</span> (p != i) f[i] = <span class="number">0</span> ;</span><br><span class="line">			<span class="keyword">if</span> (res[i] &amp;&amp; f[i] % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span> ;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (f[i] != <span class="number">0</span>)  &#123; ans = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(ans ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-魔法"><a href="#E-魔法" class="headerlink" title="E 魔法"></a>E 魔法</h1><blockquote>
<p>C 国由 $n$ 座城市与 $m$ 条有向道路组成，城市与道路都从 $1$ 开始编号，经过 $i$ 号道路需要 $t_i$ 的费用。</p>
<p>现在你要从 $1$ 号城市出发去 $n$ 号城市，你可以施展最多 $k$ 次魔法，使得通过下一条道路时，需要的费用变为原来的相反数，即费用从 $t_i$ 变为 $-t_i$。请你算一算，你至少要花费多少费用才能完成这次旅程。</p>
<p>注意：使用魔法只是改变一次的花费，而不改变一条道路自身的 $t_i$；最终的费用可以为负，并且一个城市可以经过多次（包括 $n$ 号城市）。 </p>
<p>$1 \leq n \leq 100$，$1 \leq m \leq 2500$，$0 \leq k \leq 10^6$。</p>
<p>$1 \leq u_i, v_i \leq n$，$1 \leq t_i \leq 10^9$。</p>
</blockquote>
<p>其实也不难？考虑暴力做的话就是分层图最短路，状态数是 $O(nk)$ 的。可以拿到洛谷数据的 $70$ 分。大概就是先拿每条边预处理出 $f_{i,j,1}$ 表示 $(i,j)$ 之间只修改了 $1$ 次的答案。考虑转移的话，自然就是以 $1$ 为步长转移(小技巧，只用枚举最小规模的子问题)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v ; ll w ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; pq ;</span><br><span class="line">    <span class="built_in">memset</span>(A, <span class="number">-1</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">127</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i ^ j) dis[i][j] = (ll)<span class="number">1e12</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;w) ;</span><br><span class="line">        A[u][v] = w, dis[u][v] = min(dis[u][v], w) ;</span><br><span class="line">        edg[i][<span class="number">0</span>] = u, edg[i][<span class="number">1</span>] = v, edg[i][<span class="number">2</span>] = w ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            f[i][j][<span class="number">1</span>] = dis[i][j] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= m ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = edg[k][<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">int</span> y = edg[k][<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                f[i][j][<span class="number">1</span>] = min(f[i][j][<span class="number">1</span>], dis[i][x] + dis[y][j] - (ll)edg[k][<span class="number">2</span>]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span> ; k &lt;= pq ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span> ; o &lt;= n ; ++ o)</span><br><span class="line">                    f[i][j][k] = min(f[i][j][k], f[i][o][k - <span class="number">1</span>] + f[o][j][<span class="number">1</span>]) ;</span><br><span class="line">	<span class="keyword">if</span> (!pq) <span class="built_in">cout</span> &lt;&lt; dis[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][n][pq] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现最后的转移形式为 </p>
<script type="math/tex; mode=display">
f_{i,j,k}=\min_{o}\{f_{i,o,k-1}+f_{o,j,1}\}</script><p>这是一个扩展矩乘的形式。所以可以直接把预处理出来的 $f_{i,j,1}$ 作为矩阵的元素，快速幂即可。</p>
<h1 id="F-最小环"><a href="#F-最小环" class="headerlink" title="F 最小环"></a>F 最小环</h1><blockquote>
<p>给定一个长度为 $n$ 的正整数序列 $a_i$，下标从 $1$ 开始编号。我们将该序列视为一个首尾相邻的环，更具体地，对于下标为 $i$, $j(i \leqslant j)$ 的两个数 $a_i$, $a_j$，它们的距离为 $\min(j-i, i+n-j)$。</p>
<p>现在再给定 $m$ 个整数 $k_1$, $k_2$,…, $k_m$，对每个 $k_i(i=1$, $2$,…, $m)$，你需要将上面的序列 $a_i$ 重新排列，使得环上任意两个距离为 $k_i$ 的数字的乘积之和最大。</p>
<p>对于所有测试数据：$1 \leqslant m \leqslant n \leqslant 2 \times 10^5$，$0 \leqslant k \leqslant \lfloor n/2\rfloor$，$1 \leqslant a_i \leqslant 10^5$。</p>
</blockquote>
<p>为什么把这题放在 F 呢？因为一方面我最优化比较菜，另一方面我一看这种题就有种「信我，你不会」感觉233</p>
<p>这居然是个贪心…我也是人傻掉… 感觉自己贪心真的是菜爆了啊！</p>
<p>首先考虑相邻的元素大概是 $t~,~t+k~,~t+2\times k~,~t+3\times k~,~t+4\times k\cdots \pmod{n}$ 这种。记这个数列为「$t$ 在模 $n$ 意义下关于 $k$ 的轨迹」。</p>
<p>那么可以解一下方程求得循环节的长度：</p>
<script type="math/tex; mode=display">
t\equiv t+p\times k\pmod n</script><p>根据同余的基本性质可以得出</p>
<script type="math/tex; mode=display">
p\equiv 0\pmod {\frac{n}{(n,k)}}</script><p>那么可以知道最小的循环长度为 $\frac{n}{(n,k)}$ 。那么最多就会有 $(n,k)$ 条不同的轨迹。</p>
<p>另一方面，如果存在两个不同的 $t_0,t_1$，他们某一刻轨迹产生了相交，即</p>
<script type="math/tex; mode=display">
t_0+p\times k\equiv t_1+q\times k\pmod{n}</script><p>那么会有</p>
<script type="math/tex; mode=display">
(t_0-t_1)\equiv k\times (q-p)\pmod n</script><p>因为这个式子等价于一个一元二次不定方程，可知如果这个式子可以解出一组整数解，必须满足 </p>
<script type="math/tex; mode=display">
(n,k)|(t_0-t_1)</script><p>那么也就是说，如果两个 $t$ 的轨迹有相交，那么需要这两个 $t$ 之间的距离是 $(n,k)$ 的倍数。这也间接证明了，至多只会有 $(n,k)$ 条本质不同的轨迹。</p>
<p>考虑根据排序不等式，乘积方面一定是大的和大的拼在一起，小的和小的拼在一起更优。所以可以预处理每个不同的环长 $\zeta$ ，对于每一个 $\zeta$，把从大到小排好序的 $a_i$ ，$a_1\sim a_{\zeta}$ 分到第一组，$a_{\zeta+1}\sim a_{2\cdot \zeta}$ 分到第二组，以此类推。考虑对于同一组，最好的放的方式就是类似这样：</p>
<script type="math/tex; mode=display">
\ldots n-3,n-1,n,n-2,n-4\ldots</script><p>于是就可以按照奇偶性分个类预处理了。复杂度 $O(nd(n)+m\log n)$ 。后面那个 $\log$ 是求 $\gcd$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll ans ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line">ll res[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    sort(base, base + n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j += i)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i - <span class="number">2</span> ; ++ k)</span><br><span class="line">                    res[i] += (ll)base[j + k] * (ll)base[j + k + <span class="number">2</span>] ;</span><br><span class="line">                res[i] += (ll)base[j] * (ll)base[j + <span class="number">1</span>] ;</span><br><span class="line">				res[i] += (ll)base[j + i - <span class="number">1</span>] * (ll)base[j + i - <span class="number">2</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">		ans += (ll)base[i] * (ll)base[i] ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) ;</span><br><span class="line">		<span class="keyword">if</span> (!k) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[n / gcd(n, k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树状数组</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题/计数</tag>
        <tag>思维题/找性质</tag>
        <tag>数据结构/树状数组</tag>
        <tag>数学/数论</tag>
        <tag>数学/数值分析/调和级数</tag>
        <tag>贪心</tag>
        <tag>数学/线性代数/矩阵</tag>
        <tag>数据结构/线段树</tag>
        <tag>图论/并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>【置顶】我说啊…</title>
    <url>/2020/04/21/%E6%88%91%E8%AF%B4%E5%95%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>怨结于心，恨凝于笔。这篇博文大概是…整理每日随想吧。</p>
<p>我说啊…我其实还是什么都不明白吧。本来以为自己明白了一切，了解了成功密码，知晓了万物时性，懂得了历史规律，仿佛看一切，都看的那么清楚。现在才发现，自己面前清晰的一切，原来都是镜花水月。</p>
<p>我要学的还有很多。</p>
<p>我一直在路上。</p>
<a id="more"></a>
<h1 id="4-28"><a href="#4-28" class="headerlink" title="4.28"></a>4.28</h1><p>今天和我校生物奥赛同僚偶然突然提到了「支撑下去的信念」这个话题。自己其实一直很迷惑吧。从今年不知道什么时候开始，感觉自己就是在混日子，一天混过来再混一天。斯嘉丽的那句 _After all, Tomrrow is another day!_ 倒是和我的想法不谋而合——只不过是 _another new_ 和 _another numb_ 罢了。</p>
<p>于是我的回答自然是模棱两可，并且向他表达了自己的质疑「我就不明白了，为什么大家这么多人都在这里拼啊？都拿银牌以上不显然是不可能的吗？」</p>
<p>他想了想，说「我们教练说，竞赛锻炼的是一种能力，学竞赛的目的也应该是锻炼能力、锻炼一种可以让你学文化课时、办事时、将来学习时都有用的能力」。</p>
<p>我突然愣了愣。不是愣在这个观点的新颖，而是愣在我之前，再早、再早一些的时候，仿佛也用这句话劝说过别人。总之，我清楚地记得我说过、坚信过类似的内容…但…</p>
<p>但不知道什么时候，我仿佛已经忘记了自己的初心。一天天一天天，我一直在拿「我没有别人那么喜欢OI，所以不努力也可以理解」来搪塞自己、坚信 OI 是高智商对低智商的剥削，看到曾经自己的文字「不要功利地学 OI」时开始变得麻木、甚至有些纳闷——看着当时自己对这个世界的劝告，才发现「活成你最讨厌的人」与我仅有咫尺…我迷茫了。</p>
<p>他又问：「你的目标是什么？」</p>
<p>我：……</p>
<p>他：「没事的。目标就是要去寻找的嘛，人活着不就是去寻找活着的目标吗？就算找了很久找不到，这也是一种精彩的人生吧。」</p>
<p>我愣了愣。看着一旁洒进食堂的阳光，周围的嘈杂在那一刹那仿佛消失不见了；筷子掉到桌子上，发出悠长的回响，不绝于耳。</p>
<h1 id="4-27"><a href="#4-27" class="headerlink" title="4.27"></a>4.27</h1><p>总会因为奇奇怪怪的事情陷入东亚式情绪内卷…</p>
<p>感觉有很多事情都是自讨没趣。自己找来痛苦让自己承受。习惯痛苦之后，积极的生活态度反而让人感到陌生…</p>
<p>争取逐渐削弱这个内卷的过程吧。</p>
<h1 id="4-26"><a href="#4-26" class="headerlink" title="4.26"></a>4.26</h1><p>郁郁寡欢…不过山崎将义的「One more time, one more chance」里面倒是提过</p>
<blockquote>
<p>如果只是缓解寂寞，随便一个人就可以了吧。</p>
</blockquote>
<p>…我一直把这个当做信条。自己会经常期许很多不能得到的东西、不能传达的心意。如果这么想的话，可能自己会稍微好受一点吧。</p>
<p>感觉自己从未真正变得成熟过…</p>
<h1 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h1><p>我…很烦「浮躁」的感觉。如果每天不给我几分钟，让我去仔细思考一下人生，我就会感到难以入睡。</p>
<p>我才发现，虽然我很向往热烈，但是骨子里还是喜欢孤独一人的感觉。自由、不受约束。身上不需要承担那些若有若无的责任…我向往人与人之间的羁绊，但我同时也在一直回避这些。</p>
<h1 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h1><p>最近一直很忙，忙着把自己之前做过的题都复习一遍，不给自己的青春留下遗憾。</p>
<p>计数啦，刘汝佳的紫书/蓝书啦，李煜东的书啦…都是我未尽的回忆。</p>
<p>我就像一个小心翼翼的孩子，认真地找回失落的每一块拼图，笨笨地拼回原处…拼的东倒西歪，但算不上不满意。</p>
<p>就这样吧。尽我所能，把自己丢下的、落下的，一件一件拾起来。</p>
<p>但…我还没有看过远处的风景啊，现在就要准备沿途返回了吗？我不甘心的吧？</p>
<p>可能，有些人属于这里，有些人不属于这里。这有点宿命论的意味——虽然我是不信的，但你不得不说，有时候这东西似乎就是贯穿万事万物的那一条透明的线，引领着每个人走向自己的终章。</p>
<p>终章之后呢？是一片新的天地吧。</p>
<p>但…还是最好不要停下来吧。</p>
<h1 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h1><p>我被关在笼子里。</p>
<p>周围密布的…是黑色。</p>
<p>外面…似乎也套着笼子。这个机房是笼子，这栋综合楼是笼子，这个学校是笼子。</p>
<p>要继续说下去的话，这个城市，这个地区，这个世界都是笼子。似乎找不到任何一缕自由的风。</p>
<p>虽然我看不见——因为最靠近我的这个笼子已经将我的双眼层层蒙蔽。但我坚信。</p>
<p>其实我是被自己的心关起来的，我自己很清楚。</p>
<p>我不断地反复，跟自己博弈、决斗、撕扯、争吵…最终是赢了呢？还是输了呢？我只知道无论输赢，我都还是停留在这个笼子里。</p>
<p>所以，外界可能并不存在什么笼子，罩着我的只有一层笼子，其余的只是我内心积攒的恐惧而已。</p>
<p>但是…虽然自己提出了疑问，但是我依然相信外面是有笼子的、数不清的那种…</p>
<p>是的，这种寄托方式，是坚信。区分「坚信」和「迷信」的根据大概就是，坚信可以包容质疑，但是迷信从来不容置疑。</p>
<p>你看我为数不多的信念，也只能用在这种地方了吧。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】RE:从零开始的计数生活</title>
    <url>/2020/04/21/RE-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E6%95%B0%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一部分大概是整理一下自己做过的计数题？</p>
<p>感觉有很多题都很神(不)仙(会)。慢慢来吧…</p>
<p>感觉其实本质上考察的还是 dp 功底+组合技巧/能力。</p>
<p>总的来说，如果没有计数头脑(个人认为是可以练出来的)的人，遇到这种题一般要么是 <code>dfs</code>/子集枚举，要么是状压，大概是常见比赛里面 $3/5/7/10$ 这档最低的部分分…所以计数这东西如果不是天赐之才，其实是需要深入研究的吧。</p>
<p><del>等会儿，我扯这些干什么？扯这些能帮我学会计数吗？</del></p>
<a id="more"></a>
<p><del>咕咕咕咕咕，只写了题面，题解留给大家自行思考</del></p>
<h1 id="BJWC2018-最长上升子序列"><a href="#BJWC2018-最长上升子序列" class="headerlink" title="[BJWC2018]最长上升子序列"></a>[BJWC2018]最长上升子序列</h1><blockquote>
<p>现在有一个长度为 $n$ 的随机排列，求它的最长上升子序列长度的期望。$n\leq 20$ 。</p>
</blockquote>
<p>其实是把数据范围改小了，原题是个打表题233</p>
<p>考虑观察最长上升子序列的性质。记 $h_i$ 为截止到前 $i$ 位中最长上升子序列的长度，同时设 $g_{i}=\max_{j=1}^i\{h_j\}$ ，那么可以知道</p>
<script type="math/tex; mode=display">
g_{i}\leq g_{i+1}\leq g_{i}+1</script><p>发现这个序列差分之后正好是 $01$ 串，不妨设 $\{g_n\}$ 的一阶差分是 $\{d_n\}$，于是考虑对着这个东西 $dp$ 。即设 $f_{i,s}$ 表示以 $i$ 结尾的，差分序列是 $s$ 的排列数。考虑从小向大插入每个数。假设当前的 $x$ 插在原来的串的 $i$ 和 $i+1$ 之间，那么因为 $x$ 比之前任何一个数都大，那么可以知道 $h’_{i+1}=h_i+1$ ，同时假设存在某个 $k&gt;i$ 使得 $a_k$ 是第一个大于 $a_i$ 的数，那么可以知道根据差分，应该将 $d_k$ 置为 $0$ ，所以从大到小扫的时候不断更新即可。</p>
<p>于是最后复杂度 $O(2^n\cdot n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			res = (ll)res * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line"><span class="keyword">int</span> fac[N] ; </span><br><span class="line"><span class="keyword">int</span> size[M] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][M] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n ; fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)	_bit[i] = <span class="number">1</span> &lt;&lt; i ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">		size[i] = size[i -(i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//	debug(_bit, 1, n) ;</span></span><br><span class="line"><span class="comment">//	debug(size, 1, m) ; </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>, i = <span class="number">0</span> ; i &lt; n - <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> t = (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> ; </span><br><span class="line">		fill(f[d ^ <span class="number">1</span>], f[d ^ <span class="number">1</span>] + t + <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span> ; s &lt;= t ; ++ s)&#123;</span><br><span class="line">			<span class="keyword">int</span> pos = <span class="number">2333</span> ; </span><br><span class="line">			add(f[d ^ <span class="number">1</span>][s &lt;&lt; <span class="number">1</span>], f[d][s]) ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i ; k &gt;= <span class="number">0</span> ; -- k)&#123;</span><br><span class="line">				<span class="keyword">int</span> t = (s &gt;&gt; k) &lt;&lt; (k + <span class="number">1</span>) ; </span><br><span class="line">				t  |= _bit[k], t |= (_bit[k] - <span class="number">1</span>) &amp; s ; </span><br><span class="line">				<span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; s) pos = k ; </span><br><span class="line">				<span class="keyword">if</span> (pos != <span class="number">2333</span>) t ^= _bit[pos + <span class="number">1</span>] ;</span><br><span class="line">				add(f[d ^ <span class="number">1</span>][t], f[d][s]) ; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		d ^= <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">		fac[i] = (ll)i * fac[i - <span class="number">1</span>] % P ;</span><br><span class="line"><span class="comment">//	debug(fac, 1, n) ;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)</span><br><span class="line">		add(ans, (<span class="keyword">int</span>)(<span class="number">1l</span>l * f[(n - <span class="number">1</span>) &amp; <span class="number">1</span>][i] * (size[i] + <span class="number">1</span>) % P)) ;</span><br><span class="line">	ans = (ll)ans * expow(fac[n], P - <span class="number">2</span>) % P ; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AGC002-F-Left-Most-Ball"><a href="#AGC002-F-Left-Most-Ball" class="headerlink" title="[AGC002 F]Left Most Ball"></a>[AGC002 F]Left Most Ball</h1><blockquote>
<p>给你 $n$ 种颜色的球，每个球有 $k$ 个，把这 $n\times k$ 个球排成一排，把每一种颜色的最左边出现的球涂成白色(初始球不包含白色)，求有多少种不同的颜色序列，答案对 $10^9+7$ 取模。</p>
<p>$1\leq n, k\leq 2000$。</p>
</blockquote>
<h1 id="CQOI2011-放棋子"><a href="#CQOI2011-放棋子" class="headerlink" title="[CQOI2011]放棋子"></a>[CQOI2011]放棋子</h1><blockquote>
<p>在一个 $m$ 行 $n$ 列的棋盘里放一些颜色在 $1\sim c$ 之间的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列，有多少种方法？</p>
<p>$1\le n,m\le 30$，$1\le c\le 10$，总棋子数 $\le \min(250,n\times m)$。</p>
</blockquote>
<h1 id="LuoguP5241-序列"><a href="#LuoguP5241-序列" class="headerlink" title="[LuoguP5241] 序列"></a>[LuoguP5241] 序列</h1><blockquote>
<p>构建一个 $n$ 个点的有向图 G，初始没有任何边。</p>
<p>接下来构建一个长度为 E 的边的序列 A，序列中每条边都是满足 $1≤s,t≤n$ 且 $s≠t$ 的有向边 $(s,t)$，且序列中的边互不相同。按照顺序把这些边加入到 G 中，每次加入后计算当前图的强连通分量个数并记录下来，得到一个新的长度为 E 的正整数序列 B。如果两个边的序列得到的 B 相同则称它们本质相同。</p>
<p>请问有多少种本质不同的边的序列，</p>
<p>$1\leq n\leq 400$ 。</p>
</blockquote>
<h1 id="SDOI2010-地精部落"><a href="#SDOI2010-地精部落" class="headerlink" title="[SDOI2010]地精部落"></a>[SDOI2010]地精部落</h1><blockquote>
<p>传说很久以前，大地上居住着一种神秘的生物：地精。地精喜欢住在连绵不绝的山脉中。具体地说，一座长度为 $N$ 的山脉 $H$ 可分为从左到右的 $N$ 段，每段有一个<strong>独一无二</strong>的高度 $H_i$ ，其中 $H_i$ 是 $1$ 到 $N$ 之间的正整数。</p>
<p>如果一段山脉比所有与它相邻的山脉都高，则这段山脉是一个山峰。位于边缘的山脉只有一段相邻的山脉，其他都有两段（即左边和右边）。类似地，如果一段山脉比所有它相邻的山脉都低，则这段山脉是一个山谷。</p>
<p>地精们有一个共同的爱好——饮酒，酒馆可以设立在山谷之中。地精的酒馆不论白天黑夜总是人声鼎沸，地精美酒的香味可以飘到方圆数里的地方。</p>
<p>地精还是一种非常警觉的生物，他们在每座山峰上都可以设立瞭望台，并轮流担当瞭望工作，以确保在第一时间得知外敌的入侵。</p>
<p>地精们希望这 $N$ 段山脉每段都可以修建瞭望台或酒馆的其中之一，只有满足这个条件的整座山脉才可能有地精居住。</p>
<p>现在你希望知道，长度为 $N$ 的可能有地精居住的山脉有多少种。两座山脉 $A$ 和 $B$ 不同当且仅当存在一个 $i$，使得 $A_i≠B_i$。由于这个数目可能很大，你只对它除以 $P$ 的余数感兴趣。</p>
<p>对于 $100\%$ 的数据，满足 $3≤N≤4200$，$P≤10^9$。</p>
</blockquote>
<h1 id="ARC074C-RGB-Sequence"><a href="#ARC074C-RGB-Sequence" class="headerlink" title="[ARC074C]RGB Sequence"></a>[ARC074C]RGB Sequence</h1><blockquote>
<p>有一个序列 $\left\{a_{n}\right\}$，要给序列中的每个元素一种颜色：红/绿/蓝。有 $m$ 条限制 $(l,r,x)$，表示格子 $l\sim r$ 中颜色的种类数要恰好为 $x$，问可行的方案数。</p>
<p>$ 1\leq n,m\leq 300 $ 。</p>
</blockquote>
<h1 id="ARC071D-Infinite-Sequence"><a href="#ARC071D-Infinite-Sequence" class="headerlink" title="[ARC071D] Infinite Sequence"></a>[ARC071D] Infinite Sequence</h1><blockquote>
<p>定义 $n-$可爱序列 指无限长的由 $\{1,2…,n\}$ 组成的序列。同时 $a_1,a_2…$满足以下条件:</p>
<p>1.第 $n$ 个及以后的元素是相同的，即若 $\forall i,j\geq n,a_i=a_j$ 。</p>
<p>2.对于每个位置 $i$，紧随第 $i$ 个元素后的 $a_i$ 个元素是相同的，即若 $\forall  i&lt;j&lt;k≤i+a_i,a_j=a_k$。</p>
<p>输入 $n$，请输出 $n-$可爱序列的数量 $\bmod 10^9+7$ 。</p>
<p>$n\leq{10^6}$。</p>
</blockquote>
<h1 id="Luogu-P5464-缩小社交圈"><a href="#Luogu-P5464-缩小社交圈" class="headerlink" title="[Luogu]P5464 缩小社交圈"></a>[Luogu]P5464 缩小社交圈</h1><blockquote>
<p>社交圈子里有 $n$ 个人，每个人都有一个 SAN 值范围 $[l_i,r_i]$。当两个人的 SAN 值交集不为空时，这两个人有 PY 关系。</p>
<p>现在希望从社交圈子里面挑选出一些人组成一个集合 $S$，如果将所有集合内的人中有 PY 关系的那一对人都连上边，则 $S$ 刚好成为一个树（森林不行哦）。</p>
<p>请问，有多少种可以选择的方案？由于答案可能很大，请对 $10^{9}+7$ 取模。</p>
<p>$1\leq n\leq 2000,1\leq l_i,r_i\leq 4000$ 。</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>思维题/计数</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】简单题选做·第二弹</title>
    <url>/2020/04/21/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC%E4%BA%8C%E5%BC%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>感觉自己真的是菜成一团…</p>
<p>感觉自己其实是地地道道的「empiricist」而不是「innovators」，也就是自己似乎并不具有「Pioneering thinking」。但为什么，为什么我想从事的一切恰恰都需要「Pioneering thinking」呢…？</p>
<p>可能是人越缺少什么，就越向往什么吧？但是这怎么解释，我之前还不明白自己缺少什么的时候，怀抱着的对那片天空的无限憧憬呢？</p>
<p>人总是喜欢问没有答案的问题。因为求索总是让人感觉自己还切切实实活着在这个世界上啊。</p>
<p>Hide your skill from your clumsiness, make you fast in slowly.</p>
<p>本文共计 15 道题。</p>
<a id="more"></a>
<h1 id="UVA1407-Caves"><a href="#UVA1407-Caves" class="headerlink" title="UVA1407 Caves"></a><a href="https://uva.onlinejudge.org/external/14/p1407.pdf" target="_blank" rel="noopener">UVA1407 Caves</a></h1><blockquote>
<p>给定一棵 $n$ 个节点、边带权的树。$q$ 次询问，每次给定一个 $x$ ，询问从根出发走多少个点，满足走过的边权和 $&lt;x$ 且经过的点最多。点可以重复经过，但只会被计算一次。</p>
<p>$n\leq 500,q\leq 10^5,x\leq 5\cdot 10^8$ 。</p>
</blockquote>
<p>一个比较基础的思想是背包，但这时空显然不是背包能做的。这个地方考虑，点数只有 $500$，也就是至多只能走 $500$ 个点。于是就考虑把状态定义到点上，即 $f_{x,j}$ 表示以 $x$ 为根走了 $j$ 个不同的点的最小代价。注意到由于可以重复经过，所以多记一维 $0/1$ ，即 $f_{x,j,0/1}$ 表示以 $x$ 为根走了 $j$ 个不同的点，最终没回到/回到了 $i$ 的最小代价。考虑转移：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{x,j,1}&=\min_{y\in son(x),1\leq k\leq size(y)}\{f_{x,k,1}+f_{y,j-k,1}+w\times 2\} \\
f_{x,j,0}&=\min_{y\in son(x),1\leq k\leq size(y)}\{f_{x,k,1}+f_{y,j-k,0}+w,f_{x,k,0}+f_{y,j-k,1}+w\times 2\} 
\end{aligned}</script><p>其中第二个转移表达的是这条路径的终点是否在以 $y$ 为根的子树内。注意转移的时候要倒序枚举 $j$ ，保证当前转移不重复。</p>
<p>发现 $f_{root}$ 显然是单调的，于是回答询问时二分即可。复杂度 $O(n^2+q\log n)$ 。因为好像有证明，这种东西的复杂度是 $O(n^2)$ 的…</p>
<h1 id="BZOJ4160-Exclusive-Access-2"><a href="#BZOJ4160-Exclusive-Access-2" class="headerlink" title="BZOJ4160 Exclusive Access 2"></a><a href="https://darkbzoj.tk/problem/4160" target="_blank" rel="noopener">BZOJ4160 Exclusive Access 2</a></h1><blockquote>
<p>给出 $n$ 个点 $m$ 条边的无向图，定向得到有向无环图，使得最长路最短。</p>
<p>$1\leq n ≤ 15, 1\leq m ≤ 100$ .</p>
</blockquote>
<p>大概是 $\rm dilworth$ 定理的应用，考虑 $\rm dilworth$ 定理：</p>
<blockquote>
<p>令 $(X,≤)$ 是一个有限偏序集，并令 $m$ 是反链的最大长度。则 $X$ 可以被划分成 $m$ 个但不能再少的链。 即：链的最少划分数 $=$ 反链的最长长度.。</p>
</blockquote>
<p>同时也存在对偶定理：</p>
<blockquote>
<p>令 $(X,≤)$ 是一个有限偏序集，并令 $r$ 是其最长链的大小。则 $X$ 可以被划分成 $r$ 个但不能再少的反链。</p>
</blockquote>
<p>也就是：</p>
<blockquote>
<p><strong>偏序集能划分成的最少的全序集个数等于最大反链的元素个数</strong> 。</p>
</blockquote>
<p>其中「全序集」指的是这样的一个偏序集 $(Y,\leq )$ ，改偏序集内部所有元素两两<strong>均可比</strong>。反链则指的是这样一个偏序集 $(Z,\leq )$ ，改偏序集内部所有元素两两均<strong>不可比</strong>。</p>
<p>换言之，假设给原图定向，那么根据 dilworth 定理，最长链的长度就是最小的独立集的大小，其中「独立集」的定义为原无向图中距离大于 $1$ 的两个点可以组成一个独立集(不考虑连通性)，因为只要两者没有边相连，两者的关系就是「不可比」。</p>
<p>于是这东西就可以状压了。$f_{s}$ 表示 $s$ 集合中最少有多少个独立集。这东西就可以先预处理一下每个 $s$ 是否是独立集，然后 $3^n$  暴力 $dp$ 即可。</p>
<h1 id="POJ3735-Training-little-cats"><a href="#POJ3735-Training-little-cats" class="headerlink" title="POJ3735 Training little cats"></a><a href="http://poj.org/problem?id=3735" target="_blank" rel="noopener">POJ3735 Training little cats</a></h1><blockquote>
<p>现在给你一个长度为 $n$ 的序列，开始这个序列都是 0。对这个序列一共有三种操作：</p>
<p>操作 1：输入一个 $x$，把 $x$ 位置上的值 $+1$ 。</p>
<p>操作 2：输入一个 $x$ 一个 $y$，交换 $x$，$y$ 位置上的值。</p>
<p>操作 3：输入一个 $x$，把 $x$ 位置上的值变成 $0$ 。</p>
<p>我们接着对这个序列进行 $k$ 次操作。</p>
<p>我们把这 $k$ 次操作叫做一轮，现在这个 $k$ 个操作进行了 $m$ 轮。</p>
<p>输出最后的序列。</p>
<p>$1\leq n\leq 100,1\leq k\le 10^4,1\leq m\leq 10^9$ 。</p>
</blockquote>
<p>…矩阵快速幂神题 sto</p>
<p>考虑一开始把这个空的序列记作一个 $n+1$ 维向量 $A:[1,0,0\cdots,0]$ 。其中第一维留空赋值为 $1$ ，$2\sim n+1$ 分别代表序列的第 $1\sim n$ 号元素。</p>
<p>那么考虑由于 $m$ 比较大，但是每次操作都是一样的，于是启发要用矩阵快速幂。</p>
<p>考虑三个操作，以下默认右乘转移矩阵 $T$ 、位置 $p,q$ 都是原序列右移一位的位置。</p>
<p>1、位置 $p$ 的数 $+1$ 。</p>
<p>考虑对于 $n+1$ 阶单位矩阵</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&0&0&\cdots &0\\ 0&1&0&\cdots&0 \\ 0&0&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>考虑如何使得乘上这个矩阵的某个变形之后，位置 $p$ 实现 $+1$ 。考虑矩阵运算的本质是 $c_{i,j}=\sum_{k}a_{i,k}\cdot b_{k,j}$ ，那么 $A’_{1,p}=\sum _{i=1}^{n+1}A_{1,i}\cdot T_{i,p}$ ，因为 $A_{1,1}$ 恒定为 $1$ ，所以可知应该让 $T_{1,p}=1$ 实现 $+1$ 的功能。比如 $p=2$ ：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&0&1&\cdots &0\\ 0&1&0&\cdots&0 \\ 0&0&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>2、交换位置 $p,q$ 的数。</p>
<p>还是考虑 $n+1$ 阶单位矩阵。观察矩阵乘法本质，$A’_{1,q}=\sum_{i=1}^{n+1}A_{1,i}T_{i,q}$ ，那么一方面要让之前 $q$ 位置的数消失，一方面又要让 $A’_{1,q}=A_{1,p}$ ，于是应该让 $T_{q,q}=0,T_{p,q}=1$ 。 即如果 $p=1,q=2$ ，则应该是：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&0&0&\cdots &0\\ 0&0&1&\cdots&0 \\ 0&1&0&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>3、位置 $p$ 的数清零。</p>
<p>…$T_{p,p}=0$ 就好了。</p>
<p>注意到上面都是单独进行一个操作的情况。如果出现多个操作冗杂在一起，那么一方面可以建 $k$ 个转移矩阵，每次新的转移矩阵要乘上之前的矩阵，这样复杂度就是 $O(n^3k+n^3\log m)$ 。有点爆炸。</p>
<p>注意到可以把这 $k$ 次操作都放到一个转移矩阵里面，第 $2,3$ 操作就要相应发生改变，$2$ 操作就需要对换 $T$ 的 $p$ 列和 $q$ 列，$3$ 操作则需要把 $p$ 这一列全部清零。这样复杂度就是 $O(nk+n^3\log m)$ 了， 可以通过本题。</p>
<p>但其实 $n$ 可以出到 $2000$。注意到本题中最多只有 $O(n)$ 个不为零的位置。所以只需要对这些位置做矩阵乘法即可。复杂度变成了 $O(nk+n^2\log m)$ 。</p>
<p>哦，poj 上多组数据，那没事了（</p>
<h1 id="UVA1437-String-painter"><a href="#UVA1437-String-painter" class="headerlink" title="UVA1437 String painter"></a><a href="https://www.luogu.com.cn/problem/UVA1437" target="_blank" rel="noopener">UVA1437 String painter</a></h1><blockquote>
<p>给定一个串 $s$ 和一个目标串 $t$。每次可以将 $s$ 的连续一段刷成一个同一个字符。求最少多少次操作使得 $s$ 变成 $t$ 。</p>
<p>$1\leq |s|,|t|\leq 500$ 。</p>
</blockquote>
<p>一开始的错误思路：考虑如果两个对应位置的字符相同，那么就可以把这对字符删掉不需要管，剩下的 $s$ 就可以看做空串。对这个进行 $dp$ ，$f_{i,j}$ 表示刷好了区间 $[i,j]$ 内字符的最小代价，每次转移考虑如果 $i$ 和 $j$ 相同就从 $f_{i+1,j}$ 或者 $f_{i,j-1}$ 转移过来之类的…反正很乱很乱很乱…</p>
<p>写了一发之后发现挂了。理了理思路，发现首先有个错误的点，即不一定「删掉不管」是最优的，可能相同的字符会先被覆盖然后再涂上。所以这个思路本来就是错的。之后再考虑，以 $1$ 为步长转移本身没有道理，因为转移时枚举一个子状态，要枚举一个可能存在的确定量。</p>
<p>所以设 $f_{i,j}$ 表示一个空串的 $[l,r]$ 刷成 $t[l…r]$ 的最少代价。转移时考虑枚举一个和 $l$ 或 $r$ 同色的端点 $k\in[l,r]$ 分成两个子问题即可。之后考虑如何把 $s$ 刷成 $t$ 。设 $g_i$ 表示 $s[1…i]$ 刷成 $t[1…i]$ 的最小代价。考虑比起一个空串，$s$ 中可能存在某些与 $t$ 对应相等的位置。这时只要 <code>chkmax(g[i], g[i - 1])</code> 即可。为了保证转移全面，直接枚举断点转移即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[i][i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt; n ; ++ len)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - len ; ++ i)&#123;</span><br><span class="line">		j = i + len ; f[i][j] = f[i][j - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = i ; k &lt;= j - <span class="number">1</span> ; ++ k)</span><br><span class="line">			<span class="keyword">if</span> (t[j] == t[k]) </span><br><span class="line">				chkmin(f[i][j], f[k + <span class="number">1</span>][j - <span class="number">1</span>] + f[i][k]) ;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">	g[i] = f[<span class="number">1</span>][i] ;</span><br><span class="line">	chkmin(g[i], s[i] == t[i] ? g[i - <span class="number">1</span>] : P) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= i ; ++ k)</span><br><span class="line">		chkmin(g[i], g[k - <span class="number">1</span>] + f[k][i]) ; </span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">//为什么总是学不会？</span></span><br></pre></td></tr></table></figure>
<h1 id="UVA1427-Parade"><a href="#UVA1427-Parade" class="headerlink" title="UVA1427 Parade"></a><a href="https://www.luogu.com.cn/problem/UVA1427" target="_blank" rel="noopener">UVA1427 Parade</a></h1><blockquote>
<p>有一个由 $n+1$ 条横向路和 $m+1$ 条竖向路构成的网格图，每条横向路有一个高兴值和经过的时间。</p>
<p>现在想从网格的最下方走到最上方，求能得到的最大的高兴值是多少。</p>
<p>走路有限制：不能多次经过同样的路，也不会从下往上走。另外，在每条横向路上所花的时间不能超过 $k$ 。</p>
<p>$1\leq n\leq 100,1\leq m\le 10^4$ 。</p>
</blockquote>
<p>一开始想的是直接暴力 $dp$，枚举每一行的每个出发点(即从上一行转移过来的点)，考虑向左走一定是走一个包含当前点的最大子段和，向右也是。然后一开始觉得这个思路很有道理，但有点疑惑：我把 $n$ 和 $m$ 读反了，导致我以为这个做法是 $n^2m$ 没准可以卡过去的…后来发现是 $m^2n$ …虽然 $n^2m$ 也必定过不去就是了。</p>
<p>后来想了想，大概可以定义一个比较靠谱的状态。$f_{i,j}$ 表示到达了 $(i,j)$ 的最大高兴值。那么每次转移可以定向，从右边或者从左边。注意到由于存在 $k$ 的限制，决策区间具有单调性。所以可以用单调队列优化掉一个 $m$ 。</p>
<p>好像很简单的样子…但是不能一眼 A 就是罪过吧…</p>
<h1 id="UVA11795-Mega-Man’s-Mission"><a href="#UVA11795-Mega-Man’s-Mission" class="headerlink" title="UVA11795 Mega Man’s Mission"></a><a href="https://www.luogu.com.cn/problem/UVA1427" target="_blank" rel="noopener">UVA11795 Mega Man’s Mission</a></h1><blockquote>
<p>洛克人最初只有一种武器 “Mega Buster”（这种武器可以消灭特定的一些机器人），你需要按照一定的顺序消灭 n 个其他机器人。每消灭一个机器人你将会得到他的武器（也可能没有得到武器），而这些武器可以消灭特定的机器人。你的任务是计算出消灭所有机器人的<strong>顺序总数</strong>。注意：一个机器人的武器可能可以消灭自己，但这对最终答案没有影响，因为必须先消灭这个机器人才能够得到他的武器。</p>
<p>$1\leq n\leq 16$ 。</p>
</blockquote>
<p>其实是很水的题…只是记录一个坑点。遇到这种求顺序总数的时候，我大脑总会选择性宕机…准确来说，显然这题是要预处理一个 $g_s$ 表示杀死 $s$ 中的怪物后可以获得那些武器。然后考虑 $f_s$ 表示杀死 $s$ 中的怪兽的顺序总数。对于 $f$ 的转移，我一开始是想的是要首先枚举每个元素，再去枚举这个元素第几个出现合法，但是这就需要再记一个其他元素的顺序，然后就爆炸了。</p>
<p>这也反映了自己并没有理解认真理解 $dp$ 子问题重叠的本质。考虑如何简化子问题。发现无论以什么顺序转移，最后一个加进去的元素是固定的(感性理解)。或者换句话说我们并不关心某个元素 $x$ 在集合内第几个出现，这些状态都可以合并到集合较小时 $x$ 最后一个加入的状态。所以只需要枚举最后一个元素+判断合法性即可。</p>
<p>菜成一坨，GGGGGGGGG。</p>
<h1 id="UVA1625-Color-Length"><a href="#UVA1625-Color-Length" class="headerlink" title="UVA1625 Color Length"></a><a href="https://uva.onlinejudge.org/external/16/p1625.pdf" target="_blank" rel="noopener">UVA1625 Color Length</a></h1><blockquote>
<p>输入两个长度分别是 $n$ 和 $m$ 的颜色序列，要求按顺序合并成同一个序列，即每次可以把一个序列开头的颜色放到新序列的尾部。</p>
<p>记 $L(c)$ 为关于颜色 $c$ 和合并之后的排列的一个函数，定义如下：</p>
<script type="math/tex; mode=display">
L(c)=\max_{p\in[1,n+m]\cap \mathbb{Z_+}}\{p~|~color(p)=c\} - \min_{p\in[1,n+m]\cap \mathbb{Z_+}}\{p~|~color(p)=c\}</script><p>你的任务是找一种合并方式，使得所有 $L(c)$ 的总和最小。</p>
<p>$1\leq n,m\leq 5000$ 。</p>
</blockquote>
<p>考虑朴素的状态当然是 $f_{i,j}$ 表示 $A$ 合并到位置 $i$，$B$ 合并到位置 $j$ 的最小总和…等下，似乎这东西并不可以很好的转移，因为考虑对于每个前驱状态，并不是很好记录每个颜色第一出现的位置，同时也不好维护最后出现的位置，根本没法转移。</p>
<p>考虑一个 trick，提前计算贡献。即虽然其余的都很麻烦，但是可以比较方便地知道有哪些颜色一定没有合并完。所以可以每次转移时，计算还没有合并完的贡献。这样做本质上是把贡献分摊到每个元素上面。因为考虑这种转移，对于每个终止状态，并不关心前面代价转移的形式，只关心代价转移的结果。</p>
<p>于是就预处理一个 $g_{i,j}$ 表示 $A$ 合并到位置 $i$，$B$ 合并到位置 $j$ 时有多少个字母还没有闭合。剩下的 $nm$ 转移即可。</p>
<h1 id="UVA1218-Perfect-Service"><a href="#UVA1218-Perfect-Service" class="headerlink" title="UVA1218 Perfect Service"></a><a href="https://onlinejudge.org/external/12/p1218.pdf" target="_blank" rel="noopener">UVA1218 Perfect Service</a></h1><blockquote>
<p>一个网络中有 $n$ 个节点，由 $n-1$ 条边连通，每个节点是服务器或者客户端。如果节点 $u$ 是客户端，就意味着 $u$ 所连接的所有点中有且仅有一台服务器。求最少要多少台服务器才能满足要求。</p>
<p>$1\leq n\leq 10^6$ 。</p>
</blockquote>
<p>这题比较水，主要是整理一下，给自己提个醒。如果设 $f_{x,0/1}$ 表示 $x$ 当根不选/选自己的话，注意到会出现 $f_{son_x,0}$ 没法转移到 $f_{x,1}$ 这种情况，因为不知道 $son_{son_x}$ 选没选。这种定义状态的方式就过于模糊。</p>
<p>于是考虑因为难以记儿子，所以记父亲。$f_{x,0/1/2}$ 分别表示「$x$ 和 $fa_x$ 都没选」、「$x$ 选了 $fa_x$ 不管(因为选不选都不引起冲突)」、「$x$ 没选 $fa_x$ 选了」，于是就是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{x,0}&=\min_{y\in son(x)}\{f_{y,1}+\sum_{z\in son(x),z\not=y} f_{z,0}\}\\
f_{x,1}&=1+\sum_{y\in son(x)} \min\{f_{y,1}+f_{y,2}\} \\
f_{x,2}&=\sum_{y\in son(x)} f_{y,0} 
\end{aligned}</script><p>注意到，其中 $f_{x,1}$ 这个状态，本质上是两个状态的合并。可以考虑分裂成 $f_{x,3/4}$ 表示 $x$ 选了 $fa_x$ 选没选，发现被转移的时候，两者转移是一样的。所以就可以简并成一个状态。</p>
<h1 id="UVA12099-The-Bookcase"><a href="#UVA12099-The-Bookcase" class="headerlink" title="UVA12099 The Bookcase"></a><a href="https://uva.onlinejudge.org/external/120/p12099.pdf" target="_blank" rel="noopener">UVA12099 The Bookcase</a></h1><blockquote>
<p>有 $n$ 本书，每本书有一个高度 $h_i$ 和一个宽度 $w_i$。 现在要构建一个 $3$ 层的书架，你可以选择将 $n$ 本书放在书架的哪一层。设 $3$ 层高度(每层书的最大高度)之和为 $h$，书架总宽度为 $w$，要求 $h×w$ 尽量小。</p>
<p>$3\le n\leq 70,1\leq h_i\leq 300,1\leq w_i\le 30$ 。</p>
</blockquote>
<p>本质上是要最优化两样东西，宽度和高度。所以不妨让其中一个变得有序，所以考虑先按照 $h_i$ 把所有书降序排序。</p>
<p>考虑如何设计状态。发现如果某一层有最高的那本书，那么无论怎么放书，这一层的高度都不会再受影响；同时，把每一层的高度和宽度都记下来是没有必要的，于是可以记某一维为某个确切数值时另一维的最小值。具体的，$f_{i,j,k}$ 表示考虑了前 $i$ 本书，第二层的宽度为 $j$，第三层宽度为 $k$ 时，第二层、第三层的最小高度和。此处记宽度为状态是因为一方面高度和宽度是对称的，另一方面宽度的数据范围显然比高度要小。</p>
<p>考虑转移。首先应该定一个顺序，比如第二层高度应该大于第三层，那么此时转移有：</p>
<script type="math/tex; mode=display">
f_{i,j,k}=\min\{f_{i-1,j,k}~,~f_{i-1,j-w_{i},k}+[j-w_i=0]\cdot h_i~,~f_{i-1,j,k-w_{i}}+[k-w_i=0]\cdot h_i\}</script><p>其中第三个决策当且仅当第二层已经有了一本书。</p>
<p>考虑这样 $dp$ 的复杂度，似乎是 $O(n\cdot \left(\sum w_i\right)^2)$ ，有点爆炸。考虑如何剪枝：</p>
<p>1、$j+k\leq \sum_{t=1}^iw_t$ 。</p>
<p>2、$\sum_{t=1}^iw_t-j-k+30\geq j,j+30\geq k$。</p>
<p>其中第一可行性个比较好理解，第二个最优性剪枝是在说，因为 $\max\{w_i\}\leq 30$，所以如果高层的宽度比低层的宽度 $+30$ 还要大，那么不妨将几本书放到低层，可知这样放一定不会使结果更劣。</p>
<p>这么一波剪枝之后似乎就跑的飞快了…似乎是要滚一下第一维的样子。</p>
<p>大概转移and初始赋值这些会有一点细节的样子吧。</p>
<h1 id="UVA10559-Blocks"><a href="#UVA10559-Blocks" class="headerlink" title="UVA10559 Blocks"></a><a href="https://uva.onlinejudge.org/external/105/p10559.pdf" target="_blank" rel="noopener">UVA10559 Blocks</a></h1><blockquote>
<p>有 $n$ 个带有颜色的方块，没消除一段长度为 $x$ 的连续的相同颜色的方块可以得到 $x^2$ 的分数，让你用一种最优的顺序消除所有方块使得得分最多。</p>
<p>$1\leq n\leq 200$ 。</p>
</blockquote>
<p>大概是比较神仙的 $dp$ 了吧…</p>
<p>第一感觉肯定就是 $f_{l,r}$ 嘛，但是这么做的话本质上就变成贪心了，因为可能转移时，$f_{l,k}$ 和 $f_{k,r}$ 是消掉中间一部分，再合并起来的模式。注意到，对于一段 $i,j$，假设 $i&lt;q&lt;j$ 满足 $q\sim j$ 同色，$i&lt;o&lt;p&lt;q$ 满足 $o\sim p$ 与 $q\sim j$ 同色，那么一种决策就是把这两段合并。但是注意到可能还会存在一个区间 $i&lt;s&lt;t&lt;o$ 满足 $s\sim t$ 和 $o\sim p$ 同色。</p>
<p>于是这就启发(个鬼，这怎么可能想得出来)要多记一维状态 $d$，即 $f_{l,r,d}$ 表示 $l\sim r$ 的这段区间内，区间右侧还有 $d$ 个元素和 $r$ 同颜色时的最大得分。这样每次就以「和右端点颜色相同的颜色段」为子决策进行转移。那么需要枚举每次有多少个块和右端点一起删掉，在这基础枚举一个和右端点同色的、靠左的点进行转移，表示右端点所在的同色段暂时先不删，加入继续向左延伸的长同色段的一部分。</p>
<p>复杂度的话，状态是 $O(n^3)$ 的，然后我这种写法好像很迷幻，<del>我觉得应该是 $n^5$ 但不知道为什么测出来极限数据(即所有颜色都相同)时运算量在 $n^4$ 量级</del>  …剪枝是要剪的，每次只关心和 $r$ 同色的元素就好了。</p>
<p>好的，我又重新写了一下测了一下，觉得应该把访问记忆化结果也算 $1$ 次运算。发现 $100$ 个相同的颜色放在一起，这么写的运算量大概是 $258712510\approx2.6\cdot 10^8$，大概 $1s$ 内是可以跑出来结果的(uoj custom test 900ms左右)。$200$ 个颜色相同的就已经是紫荆花之恋那题跑不出来的程度了(即 $14s$ 以内跑不出来，只能本地测试)，似乎足足要 $1\min+$，大概是 $8136350020\approx8\cdot 10^9$ 的运算量<del>中间可执行文件还一度被系统给 kill 掉了</del> 。</p>
<p>然后…然后我就加了一个好像很牛逼的剪枝，大概就是判断一下 $l\sim r$ 这一整段是不是同色，如果是的话就直接算完了返回即可。发现这样之后极端数据就应该是只有两种颜色然后左右交替这种，就可以在 $370\sim400ms$ 左右跑出来<del>但似乎应该还是过不了，因为极限可以有15组数据，每组都这个速度肯定跑不进3s鸭</del>。</p>
<p>然后发现这个某个区间是否同色可以预处理，然后就预处理了一下，发现一组快的话只需要 $320ms$ 左右了…</p>
<p>然后又改了一下，发现可以稍微贪一下，「枚举每次有多少个块和右端点一起转移走」显然是最大的那个快最好了。但这并没有快…</p>
<p>删了点重复计算和冗杂判断…发现大概是稳定在 $320ms$ 左右了…</p>
<p>…发现自己是个弟弟，如果要把右边和左边合并的话，那肯定是全都一起合并最优。所以现在大概是真正的 $O(n^4)$ 算法了？一组大概是 $200ms$ 左右了…人艰不拆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本1 最大点 400ms</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = r, j = lst[r] ; i &gt;= l ; j = lst[j], i = lst[i])</span><br><span class="line">		<span class="keyword">if</span> (i != j + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ; </span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (check(l, r)) <span class="keyword">return</span> f[l][r][t] = (t + r - l + <span class="number">1</span>) * (t + r - l + <span class="number">1</span>) ;<span class="comment">//剪枝 1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= l &amp;&amp; base[i] == base[r] ; -- i)&#123;</span><br><span class="line">		chkmax(f[l][r][t], solve(l, i - <span class="number">1</span>, <span class="number">0</span>) + (t + r - i + <span class="number">1</span>) * (t + r - i + <span class="number">1</span>)) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = lst[i] ; j &gt;= l ; j = lst[j])</span><br><span class="line">			<span class="keyword">if</span> (base[j] == base[r]) </span><br><span class="line">				chkmax(f[l][r][t], solve(j + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, r - i + <span class="number">1</span> + t)) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本2 最大点 320- ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (g[r] &lt;= l) <span class="keyword">return</span> f[l][r][t] = (t + r - l + <span class="number">1</span>) * (t + r - l + <span class="number">1</span>) ;</span><br><span class="line">	chkmax(f[l][r][t], solve(l, g[r] - <span class="number">1</span>, <span class="number">0</span>) + (t + r - g[r] + <span class="number">1</span>) * (t + r - g[r] + <span class="number">1</span>)) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= g[r] ; -- i)&#123;</span><br><span class="line">		<span class="keyword">register</span> <span class="keyword">int</span> pq = t + r - i + <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = lst[i] ; j &gt;= l ; j = lst[j])</span><br><span class="line">			chkmax(f[l][r][t], solve(j + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, pq)) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ; Q = T ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		n = qr() ;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">		<span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">		<span class="built_in">memset</span>(lst, <span class="number">0</span>, <span class="keyword">sizeof</span>(lst)) ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, Q - T) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			lst[i] = buc[base[i] = qr()], buc[base[i]] = i ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">				<span class="keyword">if</span> (base[i] == base[j]) g[i] = j ; <span class="keyword">else</span> <span class="keyword">break</span> ; </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; solve(<span class="number">1</span>, n, <span class="number">0</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本3 200- ms 左右 此时根本不需要判整段是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line">	<span class="comment">//if (g[r] &lt;= l) return f[l][r][t] = (t + r - l + 1) * (t + r - l + 1) ;</span></span><br><span class="line">	chkmax(f[l][r][t], solve(l, g[r] - <span class="number">1</span>, <span class="number">0</span>) + (t + r - g[r] + <span class="number">1</span>) * (t + r - g[r] + <span class="number">1</span>)) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = lst[g[r]] ; j &gt;= l ; j = lst[j])</span><br><span class="line">		chkmax(f[l][r][t], solve(j + <span class="number">1</span>, g[r] - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, (t + r - g[r] + <span class="number">1</span>) )) ;</span><br><span class="line">	<span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="UVA1380-A-Scheduling-Problem"><a href="#UVA1380-A-Scheduling-Problem" class="headerlink" title="UVA1380 A Scheduling Problem"></a><a href="https://onlinejudge.org/external/13/p1380.pdf" target="_blank" rel="noopener">UVA1380 A Scheduling Problem</a></h1><blockquote>
<p>给定一棵树，pks把其中某些边改成了有向边。现在要求把所有边都改成有向边，求最长链的长度最小值。</p>
<p>$1\leq n\leq 200$ 。</p>
</blockquote>
<p>考虑首先，对于这种带方向性的计算链长，在树上一般都是要分成两部分做。于是不妨令 $f_i$ 表示从 $i$ 开始，到 $i$ 子树中的某个点结束的最长链，令 $g_i$ 表示到 $i$ 结束，起点是子树内某个点的最长链。然后开始分类讨论，设当前点为 $x$ ：</p>
<p>1、如果对于某个 $x$ ，该点与所有儿子的连边均为有向边，那么：</p>
<p>那么就是比较朴素的转移。</p>
<script type="math/tex; mode=display">
f_{x}=1+\max_{y\in son(x)}\{f_{y}\cdot [\exists(x,y),x\to y]\}\\g_{x}=1+\max_{y\in son(x)}\{g_{y}\cdot [\exists(y,x),y\to x]\}\\</script><p>2、如果存在某个 $y\in son(x)$ ，$(x,y)$ 是无向边，那么： </p>
<p>那自然是再分类讨论这条边重定向成 $x\to y$ 还是 $y\to x$ 。但…这样做毕竟是 $2^{\mathrm{count}(son(x))}$ 的，如果一棵树全都是无向边那人就没了。</p>
<p>考虑观察一点更深刻的性质。发现如果对于某个 $y$ ，被定向成了 $y\to x$ ，那么考虑对于其他 $g_z&lt;g_y$ 的 $(x,z)$ 未定向的 $z\in son(x)$ ，一定是要定向成 $z\to x$ 的。原因是，定向成 $z\to x$ 对当前没有任何贡献，因为边不带权，且 $y$ 转移过来一定更优；同时 $z\to x$ 对另一边的 $f$ 的转移没有任何贡献。综上，这样做一定不会使得结果更劣。</p>
<p>那么就可以考虑，一开始用 <code>vector&lt;int&gt;</code> 将所有无向边连接的儿子给 <code>push_back</code> 进来。对于 $f$ 和 $g$ 分别处理。这个地方需要注意到题目中有个定理：</p>
<blockquote>
<p>假如 $\rm G$ 是一棵树，那么需要的天数是 $k$ 或 $k+1$ 。$k$ 满足：$k$ 是 $\rm G$ 中所有链中一条链能包含的最多顶点数。</p>
<p>链的定义：在一条路径 $ P=(x_1, x_2, …, x_k)$中 ，对于任意的 $i=1,2,…,k-1$，总有一条从 $x_i$ 指向 $x_{i+1}$ 的有向边。</p>
</blockquote>
<p><del>但其实这个定理也可以没有用。因为只需要在外层套一个二分就好了。</del>·</p>
<p>这提示我们只关心最长链是否 $&gt;k$，而不关心是否真的被最小化了。也就是说，我们致力于保证 $f$ 和 $g$ 是最优的，但是不用考虑 $f$ 和 $g$ 怎么合并——因为这个地方，可能会出现最优化 $g$ 和 $f$ 的时候，对于一条无向边被用了两次。但这并不重要，因为可能存在这么一个局面， $f_x$ 此时没有被最优化，$g_x$ 也没有被最优化，但是 $f_x+g_x\leq k$ 并且两者的决策不相交——这就可以保证至少在 $x$ 这里 $k$ 是合法的。那么就考虑在排完序扫两遍的过程中记录贡献即可。</p>
<p>注意一个问题，由于这个状态记录的不是子树的最大值(当然也可以多记一个这个)，所以如果中有以某点为根，路径长度 $&gt;k$ 的，需要将这个信息向上传导。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_in</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v ; <span class="keyword">char</span> w ;</span><br><span class="line">	res = cnt = ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ; n = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)) ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; u)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> ret ;</span><br><span class="line">        ret = <span class="number">1</span>, n = <span class="built_in">std</span> :: max(u, n) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%c"</span>, &amp;v, &amp;w) &amp;&amp; v)&#123;</span><br><span class="line">            fa[v] = u ; n = <span class="built_in">std</span> :: max(n, v) ;</span><br><span class="line">            <span class="keyword">if</span> (w == <span class="string">'d'</span>) add_e(u, v, <span class="number">2</span>), add_e(v, u, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w == <span class="string">'u'</span>) add_e(u, v, <span class="number">1</span>), add_e(v, u, <span class="number">2</span>) ;</span><br><span class="line">            <span class="keyword">else</span> add_e(u, v, <span class="number">0</span>), add_e(v, u, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    ans = <span class="built_in">std</span> :: max(ans, len) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa &amp;&amp; val(k) == <span class="number">2</span>) dfs(to(k), x, len + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">const</span> <span class="keyword">int</span> &amp; y)</span></span>&#123; <span class="keyword">return</span> f[x] &lt; f[y] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">const</span> <span class="keyword">int</span> &amp; y)</span></span>&#123; <span class="keyword">return</span> g[x] &lt; g[y] ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; x &lt;&lt; '\n' ;</span></span><br><span class="line">    f[x] = g[x] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> F, G, df, dg ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!do_dp(to(k), x)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!val(k)) son[x].p_b(to(k)) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val(k) &gt; <span class="number">1</span>)</span><br><span class="line">                 f[x] = <span class="built_in">std</span> :: max(f[x], f[to(k)] + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">else</span> g[x] = <span class="built_in">std</span> :: max(g[x], g[to(k)] + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    F = f[x] ; G = g[x] ;</span><br><span class="line">	<span class="keyword">if</span> (son[x].empty()) <span class="keyword">return</span> (<span class="keyword">bool</span>)(F + G &lt;= ans) ;</span><br><span class="line">    f[x] = ans + <span class="number">1</span> ; suf[son[x].size()] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">std</span> :: sort(son[x].begin(), son[x].end(), comp_f) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = son[x].size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">        suf[i] = <span class="built_in">std</span> :: max(suf[i + <span class="number">1</span>], g[son[x][i]]) ;</span><br><span class="line"><span class="comment">//	debug(suf, 0, n) ;</span></span><br><span class="line">	<span class="keyword">if</span> (F + suf[<span class="number">0</span>] + <span class="number">1</span> &lt;= ans) f[x] = F ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[x].size() ; ++ i)&#123;</span><br><span class="line">        dg = <span class="built_in">std</span> :: max(G, suf[i + <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">        df = <span class="built_in">std</span> :: max(F, f[son[x][i]] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (df + dg &lt;= ans) f[x] = <span class="built_in">std</span> :: min(f[x], df) ;</span><br><span class="line">	&#125;</span><br><span class="line">    g[x] = ans + <span class="number">1</span> ; suf[son[x].size()] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">std</span> :: sort(son[x].begin(), son[x].end(), comp_g) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = son[x].size() - <span class="number">1</span> ; i &gt;= <span class="number">-1</span> ; -- i)</span><br><span class="line">        suf[i] = <span class="built_in">std</span> :: max(suf[i + <span class="number">1</span>], f[son[x][i]]) ;</span><br><span class="line"><span class="comment">//	debug(suf, 0, n) ;</span></span><br><span class="line">	<span class="keyword">if</span> (G + suf[<span class="number">0</span>] + <span class="number">1</span> &lt;= ans) g[x] = G ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[x].size() ; ++ i)&#123;</span><br><span class="line">        df = <span class="built_in">std</span> :: max(F, suf[i + <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">        dg = <span class="built_in">std</span> :: max(G, g[son[x][i]] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span>(df + dg &lt;= ans) g[x] = <span class="built_in">std</span> :: min(g[x], dg) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; x &lt;&lt; " " &lt;&lt; F &lt;&lt; " " &lt;&lt; G &lt;&lt; " " &lt;&lt; f[x] &lt;&lt; " " &lt;&lt; g[x] &lt;&lt; '\n' ;</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">bool</span>)(f[x] &lt;= ans || g[x] &lt;= ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (read_in())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!fa[i]) root = i ;</span><br><span class="line">			dfs(i, <span class="number">0</span>, <span class="number">0</span>) ; son[i].clear() ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; to(i) &lt;&lt; " " &lt;&lt; val(i) &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        res = do_dp(root, <span class="number">0</span>) ; <span class="comment">//return 0 ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; f[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//      for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">//			if (f[i] + g[i] &gt; ans)&#123; res = 1 ; break ; &#125;</span></span><br><span class="line"><span class="comment">//			cout &lt;&lt; i &lt;&lt; " " &lt;&lt; f[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (res ? ans + <span class="number">1</span> : ans + <span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="UVA12170-Easy-Climb"><a href="#UVA12170-Easy-Climb" class="headerlink" title="UVA12170 Easy Climb"></a><a href="https://uva.onlinejudge.org/external/121/p12170.pdf" target="_blank" rel="noopener">UVA12170 Easy Climb</a></h1><blockquote>
<p>给出一堆山的高度 $h_i$ ，给定一个数 $d$ 。除了 $h_1,h_n$ 之外，可以任意修改山的高度，设改完之后山的高度是 $h’$，那么修改的代价是 $|h-h’|$ 。求使得任意两座相邻山峰的之间高度差得绝对值不超过 $d$ 的最小修改代价。</p>
<p>$1\leq n\leq 100,0\leq h_i\leq 10^9$ 。</p>
</blockquote>
<p><del>orz又是性质题，好烦啊怎么一直不会</del></p>
<p>考虑暴力怎么做。$f_{i,v}$ 表示把 $i$ 改成了 $v$ 后前 $i$ 座山彼此之间合法的最小代价和。你发现这个 $v$ 大概是没法直接转移的…</p>
<p>于是考虑一个深刻的性质。对于一个 $1&lt;i&lt;n$ ， $h_i$ 一定会被改成 $\max\{h_{i-1},h_{i+1}\}-d$ 或者 $\min\{h_{i-1},h_{i+1}\}+d$ 两者之一，如果一开始就满足性质就不用改，否则如果不满足就一定要去凑最近那个边界。类似的，考虑如果 $h_i ‘=h_{i+1}+d$ ，那么 $h_{i+1}’$ 就应该是关于 $h_{i}’$ 或者 $h_{i+2}$ 的一个带有常数个 $\mp d$ 的答案。那么这也就证明了，最终每座山都会变成某个 $h_p+q\cdot d$ 的形式，其中 $p\in [1,n]\cap\mathbb{Z_+}$，$q\in[-n,n]\cap\mathbb Z$ 。那么状态数就变成了 $O(n)\cdot O(n^2)=O(n^3)$ 个。考虑转移：</p>
<script type="math/tex; mode=display">
f_{i,x}=|x-h_i|+\min\{f_{i-1,y}\} \quad (x-d\leq y\leq x+d)</script><p>发现可以对 $x$ 这一维用单调队列。于是复杂度 $O(n^3)$ 。如果实现不精细可能会多一个 $\log$ 。注意到可以一开始把所有可能的 $x$ 值排序后存起来，这样就可以避免 <code>map</code> 或者 <code>set</code> 的滥用。</p>
<h1 id="UVA1228-Integer-Transmisson"><a href="#UVA1228-Integer-Transmisson" class="headerlink" title="UVA1228 Integer Transmisson"></a><a href="https://uva.onlinejudge.org/external/12/p1228.pdf" target="_blank" rel="noopener">UVA1228 Integer Transmisson</a></h1><blockquote>
<p>在一个仿真网络中传输一个 $n$ 比特的非负整数 $k$。各比特从左到右传输，第 $i$ 个比特的发送时刻为 $i$ 。每个比特的网络延迟总是为 $0\sim d$ 之间的整数(因此从左到右第 $i$ 个比特的到达时刻为 $i\sim i+d$ 之间)。若同时有多个比特到达，实际收到的顺序任意。</p>
<p>求实际收到的整数有多少种 ，以及它们的最小值和最大值。</p>
<p>例如，$n=3$，$d=1$，$k=2$ (二进制为<code>010</code>)实际收到的整数的二进制可能是 <code>001</code>(1)，<code>010</code>(2) 和 <code>100</code>(4)。</p>
<p>$1\leq n\leq 64,0\leq d\leq n,0\leq k\leq 2^n $。</p>
</blockquote>
<p>最小值和最大值都显然可以贪心。考虑求方案数。比较直接的想法就是设 $f_{i,j}$ 表示考虑前 $i$ 个 $0$ 和前 $j$ 个 $1$ 后，组成整数的方案数。但是转移并不知道要怎么转移，因为可能上一个 $0/1$ 的出现时间不确定，导致无法判定当前在整个数最右边插入 $0/1$ 是否合法。</p>
<p>然后就需要洞见一个比较深刻的性质了。考虑如果希望凑出某个数 $w$ ，那么对于任意时刻，最右边那位(指被收到的最右边那一位)必然可以<strong>没有延迟</strong> 。因为即使延迟了，结果也不会更优（即也不会存在没延迟拼不出来，只有延迟才能拼出来的情况）。证明的话比较简单，因为「若同时有多个比特到达，实际收到的顺序任意」，所以如果某个比特延后至 $&gt;$ 最右边的数接收的时间，就可以调整成等于然后重排。</p>
<p>于是就可以知道，假设第 $i$ 位的发送时间是 $t_i$，那么考虑如何从 $f_{i,j}$ 转移到 $f_{i+1,j}$ 和 $f_{i,j+1}$ 。观察到本质上是要求插入一个新的 $1$ 或者新的 $0$ 。那么考虑假设第 $i+1$ 个 $0$ 的发送时间是 $t_0$ ，第 $j+1$ 个 $1$ 的发送时间是 $t_1$ ，那么如果为了让 $0$ 能够被尽早接收到，就需要满足 $t_0\leq t_1+d$ ，同理如果是想要 $1$ 能够尽量早到，就需要 $t_1\leq t_0+d$ 。于是转移时判断一下即可。复杂度 $O(n^2)$ 。</p>
<p><del>代码懒得写了</del></p>
<h1 id="UVA1628-Pizza-Delivery"><a href="#UVA1628-Pizza-Delivery" class="headerlink" title="UVA1628 Pizza Delivery"></a><a href="https://onlinejudge.org/external/16/p1628.pdf" target="_blank" rel="noopener">UVA1628 Pizza Delivery</a></h1><blockquote>
<p>你是一个披萨店的老板，有一天突然收到了 $n$ 个客户的订单。</p>
<p>你所在的小镇只有一条笔直的大街，其中位置 $0$ 是你的披萨店，第 $i$ 个客户所在的位置为 $p_i$，如果你选择给第 $i$ 个客户送餐，他将会支付你 $e_i-t_i$ 元。其中 $t_i$ 是你到达他家的时刻。</p>
<p>当然，如果你到的太晚，使得 $e_i-t_i&lt;0$ 。你可以路过他家但是不能进去给他送餐，免得他反过来找你要钱。</p>
<p>最大化收益。</p>
<p>$n \leq 100$ 。</p>
</blockquote>
<p>考虑对于这种每秒代价递增的问题，一般都是代价提前计算。但是这题也不是最朴素的这类问题，因为存在可以放弃某些位置的情况。</p>
<p>然后就是比(我)较(又)神(不)仙(会)的状态设计环节。首先是，根据题面可知不用全部送餐，所以要把「准备送餐给ta」的人数 $k$ 放到状态里面。同时如果定义「选了某个区间内的全部数」作为状态，显然是不合适的。于是设 $f_{i,j,k,0/1}$ 表示<strong>不考虑</strong>区间 $[i,j]\cap\mathbb {Z_+}$  内的元素，还要给 $k$ 个人送餐，当前位于 $i(0)$ 还是 $j(1)$  的最小代价。那么最后答案就是 </p>
<script type="math/tex; mode=display">
\max_{k=0}^n\{\max_{i=1}^n\{f_{i,i,k-1,0/1}+(e_i-|p_i|)\times k\}\}</script><p>考虑转移。发现对于一个 $f_{i,j,k,0/1}$ 而言，必然是由一个包含 $[i,j]$ 的更大的区间 $[l,r]$ 通过切分得来的，同时为了每次只转移走一个子问题，需要 $r=j$ 或者 $l=i$ 的更大区间。于是考虑每次只转移一个点，故转移为：</p>
<script type="math/tex; mode=display">
f_{i,j,k,0}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_i|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_i|)\}\\f_{i,j,k,1}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_j|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_j|)\}</script><p>然后就刷表就好了？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = n - <span class="number">1</span> ; len ; -- len)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= n - len ; ++ k)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = i + len ; j &lt;= n ; ++ i, ++ j)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; '\n' ;</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> p = i + <span class="number">1</span> ; p &lt;= j ; ++ p)&#123;</span><br><span class="line">				chkmax(f[p][j][k + <span class="number">1</span>][<span class="number">0</span>], f[i][j][k][<span class="number">0</span>] + val[i] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[p] - pos[i])) ;</span><br><span class="line">				chkmax(f[p][j][k + <span class="number">1</span>][<span class="number">1</span>], f[i][j][k][<span class="number">0</span>] + val[i] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[i])) ;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> q = j - <span class="number">1</span> ; q &gt;= i ; -- q)&#123;</span><br><span class="line">				chkmax(f[i][q][k + <span class="number">1</span>][<span class="number">1</span>], f[i][j][k][<span class="number">1</span>] + val[j] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[q])) ;</span><br><span class="line">				chkmax(f[i][q][k + <span class="number">1</span>][<span class="number">0</span>], f[i][j][k][<span class="number">1</span>] + val[j] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[i])) ;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这东西看似是 $n^4$ 的，实际上跑得很快（</p>
<h1 id="UVA12105-Bigger-is-Better"><a href="#UVA12105-Bigger-is-Better" class="headerlink" title="UVA12105 Bigger is Better"></a><a href="https://onlinejudge.org/external/121/p12105.pdf" target="_blank" rel="noopener">UVA12105 Bigger is Better</a></h1><blockquote>
<p>用不超过 $n$ 根火柴摆出一个尽量大的、能被 $m$ 整除的数。</p>
<p>$1\leq n\leq 100,1\leq m\leq 3000$ 。</p>
</blockquote>
<p>大概是个套路？遇到这种被 $m$ 整除余几的，大概需要在 $\bmod m$ 的余数之间来回转移。</p>
<p>然后可能是因为脑子抽了，一开始设计的状态是 $f_{i,j}$ 表示用了 $i$ 根火柴，模 $m$ 余 $j$ 时可以拼出来的最大的数，然后发现最多可以有 $50$ 位，但是 <code>__int128</code> 也只是大概 $36\cdot 10^{36}$ 多一点，不足以记下所有可行的的数字。</p>
<p>然后又尝试用 <code>string</code> ，写了一会儿才意识到 string 自定义的比较函数是按字典…<del>当然也可以写一个大整数类，似乎最多只会带一个 50 的常数</del>。</p>
<p>然后考虑这么设计不行，就只能去最小化贡献，然后手动构造了。考虑 $g_{i,j}$ 表示如果想要凑出从高到低的 $i$ 位，$\bmod m$ 余 $j$ 时最少需要用多少根火柴。转移和第一个转移…基本上差不多，刷就对了。然后考虑从第一位开始贪心地凑，注意判几次合法性就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, m ;</span></span><br><span class="line"><span class="comment">ll f[N][M], ans ;</span></span><br><span class="line"><span class="comment">int num[10] = &#123;6, 2, 5, 5, 5, 5, 6, 3, 7, 6&#125; ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    while (cin &gt;&gt; n)&#123;</span></span><br><span class="line"><span class="comment">        if (!n) return 0 ; ans = -1 ;</span></span><br><span class="line"><span class="comment">        cin &gt;&gt; m ; memset(f, -1, sizeof(f)) ;</span></span><br><span class="line"><span class="comment">        for (int i = 0 ; i &lt;= 9 ; ++ i) f[i % m][num[i]] = i ;</span></span><br><span class="line"><span class="comment">        for (int j = 2 ; j &lt;= n ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            for (int k = 0 ; k &lt;= 9 ; ++ k)&#123;</span></span><br><span class="line"><span class="comment">                for (int i = 0 ; i &lt; m ; ++ i)</span></span><br><span class="line"><span class="comment">                    chkmax(f[((i * 10) + k) % m][j + num[k]], f[i][j] * 10 + k) ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        for (int i = 2 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">            chkmax(ans, f[0][i]) ; cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0 ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, T ;</span><br><span class="line"><span class="keyword">int</span> pw[N], ans[N], f[N][M] ;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n, mid, res = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++ T), <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans)) ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">9</span> ; ++ k)</span><br><span class="line">                        chkmin(f[i + <span class="number">1</span>][(j * <span class="number">10</span> + k) % m], f[i][j] + num[k]) ;</span><br><span class="line">		<span class="keyword">for</span> (res = n + <span class="number">1</span> ; f[res][<span class="number">0</span>] &gt; n ; -- res) ;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, cost = n ; pw[<span class="number">1</span>] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; res &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= res ; ++ i) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">10</span> % m ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">9</span> ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = j * pw[res - i + <span class="number">1</span>] % m ;</span><br><span class="line">                <span class="keyword">if</span> (num[j] + f[res - i][((m - p - t) % m + m) % m] &lt;= cost)&#123;</span><br><span class="line">                    cost -= num[j] ; (p += t) %= m ; ans[i] = j ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span> ; <span class="keyword">while</span> (!ans[q] &amp;&amp; q &lt; res) ++ q ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q ; i &lt;= res ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意几个细节：</p>
<p>1、最后数字的位数不具有可二分性，所以还是枚举吧。</p>
<p>2、注意可能存在前导 $0$ ，需要删掉。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实学到了许多吧？自己基础一点也不好，所以其实是把别人很早之前付出的努力，再重新付出了一遍。很遗憾，这些题目里面还是有不少无不太会做的题目…</p>
<p>感谢兔队的教导可以让我安心学下去：藏巧于拙，寓快于慢。只要努力，就一定会比昨天的我更优秀吧？</p>
<p>不过，努力和选择同样重要。希望在接下来越来越紧张的时间里面，我可以想清楚自己到底要做些什么题、要学习一些什么知识吧。加油吧！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>动态规划/有技巧的DP</tag>
        <tag>思维题/找性质</tag>
        <tag>动态规划/树形DP</tag>
        <tag>动态规划/单调队列</tag>
        <tag>数学/线性代数/矩阵</tag>
        <tag>图论/Dilworth定理</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】简单题选做</title>
    <url>/2020/04/19/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是由于基础太差了，然后打算去做点题补一下基础和脑子…</p>
<p>这个故事告诉我们，永远不要偷懒，有些力气，早晚是要出的。</p>
<p>如果来看我 blog 的你有什么好题推荐，欢迎评论，其他博客也是可以评论的（疯狂暗示</p>
<p>对了，像我这种明明要准备省选却在刷简单题补基础的人，是不是应该发一个「年度最佳人才」奖？</p>
<p>争取一句话题解…先整理十道题吧…因为奇奇怪怪的事情浪费了不少时间。</p>
<a id="more"></a>
<h1 id="UVA10891-Game-of-Sum"><a href="#UVA10891-Game-of-Sum" class="headerlink" title="UVA10891 Game of Sum"></a><a href="https://www.luogu.com.cn/problem/UVA10891" target="_blank" rel="noopener">UVA10891 Game of Sum</a></h1><blockquote>
<p>有一个长度为 $n$ 的整数序列，两个游戏者 $A$ 和 $B$ 轮流取数，$A$ 先取。每次玩家只能从左端或者右端取任意数量的数，但不能两边都取。所有数都被取走视为游戏结束，然后统计每个人取走的数之和，作为各自的得分。两个人采取的策略都是让自己得分尽可能高，并且两个人都很机智，求 $A$ 得分 - $B$ 得分后的结果。</p>
</blockquote>
<p>自己一开始想的 $dp$ 是要 $f_{i,j,0/1}$ ，并且转移有点复杂，结果发现根本不需要…考虑在博弈树上 dp，每个 $max$ 局面接下来一定是一个 $min$ 局面，所以有</p>
<script type="math/tex; mode=display">
f_{i,j}=sum(i,j)-\min\{\min_{k\in[i+1,j]}\{f_{k,j}\},\min_{k\in[i,j-1]}\{f_{i,k}\}\}</script><p>也就是找到与一端边界相邻，且最小的那个对方的决策（$min$ 局面）。发现前后缀 $min/max$ 维护一下就可以 $O(n^2)$ 了。</p>
<h1 id="CF493D-Vasya-and-Chess"><a href="#CF493D-Vasya-and-Chess" class="headerlink" title="CF493D Vasya and Chess"></a><a href="https://www.luogu.com.cn/problem/CF493D" target="_blank" rel="noopener">CF493D Vasya and Chess</a></h1><blockquote>
<p>有一个  $n\times n$  的国际象棋棋盘。将白后放在  $(1,1)$ ，黑后放在  $(1,n)$  ，其余位置全都是中立的卒。<br>双方交替移动。白方先手。 每次移动，后（Queen）可以朝八个方向（上下左右对角线）之一移动任意格，直到碰到另外一个棋子，然后吃掉这个棋子。注意，在本题中，每次移动必须吃掉一个棋子。<br>当你的皇后被吃了或者你没有棋子可以吃了，就输了。 给出棋盘大小，请问哪方会赢。</p>
</blockquote>
<p><del>发现这种对称位置决策的…一般后手都比较神必，拖，就硬拖。</del></p>
<p>考虑后手模仿先手的动作，那么如果两者之前相隔为奇数，后手可以模仿先手，发现这么做一定可以吃掉先手。如果相隔为偶数，那先手就要学聪明，移动到 $(1,2)$ ，然后成为上一种情况的后手…</p>
<h1 id="UVA1099-Sharing-Chocolate"><a href="#UVA1099-Sharing-Chocolate" class="headerlink" title="UVA1099 Sharing Chocolate"></a><a href="https://www.luogu.com.cn/problem/UVA1099" target="_blank" rel="noopener">UVA1099 Sharing Chocolate</a></h1><blockquote>
<p>给出一块长为 $x$, 宽为 $y$ 的矩形巧克力，每次操作可以沿一条直线把一块巧克力切割成两块长宽均为整数的巧克力（一次不能同时切割多块巧克力）。 </p>
<p>问：是否可以经过若干次操作得到 $n$ 块面积分别为 $a_1, a_2, …, a_n$ 的巧克力。</p>
<p>$n\leq 15,1\leq x,y\leq 100$ 。</p>
</blockquote>
<p>大力状压，$f_{s,x,y}$ 表示 $s$ 这个集合内的巧克力是否可以被 $x,y$ 给切出来。考虑这样转移存在问题。因为必须要枚举子集来转移，所以最后时间复杂度 $O(3^nxy)$，空间复杂度 $O(2^nxy)$ 。有点爆炸。</p>
<p>考虑化简状态。发现固定了巧克力集合 $s$ ，那么对于一个固定的 $x$ ，$y$ 要么不存在要么同样被固定。所以状态就可以简化成 $f_{s,\min\{x,y\}}$ 。转移时依旧要判断两个状态是否都可行。注意转移来的状态 $f_{s’,x’}$ 也需要保证信息是落在较短边上的。复杂度 $O(x3^n)$。</p>
<p>神必 uva 卡我常数。不过也需要记得，对于这种信息 $01$ 且求并的转移，一旦某个状态确定为 $1$ 了就可以 <code>break</code>。这个技巧确实要记住。</p>
<h1 id="LA4725-Airport"><a href="#LA4725-Airport" class="headerlink" title="LA4725 Airport"></a><a href="https://www.luogu.com.cn/problem/UVA1450" target="_blank" rel="noopener">LA4725 Airport</a></h1><blockquote>
<p>机场上有两个跑道，分别为 W 和 E，每个时刻 $i$，W和E都分别有 $a_i,b_i$ 架飞机进入跑道。每个跑道的飞机都按顺序从 0 开始排序，每个时刻都允许一架飞机起飞，现要求你安排起飞的飞机，使得任意时刻的飞机的最大编号最小。</p>
<p>$1\leq n\leq 5000$ 。</p>
</blockquote>
<p>这题能比较自然地想到要二分。但是问题在于二分了之后并不知道要怎么去 check。这个地方有个很妙的 idea。就是如果之前有机会要飞，可以不飞，等到什么时候攒到了 $mid$ 号再飞。这样就不需要再考虑这东西的后效性了。但是有一点需要注意，就是攒着一起飞的话，在第 $i$ 个时刻只能选择飞之前的，因为这个决策本质上等价于在 $i-1$ 时刻飞。所以也要分别统计 $W$ 和 $E$ 的可飞量。</p>
<h1 id="LA4094-Wonder-Team"><a href="#LA4094-Wonder-Team" class="headerlink" title="LA4094 Wonder Team"></a><a href="https://vjudge.net/problem/UVALive-4094" target="_blank" rel="noopener">LA4094 Wonder Team</a></h1><blockquote>
<p>There are $n$ football teams participating in the competitions, each team plays twice (home and away) against each other team. Each team receives three points for a win and one point for a draw. No point is awarded for a loss. </p>
<p>When the games are finished, teams are ranked by numbers from $1$ to $n$ according to the total points. The rank of each team $t$ having $p$ points is one plus the number of teams having more than $p$ points. It is possible that more than one team have the same ranks. In addition to the Champion (the first ranked team or teams), the <strong>Wonder Team</strong> is also awarded, if there exists one. The team that has absolutely <strong>the highest number of wins</strong> (absolutely means no other teams has the same number of wins), absolutely <strong>the highest number of goals scored</strong>, and absolutely <strong>the lowest number of goals </strong>conceded, is called the WonderTeam. (WonderTeam should have all these properties.)</p>
<p>Your task is to find out the worst possible rank for the <strong>Wonder Team</strong>.</p>
<p>$1\leq n\leq 50$ 。</p>
</blockquote>
<p>English problem, English solution!</p>
<p>First of all, I’d like to claim that the 2nd Constraint and 3rd Constraint is no-use, becauce we always can let WT won another team with $10^9:1$. </p>
<p>Let’s assume $a_1,b_1$ means the WonderTeam’s wins and draws, $a_2,b_2$ means an arbitrary team’s wins and draws, whose rank is higher than WT. After a series of easy inference, if one team has higher rank than WT,   the equation below should be satisfied:</p>
<script type="math/tex; mode=display">
b_2-b_1>3(a_1-a_2)\qquad (1)</script><p><del>Then my train of thought ended up with this:(</del></p>
<p>Thinking more carefully, if we want to maxmize WT’s rank, we have to get other teams’ score as high as we can. So we can use a greedy way to construct it : Just let WT’s wins actually one more than others. At the same time let WT lose its other games. Also we let other teams won WT one time, and draw with each other. </p>
<p>Then we can find that $\forall a_2$ ，there is $a_1-a_2=1$, which means $(1)$ turned to be:</p>
<script type="math/tex; mode=display">
b_2-b_1>3</script><p>And about $b_2$ , there will exists two teams who losed in the game with WT , which means the-two  has exactly $1$ win and $2n-4$ draws, while the rest teams has exactly $1$ win and $2n-3$ draws. </p>
<p>So we can cliam that when $n&gt;4$ , WT’s lowest rank can be $n$ ; when $n=4$, it can be $2$ ; otherwise it can only be $1$ 。 </p>
<h1 id="CCO-2017-Rainfall-Capture"><a href="#CCO-2017-Rainfall-Capture" class="headerlink" title="CCO 2017 Rainfall Capture"></a>CCO 2017 Rainfall Capture</h1><blockquote>
<p>Lucy 有 $n$ 个高度为 $h_1,h_2,…,h_n$ 的柱子。她想知道，在所有可能的摆放方案中，所有可能的雨滴量（以 $r$ 为单位）是多少。</p>
<p>柱子只能竖着摆。接雨滴的定义：满则溢。</p>
</blockquote>
<p>比较神仙的 dp，对着代码啃了很久…</p>
<p>考虑直接求雨滴量并不好求，因为要去考虑左右两边的柱子高度。考虑对于一个排布 $4,2,5$ ，那么中间 $=2$ 或者 $=1$ 时要分开考虑；但是我们发现无论怎样，中间在接完雨滴之后高度都会变成 $4$ ，所以考虑求<strong>所有可能的雨滴+柱子</strong>的体积和。由于每个柱子都要摆，所以最后只需要去 check 那些 $\sum h_i\sim max$ 的答案。</p>
<p>考虑定义 $f_{i,v}$ 表示用了 $i$ 个柱子之后能否凑出体积 $v$ 来。考虑一个比较常用的 trick，将所有 $h_i$ 从小到大排序之后，按顺序转移。这样就能保证每次加进来的柱子都是当前最高的(无中生有了一个很有用的性质)。考虑一个状态 $f_{i,v}$ ，他的转移应该为：</p>
<script type="math/tex; mode=display">
f_{i,v}=\bigcup_{p_j\leq v} f_{i-1,v-p_j}</script><p>其中 $p_j$ 是每个柱子的高度，需要从小到大转移，且转移时需要严格按照先枚举 $p_j$ 再枚举 $1\sim i$ 的顺序。</p>
<p>考虑这个式子的意义。对于任何一个大小为  $i\in[1,n-1]\cap\mathbb{Z_+} $ 的柱子集合 $o$，按秩转移时每次加入一个 $\geq \max_{t\in o}p_t$ 的新柱子 $p’$，放在最左边（或者最右边），同时再加入一个按高度从小到大排序后，恰好排名比 $p’$ 大 $1$ 的柱子 $p’’$  放在 $p’$ 的同侧（即，如果 $p’$ 放在了整个序列的左边，$p’’$ 应该被放在 $p’$ 的左边）。那么此时考虑，每当加进来一个元素 $p_0$，集合大小从 $i-1$ 变成 $i$ ，$p’$ 就向右交换一个，这样新加进来的这个柱子上方水位高度一定会是 $p’$ 的高度（因为最左边有 $p’’$）， 所以体积的变化量是 $\Delta v=(p’-p_0)+p_0$，前一半是水，后一半是新的柱子，所以可以从 $i-1,v-p’$ 转移过来。</p>
<p>需要注意的是，这样转移一定是不包含最高那个柱子的，因为当最高的柱子为 $p’$ 不存在一个更高的 $p’’$ 。</p>
<p>于是最后复杂度 $O(n^2\sum h)$ ，当然可以用 bitset 优化成 $O(\frac{n^2\sum h}{w})$ 。但其实在注意到本题只关注可达性判断之后，就可以发现等高的柱子不用重复转移，就可以优化成 $O((\sum h)\cdot n\cdot \max\{h\})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> base[N] ; </span><br><span class="line"><span class="comment">//bool f[N][M] ; </span></span><br><span class="line"><span class="built_in">bitset</span> &lt;M&gt; f[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">		base[i] = qr(), m = max(m, base[i]) ;</span><br><span class="line">	sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">		s += base[i] ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">			f[j] |= (f[j - <span class="number">1</span>] &lt;&lt; base[i]) ; </span><br><span class="line">			<span class="comment">//for (int k = base[i] ; k &lt;= n * m ; ++ k)</span></span><br><span class="line">			<span class="comment">//	f[j][k] |= f[j - 1][k - base[i]] ; </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = s ; i &lt;= n * m ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (f[n - <span class="number">1</span>][i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - s) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="UVA1073-Glenbow-Museum"><a href="#UVA1073-Glenbow-Museum" class="headerlink" title="UVA1073 Glenbow Museum"></a><a href="https://www.luogu.com.cn/problem/UVA1073" target="_blank" rel="noopener">UVA1073 Glenbow Museum</a></h1><blockquote>
<p>对于一个各边长度任意且都平行于坐标轴的多边形，我们可以用这样的方式描述它：考虑它的每一个内角，如果这个内角为 $90$ 度，那么用 $R$ 代表它；如果这个内角为 $270$ 度，那么用 $O$ 代表它。从某个点开始，按照逆时针的顺序读取 $R$ 和 $O$，最后得到一个由 $O,R$ 组成的字符串。</p>
<p>给定整数 $n$，问有多少个长度为 $n$ 的 $O,R$ 组成的字符串，使得有一个或以上与之对应的多边形，满足这个多边形内部有一点，可以看到这个多边形的所有内角（即，这个点与多边形所有内角顶点的连线都不与多边形的边相交）。</p>
</blockquote>
<p>显然最后一定是 $\frac{n}{2}-2$ 个 $O$ 和 $\frac{n}{2}+2$ 个 $R$。同时显然不会有相邻的 $O$，证明大概是需要拐回来之类的。那么问题就是给你固定数量的 R 和 O ，O 和 O 之间不相邻的方案数。</p>
<p>第一种 $dp$ 就是 $f_{k_1,k_2,l,r}$ 表示用了 $k_1$ 个 O 和 $k_2$ 个 R，最左端的字母是 $l$，最右端是 $r$ 的方案数。转移的时候考虑新加入一个 $R$ 还是 $O$ 即可。</p>
<p>第二种 $dp$ 则是一个改进，因为显然我们不关心 $O$ 的数量，因为最后是一定的；只关心如何排列。所以令 $f_{k_1,k_2,c}$ 表示有 $k_1$ 个 R ，$k_2$ 对相邻的 RR，第一个字母是 $c$ 的方案数。转移的时候考虑向后加一个 R​ 还是 OR 即可 。</p>
<p>然而显然这种 dp 是有组合意义的。所以我们分类讨论：</p>
<p>1、尾部不是 O 的方案数，显然就是前面 $\frac{n}{2}+2$ 个空填 $\frac{n}{2}-2$ 个O的方案数。</p>
<p>2、尾部是 O 的方案数，此时第一个位置不能放  O。类似的组合一下就完了。</p>
<p>于是就可以组合数做。处理的时候因为答案过大，所以可以考虑取对数<del>（学到许多）</del>。</p>
<h1 id="CF340E-Iahub-amp-Permutations"><a href="#CF340E-Iahub-amp-Permutations" class="headerlink" title="CF340E Iahub &amp; Permutations"></a><a href="https://www.luogu.com.cn/problem/CF340E" target="_blank" rel="noopener">CF340E Iahub &amp; Permutations</a></h1><blockquote>
<p>有一个长度为 $n$ 的排列 $a$，其中有一些位置被替换成了 <code>-1</code>。你需要尝试恢复这个排列，将 <code>-1</code> 替换回数字。<br>求多少种可行方案使得得到的是一个排列且不存在 $a_i=i$ 的位置。</p>
<p>$n\leq 5000$ 。</p>
</blockquote>
<p>orz 一个十分巧妙的转化，大概就是对于这种带有<strong>放置限制</strong>的排列问题，比如某个下标不能放置某个数，那么可以将这个排列对应到一个 $n$ 阶摆 $rook$ （即 $n\times n$ 的棋盘上放 $n$ 个互不攻击的车）问题上。这样一方面可以把「位置 x 不能放 y」约束展开，抽象成一个二维约束点 $(x,y)$ 上不能放车的约束；另一方面可以知道这个对应一定是完备的。</p>
<p>那么就转化成了，有些行和列已经放了车，整个棋盘对角线不能放车，有多少种本质不同的放车方案数。首先可以发现，如果某行某列有车，这一行一列就可以删掉；同时如果对于某个 $-1$ ，他所在的这个位置对应的行/列恰好被删了（同时存在位于下标 $k$ 的 $-1$ 和一个 $pos$ 使得 $a_{pos}=k$ ），那么对于这个 $-1$ 而言就没有限制了。</p>
<p>这样考虑 $dp$ 。$f_{i,j}$ 表示 $i\times i$ 的方格里考虑 $j$ 个限制的方案数。那么 $f_{i,0}=i!$。同时注意到 $f_{i,j-1}$ 到 $f_{i,j}$ 恰好多了一个限制，这个限制对应的应该是 $f_{i-1,j-1}$ 的方案数。所以有转移</p>
<script type="math/tex; mode=display">
f_{i,j}=f_{i,j-1}-f_{i-1,j-1}</script><p>复杂度 $n^2$ 。</p>
<h1 id="CF212D-Cutting-Fence"><a href="#CF212D-Cutting-Fence" class="headerlink" title="CF212D Cutting Fence"></a>CF212D Cutting Fence</h1><blockquote>
<p>给出 $a[1…n]$ 。<br>定义 $f$ ：</p>
<script type="math/tex; mode=display">
f(i,k)=\min_{i\leq j\leq i+k-1}\{a[j]\}</script><p>之后有 $m$ 个询问，每个询问给出一个数 $k$，问所有 $f(j,k) (1\leq j\leq n-k+1)$ 的平均值。<br>$1\leq n,m\leq 10^6$.</p>
</blockquote>
<p>首先不难知道要求出每个 $a_i$ 对包含其区间的贡献，然后对于长度为 $1\sim n$ 的区间分别计算其和，最终除以 $n-k+1$ 即为答案。</p>
<p>考虑两遍单调栈求出每个元素 $x$ 左/右边第一个比他小的元素下标 $l,r$，可知 $x$ 的贡献区间即为 $[l+1,r-1]$。枚举 $x$ ，那么区间 $l+1,r-1$ 的所有跨过 $x$ 的子区间都会存在贡献。此处假设 $x-l&lt;r-x$，考虑分类讨论子区间长度 $L$ ： </p>
<p>1、 $1\leq L\leq x-l$ ，这种区间每个元素都可以是 $x$ ，所以贡献为 $L\cdot a_x$ 。</p>
<p>2、$x-l+1\leq L\leq r-x$ ，这种区间最多只能取到 $x-l$ 次 $x$ ，所以贡献为 $(x-l)\cdot a_x$ 。</p>
<p>3、$r-x+1\leq L\leq r-l-1$ ，这种区间最多只能取到 $r-l-L$ 次，故贡献为 $(r-l-L)\cdot a_x$ 。</p>
<p>然后观察这些修改，发现 $L\cdot a_x$ 这东西，对于一个区间是在加一个等差数列的形式，$(x-l)\cdot a_x$ 和 $(r-l)\cdot a_x$ 都是区间加一个常数的形式。于是可以维护二阶差分。复杂度线性。</p>
<h1 id="USACO12-Bovine-Alliance-G"><a href="#USACO12-Bovine-Alliance-G" class="headerlink" title="USACO12 Bovine Alliance G"></a><a href="https://www.luogu.com.cn/problem/P3043" target="_blank" rel="noopener">USACO12 Bovine Alliance G</a></h1><blockquote>
<p><del>给出 $n$ 个点 $m$ 条边的图，现把点和边分组，每条边只能和相邻两点之一分在一组，点可以单独一组，问分组方案数</del>.</p>
<p>以上是错误的题意，以下是正确的题意：</p>
<blockquote>
<p>题意是给每条边找一个配对的点，要求边 $(u,v)$ 配对的点是 $u$ 或 $v$ ，且每个点最多只能被一条边配对，求不同方案数。</p>
</blockquote>
<p>$1\leq m\leq n\leq 10^5$ 。</p>
</blockquote>
<p>对着错误的题意思考了半天也不会…觉得首先对于点分组可以直接跑一个第二类斯特林数，但是这样边就没法分配了，因为可能存在边的两个端点在同一个点集内，所以可能需要套一个容斥什么的。推容斥系数可能会很高妙<del>反正我不会</del>。</p>
<p>然后正确的题面的话，考虑问题可以转化成给每条边定向，使得最后整张图每个点的度数都 $\leq 1$ 的方案数。然后…然后就是考察对于图论模型的洞见性有多强了：</p>
<p>1、不难发现一个简单环的定向方式总共是 $2$ 。</p>
<p>2、考虑去计算一棵树的定向方式。发现随便找一个根，显然哪个点当根对于整棵树的方案数没有影响。考虑如果将所有边都向儿子定向，那么这样一定合法，这是第一种方案。同时，单独把某一条边取反，假设这条边连接的儿子是 $x$ ，那么同时需要把 $x\to fa_x,fa_x\to fa_{fa_x}, fa_{fa_x}\to fa_{fa_{fa_x}}$ 全部取反，那么最终会取反到根，根的入度会变成 $1$ ，这也就说明不能有 $&gt;1$ 条边同时取反。所以可以知道一棵树的定向方式为 $1+(n-1)=n$ 。</p>
<p>发现对于无向图，本质上就是树插环的形态。所以拿一个带权并查集维护即可。有一个坑点，就是如果两个点不在同一个即集合里，边数也要++。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>动态规划/有技巧的DP</tag>
        <tag>思维题/计数</tag>
        <tag>动态规划/普通DP</tag>
        <tag>思维题/构造</tag>
        <tag>贪心</tag>
        <tag>有趣的二分答案</tag>
        <tag>单调队列/单调栈</tag>
        <tag>图论/并查集</tag>
        <tag>思维题/对应与转化</tag>
        <tag>动态规划/状态合并</tag>
        <tag>博弈论/对称博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[CF671E] Organizing a Race</title>
    <url>/2020/04/17/CF671E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。</p>
<p>你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。</p>
<p>你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。</p>
<p>你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？</p>
</blockquote>
<p>这题十分的神…所以也难怪 $4$ 年前的题目会被选入今年的集训队作业。</p>
<p>做这题，那必然就是看题解…这题难点由两部分，「转化成抽象模型」和「用线段树维护」，比较神奇的是这题里这两部分几乎同等难度，并且都是我难以望见的高度…</p>
<p>接下来应该不太会做这种难度的题了。感觉很不好。虽然这题确实十分的好，新颖有趣且经典，但我还是驾驭不了这种题目吧… </p>
<a id="more"></a>
<p>XXXXXXXXXXXX 正文 XXXXXXXXXXXX</p>
<p>首先考虑，对于一段区间而言，需要多少操作多少次，才能保证正着走完并且反着走完。那么也就是需要算出正着走和反着走都需要额外的多少代价。</p>
<p>这个地方有个贪心。考虑定「向右走」为正方向。那么假设从 $i$ 开始走，如果遇到某个 $j&gt;i$ 发现走不得，那么应该在何处加油？因为还要考虑反着走回来，所以必然是加在最靠右的地方最优，所以就会选择的在 $j-1$ 处加油。记 $i$ 向右走遇到的第一个这样的 $j$ 为 $stop_i$  。</p>
<p>于是根据这个贪心就可以求出 $need(i,j)$ ，表示从 $i$ 走到 $j$ 需要多少代价。但这样也是只是保证了正着可以走。不妨令 $p_{i}$ 表示从 $1$ 走到 $i$ 花费的油量，$q_i$ 表示从 $i$ 走到 $1$ 花费的油量。 那么可知有递推：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p_i&=p_{i-1}+g_{i-1}-w_{i-1}\\
q_i&=q_{i-1}+g_{i-1}-w_i
\end{aligned}</script><p>那么可以知道，在走 $i\to j$ 这条路线时，同时也在进行对 </p>
<script type="math/tex; mode=display">
g_{stop_i},g_{stop_{stop_i}},g_{stop_{stop_{stop_i}}}\cdots</script><p>这些位置进行单点加，那么对 $q$ 的影响就是一个后缀加。记后缀加完之后的 $\{q_n\}$ 为 $\{\tau_n\}$ 。则如果不能从 $j$ 回到 $i$ ，就意味着着存在一个 $i\leq k&lt;j$ ，使得 $q_{k}-q_{j}&lt;0$ 。怎么量化这个东西呢？考虑还是贪心，如果从 $j$ 到 $i$ 走不了，那么一定会要把贡献累加到 $j$ 上，那需要累加的量就是 $q_{j}-\min_{k=i}^{j-1}\{q_{k}\}$ 。这也就是如果想要 $[i,j]$ 这个区间变得合法的最小贡献。</p>
<p>考虑如何计算这个东西。比较暴力的解法那必然是枚举一个左端点，然后向右走更新右端点。这样是 $n^2$ 的。发现如果想要优化，只能选择加速寻找右端点这个过程。但是有个问题在于，对于固定的 $i$ ，和想要二分出的 $j’$，要经过不同的 $stop$ 集合，同时有着不同的 $q_{j’}-\min_{k=i}^{j’-1}\{q_{k}\}$ ，求一次是 $O(n)$ 的，反而把复杂度搞成了 $n^2\log n$ 。</p>
<p>分开考虑这两点。对于经过不同 $stop$ 集合这个问题，可以继续深入挖掘性质。发现对于一个 $j$，可能存在一个连续段 $[k_1,k_2]$ 满足 $\forall z\in[k_1,k_2]\cap\mathbb{Z_+}$ ，$stop_z=j$ 。这种一对多的逻辑结构不难想到要用森林去表征。那么这个问题比较好解决了。建出一棵森林 $T$ ，连边 $i\leftrightarrow stop_i$ 。再建立一个虚根 $root$ ，与所有 $stop_i$ 未定义的结点相连。这样只要从 $root$ 开始 dfs，用退栈的方式辅助二分即可快速修改。</p>
<p>对于第二点，考虑对于一个固定的 $i$ ，本质上是在维护这么一个式子：</p>
<script type="math/tex; mode=display">
t_{j'}=q_{j'}-\min_{k=i}^{j'}\{\tau_k \}</script><p>首先变一下形：</p>
<script type="math/tex; mode=display">
t_{j'}=q_{j'}-\min_{k=1}^{j'}\{\tau_k \}</script><p>这样做的正确性在于，只要每次将 $&lt;i$ 的那些 $k$ 的 $\tau_k$ 都置为 $+\infty$ 就可以了。</p>
<p>考虑到底要怎么维护这个东西。发现在查询的过程中，需要单点修改 $g_i$ ，那么也就是区间修改 $q_j$ 和 $\tau_k$ ，那么也就是说要支持：1、维护前缀最小值 2、区间加/减 3、查询出某个最小值的位置。那自然就是线段树了。</p>
<p>考虑后一半的前缀最小值，因为带上修改比较麻烦，所以维护起来依然要选择楼房重建的方式，拿左区间的最小值去二分右区间的前缀。于是可以比较简单地维护出一个区间的 $\min\{t_i\}$ 。</p>
<p>考虑修改。修改的话就是暴力打标记，注意到 $t_i$ 中的 $\tau_k$ 是负贡献，被 $\min$ 套着，但由于是区间修改所以可以直接减。</p>
<p>考虑如何查询。询问比较麻烦，因为相当于查询时要合并多个区间的单调栈，所以无法直接线段树二分。或者说，需要魔改一下二分，让这个二分可以「边二分，边合并」。</p>
<p>考虑一种比较神秘的方式去找。<code>query(root, l, r, val)</code> 查询的是区间 $[1,l-1]$ 内某个数 <code>val</code>，作为前缀最小值对区间 $[l,r]$ 有影响时，最靠右的 $\leq m$ 的位置。那么考虑分类：</p>
<p>1、如果当前左孩子区间的 $\min\{\tau_k\}$ 比 $val$ 要小，说明当前的前缀最小值不会对右区间产生影响(因为左右区间已经合并了)，那么就可以直接判断在算上左区间对右区间贡献时，右区间 $t$ 的最小值是否 $\leq m$  —— 这就是比较朴素的线段树上二分 —— 如果是的话就应该去右儿子里面找，否则去左儿子里找。</p>
<p>2、如果当前左孩子区间的 $\min\{\tau_k\}$ 比 $val$ 要大，说明左区间对右区间产生的贡献会被 $val$ 产生的贡献代替，所以直接递归进右孩子。并且由于 $val$ 已经变成了当前左区间的前缀最小值，所以左区间的 $\min\{\tau_k\}$ 就变成了无用信息(因为肯定都比 $val$ 大)，只需要查询在 $q_i+val\leq m$ 时的最大下标即可，这一部分可以直接线段树二分。</p>
<p>但…这似乎也不是最终的查询。考虑为了让最后的 $\min_{k=1}^{j’}\{\tau_k\}$ 真的变成从 $1$ 开始到 $i$ 结束的最小值， 所以需要动态修改 $val$ 的值。先序遍历线段树即可。当然也可以直接维护一个前缀最小 $\tau_k$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr firsr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (rt &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (rt &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mint ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-7</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Inf = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Fni = -(<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>)&#123;</span><br><span class="line">        r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r * f ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(T *<span class="keyword">const</span> tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v = <span class="string">' '</span>, <span class="keyword">char</span> c = <span class="string">'\n'</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i) <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_e</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = y ; val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[x] ; head[x] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">ll sp[N] ;</span><br><span class="line">ll ss[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> w[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"></span><br><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll sa[N * <span class="number">3</span>] ;</span><br><span class="line">ll sb[N * <span class="number">3</span>] ;</span><br><span class="line">ll tag[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">	<span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">		s[ls] -= tag[rt] ;</span><br><span class="line">		s[rs] -= tag[rt] ;</span><br><span class="line">		sb[ls] += tag[rt] ;</span><br><span class="line">		sb[rs] += tag[rt] ;</span><br><span class="line">		tag[ls] += tag[rt] ;</span><br><span class="line">		tag[rs] += tag[rt] ;</span><br><span class="line">		tag[rt] = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt ,<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">		<span class="keyword">return</span> sa[rt] - v ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">	<span class="keyword">if</span> (sb[ls] &lt; v)</span><br><span class="line">		<span class="keyword">return</span> min(solve(ls, l, mid, v), s[rt]) ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> min(solve(rs, mid + <span class="number">1</span>, r, v), sa[ls] - v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">void</span>(sa[rt] = sb[rt] = ss[l]) ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	build(ls, l, mid) ;</span><br><span class="line">	build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">	sa[rt] = min(sa[ls], sa[rs]) ;</span><br><span class="line">	sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">	s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">		tag[rt] += v ;</span><br><span class="line">		sb[rt] += v ;</span><br><span class="line">		s[rt] -= v ; <span class="comment">//1</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	_down(rt, l, r) ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">		update(ls, l, mid, ul, ur, v) ;</span><br><span class="line">	<span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">		update(rs, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">	sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">	s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (sa[rs] &gt; v)</span><br><span class="line">		<span class="keyword">return</span> ask(ls, l, mid, v) ;</span><br><span class="line">	<span class="keyword">return</span> ask(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll &amp;v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		<span class="keyword">int</span> ret ;</span><br><span class="line">		ret = sa[rt] - v &lt;= m ? l : <span class="number">0</span> ;</span><br><span class="line">		v = min(v, sb[rt]) ;</span><br><span class="line">		<span class="keyword">return</span> ret ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">	<span class="keyword">if</span> (sb[ls] &lt; v)&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[rt] &lt;= m)&#123;</span><br><span class="line">			v = sb[ls] ;</span><br><span class="line">			<span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> ret ;</span><br><span class="line">			ret = query(ls, l, mid, v) ;</span><br><span class="line">			v = min(v, sb[rt]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">if</span> (sa[rt] - v &lt;= m)</span><br><span class="line">			ret = ask(ls, l, mid, m + v) ;</span><br><span class="line">		<span class="keyword">return</span> max(ret, query(rs, mid + <span class="number">1</span>, r, v)) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	stk[++ top] = x ;</span><br><span class="line">	<span class="keyword">if</span> (fa[x] &lt;= n)</span><br><span class="line">		update(<span class="number">1</span>, <span class="number">1</span>, n, fa[x] - <span class="number">1</span>, n, - sp[fa[x]] + sp[x]) ;</span><br><span class="line">	<span class="keyword">if</span> (x &lt;= n)&#123;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">2</span>, r = top - <span class="number">1</span>, ans = <span class="number">1</span>, mid ;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">if</span> (sp[stk[mid]] - sp[x] &gt; m)</span><br><span class="line">				ans = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		ll tmp = Inf ; ans = stk[ans] - <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, Inf) ;</span><br><span class="line">		<span class="keyword">if</span> (ans &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, ans, n, Fni) ;</span><br><span class="line">		res = max(res, query(<span class="number">1</span>, <span class="number">1</span>, n, tmp) - x + <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, Fni) ;</span><br><span class="line">		<span class="keyword">if</span> (ans &lt;= n) update(<span class="number">1</span>, <span class="number">1</span>, n, ans, n, Inf) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k)) dfs(to(k)) ;</span><br><span class="line">	stk[top --] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (fa[x] &lt;= n)</span><br><span class="line">		update(<span class="number">1</span>, <span class="number">1</span>, n, fa[x] - <span class="number">1</span>, n, sp[fa[x]] - sp[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; w[n] = Inf ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) w[i] = qr() ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) g[i] = qr() ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">		sp[i] = sp[i - <span class="number">1</span>] - g[i - <span class="number">1</span>] + w[i - <span class="number">1</span>] ;</span><br><span class="line">		ss[i] = ss[i - <span class="number">1</span>] - g[i] + w[i - <span class="number">1</span>] ;</span><br><span class="line">	&#125;</span><br><span class="line">	stk[++ top] = n + <span class="number">1</span> ;</span><br><span class="line">    sp[n + <span class="number">1</span>] = Inf ; fa[n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">		<span class="keyword">while</span> (top &amp;&amp; sp[stk[top]] &lt;= sp[i]) -- top ;</span><br><span class="line">		fa[i] = stk[top] ; stk[++ top] = i ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) add_e(fa[i], i) ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">1</span>, n) ; top = <span class="number">0</span> ; dfs(n + <span class="number">1</span>) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/找性质</tag>
        <tag>贪心</tag>
        <tag>树模型</tag>
        <tag>数据结构/线段树</tag>
        <tag>单调队列/单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】兔队线段树</title>
    <url>/2020/04/16/%E5%85%94%E9%98%9F%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实真正的题目应该是「小粉兔教你如何玩转线段树」。这件事要回溯到去年 CSP 之前，有人在 uoj 群里问了一道题的做法：<a href="https://www.luogu.com.cn/problem/U96354" target="_blank" rel="noopener">Luogu U96354</a> 。然后兔队飞快的 A 了这道题并在 uoj 群给出了代码链接。当时就带着机房小伙伴学习了一波…233</p>
<p>然后今天又看到了兔的博文：<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html" target="_blank" rel="noopener">从《楼房重建》出发浅谈一类使用线段树维护前缀最大值的算法</a>。 感觉很神仙，然后就打算把这三道题都整理一下。</p>
<p><del>所以就是类似于复刻了一下兔秒掉or推荐的题</del>。</p>
<p>分别是三道题：<code>LGU96354 魔能阵列</code>，<code>BZOJ2957 楼房重建</code> 和 <code>CF671E Organizing a Race</code> .</p>
<a id="more"></a>
<h1 id="LGU96354-魔能阵列"><a href="#LGU96354-魔能阵列" class="headerlink" title="LGU96354 魔能阵列"></a>LGU96354 魔能阵列</h1><blockquote>
<p>给定两个序列 $\{a_n\},\{b_n\}$，定义一段区间 $[l,r]$ 的权值为</p>
<script type="math/tex; mode=display">
\sum_{i=l}^r[b_i>0]a_i</script><p>现在给定两种操作，对 $\{b_n\}$ 区间加 $x$ (可正可负) 和询问某个区间的权值。保证任何时刻 $b_i\geq 0$ 。</p>
<p>$1 \leq n,m\leq 2 \times 10^5$   </p>
</blockquote>
<p>一个比较自然的想法，是分别维护区间 $b_i=0$ 的和 and 区间 $b_i\not = 0$ 的和。但是这个东西维护起来复杂度并不对。所以考虑换一下，由于保证任意时刻 $b_i\geq 0$ ，所以维护区间最小值， 区间 $b_i$ 的值 = 最小值的权值 and 区间 $b_i$ 的值 $\not =$ 最小值的权值和。那么转移就分类讨论一下即可。回答询问的时候只需要再建立一个虚点，对询问区间进行合并，最后只需要判断该区间最小值是否是 $0$ 即可。</p>
<p>大概首先维护区间最小值是个 trick ，建一个虚点对 $\log n$ 个区间进行合并也是一个 trick 。但是这俩似乎我都不是很熟，导致我当时不太会做.jpg</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> cnt, _tag[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> s[MAXN &lt;&lt; <span class="number">2</span>], v[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], mnx[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span>, fg = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) fg = <span class="number">-1</span> ;  c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * fg ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _merge(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnx[x] == mnx[y])</span><br><span class="line">        s[x] = s[x] + s[y], v[x] = v[x] + v[y] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mnx[x] &lt; mnx[y]) s[x] = s[x] + s[y] + v[y] ;</span><br><span class="line">    <span class="keyword">else</span> mnx[x] = mnx[y], s[x] = s[x] + s[y] + v[x], v[x] = v[y] ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _merge(<span class="keyword">int</span> rt, <span class="keyword">int</span> ls, <span class="keyword">int</span> rs)&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnx[ls] == mnx[rs])</span><br><span class="line">        mnx[rt] = mnx[ls], s[rt] = s[ls] + s[rs], v[rt] = v[ls] + v[rs] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mnx[ls] &gt; mnx[rs])</span><br><span class="line">        mnx[rt] = mnx[rs], s[rt] = s[ls] + s[rs] + v[ls], v[rt] = v[rs] ;</span><br><span class="line">    <span class="keyword">else</span> mnx[rt] = mnx[ls], s[rt] = s[ls] + s[rs] + v[rs], v[rt] = v[ls] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">pdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_tag[rt])&#123;</span><br><span class="line">    	mnx[rt &lt;&lt; <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">    	mnx[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">    	_tag[rt &lt;&lt; <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">   		_tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += _tag[rt] ;</span><br><span class="line">   		_tag[rt] = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    mnx[rt] = Inf, s[rt] = <span class="number">0</span>, v[rt] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; ++ cnt ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v[rt] = base[l], <span class="keyword">void</span>() ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur) </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">void</span>(mnx[rt] += x, _tag[rt] += x) ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; pdown(rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, x) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, x) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) </span><br><span class="line">		<span class="keyword">return</span> _merge(ans, rt), <span class="keyword">void</span>() ;</span><br><span class="line">    pdown(rt) ; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr, ans) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr, ans) ;</span><br><span class="line">    _merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, N) ; (cnt *= <span class="number">2</span>) += <span class="number">1</span> ; <span class="keyword">int</span> l, r, x, opt ;</span><br><span class="line">    <span class="keyword">while</span> (M --)&#123;</span><br><span class="line">        opt = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line">            l = qr(), r = qr(), x = qr(), update(<span class="number">1</span>, <span class="number">1</span>, N, l, r, x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ++ cnt, l = qr(), r = qr() ;</span><br><span class="line">            init(cnt), query(<span class="number">1</span>, <span class="number">1</span>, N, l, r, cnt) ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mnx[cnt] ? s[cnt] + v[cnt] : s[cnt]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="bzoj2957-楼房重建"><a href="#bzoj2957-楼房重建" class="headerlink" title="bzoj2957 楼房重建"></a>bzoj2957 楼房重建</h1><blockquote>
<p>单点修改，查询整个序列有多个前缀最大值。</p>
<p>$1\leq n,m\leq 10^5$</p>
</blockquote>
<p>sto 兔。</p>
<p>首先考虑这东西暴力做的话，就是在模拟一个单调栈的过程。带修的话就要考虑套一个 ds。考虑 ds 的作用，本质上是要在每次修改完 $x$ 之后，将 $[1,x-1]$ 和 $[x+1,n]$ 这两个区间的单调栈和 $x$ 放在一起合并。于是不难想到要用线段树。</p>
<p>但…线段树似乎也没法快速合并。考虑每次 <code>push_up</code> 暴力把右区间合并到左区间里面，这样做显然是单次 $O(n)$ 的。考虑发掘更深一些，每次合并左右区间时，左区间是不受影响的，只需要统计左区间最大值对右区间答案的贡献。考虑每次合并，左区间最大值对右区间的影响一定是一个右区间的一个前缀。所以只需要每次合并时，线段树上二分出这个前缀的位置来即可。</p>
<p>然后实现的时候需要注意，二分完前缀之后，前缀的贡献是 $1$ ，剩下的后缀贡献不是 $cnt_{rc}$ 而是 $cnt_{root}-cnt_{lc}$ 。因为此时需要加上的是<strong>合并之后</strong>右区间对整体有多少贡献。</p>
<p>这样线段树二分 $1$ 个 $\log $ ，本身 <code>update</code> 又是 $1$ 个 $\log $ 。复杂度 $m\log ^2 n$ 。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line">db base[N] ;</span><br><span class="line">db s[N * <span class="number">3</span>] ; </span><br><span class="line"><span class="keyword">int</span> cnt[N * <span class="number">3</span>] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		s[rt] = <span class="number">0</span> ; </span><br><span class="line">		cnt[rt] = <span class="number">1</span> ; <span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	build(ls, l, mid) ; </span><br><span class="line">	build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, db v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">		<span class="keyword">return</span> (s[rt] &gt; v) ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">if</span> (s[ls] &gt; v) </span><br><span class="line">		<span class="keyword">return</span> query(ls, l, mid, v) + cnt[rt] - cnt[ls] ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">void</span>(s[rt] = base[l]) ; </span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= p) </span><br><span class="line">		update(ls, l, mid, p) ; </span><br><span class="line">	<span class="keyword">else</span> update(rs, mid + <span class="number">1</span>, r, p) ; </span><br><span class="line">	s[rt] = max(s[ls], s[rs]) ; </span><br><span class="line">	cnt[rt] = cnt[ls] + query(rs, mid + <span class="number">1</span>, r, s[ls]) ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">	build(<span class="number">1</span>, <span class="number">1</span>, n) ; <span class="keyword">int</span> x ; db y ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">		x = qr(), y = qr(), base[x] = (<span class="number">1.0</span> * y) / (<span class="number">1.0</span> * x) ; </span><br><span class="line">		update(<span class="number">1</span>, <span class="number">1</span>, n, x) ; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">0</span>)) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CF671E-Organizing-a-Race"><a href="#CF671E-Organizing-a-Race" class="headerlink" title="CF671E Organizing a Race"></a>CF671E Organizing a Race</h1><blockquote>
<p>有 $n$ 个点依次排成一列，第 $i$ 个点与第 $i + 1$ 个点之间的距离为 $w_i$ 个单位。</p>
<p>第 $i$ 个点有一个加油站，可以给你的车加能跑 $g_i$ 个单位的油。</p>
<p>你需要在 $l, r$ 之间往返（$l \le r$），也就是说，要满足一辆没有油的车能从 $l$ 一路向右开到 $r$，也能从 $r$ 一路向左开到 $l$。</p>
<p>车会在起点加好油，你可以在中途加油，但是方向是不能改变的。你可以假设车的油箱是无限大的。</p>
<p>你还没选好 $l, r$ 的具体取值，不过你希望让你经过的点数尽量多，也就是让 $r - l + 1$ 尽量大。</p>
<p>你现在有 $k$ 个机会，每个机会可以将任意一个 $g_i$ 增加 $1$。</p>
<p>问：使用 $k$ 次机会后，能得到的最大的 $r - l + 1$ 是多少？</p>
</blockquote>
<p>这个地方的转化会单独开一篇新的 $blog$，因为比较毒瘤。大概最后就是转化成了令</p>
<script type="math/tex; mode=display">
t_i=suf_i-\min_{j=1}^i\{suf'_j\}</script><p>求最大的 $i$ 满足 $t_i\leq k$ 。然后要支持 $suf’_i$ 的区间加/减以及多次询问。</p>
<p>考虑后一半就是前缀最小值，因为带上修改比较麻烦，所以维护起来依然要选择楼房重建的方式，拿左区间的最小值去二分右区间的前缀。于是可以比较简单地维护出一个区间的 $\min\{t_i\}$ 。</p>
<p>考虑修改。修改的话就是暴力打标记，注意到 $t_i$ 中的 $suf’$ 是负贡献，被 $\min$ 套着，但由于是区间修改所以可以直接减。</p>
<p>考虑如何查询。询问比较麻烦，因为相当于查询时要合并多个区间的单调栈，所以无法直接线段树二分。或者说，需要魔改一下二分，让这个二分可以「边二分，边合并」。</p>
<p>考虑一种比较神秘的方式去找。<code>query(root, l, r, val)</code> 查询的是区间 $[1,l-1]$ 内某个数 <code>val</code>，作为前缀最小值对区间 $[l,r]$ 有影响时，最靠右的 $\leq m$ 的位置。那么考虑分类：</p>
<p>1、如果当前左孩子区间的 $\min\{suf_j’\}$ 比 $val$ 要小，说明当前的前缀最小值不会对右区间产生影响(因为左右区间已经合并了)，那么就可以直接判断在算上左区间对右区间贡献时，右区间 $t$ 的最小值是否 $\leq m$  —— 这就是比较朴素的线段树上二分 —— 如果是的话就应该去右儿子里面找，否则去左儿子里找。</p>
<p>2、如果当前左孩子区间的 $\min\{suf_j’\}$ 比 $val$ 要大，说明左区间对右区间产生的贡献会被 $val$ 产生的贡献代替，所以直接递归进右孩子。并且由于 $val$ 已经变成了当前左区间的前缀最小值，所以左区间的 $\min\{suf_j’\}$ 就变成了无用信息(因为肯定都比 $val$ 大)，只需要查询在 $a_i+val\leq m$ 时的最大下标即可，这一部分可以直接线段树二分。</p>
<p>但…这似乎也不是最终的查询。考虑为了让最后的 $\min_{j=1}^i\{suf’_j\}$ 真的变成从 $1$ 开始到 $i$ 结束的最小值， 所以需要动态修改 $val$ 的值。先序遍历线段树即可。当然也可以直接维护一个前缀最小 $suf’$ 。</p>
<p>这里就先只给出线段树部分的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll s[N * <span class="number">3</span>] ;</span><br><span class="line">ll sa[N * <span class="number">3</span>] ;</span><br><span class="line">ll sb[N * <span class="number">3</span>] ;</span><br><span class="line">ll tag[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;<span class="comment">//bingo</span></span><br><span class="line">	<span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">		s[ls] -= tag[rt] ;</span><br><span class="line">		s[rs] -= tag[rt] ;</span><br><span class="line">		sb[ls] += tag[rt] ;</span><br><span class="line">		sb[rs] += tag[rt] ;</span><br><span class="line">		tag[ls] += tag[rt] ;</span><br><span class="line">		tag[rs] += tag[rt] ;</span><br><span class="line">		tag[rt] = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt ,<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line">	<span class="keyword">if</span> (l == r)</span><br><span class="line">		<span class="keyword">return</span> sa[rt] - v ; <span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">	<span class="keyword">if</span> (sb[ls] &gt;= v)</span><br><span class="line">    <span class="keyword">return</span> min(solve(rs, mid + <span class="number">1</span>, r, v), sa[ls] - v) ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> min(solve(ls, l, mid, v), s[rt]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		sa[rt] = ss[l] ; </span><br><span class="line">    sb[rt] = ss[l]</span><br><span class="line">    <span class="keyword">return</span>  ;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	build(ls, l, mid) ;</span><br><span class="line">	build(rs, mid + <span class="number">1</span>, r) ;</span><br><span class="line">	sa[rt] = min(sa[ls], sa[rs]) ;</span><br><span class="line">	sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">	s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">		tag[rt] += v ;</span><br><span class="line">		sb[rt] += v ;</span><br><span class="line">		s[rt] -= v ; <span class="comment">//1</span></span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	_down(rt, l, r) ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= mid)</span><br><span class="line">		update(ls, l, mid, ul, ur, v) ;</span><br><span class="line">	<span class="keyword">if</span> (ur &gt; mid)</span><br><span class="line">		update(rs, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">	sb[rt] = min(sb[ls], sb[rs]) ;</span><br><span class="line">	s[rt] = solve(rs, mid + <span class="number">1</span>, r, sb[ls]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (sa[rs] &gt; v)</span><br><span class="line">		<span class="keyword">return</span> ask(ls, l, mid, v) ;</span><br><span class="line">	<span class="keyword">return</span> ask(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll &amp;v)</span></span>&#123;<span class="comment">//bingo</span></span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		<span class="keyword">int</span> ret ;</span><br><span class="line">		ret = sa[rt] - v &lt;= m ? l : <span class="number">0</span> ;</span><br><span class="line">		v = min(v, sb[rt]) ;</span><br><span class="line">		<span class="keyword">return</span> ret ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">	<span class="keyword">if</span> (sb[ls] &lt; v)&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[rt] &lt;= m)&#123;</span><br><span class="line">			v = sb[ls] ;</span><br><span class="line">			<span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> ret ;</span><br><span class="line">			ret = query(ls, l, mid, v) ;</span><br><span class="line">			v = min(v, sb[rt]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">if</span> (sa[rt] - v &lt;= m)</span><br><span class="line">			ret = ask(ls, l, mid, m + v) ;</span><br><span class="line">		<span class="keyword">return</span> max(ret, query(rs, mid + <span class="number">1</span>, r, v)) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数据结构/线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】bzoj2391 Cirno的忧郁</title>
    <url>/2020/04/15/Cirno-%E7%9A%84%E5%BF%A7%E9%83%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Cirno 闲着无事的时候喜欢冰冻青蛙。</p>
<p>雾之湖生活着 $m$ 只青蛙，青蛙有大有小，所以每只青蛙的价值为一个不大于 $10000$ 的正整数。</p>
<p>Cirno 每次从雾之湖中固定的 $n$ 个结点中选出一些点构成一个简单多边形，Cirno 运用自己的能力能将此多边形内所有青蛙冰冻。Cirno 很想知道每次冻住的青蛙的价值总和。因为智商有限，Cirno 将这个问题交给完美算术教室里的你。</p>
<p>因为爱护动物，所以每次冻结的青蛙会被放生。也就是说一只青蛙可以被多次统计。</p>
<p>对于 $100\%$ 的数据，$n,m\leq 10^3, q\leq 10^4,-10^4\leq x,y\leq 10^4,0&lt;v\leq 10^4$ 。</p>
</blockquote>
<p>不知道为什么校内测试，某 NOIP 模拟题考了三角剖分…但不知道为什么一眼就看出是三角剖分。</p>
<p>紧接着发现是 bzoj 原题，学了一波三角剖分+温习了一遍向量之后感觉这题有点猛男。</p>
<a id="more"></a>
<p>大概考虑三角剖分本来是用于求多边形面积，方法是选择一个原点，按照逆时针或者顺时针的方式，把多边形顶点向量叉一圈的结果。形式化地讲，给定一个多边形 $A_1A_2A_3\ldots A_n$ ，那么这个多边形的面积就是</p>
<script type="math/tex; mode=display">
\frac{\overrightarrow{O A_{n}}\times \overrightarrow{OA_1}}{2}+\sum_{i=1}^{n-1} \frac{\overrightarrow{O A_{i}}\times \overrightarrow{OA_{i+1}}}{2}</script><p>证明的话可能容斥可证，但我不会…我只知道两个向量的叉积是以这两个向量为临边的平行四边形的面积。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://www.wjyyy.top/wp-content/uploads/2019/02/201902140847.png" alt="wjyyy的图"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://www.wjyyy.top/wp-content/uploads/2019/02/201902140906.png" alt="wjyyy的图"></p>
<p>然后这里放了神仙 <code>wjyyy</code> 的图，看上去比较直观。</p>
<p>然后考虑这题怎么做。发现 $n+m$ 不大，于是考虑求一个 $f_{i,j}$ 表示向量 $\bf V_i$ 与 $\bf V_{j}$ 之间，$\bf V_{i}\to \bf V_{j}$ 需要逆时针旋转时，$i,j$ 之间的价值和。那么对于每一个询问 $\{s_n\}$ ，答案就是 $\sum f_{s_i,s_{i+1}}$ 。 </p>
<p>考虑如何预处理这个东西。首先对所有向量按照极角逆时针排序(相等则模长大者位次靠后)，枚举 $i$ ，之后就需要喜闻乐见的平衡树了。大概是这样：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<p>其中红色向量是题目所给的向量，蓝色向量是辅助线。因为一开始就已经是逆时针排序，所以只需要判断每个向量的中点是否落在向量 $\bf i,j,t_2$ 构成的三角形即可。观察落在三角形内部的向量 $\bf k$ 和落在外部的向量 $\bf p$ ，会发现有 </p>
<script type="math/tex; mode=display">
\bf {\text{<}i,t_1\text{>} \geq \text{<}i,t_2\text{>}\geq \text{<}i,t_3\text{>}}</script><p>考虑向量夹角最大为 $\pi$ ，$y=\cos x$ 在 $[0,\pi]$ 上单调递减，于是可以知道要拿 $\cos x$ 作为键值，该向量的 $val$ 作为点值插入平衡树。其中 $\cos x$ 拿向量内积求即可。 </p>
<p>最终复杂度 $O(n^2\log n+ms)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> f[N][N] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pts</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id ; <span class="keyword">int</span> val ; db x, y ;</span><br><span class="line">	<span class="function">il db <span class="title">mo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y) ; &#125;</span><br><span class="line">	il <span class="keyword">friend</span> pts <span class="keyword">operator</span> - (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line">		<span class="keyword">return</span> (pts)&#123;<span class="number">0</span>, <span class="number">0</span>, p.x - q.x, p.y - q.y&#125; ;</span><br><span class="line">	&#125;</span><br><span class="line">	il <span class="keyword">friend</span> db <span class="keyword">operator</span> * (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line">		<span class="keyword">return</span> p.x * q.y - p.y * q.x ;</span><br><span class="line">	&#125;</span><br><span class="line">	il <span class="keyword">friend</span> db <span class="keyword">operator</span> + (ct pts &amp;p, ct pts &amp;q)&#123;</span><br><span class="line">		<span class="keyword">return</span> p.x * q.x + p.y * q.y ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;v[N], org, calc[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il db <span class="title">cosi</span><span class="params">(pts a, pts b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a + b) / (a.mo() * b.mo()) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(pts a, pts b)</span></span>&#123;</span><br><span class="line">	db ang = (a - org) * (b - org) ;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; ang &lt;&lt; '\n' ;</span></span><br><span class="line">	<span class="keyword">if</span> (ang != eps) <span class="keyword">return</span> ang &gt; eps ;</span><br><span class="line">	<span class="keyword">return</span> (a - org).mo() &lt; (b - org).mo() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _splay&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">splay</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">		<span class="keyword">int</span> tot ;</span><br><span class="line">		<span class="keyword">int</span> val ;</span><br><span class="line">		<span class="keyword">int</span> sum ;</span><br><span class="line">		<span class="keyword">int</span> fa ;</span><br><span class="line">		<span class="keyword">int</span> sz ;</span><br><span class="line">		db key ;</span><br><span class="line">	&#125;s[N] ;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> sz(x) s[x].sz</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> fa(x) s[x].fa</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> val(x) s[x].val</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> key(x) s[x].key</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> tot(x) s[x].tot</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> sum(x) s[x].sum</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].son[0]</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].son[1]</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> size ;</span><br><span class="line">	<span class="keyword">int</span> root ;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x == rc(fa(x))) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= size ; ++ i)&#123;</span><br><span class="line">			sz(i) = lc(i) = rc(i) = fa(i) = <span class="number">0</span> ;</span><br><span class="line">			tot(i) = val(i) = key(i) = sum(i) = <span class="number">0</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		size = <span class="number">0</span> ; root = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		sz(x) = tot(x) ;</span><br><span class="line">		sum(x) = val(x) ;</span><br><span class="line">		<span class="keyword">if</span> (lc(x))&#123;</span><br><span class="line">			sz(x) += sz(lc(x)) ;</span><br><span class="line">			sum(x) += sum(lc(x)) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (rc(x))&#123;</span><br><span class="line">			sz(x) += sz(rc(x)) ;</span><br><span class="line">			sum(x) += sum(rc(x)) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> c = w(x) ;</span><br><span class="line">		<span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">		<span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">		<span class="keyword">if</span> (!f2) root = x ;</span><br><span class="line">		<span class="keyword">else</span> s[f2].son[w(f1)] = x ;</span><br><span class="line">		fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">		fa(s[x].son[c ^ <span class="number">1</span>]) = f1 ;</span><br><span class="line">		s[f1].son[c] = s[x].son[c ^ <span class="number">1</span>] ;</span><br><span class="line">		s[x].son[c ^ <span class="number">1</span>] = f1 ; upd(f1), upd(x) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> aim)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (fa(x) != aim)&#123;</span><br><span class="line">			<span class="keyword">if</span> (fa(fa(x)) != aim)</span><br><span class="line">				rotate(w(x) == w(fa(x)) ? fa(x) : x) ;</span><br><span class="line">			rotate(x) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> &amp;x, db ky, <span class="keyword">int</span> v, <span class="keyword">int</span> dad)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!x)&#123;</span><br><span class="line">			x = ++ size ;</span><br><span class="line">			fa(x) = dad ;</span><br><span class="line">			key(x) = ky ;</span><br><span class="line">			val(x) = sum(x) = v ;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ky &lt; key(x))</span><br><span class="line">			Ins(lc(x), ky, v, x) ;</span><br><span class="line">		<span class="keyword">else</span> Ins(rc(x), ky, v, x) ; upd(x) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> _splay ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	org.x = <span class="number">-100000</span> ;</span><br><span class="line">	org.y = <span class="number">-100000</span> ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">	db x, y, w ; <span class="keyword">int</span> z, h, r ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y, v[++ cnt] = (pts)&#123;i, <span class="number">0</span>, x, y&#125; ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span> ; i &lt;= n + m ; ++ i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w, v[++ cnt] = (pts)&#123;i, w, x, y&#125; ;</span><br><span class="line">	sort(v + <span class="number">1</span>, v + cnt + <span class="number">1</span>, comp) ; m = n ; n = cnt ; <span class="built_in">cin</span> &gt;&gt; q ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (v[i].id &gt; m) <span class="keyword">continue</span> ;</span><br><span class="line">		clear() ; pts o = v[i] - org ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">			pts z = v[j] - v[i] ; db ky = cosi(o, z) ;</span><br><span class="line"><span class="comment">//			cout &lt;&lt; root &lt;&lt; '\n' ;</span></span><br><span class="line">			Ins(root, ky, v[j].val, <span class="number">0</span>) ; splay(size, <span class="number">0</span>) ;</span><br><span class="line">        	<span class="keyword">if</span>(v[j].id &lt;= m)&#123;</span><br><span class="line">        	    f[v[i].id][v[j].id] = sum(lc(root)) ;</span><br><span class="line">        	    f[v[j].id][v[i].id] = - sum(lc(root)) ;</span><br><span class="line">        	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">		for (int j = 1 ; j &lt;= n ; ++ j)</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; f[i][j] &lt;&lt; " \n"[j == n] ; */</span></span><br><span class="line">	<span class="keyword">while</span> (q --)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; L ; <span class="built_in">cin</span> &gt;&gt; h ; r = h ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; ++ i)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; z, ans += f[h][z], h = z ;</span><br><span class="line">		ans += f[h][r] ; <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, <span class="built_in">abs</span>(ans)) ; ans = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写了一遍 splay，发现是真的慢+维护的信息真的多…</p>
<p>并且发现递归式的 splay 插入是真的好写。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>计算几何/三角剖分</tag>
        <tag>数据结构/平衡树/splay</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】bzoj3881[COCI2015] Divljak</title>
    <url>/2020/04/15/COCI2015-Divljak/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Alice 有 $n$ 个字符串 $\rm S_1,S_2,\dots,S_n$，Bob 有一个字符串集合 $\rm T$ ，一开始集合是空的。</p>
<p>接下来会发生 $q$ 个操作，操作有两种形式：</p>
<ol>
<li><code>1 P</code> Bob 往自己的集合里添加了一个字符串 $\rm P$。</li>
<li><code>2 x</code> Alice 询问 Bob，集合 $\rm T$ 中有多少个字符串包含串 $\rm S_x$（我们称串 $\rm A$ 包含串 $\rm B$，当且仅当 $\rm B$ 是 $\rm A$ 的子串）。</li>
</ol>
<p>对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，所有字符串的总长 $\le 2 \times 10^6$。</p>
</blockquote>
<p>今天突然和 zay 聊起 ACAM 来，于是想到还有这道好题没整理。</p>
<p>啊，这题背后可是记载着光荣岁月啊…但这是只有我和 zay 知道的秘密/qq</p>
<a id="more"></a>
<p>大概是考虑，反正是匹配问题——那么是对着 $\rm T$ 建自动机呢，还是对 $\rm \{S_n\}$ 建。 考虑 AC 自动机更适合做这种匹配题，于是大概想到要拿 AC 自动机做；考虑如果对着 $\rm T$ 建自动机，树的形态会变，$\rm S$ 的信息需要动态维护，并不很好做，于是考虑对 $\rm S$ 建自动机 $\rm AC_s$。</p>
<p>考虑这样做，就需要在已经建好的自动机上，对于每个新加进来的 $P$ 计算贡献。那么会被 $P$ 包含的字符串，一定是 $P$ 在 $\rm AC_s$ 里匹配的 $endpos$ 到根的路径上每个点，到根的链上的点集并。暴力是 $n^2$ 的，考虑如何快速计算这个贡献，发现能做到最快的，也就是通过维护 dfs 序的方式求出点集并。对于每一个这样的链的并打一个标记。询问的时候只需要回答一下子树内有多少个点被打了不同的标记。</p>
<p>发现「维护树链标记」+「子树求和」，最快速的方法是维护差分。同时由于是动态的，可以想到用线段树或者 BIT 快速维护。</p>
<p>考虑修改如何进行。发现为了保证 $\land$ 形态的链只会被计数一次，需要在 $lca$ 处差分。此处需要注意的是，要对 $dfs$ 序排序之后，再逐个差分，方法是 $(i,+1),(i+1,+1),(lca_{i,i+1},-1)$ 。</p>
<p>想了半天才大约明白为什么要按 dfs 序排一遍序。大概是如果不按 dfs 序的顺序枚举，可能会出现某个子树未被成功打上标记的情况。</p>
<p>最终复杂度是 $O(\rm |S|\log |S|)$ 的，跑的不是很快。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sigma 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2001010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> T, M, N, L[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], base[MAXN], cnt, tot ;</span><br><span class="line"><span class="keyword">int</span> _ed[MAXN], dfn[MAXN], rgl[MAXN], rgr[MAXN], tp ;</span><br><span class="line"><span class="keyword">int</span> sz[MAXN], dep[MAXN], fa[MAXN], top[MAXN], son[MAXN], val[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dep[u] = dep[fa[u]] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        fa[to(k)] = u, dfs(to(k)), sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp,</span><br><span class="line">    dfn[u] = rgl[u] = ++ tot ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs2(son[u], tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u]) dfs2(to(k), to(k)) ;</span><br><span class="line">    rgr[u] = tot ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">return</span> dfn[x] &lt; dfn[y] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &gt;= dep[top[v]]) u = fa[top[u]] ;</span><br><span class="line">        <span class="keyword">else</span> v = fa[top[v]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> rt)&#123;</span><br><span class="line">    val[rt] = val[rt &lt;&lt; <span class="number">1</span>] + val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] += v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= p)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, v) ;</span><br><span class="line">    _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pl, <span class="keyword">int</span> pr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= pl &amp;&amp; pr &gt;= r) <span class="keyword">return</span> val[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (pl &lt;= mid) res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, pl, pr) ;</span><br><span class="line">    <span class="keyword">if</span> (pr &gt; mid) res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, pl, pr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> _size, fail[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L[n] ; ++ i)&#123;</span><br><span class="line">            x = s[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trie[rt][x])</span><br><span class="line">                trie[rt][x] = ++ _size ;</span><br><span class="line">            rt = trie[rt][x] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[n] = rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trie[<span class="number">0</span>][i]) q.push(trie[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.front() ; add(fail[n], n), q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trie[n][i]) trie[n][i] = trie[fail[n]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[trie[n][i]] = trie[fail[n]][i], q.push(trie[n][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> *S)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, rt = <span class="number">0</span> ; tp = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            x = S[i] - <span class="string">'a'</span>, rt = trie[rt][x], base[++ tp] = rt ;</span><br><span class="line">        sort(base + <span class="number">1</span>, base + tp + <span class="number">1</span>, comp),</span><br><span class="line">        tp = unique(base + <span class="number">1</span>, base + tp + <span class="number">1</span>) - base - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tp ; ++ i)&#123;</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, tot, dfn[base[i]], <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, tot, dfn[lca(base[i], base[i - <span class="number">1</span>])], <span class="number">-1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;AC ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) r = (r &lt;&lt; <span class="number">1</span>) + (r &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("1.in", "r", stdin) ;</span></span><br><span class="line">    <span class="comment">// freopen("1.ans", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> m, q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= T ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), L[i] = <span class="built_in">strlen</span>(S + <span class="number">1</span>), AC.insert(S, i) ;</span><br><span class="line">    AC.build() ; <span class="built_in">cin</span> &gt;&gt; M ; dfs(<span class="number">0</span>), dfs2(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= T ; ++ i) cout &lt;&lt; rgl[i] &lt;&lt; " " &lt;&lt; rgr[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">while</span> (M --)&#123;</span><br><span class="line">        m = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), AC.solve(S) ;</span><br><span class="line">        <span class="keyword">else</span> q = qr(),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, tot, <span class="number">1</span>, rgr[_ed[q]]) - query(<span class="number">1</span>, <span class="number">1</span>, tot, <span class="number">1</span>, rgl[_ed[q]] - <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>树上技巧/dfs序+树状数组</tag>
        <tag>字符串/AC自动机</tag>
        <tag>数据结构/树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[CF626F]Group Projects</title>
    <url>/2020/04/15/CF626F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>有 $n$ 个学生，每个学生有一个能力值 $a_i$。现在要把这些学生分成一些(任意数量的)组，每一组的“不和谐度”是该组能力值最大的学生与能力值最小的学生的能力值的差。求所有不和谐度之和不超过 $k$ 的分组方案总数对 $10^9+7$ 取模。</p>
<p>$n\leq 200,k\leq 1000,0\leq a_i\leq 500$</p>
</blockquote>
<p>从头开始的计数生活.png</p>
<a id="more"></a>
<p>考虑暴力计数，大概就是 $f_{i,j,k}$ 表示考虑了前 $i$ 个学生，分了 $j$ 组，当前不和谐度总和为 $k$ 的方案数。发现这样没法转移，因为并不知道该怎么考虑插入一个元素时的贡献。考虑对于一种状态，如果钦定了其中某些集合的最大值或者最小值已经固定，如果当前元素超过了这个 bond，就不能再用当前元素更新。于是考虑另一种状态，$f_{i,j,k}$ 表示考虑了前 $i$ 个学生，分了不知道组，但是有 $j$ 组的最大值还没确定，当前不和谐度总和为 $k$ 的方案数 。这样显然是需要将所有权值排序之后再 $dp$ 的。</p>
<p>考虑转移。每次遇到一个新的元素，可以将其和之前的某一组合并，或者单独新开一组。记没确定最大值的集合为「未闭合集合」，那么就有四种情况：</p>
<p>1、合并，但是那个集合仍未闭合。</p>
<p>2、合并，那个集合闭合了。</p>
<p>3、不合并，新开的集合未闭合。</p>
<p>4、不合并，新开的集合闭合了。</p>
<p>于是转移就是</p>
<script type="math/tex; mode=display">
f_{i,j,k}=\sum \begin{cases}j\times f_{i-1,j,k}\\ (j+1)\times f_{i-1,j+1,k+a_i}\\ f_{i-1,j-1,k-a_i}\\f_{i-1,j,k}\end{cases}</script><p>分别对应四种情况。</p>
<p>考虑这么做的复杂度，似乎是 $O(n^2k)$ ，但是由于中间转移过程的第三维可能会到 $\pm 10^4$ ，大小无法准确预估，所以时空复杂度都是 $O(n^2\sum a_i)$ 的。于是就 gg 。</p>
<p>考虑稍微抽象一下，每个集合的 $min/max$ 可以看做在一条值域轴上线段的左、右端点，对于每个时刻 $i$ ，未闭合的集合就是某些会被 $i$ 横切掉的线段。那么对于某条直线 $(l,r)$ ，满足 $l&lt;i&lt;r$ ，在第 $i$ 个时刻，记录的是代价是 $-a_l$，但这种方法并不聪明，因为只有当取到 $r$ 时，$-a_l$ 才会被用上，所以对于任意一个 $i,l&lt;i&lt;r$ 而言，$-a_l$ 都是没必要承载的空间。于是考虑怎么将一条线段的贡献平摊到每个点上，这样每一维转移就不再是 $O(\max\{\sum a_i,k\})$ 而是 $O(\max\{a_i,k\})$ 。</p>
<p>考虑平摊的话，即如何将 $a_r-a_l$ 展开成每一项都 $&lt;\max\{a_i,k\}$ 的这么一个数列。一个比较简单的方法就是：</p>
<script type="math/tex; mode=display">
a_r-a_l=\sum_{i=l+1}^r(a_i-a_{i-1})</script><p><del>一看就是老分式裂项了</del></p>
<p>于是本质上只是优化了转移。令 $d=a_i-a_{i-1}$ 可以得到：</p>
<script type="math/tex; mode=display">
f_{i,j,k}=\sum \begin{cases}j\times f_{i-1,j,k-j\times d}\\ (j+1)\times f_{i-1,j+1,k-(j+1)\times d}\\ f_{i-1,j-1,k-(j-1)\times d}\\f_{i-1,j,k-j \times d}\end{cases}</script><p>然后就没有然后了，复杂度 $O(n^2\max\{k,\max\{a_i\}\})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 510</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXK 1010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line">LL dp[<span class="number">2</span>][MAXN][MAXK], ans ;</span><br><span class="line"><span class="keyword">int</span> N, K, M, base[MAXN], dif[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123; x -= y ; <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += Mod ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(LL &amp;x, <span class="keyword">const</span> LL &amp;y)</span></span>&#123; x += y ; <span class="keyword">if</span> (x &gt; Mod) x %= Mod ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; <span class="keyword">int</span> i, j, k, d ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"> 	sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>), dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) dif[i] = base[i + <span class="number">1</span>] - base[i] ;</span><br><span class="line">	<span class="keyword">for</span> (d = i = <span class="number">1</span> ; i &lt; N ; ++ i, d ^= <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> o = d ^ <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">			<span class="keyword">int</span> op = dif[i] * j ;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= K ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">int</span> val = k + op ;</span><br><span class="line">				LL res = dp[o][j][k], v = res * j % Mod ;</span><br><span class="line">				dp[o][j][k] = <span class="number">0</span> ; <span class="keyword">if</span> (val &gt; K) <span class="keyword">continue</span> ;</span><br><span class="line">				<span class="keyword">if</span> (j) add(dp[d][j - <span class="number">1</span>][val], v) ; </span><br><span class="line">				add(dp[d][j][val], v + res), add(dp[d][j + <span class="number">1</span>][val], res) ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) </span><br><span class="line">		add(ans, dp[(N - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">0</span>][i]) ; </span><br><span class="line">  	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划/有技巧的DP</tag>
        <tag>思维题/计数</tag>
        <tag>思维题/找性质</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[Ynoi2019]Yuno loves sqrt technology II</title>
    <url>/2020/04/12/Ynoi2019%E6%A8%A1%E6%8B%9F%E8%B5%9B-Yuno-loves-sqrt-technology-II/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定一个序列 $\{a_n\}$，多次询问某个区间的逆序对数。</p>
<p>$1\leq n,m\leq 10^5,|a_i|\leq 10^9$ 。</p>
</blockquote>
<p>这还是我第一次认真做了 lxl 的由乃 OI 题目，233.</p>
<a id="more"></a>
<p>还是考虑二次离线，那么需要预处理</p>
<script type="math/tex; mode=display">
\sum_{i=1}^k (i,i)(1,i-1)\quad | \quad \sum_{i=1}^k (i,i)(1,i)</script><p>和</p>
<script type="math/tex; mode=display">
\sum_{i=k+1}^n (i,i)(i+1,n)\quad | \quad \sum_{i=k+1}^n (i,i)(i,n)</script><p>这 $4$ 个信息，因为在计算逆序对的时候是有方向性的，$l$ 向左扩展/向右收缩对应的是 $(l+1,n)$ 之间的信息，$r$ 向右扩展/左收缩对应的是 $(1,r-1)$ 之间的信息。同时注意到由于 $(i,i)(1,i)=(i,i)(1,i-1)$ ，所以本质上是两个信息。这个可以 $O(n\log n)$ 预处理。</p>
<p>同理，对于不能预处理的区间，也是要分左边的贡献和右边的贡献来做。根据方向，可以方便地判断每种情况贡献应该怎么加，拿两种值域分块，分别维护前缀和&amp;后缀和就好了。</p>
<p>实现细节方面需要注意：</p>
<p>1、本题数据中存在 $a_i$ 相同的情况，这个地方会卡求逆序对时的边界，注意判一下即可。</p>
<p>2、值域分块需要注意，只需要修改整块的 <code>sum</code>，零散的点单独算贡献。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lwb lower_bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> B ;</span><br><span class="line"><span class="keyword">int</span> V ;</span><br><span class="line"><span class="keyword">int</span> L ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">ll s1[N] ;</span><br><span class="line">ll s2[N] ;</span><br><span class="line">ll res[N] ;</span><br><span class="line">ll ans[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> blv[N] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> sumb[N] ;</span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qrd</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qrd(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qrd;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; ql[N], qr[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span> <span class="keyword">int</span> id, l, r ;&#125; q[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> query &amp;a, <span class="keyword">const</span> query &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">		   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= p &amp; -p) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= V ; p += p &amp; -p) _bit[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Inssuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = blv[x] + <span class="number">1</span> ; i &lt;= blv[V] ; ++ i) sumb[i] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; blv[x] == blv[i] &amp;&amp; i &lt;= V ; ++ i) sump[i] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Asksuf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sump[x] + sumb[blv[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Inspre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= blv[x] - <span class="number">1</span> ; ++ i) sumb[i] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x ; blv[x] == blv[i] &amp;&amp; i &gt;= <span class="number">1</span> ; -- i) sump[i] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Askpre</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sump[x] + sumb[blv[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	qrd(n), qrd(m), B = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        qrd(base[i]), tmp[i] = base[i] ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ;</span><br><span class="line">    L = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        base[i] = lwb(tmp + <span class="number">1</span>, tmp + L + <span class="number">1</span>, base[i]) - tmp ;</span><br><span class="line">        V = max(base[i], V) ; bl[i] = i / B ;</span><br><span class="line">    &#125;</span><br><span class="line">    B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= V ; ++ i) blv[i] = i / B + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        s2[i] = s2[i + <span class="number">1</span>] + ask(base[i] - <span class="number">1</span>), add(base[i]) ;</span><br><span class="line">    fill(_bit, _bit + V + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        s1[i] = s1[i - <span class="number">1</span>] + i - <span class="number">1</span> - ask(base[i]), add(base[i]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">		qrd(q[i].l), qrd(q[i].r), q[i].id = i ;</span><br><span class="line">	sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; q[<span class="number">0</span>].l = <span class="number">1</span>, q[<span class="number">0</span>].r = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> newl = q[i].l ;</span><br><span class="line">		<span class="keyword">int</span> newr = q[i].r ;</span><br><span class="line">		<span class="keyword">int</span> l = q[i - <span class="number">1</span>].l ;</span><br><span class="line">		<span class="keyword">int</span> r = q[i - <span class="number">1</span>].r ;</span><br><span class="line">		ans[i] -= s2[l] + s1[r] ;<span class="comment">//l 的贡献变成了一个后缀，原来是 l'-(l-1),现在变成了 l-l'</span></span><br><span class="line">		ans[i] += s2[newl] + s1[newr] ;<span class="comment">//l 和 r 要分开计算贡献</span></span><br><span class="line">		<span class="keyword">if</span> (newl &lt; l)</span><br><span class="line">			qr[newr + <span class="number">1</span>].emplace_back(newl, l - <span class="number">1</span>, -i) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newl &gt; l)</span><br><span class="line">			qr[newr + <span class="number">1</span>].emplace_back(l, newl - <span class="number">1</span>, i) ;</span><br><span class="line">		<span class="keyword">if</span> (newr &lt; r)</span><br><span class="line">			ql[l - <span class="number">1</span>].emplace_back(newr + <span class="number">1</span>, r, i) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newr &gt; r)</span><br><span class="line">			ql[l - <span class="number">1</span>].emplace_back(r + <span class="number">1</span>, newr, -i) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        Inspre(base[i]) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : ql[i])&#123;</span><br><span class="line">			<span class="keyword">int</span> l, r, id ;</span><br><span class="line">			tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o)</span><br><span class="line">                tmp += Askpre(base[o] + <span class="number">1</span>) ;</span><br><span class="line">			<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">                ans[id * (<span class="number">-1</span>)] -= tmp ;</span><br><span class="line">            <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">memset</span>(sumb, <span class="number">0</span>, <span class="keyword">sizeof</span>(sumb)) ;</span><br><span class="line">    <span class="built_in">memset</span>(sump, <span class="number">0</span>, <span class="keyword">sizeof</span>(sump)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        Inssuf(base[i]) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : qr[i])&#123;</span><br><span class="line">			<span class="keyword">int</span> l, r, id ;</span><br><span class="line">			tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o)</span><br><span class="line">                tmp += Asksuf(base[o] - <span class="number">1</span>) ;</span><br><span class="line">			<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">                ans[id * (<span class="number">-1</span>)] -= tmp ;</span><br><span class="line">            <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ans[i] += ans[i - <span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) res[q[i].id] = ans[i] ; </span><br><span class="line">	qwa(res, n, <span class="string">'\n'</span>, <span class="string">'\n'</span>) ;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>技巧/二次离线</tag>
        <tag>数据结构/数据结构方法/莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】莫队二次离线</title>
    <url>/2020/04/11/%E8%8E%AB%E9%9A%8A%E4%BA%8C%E6%AC%A1%E9%9B%A2%E7%B7%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前一直以为会很难，但在重听了 dls 讲的课之后感觉好像有点深刻，于是打算整理一下。</p>
<p>另附 pks 词典：</p>
<blockquote>
<p>『有点深刻』：感觉好像听明白了，但是还有细节没太懂，如果要是让我写我肯定写不出来。</p>
<p>『有点神奇』：大致都听明白了，精髓什麽的都理解的十分透彻，只是实现方面还是不太会。</p>
<p>『 』(无评价) ：学会了。</p>
</blockquote>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>大概是一种需要维护信息具有可减性的莫队。只要具可减性，就可以容斥，就可以二次离线。所谓『二次离线』，大概是指由于普通莫队无法快速计算贡献，所以第一次离线把询问离线下来，第二次离线把莫队的转移过程离线下来。然后由于信息具有可减性(比如常见的「点对数」)，那么可以：</p>
<p>记 $(a,b)(c,d)$ 表示区间 $[a,b]$ 内的点和区间 $[c,d]$ 内的点对彼此产生的贡献(区间内部不算)。 </p>
<p>1、如果 $[l,r]\to [l+t,r]$ ，那么可知 </p>
<script type="math/tex; mode=display">
\Delta ans=\sum_{i=l}^{l+t-1} (i,i)(i+1,r)=\sum_{i=l}^{l+t-1} \left((i,i)(1,r)-(i,i)(1,i)\right)=(l,l+t-1)(1,r)-\sum_{i=l}^{l+t-1}(i,i)(1,i)</script><p>2、如果 $[l,r]\to [l-t,r]$ ，那么可知</p>
<script type="math/tex; mode=display">
\Delta ans=\sum_{i=l-t}^{l-1} (i,i)(i+1,r)=\sum_{i=l-t}^{l-1} \left((i,i)(1,r)-(i,i)(1,i)\right)=(l-t,l-1)(1,r)-\sum_{i=l-t}^{l-1}(i,i)(1,i)</script><p>3、如果 $[l,r]\to [l,r+t]$ ，那么可知</p>
<script type="math/tex; mode=display">
\Delta ans=\sum_{i=r+1}^{r+t}(i,i)(l,i-1)=\sum_{i=r+1}^{r+t}((1,i-1)(i,i)-(1,l-1)(i,i))=-(1,l-1)(r+1,r+t)+\sum_{i=r+1}^{r+t}(i,i)(1,i-1)</script><p>4、如果 $[l,r]\to [l,r-t]$ ，那么可知</p>
<script type="math/tex; mode=display">
\Delta ans=\sum_{i=r-t+1}^{r}(i,i)(l,i-1)=\sum_{i=r-t+1}^{r}((1,i-1)(i,i)-(1,l-1)(i,i))=-(1,l-1)(r-t+1,r)+\sum_{i=r-t+1}^{r}(i,i)(1,i-1)</script><p>其中 $\sum$ 并不是真正的 $\sum$ ，不同情况下需要按顺序(即不再有交换律)，比如 $[l,r]\to [l,r-t]$ 时就需要从 $r-1$ 算到 $r-t$ 。</p>
<p>然后这样容斥之后，后面的 $\sum$ 就可以预处理了，前面的 $()()$ ，由于莫队的复杂度，可以知道至多有 $n\sqrt m$ 个不同的询问，这样就可以把每一组询问打标记，打到左端点是 $1$ 的那个询问上 (比如 $[l,r]\to [l,r-t]$ 就打到 $l-1$ 上)。最后扫一遍全部的 $i\in[1,n]\cap\mathbb{Z_+}$，这样最终复杂度 $O(n\sqrt m)$ 。可以看出比起普通的莫队，二次离线还有一个好处，就是只有 $O(n)$ 次插入，于是对于某些题就可以用值域分块的技巧做到 $O(n\sqrt m+n\sqrt n)$ 。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote>
<p>LG 4887 第十四分块(前体)</p>
<p>珂朵莉给了你一个序列 $a$，每次查询给一个区间 $[l,r]$ </p>
<p>查询 $l \leq i&lt; j \leq r$ ,且 $a_i \oplus a_j$ 的二进制表示下有 $k$ 个 $1$ 的二元组 $(i,j)$ 的个数。$\oplus$ 是指按位异或。</p>
</blockquote>
<p>似乎就是板子题，然后对于 $(i,i)(1,i-1)$ 和 $(i,i)(1,i)$ 这个东西的预处理可以拿一个桶来维护，$buc_x$ 表示有多少个数 $\oplus x$ 之后二进制位有 $k$ 个 $1$ ，剩下的就是比较典型的莫队二次离线了。</p>
<p>值得一提的是…$\binom{14}{7}=3432$ ，再乘上一个 $10^5$ ，时间根本承受不了…所以这就很神必…打算写完之后出个数据卡一卡，不知道能不能成功。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">16385</span> ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> cnt ;  </span><br><span class="line">ll s1[N] ; </span><br><span class="line">ll s2[N] ; </span><br><span class="line">ll res[N] ;</span><br><span class="line">ll ans[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ; </span><br><span class="line"><span class="keyword">int</span> bu[N] ;</span><br><span class="line"><span class="keyword">int</span> len[M] ;</span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ; </span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; qs[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span> <span class="keyword">int</span> id, l, r ;&#125; q[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(query a, query b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">		   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">	B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) ; </span><br><span class="line">	<span class="keyword">if</span> (!k) bu[++ cnt] = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; M ; ++ i)&#123;</span><br><span class="line">		len[i] = len[i - (i &amp; -i)] + <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">if</span> (len[i] == k) bu[++ cnt] = i ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) bl[i] = i / B ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">		s1[i] = s1[i - <span class="number">1</span>] + (ll)buc[base[i]] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">			buc[base[i]  ^  bu[j]] += <span class="number">1</span> ; </span><br><span class="line">		s2[i] = s2[i - <span class="number">1</span>] + (ll)buc[base[i]] ; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; s1[i] &lt;&lt; " " &lt;&lt; s2[i] &lt;&lt; '\n' ; </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ; </span><br><span class="line">	sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; q[<span class="number">0</span>].l = <span class="number">1</span>, q[<span class="number">0</span>].r = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">		<span class="comment">//emplace_back </span></span><br><span class="line">		<span class="keyword">int</span> newl = q[i].l ;</span><br><span class="line">		<span class="keyword">int</span> newr = q[i].r ;</span><br><span class="line">		<span class="keyword">int</span> l = q[i - <span class="number">1</span>].l ;</span><br><span class="line">		<span class="keyword">int</span> r = q[i - <span class="number">1</span>].r ;</span><br><span class="line">		ans[i] -= s2[l - <span class="number">1</span>] + s1[r] ; </span><br><span class="line">		ans[i] += s2[newl - <span class="number">1</span>] + s1[newr] ;</span><br><span class="line">		<span class="keyword">if</span> (newl &lt; l)</span><br><span class="line">			qs[newr].emplace_back(newl, l - <span class="number">1</span>, i) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newl &gt; l)</span><br><span class="line">			qs[newr].emplace_back(l, newl - <span class="number">1</span>, -i) ;</span><br><span class="line">		<span class="keyword">if</span> (newr &lt; r) </span><br><span class="line">			qs[l - <span class="number">1</span>].emplace_back(newr + <span class="number">1</span>, r, i) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (newr &gt; r) </span><br><span class="line">			qs[l - <span class="number">1</span>].emplace_back(r + <span class="number">1</span>, newr, -i) ;</span><br><span class="line">	&#125;</span><br><span class="line">	debug(ans, <span class="number">1</span>, m, <span class="string">'\n'</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M ; ++ i) buc[i] = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j) </span><br><span class="line">			buc[base[i] ^ bu[j]] += <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;j : qs[i])&#123;</span><br><span class="line">			<span class="keyword">int</span> l, r, id ;</span><br><span class="line">			tie(l, r, id) = j ; ll tmp = <span class="number">0</span> ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> o = l ; o &lt;= r ; ++ o) tmp += buc[base[o]] ;</span><br><span class="line">			<span class="keyword">if</span> (id &lt; <span class="number">0</span>) ans[id * (<span class="number">-1</span>)] -= tmp ; <span class="keyword">else</span> ans[id] += tmp ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) ans[i] += ans[i - <span class="number">1</span>] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) res[q[i].id] = ans[i] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[i]) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便结束之后卡了一下，写了个觉得肯定可以卡的 gen：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">16383</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">7</span> ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gene_Array</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">		<span class="keyword">int</span> i = j ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> p = j ; (i - j) &lt; M &amp;&amp; p &lt;= n ; i ++, p += <span class="number">2</span>)</span><br><span class="line">			base[p] = M - (i - j), base[p + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">		j = i ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"data.in"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>) ;</span><br><span class="line">	srand(time(<span class="number">0</span>)) ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span> &lt;&lt; m &lt;&lt; <span class="string">" "</span> &lt;&lt; k &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">	gene_Array() ; <span class="keyword">int</span> B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, base[i], <span class="string">" \n"</span>[i == n]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; p) p += B ;</span><br><span class="line">		<span class="keyword">int</span> l = p, r = n - p / <span class="number">2</span> ;</span><br><span class="line">        l %= n, r %= n ; <span class="keyword">if</span> (r &lt; <span class="number">0</span>) r += n ;</span><br><span class="line">		<span class="keyword">if</span> (l &gt; r) swap(l, r) ;</span><br><span class="line">		l += rand() % (r-l+<span class="number">1</span>) ;</span><br><span class="line">		r += rand() % (n-r+<span class="number">1</span>) ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, l, r) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="233.jpeg" alt=""></p>
<p>其中第二行是我拿一个计数器，记了一下运算量。$7e8$ 能稳过 $1s$，这就很睿智，我果然跟时代脱节了。</p>
<h1 id="例题-amp-总结"><a href="#例题-amp-总结" class="headerlink" title="例题&amp;总结"></a>例题&amp;总结</h1><blockquote>
<p>由于个人感觉很有整理价值，于是决定新开一篇整理（</p>
</blockquote>
<p>之前一直觉得二次离线会很难，学了学觉得其实还可以。并且没准二次离线这个技巧可以利用到其它地方？或许吧。</p>
<p>莫队系列似乎是都学完了，爷的青春结束啦！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>技巧/二次离线</tag>
        <tag>数据结构/数据结构方法/莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>【題解】[bzoj3730]震波</title>
    <url>/2020/04/09/%E9%9C%87%E6%B3%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。</p>
<p>不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。</p>
<p>接下来你需要在线处理 $m$ 次操作：</p>
<p><code>0 x k</code> 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。</p>
<p><code>1 x y</code> 表示第 $x$ 个城市的价值变成了 $y$ 。</p>
<p>为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。</p>
</blockquote>
<p>這題有點自閉，各種 bug 調了好久。是點分樹沒錯，但是似乎不是很簡單，有一堆細節…</p>
<p>不過最後好像寫了個 $\log ^3$ ，死命卡常才給卡過去。</p>
<p>upd: 其實是大常數的 $\log ^2$ ，不知道我算複雜度的時候在瞎想什麼。</p>
<a id="more"></a>
<p>大概就是如果沒有修改操作的話，就是比較裸的點分樹。於是先考慮沒有修改操作的情況。</p>
<p>考慮怎麼維護這個東西，自然是希望對每個點都記錄一個桶，但這樣顯然由於每個點的深度不可控，最終需要的空間代價是 $O(n^2)$ 的。於是考慮怎麼調整樹的高度使得最終總的空間複雜度可以接受，那自然就會想到點分治。注意到點分治時，每個點在分治過程中，『邏輯樹高』都只有 $\log n$ 。這大概就是為什麼用點分樹的原因。</p>
<p>所以就是建出點分樹來，每個點維護一個 <code>vector</code> 作為桶，維護點分樹上子樹內到當前點距離為 $k$ 的點權和。這樣對於詢問，每次只需要跳點分樹，然後對於每個 $fa$ 統計 $k-dis(fa,x)$ 的點對的數量就好了。但是還有一個問題，就是對於以當前 $fa$ 為根的那些子樹，在算下一個 $fa$ 的時候會被算重。於是就要再維護一個桶，表示 $x$ 子樹內的點，到點分樹上 $x$ 的父親的距離為 $k$ 的點權和。由於邊權都為 $1$ ，這個操作就會很方便。</p>
<p>考慮如果帶修改，那無非就是把桶換成樹狀數組即可。這樣複雜度就會是 $O(m\log ^2 n)$ 的了。可能我寫的比較醜？預處理是常數不小的 $O(n\log ^2 n)$ ，似乎比其他人都慢誒…</p>
<p>然後是 bug 集錦：</p>
<p>1、最開始的時候維護的是 <strong>點分樹</strong> 上距離為 $k$ 的點的點權和。</p>
<p>2、然後改了改，但是查詢的時候沒有維護兩個 BIT，只維護了一個，然後減去的是查詢 $x$ 的點分樹子樹內到 $x$ 距離 $\leq k-2\times dis(fa_x,x)$ 的點權和。看上去有點東西，但問題在於到 $x$ 距離和到 $fa_x$ 距離沒有本質上的關係…比如可以在樹的對側。</p>
<p>3、最後還是寫了兩個 BIT，但是調了很久，原因是向上跳遇到 $dis(fa_x,x)&gt;k$ 應該 <code>continue</code> 而不是 <code>break</code> ，因為這距離並是實際距離，在點分樹上沒有單調性。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> lans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> d[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N] ;</span><br><span class="line"><span class="keyword">int</span> mx_dep ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to ;</span><br><span class="line">	<span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Id[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; sub[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; buc[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	to(++ cnt) = b ;</span><br><span class="line">	next(cnt) = head[a] ;</span><br><span class="line">	head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> findCG&#123;</span><br><span class="line">	<span class="keyword">int</span> grt ;</span><br><span class="line">	<span class="keyword">int</span> num ;</span><br><span class="line">	<span class="keyword">int</span> g[N] ;</span><br><span class="line">	<span class="keyword">int</span> size[N] ;</span><br><span class="line">	<span class="function">il <span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		a = b &lt;= a ? a : b ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">il <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">		g[grt = <span class="number">0</span>] = <span class="number">19690126</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">		size[x] = <span class="number">1</span> ; g[x] = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">			<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">				dfs(to(k), x) ;</span><br><span class="line">				size[x] += size[to(k)] ;</span><br><span class="line">				g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		chk(g[x], num - size[x]) ;</span><br><span class="line">		<span class="keyword">if</span> (g[x] &lt; g[grt]) grt = x ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> findCG ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= x ; ++ i)</span><br><span class="line">		buc[root].push_back(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = buc[root].size() ;</span><br><span class="line">	<span class="keyword">for</span> ( ; x &lt; t ; x += low(x)) buc[root][x] += p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= buc[root].size())</span><br><span class="line">		x = (<span class="keyword">int</span>)buc[root].size() - <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( ; x ; x -= low(x)) ret += buc[root][x] ;</span><br><span class="line">	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= x ; ++ i)</span><br><span class="line">		sub[root].push_back(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = sub[root].size() ;</span><br><span class="line">	<span class="keyword">for</span> ( ; x &lt; t ; x += low(x)) sub[root][x] += p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= sub[root].size())</span><br><span class="line">		x = (<span class="keyword">int</span>)sub[root].size() - <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( ; x ; x -= low(x)) ret += sub[root][x] ;</span><br><span class="line">	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">	size[x] = <span class="number">1</span> ;</span><br><span class="line">	dep[x] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">	Id[root][x] = dep[x] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(i)] &amp;&amp; to(i) != fa)</span><br><span class="line">			calc(to(i), x, root), size[x] += size[to(i)] ;</span><br><span class="line">	mx_dep = max(dep[x], mx_dep) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> root, <span class="keyword">int</span> frt)</span></span>&#123;</span><br><span class="line">	add(root, dep[x], base[x]) ;</span><br><span class="line">	<span class="keyword">if</span> (frt) add2(root, Id[frt][x], base[x]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(i)] &amp;&amp; to(i) != fa) calc2(to(i), x, root, frt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_tree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mx ; vis[x] = <span class="number">1</span> ; mx_dep = <span class="number">0</span> ; </span><br><span class="line">	calc(x, <span class="number">0</span>, x), init(x, mx_dep) ; </span><br><span class="line">	init2(x, h) ; mx = mx_dep ; </span><br><span class="line">	calc2(x, <span class="number">0</span>, x, fa) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">		num = size[to(k)] ; reset() ;</span><br><span class="line">		dfs(to(k), x) ; f[grt] = x ;</span><br><span class="line">		find_tree(grt, x, mx) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">char</span> c = getchar() ; </span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ; </span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">		r = r * <span class="number">10</span> + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">	<span class="keyword">return</span> r ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, c ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) base[i] = qr() ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">		a = qr(), b = qr(), add(a, b), add(b, a) ;</span><br><span class="line">	reset() ; num = n ; dfs(<span class="number">1</span>, <span class="number">0</span>) ; find_tree(grt, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">while</span> (m --)&#123;</span><br><span class="line">		a = qr() ; </span><br><span class="line">		b = qr() ^ lans ; </span><br><span class="line">		c = qr() ^ lans ;</span><br><span class="line">		<span class="keyword">if</span> (!a)&#123;</span><br><span class="line">			<span class="keyword">int</span> fb = f[b] ;</span><br><span class="line">			<span class="keyword">int</span> ob, lb = b, df ;</span><br><span class="line">			ans += ask(lb, c + <span class="number">1</span>) ;</span><br><span class="line">			<span class="keyword">while</span> (fb)&#123;</span><br><span class="line">				df = Id[fb][b] - <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (c - df &lt; <span class="number">0</span>)&#123;				</span><br><span class="line">					lb = fb, fb = f[fb] ;</span><br><span class="line">					<span class="keyword">continue</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">				ans += ask(fb, c - df + <span class="number">1</span>) ;</span><br><span class="line">				ans -= ask2(lb, c - df + <span class="number">1</span>) ;</span><br><span class="line">				lb = fb, fb = f[fb] ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>, (lans = ans)) ; </span><br><span class="line">			ans = <span class="number">0</span> ; <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> ob = b ;</span><br><span class="line">			add(b, <span class="number">1</span>, -base[b] + c) ;</span><br><span class="line">			<span class="keyword">while</span> (f[b])&#123;</span><br><span class="line">				<span class="keyword">int</span> df = Id[f[b]][ob] ;</span><br><span class="line">				add(f[b], df, -base[ob] + c) ;</span><br><span class="line">				add2(b, df, -base[ob] + c) ; b = f[b] ;</span><br><span class="line">			&#125;</span><br><span class="line">			base[ob] = c ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>題解</category>
        <category>BOZJ</category>
      </categories>
      <tags>
        <tag>数据结构/点分树</tag>
      </tags>
  </entry>
  <entry>
    <title>【題解】[bzoj4182] Shopping</title>
    <url>/2020/04/09/shopping/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>马上就是小苗的生日了，为了给小苗准备礼物，小葱兴冲冲地来到了商店街。商店街有 $n$ 个商店，并且它们之间的道路构成了一棵树的形状。</p>
<p>第 $i$ 个商店只卖第 $i$ 种物品，小苗对于这种物品的喜爱度是 $w_i$，物品的价格为 $c_i$，物品的库存是 $d_i$。但是商店街有一项奇怪的规定：如果在商店 $u,v$ 买了东西，并且有一个商店 $w$ 在 $u$ 到 $v$ 的路径上，那么必须要在商店 $w$ 买东西。小葱身上有 $m$ 元钱，他想要尽量让小苗开心，所以他希望最大化小苗对买到物品的喜爱度之和。</p>
<p>这种小问题对于小葱来说当然不在话下，但是他的身边没有电脑，于是他打电话给同为OI选手的你，你能帮帮他吗？</p>
<p>对于全部的测试点，保证 $1\leq n\le 500$，$1\le m\le 4000$，$1\le T \le 5$，$0\le w_i\le 4000$，$1\le d_i\le 100$ 。</p>
</blockquote>
<a id="more"></a>
<p>然後大概是整理過的題目，但個人感覺還是有必要再整理一遍的。</p>
<p>題意大概是說，在樹上做背包，但是不允許選不連通的點。据说是经典套路题，但我不是很会…</p>
<p>先考慮比較簡單的 $01$ 背包。考慮一般這種情況需要記錄一下每個點用沒用，所以比較直接的想法是枚舉每個點當根，然後求一個以該點為根時的連通塊出來。但問題就在於合併子樹的複雜度是 $O(V^2)$ （個人覺得存在某種方式的 $V\log V$ 合併，畢竟形式上十分的NTT）。但這樣就是 $n^2V^2$ 的了，所以考慮一個比較經典的優化，在 $dfs$ 序上做，記錄一下每個點子樹內 $dfs$ 序的最大值 $r_i$ 。定義 $f_{i,v}$ 表示 $i\sim n$ 都被考慮完了，代價為 $v$ 時的結果。轉移的話，如果選 $i$ 就從 $i+1$ 來轉移，不選 $i$ 那麼整棵子樹都不能選，從 $r_i+1$ 轉移。 </p>
<p>然後如果是多重背包的話，套一個單調隊列就可以做到 $n^2V$ 了，但是實際上這題很水，直接 $O(nV\max\{c_i\})$ 的多重背包也沒有問題。然後就是在寫多重背包的時候，發現了很弱智的一點，就是『物品個數』和『體積』哪一個先枚舉的問題…</p>
<p>顯然的是應該先枚舉體積，否則同一層的狀態會互相嵌套。所以應該這麼寫：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<p>但是還有另一種寫法，用到了『狀態堆疊』這個 trick，雖然複雜度不變但是看起來更帥一點</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.jpg" alt=""></p>
<p>然後考慮如何消掉一個 $n$ ，發現這個 $dp$ 很符合點分治的特點，每次將分治中心作為根，那麼選了根就是經過分治中心，不經過跟就是沒經過分治中心。於是最後的複雜度是 $nV\max\{c_i\}\log n $ 。</p>
<p>然後就是單調隊列優化多重背包，感覺這個東西很玄妙，十分深刻<del>（被 uoj 群友提醒之後發現似乎不是很深刻，只是自己做題少）</del>：</p>
<p>考虑原本的转移</p>
<script type="math/tex; mode=display">
f_{i,j}=\max\{f_{i-1,j-k\cdot w_i}\}+k\cdot v_i\quad (1\leq k\leq c_i)</script><p>其中需要优化掉的是 $k$ 这一维，发现他原本并没有任何对于转移单调的限制，于是考虑变一下形。</p>
<p>令 $d=j\bmod w_i$，$s=\lfloor\frac{j}{w_i}\rfloor$，那么转移就可以写作</p>
<script type="math/tex; mode=display">
f_{i,j}=\max\{f_{i-1,d+k\cdot w_i}-k\cdot v_i\}+s\cdot v_i \quad (s-k\leq c_i)</script><p>发现转移条件 $s-k\leq c_i\Longrightarrow k\geq s-c_i=\lfloor\frac{j}{w_i}\rfloor-c_i$ ，可知對於一個相同的 $i$，不同的 $j$ ，轉移區間的左端點是不降的，于是就对每个 $d$ 用单调队列即可。</p>
<p>仔細想了想，大概是這麼一個思考過程：觀察上面那個式子可以知道，每次枚舉的會是一些 $w_i$ 的倍數，那麼對於任意一個 $j$ ，轉移路徑裡最初的轉移點就一定在 $0\sim w_i-1$ 中進行，注意到這一點之後自然考慮對於每一個 $d$ 分別做。那麼可以發現，對於每個 $d$ 而言，$d+k<em>w$ 的轉移點都是固定的，比如 $d+7</em>w$ 就只能從 $d+w,d+2\cdot w,\cdots ,d+6*w$ 來轉移，同時由於數量 $c_i$ 的限制，可以知道對於每個 $j$ 只能從 $\geq \lfloor\frac{j}{w_i}\rfloor-c_i$ 的其它 $j$ 來轉移，就變成了一個區間彼此不包含的轉移問題，顯然可以用單調隊列來優化。</p>
<p>然後最後複雜度就變成了 $O(nV\log n )$ 。</p>
<p>感覺這個單調隊列的實現有億點細節，可能需要再琢磨一下。</p>
<hr>
<p>思考了一下，順便去問了 zay，發現這個轉移有點東西：</p>
<p>1、由於轉移時是要從 $i-1$ 的狀態轉移，一開始初始賦值完畢之後 $i$ 就是 $i-1$ 的狀態了。那麼每次入隊的時候要保證把 $i-1,j$ 入隊而不是 $i,j$ 。所以入隊的時候要是轉移前的結果。</p>
<p>2、注意到單調隊列有個問題，就是兩個端點『左閉右閉』和『左閉右開』。左閉右閉的時候需要注意判斷 <code>while (h &lt;= t)</code>，因為當 $h=t$ 的時候還會有元素在隊伍當中。</p>
<p>3、很 sb 的一點，就是手寫隊列，如果不能保證每次 $dp$ 前隊列都是空的，那麼轉移的時候就需要判斷是否為空，不然會從不合法的狀態點轉移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d, s = u[x] - <span class="number">1</span>, o, j ;</span><br><span class="line">	<span class="keyword">if</span> (s &gt; m / w[x]) s = m / w[x] ;</span><br><span class="line">	<span class="keyword">for</span> (d = <span class="number">0</span> ; d &lt; w[x] ; ++ d)&#123;</span><br><span class="line">		h = <span class="number">1</span> ; t = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= (m - d) / w[x] ; ++ j)&#123;</span><br><span class="line">			o = dp[j * w[x] + d] - v[x] * j ; <span class="comment">//1</span></span><br><span class="line">			<span class="keyword">while</span> (h &lt;= t &amp;&amp; q[t] &lt;= o) q[t --] = <span class="number">0</span> ; <span class="comment">//2</span></span><br><span class="line">			<span class="keyword">while</span> (h &lt;= t &amp;&amp; j - q2[h] &gt; s) q[h ++] = <span class="number">0</span> ;<span class="comment">//2</span></span><br><span class="line">			<span class="keyword">if</span> (h &lt;= t) dp[j * w[x] + d] = q[h] + v[x] * j ;<span class="comment">//3 </span></span><br><span class="line">			q[++ t] = o ; q2[t] = j ; <span class="comment">//1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感覺自己真的沒怎麼寫過單調隊列，同時也對單調隊列理解的不是很好的樣子。</p>
<p>總代碼：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">5010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> id ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h, t ;</span><br><span class="line"><span class="keyword">int</span> u[N] ;</span><br><span class="line"><span class="keyword">int</span> v[N] ;</span><br><span class="line"><span class="keyword">int</span> w[N] ;</span><br><span class="line"><span class="keyword">int</span> q[V] ;</span><br><span class="line"><span class="keyword">int</span> q2[V] ;</span><br><span class="line"><span class="keyword">int</span> rg[N] ;</span><br><span class="line"><span class="keyword">int</span> rev[N] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][V] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to ;</span><br><span class="line">	<span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	to(++ cnt) = b ;</span><br><span class="line">	next(cnt) = head[a] ;</span><br><span class="line">	head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> findCG&#123;</span><br><span class="line">	<span class="keyword">int</span> grt ;</span><br><span class="line">	<span class="keyword">int</span> num ;</span><br><span class="line">	<span class="keyword">int</span> g[N] ;</span><br><span class="line">	<span class="keyword">int</span> size[N] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		a = b &lt;= a ? a : b ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">		g[grt = <span class="number">0</span>] = <span class="number">19690126</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">		size[x] = <span class="number">1</span> ; g[x] = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">			<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">				dfs(to(k), x) ;</span><br><span class="line">				size[x] += size[to(k)] ;</span><br><span class="line">				g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		chk(g[x], num - size[x]) ;</span><br><span class="line">		<span class="keyword">if</span> (g[x] &lt; g[grt]) grt = x ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	findCG :: size[x] = <span class="number">1</span> ;</span><br><span class="line">	dfn[x] = ++ id ; rev[id] = x ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(k)] &amp;&amp; to(k) != fa)</span><br><span class="line">			dfs(to(k), x), findCG :: size[x] += findCG :: size[to(k)] ;</span><br><span class="line">	rg[x] = id ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *dp, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d, s = u[x] - <span class="number">1</span>, o, j ;</span><br><span class="line">	<span class="keyword">if</span> (s &gt; m / w[x]) s = m / w[x] ;</span><br><span class="line">	<span class="keyword">for</span> (d = <span class="number">0</span> ; d &lt; w[x] ; ++ d)&#123;</span><br><span class="line">		h = <span class="number">1</span> ; t = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= (m - d) / w[x] ; ++ j)&#123;</span><br><span class="line">			o = dp[j * w[x] + d] - v[x] * j ;</span><br><span class="line">			<span class="keyword">while</span> (h &lt; t &amp;&amp; q[t - <span class="number">1</span>] &lt;= o) q[t --] = <span class="number">0</span> ;</span><br><span class="line">			q[t] = o ; q2[t ++] = j ;</span><br><span class="line">			<span class="keyword">while</span> (h &lt; t &amp;&amp; j - q2[h] &gt; s) q[h ++] = <span class="number">0</span> ;</span><br><span class="line">			dp[j * w[x] + d] = max(dp[j * w[x] + d], q[h] + v[x] * j) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	vis[x] = <span class="number">1</span> ;</span><br><span class="line">	id = <span class="number">0</span> ; dfs(x, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= id + <span class="number">1</span> ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= m ; ++ j) f[i][j] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = id ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">		<span class="keyword">int</span> ii = rev[i] ;</span><br><span class="line"><span class="comment">//		if(x == 2) cout &lt;&lt; w[ii] &lt;&lt; " " &lt;&lt; v[ii] &lt;&lt; " " &lt;&lt; ii &lt;&lt; " " &lt;&lt; rg[ii] + 1 &lt;&lt; endl ;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= w[ii] ; -- j) f[i][j] = f[i + <span class="number">1</span>][j - w[ii]] + v[ii] ;</span><br><span class="line">		calc(f[i], ii) ; <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; -- j) f[i][j] = max(f[i][j], f[rg[ii] + <span class="number">1</span>][j]) ;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; f[1][m] &lt;&lt; endl ;</span></span><br><span class="line">	ans = max(f[<span class="number">1</span>][m], ans) ;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">			findCG :: reset() ;</span><br><span class="line">			findCG :: num = findCG :: size[to(k)] ;</span><br><span class="line">			findCG :: dfs(to(k), <span class="number">0</span>) ; solve(findCG :: grt) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">		<span class="keyword">int</span> a, b ; findCG :: num = n ;</span><br><span class="line">		fill(vis + <span class="number">1</span>, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">		fill(head, head + n + <span class="number">1</span>, ans = cnt = <span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; v[i] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; w[i] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; u[i] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b, add(a, b), add(b, a) ;</span><br><span class="line">		findCG :: reset() ; findCG :: dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">		solve(findCG :: grt) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最終被 zay 的二進制分組吊著錘，感覺很不爽 QAQ</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>动态规划/单调队列</tag>
        <tag>动态规划/背包模型</tag>
        <tag>数据结构/数据结构方法/点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【听课笔记】分块&amp;莫队&amp;根号分治</title>
    <url>/2020/04/08/%E5%88%86%E5%9D%97%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>啊，其实就是一直听说分块很nb但是一直没有深刻理解，于是就整理了一下…</p>
<p>话说我分块历史上只写过一道题…蒲公英那题…当时写的还一堆诡异的边界，导致我毫无复盘的欲望…</p>
<p>日常不想写数据结构(1/1) 。</p>
<p>然而内容就是 lxl 的 PPT ，個人感覺退役之前這個 PPT 是學不完了😭</p>
<a id="more"></a>
<p>不做說明的話，全部數據的 $n,m$ 都是 $10^5$ 的。块大小记作 $B$ .</p>
<h1 id="序列分块"><a href="#序列分块" class="headerlink" title="序列分块"></a>序列分块</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><blockquote>
<p>维护一个序列，支持</p>
<p>1.区间加。</p>
<p>2.查询区间小于 $x$ 的数个数。</p>
</blockquote>
<p>对于询问操作而言，可以发现区间加不影响块内部的顺序，所以考虑对于每个块维护块内元素排完序之后的结果，存在一个容器里，记为 $ov_x$ 。</p>
<p>对于修改操作，整块就直接打一个 $tag_x$ ，零散块由于至多有两块受影响，于是考虑暴力重构。暴力重构的方法大概是按顺序将 $ov_x$ 里那些要被加的元素取出，可以知道这样 $ov_x$ 和被取出的那些元素就都是有序的了，可以归并排序做到线性。所以修改复杂度是 $O(B)+O(\frac{n}{B})$ 的。</p>
<p>查询操作，零散块当然是暴力 for​ ，整块的话可以二分，查询复杂度 $O(B)+O(\frac{n}{B}\log B)$ 。发现如果令 $B = \sqrt{n\log B}$ ，那么总复杂度会变成 $O(m\sqrt{n\log B})$ ，可能会更优。</p>
<p>同时也可以把询问对于每一块都离线下来，对于每个块，在每次重构之前可以回答上一次重构之后的问题，用基数排序把这些询问排序之后，和块内元素一起归并可以做到线性。于是就可以离线 $O(m\sqrt n)$ 了。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><blockquote>
<p>维护一个序列，支持查询</p>
<p>1.区间加</p>
<p>2.查询区间k小</p>
</blockquote>
<p>考虑和上一道题一样的做法，每次外层套一个二分，那么就是查询每个块内 $&lt;x$ 的数的个数，这样还需要再二分，询问复杂度变成了 $O(\frac{n}{B}\log B\log V)$ ，平衡之后就是 $O(\sqrt{n\log B}\log V)$。</p>
<p>……然而 lxl 出的 YNOI 把这个 Sol 给卡了。</p>
<p>考虑一个 $trick$ ，就是调整块的大小。令 $B=\sqrt n \log n$ ，那么每次修改显然还是 $O(B)&gt;O(\frac{n}{B})$ 的，查询还是用二分，但是由于整块的数量下降到了 $O(\frac{n}{\sqrt n \log n})=O(\frac{\sqrt n}{\log n})$ ，那么这部分复杂度就变成了 $O(\sqrt n\log n)$ 。看上去很不错？但是零散块查询的时候，由于有 $O(\sqrt  n\log n)$ 的零散点，所以如果暴力二分就又变成俩 $\log $ 了。不过显然这些零散点是可以归并的，于是这部分的复杂度就变成了 $O(\sqrt n\log n+\log n)$ 。</p>
<p>最终总复杂度 $O(m\sqrt n\log n)$ 。</p>
<h1 id="根号平衡"><a href="#根号平衡" class="headerlink" title="根号平衡"></a>根号平衡</h1><h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><blockquote>
<p>维护序列，要求 $O(1)$ 修改， $O(\sqrt n)$ 求区间和。</p>
</blockquote>
<p>似乎就是最水的分块题。考虑分块维护块内和，修改的时候 $O(1)$ 修改点值和块值，询问就是朴素询问即可。</p>
<h2 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h2><blockquote>
<p> 维护序列，要求 $O(\sqrt n)$  修改， $O(1)$ 求区间和。</p>
</blockquote>
<p>这个比较有意思。发现要求 $O(1)$ 求区间和，那自然就是要维护前缀和。于是就分别维护块的前缀和 and 块内部的前缀和，每次修改就是要修改之后的块的前缀和 and 散点所在块内部的前缀和，查询作差即可。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote>
<p>维护序列，要求 $O(\sqrt n)$ 区间加，$O(1)$ 询问单点。</p>
</blockquote>
<p>改成维护差分就变成 B 的内容了。</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><blockquote>
<p>维护序列，要求 $O(1)$ 区间加，$O(\sqrt n)$ 询问单点。</p>
</blockquote>
<p>维护差分，就变成 A 了…这一波，这一波整理顺序没有决策单调性（雾）。</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><blockquote>
<p>维护一个集合，支持 $O(1)$ 插入一个数，$O(\sqrt n)$ 查询 $k$ 小。</p>
</blockquote>
<p>大概就是考虑值域分块。考虑把所有数字离散化之后是 $1\sim m$ ，然后按照值域分块，对于每个块记录一下这段值域出现了多少个数，每个位置出现了多少个数。插入就是在对应位置 $+1$，这个块 $+1$，询问就是 forforfor。</p>
<p>似乎有个小问题，就是如果值域 $1e9$ 可能要多一个二分的 log。如果不强制在线可以把询问一起离散化，但是如果强制在线可能就必须要二分了。</p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote>
<p>维护一个集合，支持 $O(\sqrt n)$ 插入一个数，$O(1)$ 查询 $k$ 小。</p>
</blockquote>
<p>还是按值域分块。同时维护每个块的 $ov$。</p>
<p>那么如果要插入一个数，那么那个块本身需要重构，然后对于这之后的所有数都需要后移一位，相当于每次每个块头部删一个元素，尾部加入一个元素。查询的时候直接定位到那个块即可。</p>
<p>实现方面，每个块的 $ov$ 拿一个支持双端删插的容器即可。这题的关键点就在于要保证前 $k$ 个块的大小可以快速查询，那么令每个块的大小相同就是不错的选择。</p>
<h2 id="CodeChef-Chef-and-Churu"><a href="#CodeChef-Chef-and-Churu" class="headerlink" title="[CodeChef] Chef and Churu"></a>[CodeChef] Chef and Churu</h2><blockquote>
<p>给 $n$ 个数，给定 $m$ 个函数，每个函数为序列中第 $l_i$ 到第 $r_i$ 个数的和。有 $q$ 个询问，两种类型的操作：</p>
<p><code>1 x y</code> 把序列中的第 $x$ 个数改为 $y$ 。</p>
<p><code>2 x y</code> 求第 $x$ 个函数到第 $y$ 个函数的和。</p>
</blockquote>
<p>一眼感觉是什么 CDQ 🐂🍺题.jpg</p>
<p>草，知道正解的我眼淚掉下來，感覺好神仙啊。大概就是考虑这些函数都是静态的，所以可以对函数分块，然后维护前 $i$ 个函数里面，序列上每个元素要被算多少次，并且维护前缀函数的答案和。那么每次修改只需要 $\frac{n}{B}$ 地修改每个前缀和即可。询问的时候，整块就是直接拿前缀和作差，对于散点而言，考虑至多是 $O(B)$ 次查询，每次查询本质上是对序列上一个区间的查询。所以用那个 $O(\sqrt n)$ 单点修改 $O(1)$ 查询区间和的方式，即 B 中的技巧就好了。</p>
<p>最终复杂度 $O(m\sqrt n)$ 。 </p>
<h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><h2 id="AHOI2013-作业"><a href="#AHOI2013-作业" class="headerlink" title="[AHOI2013]作业"></a>[AHOI2013]作业</h2><blockquote>
<p>查询区间 $[l,r]$ 中值在 $[a,b]$ 内的不同数个数</p>
<p>$n \leq 10^5 , m \leq 10^5$</p>
</blockquote>
<p>考虑直接莫队的话，需要支持查询某个值域中的数，需要上树状数组，但这样带 $\log$ 。</p>
<p>于是考虑一下莫队的本质，即莫队的复杂度分析，本质上分析的是 $l,r$ 移动的复杂度，也就是修改的复杂度。所以莫队可以本质上看成一个 $O(n\sqrt m)$ 修改，$O(m)$ 询问的数据结构，也就是可以用一个可以快速修改，低速查询的 ds 来维护值域，那这自然就是值域分块，最终复杂度 $O(n\sqrt m+m\sqrt n)$ 。</p>
<p>然后本题需要分别维护出现次数和是否出现，分别维护即可。</p>
<p>不过话说回来，这东西本质上等价于查询 $pre_x&lt;l,pos_x\in[l,r],x\in[a,b]$ 的这样的 $x$ 的个数。那么这就是一个三维数点，CDQ 套树状数组即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> V ; </span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line"><span class="keyword">int</span> blv[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> sumr[N] ;</span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id ; </span><br><span class="line">	<span class="keyword">int</span> l, r ; </span><br><span class="line">	<span class="keyword">int</span> a, b ; </span><br><span class="line">&#125;q[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(query a, query b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">		   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	sump[base[p]] -- ; </span><br><span class="line">	sumr[blv[base[p]]] -- ;</span><br><span class="line">	<span class="keyword">if</span> (sump[base[p]] &lt;= <span class="number">0</span>) -- sum[blv[base[p]]]  ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	sump[base[p]] ++ ; </span><br><span class="line">	sumr[blv[base[p]]] ++ ; </span><br><span class="line">	<span class="keyword">if</span> (sump[base[p]] &lt;= <span class="number">1</span>) ++ sum[blv[base[p]]]  ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">	r = min(r, V) ; </span><br><span class="line">	<span class="keyword">if</span> (l &gt; V) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">int</span> nl = blv[l] + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">int</span> nr = blv[r] - <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (blv[l] == blv[r])&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">			ret += (<span class="keyword">bool</span>)sump[i] ; <span class="keyword">return</span> ret ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nl ; i &lt;= nr ; ++ i) ret += sum[i] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l ; blv[i] == blv[l] &amp;&amp; l &lt;= V ; ++ i) ret += (<span class="keyword">bool</span>)sump[i] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = r ; blv[i] == blv[r] &amp;&amp; r &gt;= <span class="number">0</span> ; -- i) ret += (<span class="keyword">bool</span>)sump[i] ;</span><br><span class="line">	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_res</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">	r = min(r, V) ; </span><br><span class="line">	<span class="keyword">if</span> (l &gt; V) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">int</span> nl = blv[l] + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">int</span> nr = blv[r] - <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (blv[l] == blv[r])&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">			ret += sump[i] ; <span class="keyword">return</span> ret ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = nl ; i &lt;= nr ; ++ i) ret += sumr[i] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l ; blv[i] == blv[l] &amp;&amp; l &lt;= V ; ++ i) ret += sump[i] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = r ; blv[i] == blv[r] &amp;&amp; r &gt;= <span class="number">0</span> ; -- i) ret += sump[i] ;</span><br><span class="line">	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">	B = <span class="number">1.0</span> * n / <span class="built_in">sqrt</span>(m) + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), V = max(V, base[i]), bl[i] = i / B ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].a, &amp;q[i].b), q[i].id = i ; </span><br><span class="line">	sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; </span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span> ; B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= V ; ++ i) blv[i] = i / B ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = q[i].a, b = q[i].b ; </span><br><span class="line">		<span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ; </span><br><span class="line">		<span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ; </span><br><span class="line">		<span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line">		<span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">		res[q[i].id] = get_res(a, b) ;</span><br><span class="line">		ans[q[i].id] = get_ans(a, b) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res[i], ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AT1219-歴史の研究"><a href="#AT1219-歴史の研究" class="headerlink" title="AT1219 歴史の研究"></a>AT1219 歴史の研究</h2><blockquote>
<p>給定序列，定义 $v_x$ 为 $x$ 在区间 $[l,r]$ 中的出现次数，查询一个区间中最大的 $x\times v_x$ 。</p>
</blockquote>
<p>發現就是莫隊，然後要求查詢某個數的出現次數，跟上面『作業』那個題一樣，直接對值域分塊就好了。</p>
<p>預處理起來似乎也不是很難的樣子，對每個 $k\times x~(k=1,2,3,\cdots,cnt_x)$ 放到一起離散化就好了。 于是最后复杂度是 $O(n\sqrt m+m\sqrt n)$ 。因为滥用 <code>vector</code> 以及 cache 十分不友好导致慢的一匹，用了 zay 的快读也毛用没有/dk。</p>
<p>实现细节：</p>
<p>1、按照平常莫队的写法，如果先 <code>del</code> 再 <code>add</code> 会出现某些数出现了负数次，解决方法比较简单，判一下就好了。</p>
<p>2、十分神必的一点，一开始我把对每个点标号放到了对询问排序的后面，所以 T 了半天，并且自己以为是缓冲区溢出的锅…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(fast)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lwb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upb upper_bound</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vint vector <span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mint map <span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> minttoll map <span class="meta-string">&lt;int, ll&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> v, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; v ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qr</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qr(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qr;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"><span class="keyword">int</span> B ; </span><br><span class="line"><span class="keyword">int</span> L ; </span><br><span class="line"><span class="keyword">int</span> V ; </span><br><span class="line">ll res ;</span><br><span class="line">ll t[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ; </span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> bl[N] ;</span><br><span class="line">ll ans[M] ;</span><br><span class="line"><span class="keyword">int</span> vl[N] ; </span><br><span class="line"><span class="keyword">int</span> vr[N] ; </span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ; </span><br><span class="line"><span class="keyword">int</span> blv[N] ; </span><br><span class="line"><span class="keyword">int</span> sumb[N] ; </span><br><span class="line"><span class="keyword">int</span> sump[N] ;</span><br><span class="line">minttoll su ;</span><br><span class="line">mint bu, vu ;</span><br><span class="line">vint base[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id ; </span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">&#125;q[M] ;  </span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> query &amp;a, <span class="keyword">const</span> query &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (bl[a.l] ^ bl[b.l]) ? bl[a.l] &lt; bl[b.l] : </span><br><span class="line">		   ((bl[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (buc[tmp[p]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		++ buc[tmp[p]] ; <span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> lval = base[tmp[p]][buc[tmp[p]]] ;</span><br><span class="line">	<span class="keyword">int</span> val = base[tmp[p]][++ buc[tmp[p]]] ; </span><br><span class="line"><span class="comment">//	cout &lt;&lt; val &lt;&lt; " " &lt;&lt; lval &lt;&lt; endl ; </span></span><br><span class="line">	sump[val] ++ ; sumb[ blv[val] ] ++ ;</span><br><span class="line">	sump[lval] -- ; sumb[ blv[lval] ] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (buc[tmp[p]] &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">		-- buc[tmp[p]] ; <span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	if (buc[tmp[p]] + 1 &gt;= base[tmp[p]].size()) cout &lt;&lt; base &lt;&lt;buc[tmp[p]] &lt;&lt; " " &lt;&lt; p &lt;&lt; ' ' &lt;&lt; tmp[p] &lt;&lt;'\n', exit(0) ; </span></span><br><span class="line">	<span class="keyword">int</span> lval = base[tmp[p]][buc[tmp[p]]] ;</span><br><span class="line">	<span class="keyword">int</span> val = base[tmp[p]][-- buc[tmp[p]]] ; </span><br><span class="line">	sump[val] ++ ; sumb[ blv[val] ] ++ ;</span><br><span class="line">	sump[lval] -- ; sumb[ blv[lval] ] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ob = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> b = blv[V] ; b &gt;= <span class="number">0</span> ; -- b)</span><br><span class="line">		<span class="keyword">if</span> (sumb[b] &gt; <span class="number">0</span>) &#123; ob = b ; <span class="keyword">break</span> ; &#125; <span class="keyword">if</span> (!ob) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = vr[ob] ; p &gt;= vl[ob] ; -- p) <span class="keyword">if</span> (sump[p]) <span class="keyword">return</span> p ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    qr(n) ; qr(m) ; B = n / <span class="built_in">sqrt</span>(m) ;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) qr(g[i]) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">		bu[g[i]] ++, t[++ cnt] = <span class="number">1l</span>l * g[i] * bu[g[i]] ;</span><br><span class="line"><span class="comment">//	debug(t, 1, cnt, ' ', '\n') ;</span></span><br><span class="line">	sort(t + <span class="number">1</span>, t + cnt + <span class="number">1</span>) ; bu.clear() ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">		bl[i] = i / B ; bu[g[i]] ++ ; <span class="keyword">int</span> w ; </span><br><span class="line">		w = upb(t + <span class="number">1</span>, t + cnt + <span class="number">1</span>, <span class="number">1l</span>l * g[i] * bu[g[i]]) - t - <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; g[i] &lt;&lt; " " &lt;&lt; w &lt;&lt; '\n' ;</span></span><br><span class="line">		<span class="keyword">if</span> (bu[g[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">			base[w].push_back(<span class="number">0</span>) ; </span><br><span class="line">			base[w].push_back(w) ; vu[g[i]] = w ; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> base[vu[g[i]]].push_back(w) ; V = max(V, w) ;  </span><br><span class="line">		su[w] = <span class="number">1l</span>l * g[i] * bu[g[i]] ; t[w] ++ ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(q[i].l), qr(q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) tmp[i] = vu[g[i]] ;</span><br><span class="line"><span class="comment">//	for (int i = 1 ; i &lt;= n ; ++ i) if(buc[tmp[i]]) return 0 ; else buc[tmp[i]] ++ ; </span></span><br><span class="line"><span class="comment">/*	for (int i = 1 ; i &lt;= n ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; g[i] &lt;&lt; " " &lt;&lt; tmp[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">		debug(base[tmp[i]], 0, base[tmp[i]].size() - 1, ' ', '\n') ;</span></span><br><span class="line"><span class="comment">	&#125;return 0 ; */</span></span><br><span class="line"><span class="comment">//	debug(tmp, 1, n, ' ', '\n') ;</span></span><br><span class="line">	B = <span class="built_in">sqrt</span>(V) + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= V ; ++ i)&#123;</span><br><span class="line">		blv[i] = i / B + <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">if</span> (blv[i] != blv[i - <span class="number">1</span>])</span><br><span class="line">			vr[blv[i - <span class="number">1</span>]] = i - <span class="number">1</span>, vl[blv[i]] = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span> ; vr[blv[V]] = V ;</span><br><span class="line"><span class="comment">//	debug(blv, 1, V, ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//	debug(vl, 1, blv[V], ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//	debug(vr, 1, blv[V], ' ',  '\n') ;</span></span><br><span class="line"><span class="comment">//	while (l &lt;= n) add(l ++) ;// cout &lt;&lt; l &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ; </span><br><span class="line">		<span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ; </span><br><span class="line">		<span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">		ans[q[i].id] = su[ ask() ] ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qw(ans[i], <span class="string">'\n'</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SNOI2017-一个简单的询问"><a href="#SNOI2017-一个简单的询问" class="headerlink" title="[SNOI2017] 一个简单的询问"></a>[SNOI2017] 一个简单的询问</h2><blockquote>
<p>给你一个长度为 $N$ 的序列 $a_i$，$1\leq i\leq N$，和 $q$ 组询问，每组询问读入 $l_1,r_1,l_2,r_2$，需输出</p>
<script type="math/tex; mode=display">
\sum\limits_{x=0}^\infty \text{get}(l_1,r_1,x)\times \text{get}(l_2,r_2,x)</script><p>$ \text{get}(l,r,x)$ 表示计算区间 $[l,r]$ 中，数字 $x$ 出现了多少次。</p>
</blockquote>
<p>首先可以發現這東西就是在求 $\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a_i=a_j]$ 。由於是 $\sum $ 的形式，那麼自然可以拆成四個詢問，即詢問</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a_i=a_j]\\
=&\sum_{i=1}^{r_1}\sum_{j=1}^{r_2}[a_i=a_j]-\sum_{i=1}^{r_1}\sum_{j=1}^{l_2-1}[a_i=a_j]-\sum_{i=1}^{l_1-1}\sum_{j=1}^{r_2}[a_i=a_j]+\sum_{i=1}^{l_1-1}\sum_{j=1}^{l_2-1}[a_i=a_j]
\end{aligned}</script><p>那麼就變成了四個雙端點詢問的問題了。注意到每多一個元素 $x$，就會多 $buc_x$ 個 <code>pair</code>，莫隊即可。</p>
<h2 id="Ynoi2016-这是我自己的发明"><a href="#Ynoi2016-这是我自己的发明" class="headerlink" title="[Ynoi2016]这是我自己的发明"></a>[Ynoi2016]这是我自己的发明</h2><blockquote>
<p>给一个树，$n$ 个点，有点权，初始根是 $1$ 。$m$ 个操作，每次操作：</p>
<ol>
<li>将树根换为 $x$ 。</li>
<li>给出两个点 $x$，$y$，从 $x$ 的子树中选一个点，$y$ 的子树中选一个点，如果两个点点权相等，<code>ans++</code>，求 ans。</li>
</ol>
<p>$n\leq 10^5,m\leq 5\times 10^5$。</p>
</blockquote>
<p>發現…似乎本質上就是上面那個題。因為換根這個地方，對於某個點至多有兩種可能，就是子樹內的點為根、子樹外的點為根和自己為根。然後就可以一開始先按照操作，把所有詢問轉化成以 $1$ 為根，$dfs$ 序上的操作。然後大概就和上一道題一樣了。</p>
<p>需要注意的是，如果是遇到子樹內的點作為根，那麼本身就要兩個詢問，一個詢問全局的，一個減去這個子樹的，注意到詢問全局的並不需要拆，所以一個詢問最多會被拆分成 $(2+1)\times (2+1)=9$ 個詢問，最後 $m$ 可以到 $5\times 10^6$ 左右。雖然莫隊的複雜度可以接受 $m$ 比較大，但是一開始排序的 $m\log m$ 就會很慢。所以可以用基數排序來實現這個過程。</p>
<h2 id="BZOJ3920-Yunna-的禮物"><a href="#BZOJ3920-Yunna-的禮物" class="headerlink" title="[BZOJ3920] Yunna 的禮物"></a>[BZOJ3920] Yunna 的禮物</h2><blockquote>
<p>給定序列，每次查询区间中出现次数 $k_1$ 小的数里面的 $k_2$ 小的数。</p>
</blockquote>
<p>靠，一開始沒看見『區間』這個限制，還很好奇為什麼要上莫隊…老了老了。</p>
<p>看了半天題解才大概看明白，似乎是個什麼分塊套分塊的操作。大概就是對於『出現次數』的出現次數開一個桶，然後拿值域分塊來維護這個東西，但是對於每個『次數』還是需要查詢第 $k_2$ 小的數，於是就對於這個塊內的每個『次數』，外面再套一層值域分塊來維護一個固定次數處的數的排序。</p>
<p>這樣插入就是 $O(1)+O(1)$ ，查詢就是 $O(\sqrt n) +O(\sqrt n)$ 。看上去很棒，但是空間上會被卡…</p>
<p>這個地方我就很不理解…不知道為啥會被卡…不過那個什麼『分段離散化』的 trick 大概是预处理出对于某一种出现次数，所有可能的数，再将其离散化，对于离散化后的数再來值域分塊维护。這樣複雜度就是線性了。大概是什麼 vector 保存某個數出現 $k$ 次之後的新權值？大概過程就和其他博客講的，如果某個數的總出現次數 $cnt_x&gt;i$ ，那麼就要用 $x$ 預處理 $i$ ，這是顯然的。</p>
<p>似乎空間被卡的原因是值域分塊的 size 要預先確定，所以不二次離散化，複雜度就會是 $n^2$ 的了。</p>
<h1 id="根号分治"><a href="#根号分治" class="headerlink" title="根号分治"></a>根号分治</h1><h2 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h2><blockquote>
<p>给个图</p>
<ol>
<li>把 $x$ 点权加 $y$ 。</li>
</ol>
<p>2.查询 $x$ 相邻的点权和。</p>
</blockquote>
<p>经 典 套 路 . 总结一下的话，大概就是「小的直接做，大的打标记」这么一个套路。</p>
<p>具体一点，每个点维护一下询问的 $ans$，对每个点展开关于度数的根号分治，$&lt;\sqrt m$ 的点直接加，$&gt;\sqrt m$ 的点打标记。每次询问到一个点 $x$，由于 $\deg &gt; \sqrt m$ 的点不超过 $\sqrt m$ 个，所以可以直接 $for$ 过去判断是否与 $x$ 相邻。</p>
<h2 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h2><blockquote>
<p>规定序列 $a_n$，每次给定 $x$ 和 $y$ ：</p>
<p>查询一个区间中最小的 $|i-j|$，使得 $a_i=x,a_j=y$。</p>
</blockquote>
<p>有趣的题。</p>
<p>考虑对于每种颜色按照出现次数分治。某个颜色 $x$ 的出现次数记作 $cnt_x$。对于 $cnt_x\leq \sqrt n$ 的可以预处理所有位置，这一部分时 $O(n)$ 空 $O(n\sqrt n)$ ，对于 $cnt_x&gt;\sqrt n$  的可以预处理到所有颜色的最小距离（由于是最小距离所以可以忽略区间长度的限制），这部分时 $O(n\sqrt n)$ 空 $O(n \sqrt n)$ 。</p>
<p>考虑询问 $(x,y)$，如果至少一个颜色的 $cnt&gt;\sqrt n$ 那么就可以直接做，否则考虑由于两个颜色的位置都已知且数量 $&lt;\sqrt n$，所以按顺序拿出来，对这两个序列归并一下就做完了，复杂度 $O(m\sqrt n+n\sqrt n)$ 。</p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><blockquote>
<p>[Ynoi2015]いまこの時の輝きを</p>
<p>查询一个区间乘积的约数个数。</p>
<p>值域 $v\leq 10^9$。</p>
</blockquote>
<p>考虑 $\tau(x)=\prod (a_x+1)$ ， 同时对于某个 $v$ ，素因数个数是 $\frac{\log v}{\log \log v}$ 的，所以如果暴力莫队转移的话，每次转移的复杂度是 $O(\frac{\log v}{\log \log v})$，这样最后复杂度是 $O(nv^{\frac{1}{4}}+n\sqrt m\frac{\log v}{\log \log v})$，不过被 lxl 给卡掉了。</p>
<p>考虑一个神奇的根号分治。对于每个数 $v$ 而言， $&gt;\sqrt[3]v$ 的素因子至多只会有两个，在 $v=10^9$ 时，$&lt;10^3$ 的素数也只有 $168$ 个。所以可以暴力转移这些大素数的贡献，这样转移就是 $O(1)$ 的；然后对于每次询问，只需要再暴力统计小素数的贡献即可。最终复杂度 $O(nv^{\frac{1}{4}}+m\frac{3\cdot v^{\frac{1}{3}}}{\ln v}+n\sqrt m)$ 。</p>
<h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><blockquote>
<p>POI2015 Odwiedziny</p>
<p>树，点权，多次查询，每次给 <code>x,y,k</code>。</p>
<p>求从 $x$ 开始，每次跳过 $k$ 个节点跳到 $y$ 所经过节点的和。</p>
</blockquote>
<p>还是根号分治。考虑对于 $k\leq \sqrt n$ ，可以预处理出 $k=1,2,3\cdots \sqrt n$ 然后每次暴力向上跳，对于 $k&gt;\sqrt n$ ，至多需要跳 $\sqrt n$ 次，那么可以倍增求出 k 级祖先做到 $O(m\sqrt n\log n)$ ，或者长剖做到 $O(m\sqrt n)$ 。当然也可以轻重链剖，维护每条重链上深度从大到小的点的序列，这样单次复杂度就是 $O(\log k+\frac{n}{k})$ 了。</p>
<p>还有一种 zz 做法，记录每个点的 $1,2,3\cdots\sqrt n,2\sqrt n,3\sqrt n$ 级祖先，这样也是 $n\sqrt n + m\sqrt n$ 的了。</p>
<h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><blockquote>
<p>Bzoj4320 ShangHai2006 Homework</p>
<p>1.在人物集合 S 中加入一个 X，保证 X 在当前集合中不存在。</p>
<p>2.在当前的人物集合中询问所有X mod Y 最小的值</p>
<p>值域 $&lt;300000$ 。 </p>
</blockquote>
<p>考虑对于 $&lt;\sqrt V$ 的所有 Y ，令 $f_k$ 表示 Y = $k$ 时的答案，每次修改可以暴力维护所有 $f$，查询时 $O(1)$ 。这一部分复杂度为 $m\sqrt V$。</p>
<p>考虑对于 $&gt;\sqrt V$ 的所有 Y，发现 $V$ 以内至多有 $\sqrt V$ 个 Y 的倍数，那么每次查询相当于在两个相邻的 Y 的倍数之间查询区间最小值。注意到这样最多有 $m\sqrt V$ 次查询，$m$ 次修改，所以根号平衡一下，拿一个值域分块来维护即可。</p>
<p>总复杂度 $O(m\sqrt V)$ 。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>lxl 的课件确实都是比较有意思的题目，也确实开了眼界。</p>
<p>想继续学啊…可惜实力不允许啊…</p>
<p>不知道退役之前能不能完整地把这个课件看一遍了233</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/莫队</tag>
        <tag>技巧/根号分治</tag>
        <tag>数据结构/数据结构方法/分块</tag>
      </tags>
  </entry>
  <entry>
    <title>【听课笔记】点分治/点分树相关</title>
    <url>/2020/04/03/%E5%88%86%E6%B2%BB%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>似乎主要是点分治的相关内容？</p>
<a id="more"></a>
<h1 id="简单的前言"><a href="#简单的前言" class="headerlink" title="简单的前言"></a>简单的前言</h1><p>首先对于树的点分治所要解决的问题和普通分治一样，只需要统计经过分治中心的信息，假设对于 $k$ 个点而言，统计经过分治中心的信息复杂度是 $O(\gamma(k))$ 的，那么最后的总复杂度就是 $\gamma(n)\log n $ 。</p>
<p>对于树的边分治而言，遇到菊花就会崩掉。于是考虑对每个点进行<strong>三度化</strong> ，意即建立虚点使得每个点的度数都不超过 $3$ （二度化之后要么是链要么是环）。这样最终的 $size=k$ 的一层至多会分成一个  $size=\frac{1}{3}k$ 的和一个 $size=\frac{2}{3}k$ 的，可以知道如果度数 $\leq 3$ ，这就是能做到的最佳上界。于是最后的复杂度大概是 $\gamma(k)\log _{\frac{3}{2}}k$ 。</p>
<p>嗯，可能边分治就只用来分析个复杂度，好像几乎没人用的样子。不过也有个好处吧，就是不用考虑可能存在的分治中心的边界问题。</p>
<h1 id="常见点分治"><a href="#常见点分治" class="headerlink" title="常见点分治"></a>常见点分治</h1><h2 id="比较常见的数据结构"><a href="#比较常见的数据结构" class="headerlink" title="比较常见的数据结构"></a>比较常见的数据结构</h2><p>一般这个东西都比较显然…就题论题吧。</p>
<h2 id="如果信息可以容斥"><a href="#如果信息可以容斥" class="headerlink" title="如果信息可以容斥"></a>如果信息可以容斥</h2><p>这一类比较常见的是统计满足某个有可减性的点对数，比如统计路径长度/点权和 $&lt;k$ 的路径。常规的容斥做法是考虑对于每一层，计算出所有可能的点对，并且减去那些 <code>belong(x)=belong(y)</code> 的点对 $(x,y)$ 。</p>
<h2 id="类哈夫曼树合并"><a href="#类哈夫曼树合并" class="headerlink" title="类哈夫曼树合并"></a>类哈夫曼树合并</h2><p>每次选择两个size最小的子树进行合并，这样最后合并的总复杂度摊下来也是 $n \log n$ 的。这个主要用于那些不容易插入删除但是容易合并/重构的信息统计。注意到必须是从小合并到大，这样每次已合并的两个集合 $size$ 至少是较小的那个的两倍，所以每个点至多合并 $\log n$ 次……</p>
<p>以上复杂度分析似乎很有问题。我也不知道该怎么去定量分析这个问题。</p>
<p>不过uoj群给了一种很妙的证法。就是考虑每次选两个最小的合并一定可以达到复杂度的下界，因为对于一个合并顺序 $a&lt;b&lt;c$，<code>merge(a,b)</code> 再 <code>merge(b,c)</code> 的复杂度是 $O(2(a+b)+c)$ ，改变合并顺序，<code>merge(a,c)</code> 再 <code>merge(b,c)</code>的 复杂度是 $O(2(a+c)+b)$，也就是改变这个顺序至少不会更优。所以如果想要证明这种合并方式优于某个复杂度，那么只需要随便构造一个这种复杂度的合并方式即可。</p>
<p>那么问题转化到了如何构造一种 $n\log n$ 的合并。发现如果每次分成差不多大小的两堆，那么复杂度的递推式就是</p>
<script type="math/tex; mode=display">
T(n)=T(pn)+T(qn) + O(n)\quad (p+q=1,0<p,q<1)</script><p>但是这种分析的方式存在一定的问题，就是单纯这么写很容易构造出 $O(n)$ 层，但是 $O(n)$ 层是不符合「每次分成差不多两堆递归」这种情况的。</p>
<p>然后 uoj (没错我啥都不会只能到处问)里的神仙定量分析了一波，感觉十分有道理。大概就是考虑如果存在某个物品的大小 $\geq \frac{1}{3}$，那么直接把这个物品单独拿出来分成一部分，剩下的分成一部分；否则如果全部的物品的 $size$ 都 $&lt;\frac{1}{3}$ ，那么必定可以分出一堆 $\frac{n}{3}\leq size&lt;\frac{2n}{3}$ 的物品，原因在于这种情况下至少有 $&gt;3$ 种物品，那么如果物品再多的话，只能是类似于把之前的某个物品拆分(总体积不变且每个物品至多大小为 $\frac{1}{3}$)。而在三个物品的时候，是一定可以划分出 $\frac{n}{3}$ 来的，并且物品数如果增多，那么由于体积减小一定可以让划分更平均。所以上界是</p>
<script type="math/tex; mode=display">
T(n)=T(\frac{1}{3}n)+T(\frac{2}{3}n)+O(n)</script><p>算出来复杂度就是 $O(n\log_{\frac{3}{2}} n)$ 。</p>
<p>嗯，但是这样似乎并不能证明随机选两堆合并的复杂度…那就期望 log 吧！</p>
<h1 id="一堆题"><a href="#一堆题" class="headerlink" title="一堆题"></a>一堆题</h1><h2 id="限制距离的点对数"><a href="#限制距离的点对数" class="headerlink" title="限制距离的点对数"></a>限制距离的点对数</h2><blockquote>
<p>求距离不超过 $k$ 的点对数。</p>
</blockquote>
<p>注意到可以用点分治，分治的时候只需要考虑经过分治中心的路径，这就显然是枚举每棵子树，套一个树状数组就做完了。直接合并似乎不是很简单。所以还是一个点一个点地插入写起来比较简单一点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	size[x] = g[x] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])&#123;</span><br><span class="line">			make_root(to(k), x) ;</span><br><span class="line">			size[x] += size[to(k)] ;</span><br><span class="line">			g[x] = max(g[x], size[to(k)]) ;</span><br><span class="line">		&#125;</span><br><span class="line">	chkmax(g[x], num - g[x]) ;</span><br><span class="line">	<span class="keyword">if</span> (g[x] &lt; g[rt]) rt = x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	size[x] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (fa == rt)</span><br><span class="line">		son[++ cnt] = x, lst[x] = v ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)])</span><br><span class="line">			dfs(to(k), x, val(k)), size[x] += size[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &amp; (-x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; x &lt;= k ; x += low(x)) buc[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	ll ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( ; x ; x -= low(x)) ret += buc[x] ;</span><br><span class="line">	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dx)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dx &gt; k) <span class="keyword">return</span> ; d[++ tot] = dx ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(k)] &amp;&amp; to(k) != fa)</span><br><span class="line">			calc(to(k), x, dx + val(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">	cnt = <span class="number">0</span> ;</span><br><span class="line">	vis[root] = <span class="number">1</span> ; tot = <span class="number">0</span> ;</span><br><span class="line">	rt = root ; dfs(root, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; root &lt;&lt; '\n' ; debug(son, 1, cnt, '\n') ;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> otot = tot ; calc(son[i], <span class="number">0</span>, lst[son[i]]) ;</span><br><span class="line"><span class="comment">//		for (int j = otot + 1 ; j &lt;= tot ; ++ j) cout &lt;&lt; d[j] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = otot + <span class="number">1</span> ; j &lt;= tot ; ++ j) ans += (ll)ask(k - d[j]) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = otot + <span class="number">1</span> ; j &lt;= tot ; ++ j) add(d[j], <span class="number">1</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	ans += ask(k) ; <span class="comment">// cout &lt;&lt; root &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) add(d[i], <span class="number">-1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[root] ; k ; k = next(k))</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(k)]) num = size[to(k)], make_root(to(k), rt), solve(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u, v, w ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n ; g[<span class="number">0</span>] = n ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w ;</span><br><span class="line">		add(u, v, w), add(v, u, w) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; k ; num = n ;</span><br><span class="line">	make_root(<span class="number">1</span>, <span class="number">0</span>) ; solve(rt) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好久没写了，感觉写起来还可以。</p>
<h2 id="括号序列问题"><a href="#括号序列问题" class="headerlink" title="括号序列问题"></a>括号序列问题</h2><blockquote>
<p> 树上每条边有一个括号，统计有多少合法的括号序列路径。</p>
</blockquote>
<p>还是直接点分，之后将从 $root$ 延伸出的链中，左括号未匹配的和右括号未匹配的个数相同的可以配对。于是就记一下当前分治中心到各个子树内每个点路径上的匹配值( <code>(</code> 贡献为1, <code>)</code> 为 -1)。然后拿个桶维护即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> dx)</span></span>&#123;</span><br><span class="line">	d[++ tot] = dx ; q[tot] = x ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) </span><br><span class="line">			calc(to(k), x, dx + val(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">	vis[root] = <span class="number">1</span> ; </span><br><span class="line">	tot = <span class="number">0</span> ; dfs(root, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[root] ; i ; i = next(i))&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[to(i)]) <span class="keyword">continue</span> ; </span><br><span class="line">		<span class="keyword">int</span> ot = tot ; calc(to(i), root, val(i)) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = ot + <span class="number">1</span> ; j &lt;= tot ; ++ j)</span><br><span class="line">			ans += (ll)buc[- d[j] + M / <span class="number">2</span>] ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = ot + <span class="number">1</span> ; j &lt;= tot ; ++ j)</span><br><span class="line">			buc[d[j] + M / <span class="number">2</span>] ++ ; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; root &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line"><span class="comment">//	for (int i = 1 ; i &lt;= tot ; ++ i) </span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; d[i] &lt;&lt; " " &lt;&lt; q[i] &lt;&lt; " &amp; " &lt;&lt; endl, </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) buc[d[i] + M / <span class="number">2</span>] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[root] ; k ; k = next(k))&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">			num = size[to(k)] ; rt = <span class="number">0</span> ;</span><br><span class="line">			make_root(to(k), rt) ; solve(rt) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径数量问题"><a href="#路径数量问题" class="headerlink" title="路径数量问题"></a>路径数量问题</h2><blockquote>
<p>给定一棵树，求长度分别为 $1,2,3\ldots n$ 的路径数量。</p>
</blockquote>
<p>发现可以对每个子树记一下 $buc_i$ 表示深度为 $i$ 的点的数量，发现两棵子树的 $buc$ 对答案的贡献是一个卷积的形式。那么考虑直接枚举每棵子树，计算贡献时对当前桶和前缀桶用 $\rm NTT$ 来合并即可。</p>
<p>值得注意的是，这东西必须要从小到大枚举每个子树进行合并，复杂度才是对的（证明就是上面那个类哈夫曼树合并的证明）</p>
<p>最终复杂度 $n\log ^2 n$ 。代码就不写了，就是死亡二合一罢了。</p>
<h2 id="树上背包问题"><a href="#树上背包问题" class="headerlink" title="树上背包问题"></a>树上背包问题</h2><blockquote>
<p>给定一棵树，树上每个点有一个权值一个重量。要求选择一个<strong>连通子树</strong>，使得重量和小于某个给定的 $V$ 且权值和最大。</p>
<p>$n\leq 5000,V\leq 3000$ </p>
</blockquote>
<p>据说是经典套路题，但我不会…</p>
<p>考虑强制选根怎么做。考虑直接树形dp，合并两个子树的背包复杂度是 $V^2$ 的。于是考虑换一种可以不去合并子树的 $dp$ 方式。考虑在 dfs 序上对这个东西进行dp，设一个点 $u$ 子树的范围是 $p_u\sim r_{u}$ ，那么就可以设 $f_{i,v}$ 表示考虑了 $i\sim n$ 的物品，根必选且容积为 $v$ 的最大价值。考虑转移，对于一个 $i$ 而言，如果选了他，就可以从 $i+1$ 转移，否则由于根必须被选，$i$ 不选，整棵子树都不能选，所以只能从 $r_i+1$ 转移过来。于是这样的复杂度就是 $O(nv)$ 的了。 </p>
<p>暴力做是 $O(n^2v)$ 的，复杂度瓶颈在于枚举根。考虑一个性质，就是如果点 $v$ 不在答案中，那么与其相邻的连通块不会互相通达，因为树上路径唯一。于是就可以考虑点分，经过/不经过根分别对应分治下去和跨过分治中心两种情况。最终复杂度 $nv\log n$ 。</p>
<p>在合并的时候可能有亿点细节需要去写…233</p>
<h1 id="点分树"><a href="#点分树" class="headerlink" title="点分树"></a>点分树</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>对于点分树，有一个很优秀的性质，就是树高不超过 $\log n$ ，对于一些题目可以用这个性质进行转化。</p>
<blockquote>
<p>给定一棵无权树，单点修改，求距离 $x$ 不超过 $r$ 的点权和。</p>
</blockquote>
<p>考虑如果没有修改操作时，直接求也是不太好求的。于是考虑点分治，对于每个分治中心，预处理记录一下子树中距离 $\leq k\quad (k=1,2,3\cdots )$ 的点权和。 注意到这最多需要 $n \log n$ 的空间，拿 <code>vector</code> 实现即可。</p>
<p>那么对于询问而言，直接从点分树上暴跳，每跳到一个点分中心 $p$，就可以加上这个点记录的 $\leq r-(dep_p-dep_x)$ 的点权和，并且减去上一个点分中心子树内部 $\leq r-(dep_p-dep_x)$ 的点权和。由于点分树树高的限制，这个过程是 $\log n$ 的。</p>
<p>考虑如何修改，发现本质上修改+询问是一个单点修改，前缀查询的过程，于是就可以换用树状数组来维护，修改时只需要暴力跳即可，这样最终复杂度就是 $m\log ^2 n$ 的了。</p>
<h2 id="树上背包问题2"><a href="#树上背包问题2" class="headerlink" title="树上背包问题2"></a>树上背包问题2</h2><blockquote>
<p>给定一棵树，树上每个点有一个权值一个重量。要求选择一个<strong>独立集</strong>，使得重量和小于某个给定的 $V$ 且权值和最大。</p>
<p>$n\leq 100,V\leq 30000$ </p>
</blockquote>
<p>考虑一个比较 <code>general</code> 的 $dp$ ，还是跟上个题一样，直接合并背包是 $V^2$ 的，所以考虑把这棵树的 $dfs$ 序写下来，然后 $f_{i,j,s}$ 表示考虑了前 $i$ 个点，容量为 $j$ ，每个点选不选表示为集合 $s$ ，最终复杂度就是 $nv2^n$ 。</p>
<p>考虑如何少记一点东西，似乎需要把这个 $2^n$ 给降下来。于是考虑点分治。发现点分治的每一层，子树之间都是互不影响的，所以只需要把点分树找出来，对点分树进行树形 $dp$ ，记 $s$ 时只需要记每一层的点分中心的状态即可。这样由于点分树高是 $O(\log n)$ 的，所以最终复杂度是 $O(nv2^{\log n})=O(n^2v)$ 。</p>
<h2 id="ZJOI-2007-捉迷藏"><a href="#ZJOI-2007-捉迷藏" class="headerlink" title="ZJOI 2007 捉迷藏"></a>ZJOI 2007 捉迷藏</h2><blockquote>
<p>修改⼀个点的⿊白，求最远⿊点之间距离。</p>
</blockquote>
<p>考虑大致思路和「引入」中差不多，但是需要注意的是由于是统计最长的点对间距离，所以用边分治会好做一些。那么分治的时候还是需要按是否经过分治中心来分类。之后拿一个 multiset 来维护就好了。</p>
<p>嗯，除了边分不会写之外，没啥可说的。</p>
<p>据说还有 $1$ 个 $\log $ 的做法，那必然是鸽了。</p>
<h1 id="补充题目"><a href="#补充题目" class="headerlink" title="补充题目"></a>补充题目</h1><h2 id="某不知名CF题"><a href="#某不知名CF题" class="headerlink" title="某不知名CF题"></a>某不知名CF题</h2><blockquote>
<p>给一棵树，点、边均有权，求点 $x$，最小化 $\sum_{i=1}^{n} a_{i} \cdot \operatorname{dis}^{1.5}(i, x)$ 。  $n \leq 10^{5}$ 。</p>
</blockquote>
<p>事实上是 CF566C (雾</p>
<p>首先对于 $1.5$ 次方的 $\sum $，由于相加之后二阶导依旧 $&gt;0$ ，所以相加之后依旧是凸函数。那么也就是说，假设 $x$ 可以在边上随便取，那么对于一条固定的路径 $x\in(u,v)$ ， $\mathrm{dis}(x,u)^{1.5}$ 必定是一个下凸函数。</p>
<p>考虑在链上必然是二分，那么调整到树上就可以进行点分。考虑对于每个点分中心，都应该找可以使答案变小的那个儿子所在子树点作为下一个进行点分的连通块。考虑如何去实现判断这个过程。如果答案变小，那么一定是导数减小，于是可以求出子树中每个点对应值的导数 $df_x$，那么总体的导数就是 $\sum df_x-2\cdot df_v&lt;0$ ，$v$ 是下一个要进行点分的子树，原因是通过计算偏移量，剩余的点的 $f$ 都会变大，当前点会变小。这个求导的过程本质上是在模拟，我向每条边移动一个 $\epsilon$ 之后的结果。</p>
<p>于是就点分进行这个过程即可，点分是为了加速计算每个子树的 $df$ ，保证最终这一部分的计算量是 $n\log n$ 的。</p>
<h2 id="可达性统计"><a href="#可达性统计" class="headerlink" title="可达性统计"></a>可达性统计</h2><blockquote>
<p>给定一个有向图，每次加入一条边 $(u,v)$，或者询问有多少点对两两可达。</p>
</blockquote>
<p>考虑一个<del>深刻的</del>单调性，如果在某一时刻出现了一个SCC，把它缩起来，那么之后它也会一直被缩起来。</p>
<p>于是考虑整体二分，<code>solve(l,r,E)</code> 表示 $E$ 中的边会在时刻 $l\sim r$ 中被缩起来。于是每次把 $[l,mid]$ 这些边跑一个强连通分量，那么被缩起来的边递归到 <code>solve(l,mid,E1)</code> 里面，没被缩起来的边递归到 <code>solve(mid+1,r,E2)</code> 里面。同时为了让分治的复杂度是对的，每次点集大小不能跟 $n$ 有关，于是就需要每次在 <code>solve(l,mid,E1)</code> 之后把 E1里的点拿并查集给缩起来，这样才能保证 <code>solve(mid+1,r,E2)</code> 的复杂度只跟边数有关。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>动态点分治是不可能的，这辈子都不可能的。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据结构/树状数组</tag>
        <tag>数据结构/点分树</tag>
        <tag>数据结构/数据结构方法/点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】从剩余类到欧拉定理</title>
    <url>/2020/04/02/%E5%89%A9%E4%BD%99%E7%B1%BB%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>「重学4-6」系列的最后一篇文章。</p>
<p>感觉剩余类这部分内容，以纯数论的眼光去看待，是十分优美的。</p>
<p>嗯，将来自己抽代真正入门之后，可能就会多一点别的角度了吧。</p>
<a id="more"></a>
<h1 id="剩余类相关定义"><a href="#剩余类相关定义" class="headerlink" title="剩余类相关定义"></a>剩余类相关定义</h1><h2 id="剩余类"><a href="#剩余类" class="headerlink" title="剩余类"></a>剩余类</h2><p>定义 1.1</p>
<blockquote>
<p>记在模 $m$ 意义下，全部对 $m$ 同余的整数组成的集合，叫做 $m$ 的一个剩余类。</p>
</blockquote>
<p>那么显然对于一个固定的模 $m$，有 $m$ 个剩余类，分别同余 $0,1,2\cdots m-1$，分别记作 $\mathrm{ Z}_{m,0},\mathrm{ Z}_{m,1},\mathrm{ Z}_{m,2}\cdots,\mathrm{ Z}_{m,m-1}$ 。记所以剩余类组成的集合是 $\mathrm{ Z}_{m}$ 。</p>
<p>考虑定义剩余类之间的运算 $+$ 和 $\times $ ：</p>
<script type="math/tex; mode=display">
\mathrm{ Z}_{m,a}+\mathrm{ Z}_{m,b}=\mathrm{ Z}_{m,a+b}\\
\mathrm{ Z}_{m,a}\times \mathrm{ Z}_{m,b}=\mathrm{ Z}_{m,a\times b}</script><p>其中 $a+b$ 和 $a\times b$ 是在模 $m$ 意义下的数加和数乘。并且可以知道，对于全体模 $m$ 意义下的剩余类 $\mathrm{ Z}_{m}$ 而言，$&lt;\mathrm{ Z}_{m},+,\times&gt;$ 本身是一个环。考虑如下：</p>
<p>1、首先 $(\mathrm{ Z}_{m},+)$ 显然是一个阿贝尔群。</p>
<p>2、其次 $(\mathrm{ Z}_{m},\times )$ 显然具有结合律，但是如果对于某个剩余类 $\mathrm{ Z}_{m,p}$ $(p,m)&gt;1$ ，就说明了 $\mathrm{ Z}_{m,p}$ 本身不存在逆元 ，所以可知道 $(\mathrm{ Z}_{m},\times )$ 是一个半群。</p>
<p>3、同时可知在 $(\mathrm{ Z}_{m},\times )$ 中，高优先级运算 $\times $ 对低优先级运算 $+$ 有分配律。</p>
<p>综上，$(\mathrm{ Z}_{m},+,\times )$ 是一个环。并且不难知道 $\mathrm{ Z}_{m,0}$ 就是这个环中的零元。</p>
<p>但是这个环并不是正则环。考虑我们熟知的正则环 $&lt;\mathbb Z,+,\times&gt;$ 和 $&lt;\mathbb R,+,\times &gt;$ 内都不存在零因子 $a,b$ 使得 $a\not =0,b\not = 0$ 且 $a\times b=0$ 。但是在模运算下这是可能成立的，比如可以设 $m=pq$ ，其中 $p\not \equiv q\pmod m$，那么就有 $\mathrm{ Z}_{m,p} \times \mathrm{ Z}_{m,q}=\mathrm{ Z}_{m,0}$ ，此时 $p,q$ 就均为 $\mathrm{ Z}_{m}$ 的零因子。所以可知剩余类环并不是正则的。</p>
<h2 id="互素剩余类"><a href="#互素剩余类" class="headerlink" title="互素剩余类"></a>互素剩余类</h2><h3 id="定义1-2"><a href="#定义1-2" class="headerlink" title="定义1.2"></a>定义1.2</h3><blockquote>
<p>若对于一个模 $m$ 意义下的剩余类 $\mathrm{ Z}_{m,k}$ 满足 $(m,k)=1$ ，那么称 $\mathrm{ Z}_{m,k}$ 为模 $m$ 的一个互素剩余类。</p>
</blockquote>
<p>为了方便起见，记某个互素剩余类 $\mathrm{ Z}_{m,k}$ 为 $\mathrm{\zeta}_{m,k}$ 。同时可知这样的 $\mathrm{\zeta}_{m,k}$ 共有 $\varphi(m)$ 个。</p>
<h1 id="剩余系"><a href="#剩余系" class="headerlink" title="剩余系"></a>剩余系</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="定义2-1"><a href="#定义2-1" class="headerlink" title="定义2.1"></a>定义2.1</h3><blockquote>
<p>如果对于一个集合 $\rm S$ ，满足 $\mathrm{|S|}=m$ 且 $\forall i\not=j,i\in \mathrm{S},j\in \mathrm{S}$ 有</p>
<script type="math/tex; mode=display">
i\in\mathrm{ Z}_{m,p}, j \in \mathrm{ Z}_{m,q}, \mathrm{ Z}_{m,p}\not=\mathrm{ Z}_{m,q}</script><p>那么记这个集合为模 $m$ 的一个完全剩余系。</p>
</blockquote>
<h3 id="定义2-2"><a href="#定义2-2" class="headerlink" title="定义2.2"></a>定义2.2</h3><blockquote>
<p>如果对于一个集合 $\rm S$ ，满足 $\mathrm{|S|}=m$ 且 $\forall i\not=j,i\in \mathrm{S},j\in \mathrm{S}$ 有</p>
<script type="math/tex; mode=display">
i\in\mathrm{ \zeta}_{m,p}, j \in \mathrm{ \zeta}_{m,q}, \mathrm{ \zeta}_{m,p}\not=\mathrm{ \zeta}_{m,q}</script><p>那么记这个集合为模 $m$ 的一个简化剩余系。</p>
</blockquote>
<p>可知模 $m$ 的一个完全剩余系的大小是 $m$ ，一个简化剩余系的大小是 $\varphi(m)$ 。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2.1"></a>定理2.1</h3><blockquote>
<p>设 $m\in \mathbb Z_+$，$k,p\in \mathbb Z$ 且 $(k,m)=1$ ，则</p>
<p>（1）当 $x$ 遍历模 $m$ 的一个完全剩余系 $\mathrm{S}$ 时，$kx+p$ 也遍历模 $m$ 的一个完全剩余系 $\mathrm{S’}$ 。</p>
<p>（2）当 $x$ 遍历模 $m$ 的一个简化剩余系 $\mathrm{T}$ 时，$kx$ 也遍历模 $m$ 的一个简化剩余系 $\mathrm{T’}$ 。</p>
</blockquote>
<p>证：</p>
<p>（1）考虑只需要证对于任意两个模 $m$ 下不同余的 $x_i,x_j$ ， $kx_i+p,kx_j+p$ 也是不同余的，那么就可以得证。</p>
<p>考虑反证法。若 $kx_i+p\equiv kx_j+p\pmod m$，则有</p>
<script type="math/tex; mode=display">
kx_i\equiv kx_j\pmod m</script><p>那么由于 $(k,m)=1$ 且根据定理</p>
<blockquote>
<p>若 $ac\equiv bc\pmod m$，且 $(m,c)=d$，则 $a\equiv b \pmod{\frac{m}{d}}$ 。</p>
</blockquote>
<p>可知 $x_i\equiv x_j\pmod m$ 。矛盾。</p>
<p>（2）由（1）可以知道 $kx_i$ 彼此之间不同余，且因为 $(k,x_i)=(k,m)=1$ ，所以可知遍历的是一个简化剩余系。</p>
<h3 id="定理2-2"><a href="#定理2-2" class="headerlink" title="定理2.2"></a>定理2.2</h3><blockquote>
<p>设 $(m_1,m_2)=1$ ，则：</p>
<p>（1）当 $x,y$ 分别遍历模 $m_1,m_2$ 的一个完全剩余系时，$m_2x+m_1y$ 也遍历模 $m_1m_2$ 的一个完全剩余系。</p>
<p>（2）当 $x,y$ 分别遍历模 $m_1,m_2$ 的一个简化剩余系时，$m_2x+m_1y$ 也遍历模 $m_1m_2$ 的一个简化剩余系。</p>
</blockquote>
<p>证：</p>
<p>（1）</p>
<p>还是从证明互不同余这方面来考虑。如果存在 $x_1,x_2,y_1,y_2$ 使得</p>
<script type="math/tex; mode=display">
m_{2} x_{1}+m_{1} y_{1} \equiv m_{2} x_{2}+m_{1} y_{2}\pmod {m_{1} m_{2}}</script><p>那么首先有</p>
<script type="math/tex; mode=display">
m_{2} x_{1}+m_{1} y_{1} \equiv m_{2} x_{2}+m_{1} y_{2}\pmod {m_{1}}</script><p>即</p>
<script type="math/tex; mode=display">
m_{2} x_{1} \equiv m_{2} x_{2}\pmod {m_{1}}</script><p>那么因为 $(m_1,m_2)=1$ ，所以有</p>
<script type="math/tex; mode=display">
x_{1} \equiv x_{2}\pmod {m_{1}}</script><p>同理可知</p>
<script type="math/tex; mode=display">
y_{1} \equiv y_{2}\pmod {m_{1}}</script><p>那么就可以知道，当 $x_1,x_2$ 不同余，$y_1,y_2$ 不同余的时候，$m_2x+m_1y$ 也是不同余的。</p>
<p>（2）</p>
<p>首先由于 $(x,m_1)=(y,m_2)=1$ ，所以 $(m_2x+m_1y,m_1)=1$ 且 $(m_2x+m_1y,m_2)=1$，所以可知 $m_2x+m_1y$ 一定会属于 $m_1m_2$ 的简化剩余系。同时由（1）中的结论可知这 $\varphi(n)\varphi(m)$ 个结果是两两不同余的。于是就只需要证明 $m_1m_2$ 的简化剩余系中，均属于这 $\varphi(n)\varphi(m)$ 个元素组成的集合即可。</p>
<p>对于任意一个与 $m_1m_2$ 互质的元素 $q$，由（1）可知必定存在一组 $(s,t)$ 使得</p>
<script type="math/tex; mode=display">
q\equiv m_2s+m_1t\pmod {m_1m_2}</script><p>考虑若 $(s,m_1)&gt;1$ ，则有某个$d&gt;1,d|s$ 满足 $d|m_1\Longrightarrow d|m_1m_2$ 的同时 $d|q$ ，那么 $(m_1m_2,q)\geq d$ ，不符合互质的假设。故可知 $(s,m_1)=1$ ，同理 $(t,m_2)=1$ ，故证毕。</p>
<h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><p>由定理 2.2(2) 可知，分别遍历模 $m_1$ 和 $m_2$ 的简化剩余系的 $x$ 和 $y$ ，在 $(m_1,m_2)=1$ 时，$m_1y+m_2x$ 遍历模 $m_1m_2$ 的一个简化剩余系。 根据乘法原理，可以得到 $\varphi(m_1)\cdot \varphi(m_2)=\varphi(m_1m_2)$ 。</p>
<p>这也就证明了欧拉函数 $\varphi(x)$ 是积性函数。</p>
<h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><blockquote>
<p>若 $(a,m)=1$ ，则有 $a^{\varphi(m)}\equiv 1\pmod m$ .</p>
</blockquote>
<p>若设 $(x_1,x_2,x_3\cdots x_{\varphi(m)})$ 是模 $m$ 的一个简化剩余系，那么由定理2.1(2)可知 $(ax_1,ax_2,ax_3\cdots ax_{\varphi(m)})$ 也是模 $m$ 的一个简化剩余系。所以有</p>
<script type="math/tex; mode=display">
\prod_{i=1}^{\varphi(m)} x_i\equiv \prod_{i=1}^{\varphi(m)} ax_i\pmod m</script><p>那么由于 $\forall i,(x_i,m)=1$，所以 $(\prod x_i,m)=1$ 。于是消一下可以得到</p>
<script type="math/tex; mode=display">
1\equiv a^{\varphi(m)}\pmod m</script><p>证毕。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>个人感觉剩余类这部分是很有趣的，虽然以上内容大部分都是4-6里面提炼出来的。对于欧拉定理，用群论知识证明同样十分简洁。</p>
<p>总之，完结啦，撒花花。</p>
<p>数论4-6，也算是我的一场持续了三年的春花旧梦了吧。</p>
<p>不知道啥时候能和EI和rqy一样有对数学知识的深刻认识。慢慢来吧。只有站在越高处，才能看到越广的风景，不是吗？</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学/数论</tag>
        <tag>数学/抽象代数/环论</tag>
        <tag>数学/积性函数/欧拉反演</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[湖北省队互测2014week1 B] 一个人的数论</title>
    <url>/2020/04/01/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定 $n$ 的质因数分解 $n= \prod _{i=1}^kp^{a_{i}}$，求所有小于 $n$ 且与 $n$ 互质的正整数的 $m$ 次方之和模 $10^9 +7$ 的值。其中 $p_i$ 为质数且不超过 $10^9$ 。</p>
<p>$a_i ≤ 10^9,k ≤ 1000,m ≤ 100$。</p>
</blockquote>
<a id="more"></a>
<p>写出式子来</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^n[(i,n)=1]i^m\\
=&\sum_{i=1}^ni^m\sum_{d|i,d|n}\mu(d)\\
=&\sum_{d|n}d^m\mu(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}  i^m
\end{aligned}</script><p>然后发现这东西好像不是容易提前预处理。根据伯努利数的推论，可以知道 $\sum i^m$ 这东西是一个关于上界 $n$ 的 $m+1$ 次多项式。发现 $m$ 并不大于是可以 $O(m^2)$ 插出来。 若记这个多项式是 $f$ ，那么原式就等价于</p>
<script type="math/tex; mode=display">
\sum_{d|n}d^m\mu(d)\sum_{i=1}^{m+1} f_i\left(\lfloor\frac{n}{d}\rfloor\right) ^ i</script><p>稍微化一下就是</p>
<script type="math/tex; mode=display">
=\sum_{i=0}^{m+1} f_{i} \sum_{d | n} d^{m} \mu(d)\left(\frac{n}{d}\right)^{i}</script><p>发现对于后面的 $\sum $ 只需要求出每个 $p_i^{a_i}$ 处的值，然后每次 $O(k)$ 暴力合并，似乎也没啥问题。考虑对于每个 $p_i^{a_{i}}$ 怎么求。这个地方大概需要涨个经验，就是 $\mu(d)$ 这东西只有当 $d=1$ 和 $d=p_i$ 的时候才有值(无平方因子,剩下的因子都是 $p_i$ 的某个次数 $&gt;2$ 的幂)，所以每个只需要算两次，是 $O(1)$ 的。于是最后的复杂度 $O(m(m+k))$ 。</p>
<p>好神啊好神啊。</p>
<p>哈哈哈哈哈草这个题居然允许用高斯消元来代替插值。毕竟 $m$ 只有 $100$ 。</p>
<p>然后关于拉插，感觉很gg，因为一共有三个版本的拉插，求值和求系数，求值的又分为 $x$ 连续/不连续的。于是今天就把三个版本都写了一遍……</p>
<p>不过有一说一，求系数的拉插感觉就是在模拟。然后我还对着多项式除法(整除以一个形如 $(x+t)$ 的多项式)摸了好久，一直感觉很迷乱，后来用了用大除法，发现就是在模拟大除法的过程罢了。</p>
<p>然后一开始我还憨憨的写了个线性筛，然后发现 $\mu(d)$ 的 $d$ 是 $1e9$ 的，就懵圈了，然后又发现 $\mu(d)$ 只会是 $1/-1$ 并且很好判断，于是感觉自己是个sb。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span> ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Interpolation&#123;</span><br><span class="line">	<span class="keyword">int</span> ans ; </span><br><span class="line">	<span class="keyword">int</span> now ; </span><br><span class="line">	<span class="keyword">int</span> x[N] ;</span><br><span class="line">	<span class="keyword">int</span> y[N] ;</span><br><span class="line">	<span class="keyword">int</span> fac[N] ; </span><br><span class="line">	<span class="keyword">int</span> inv[N] ; </span><br><span class="line">	<span class="keyword">int</span> pres[N] ; </span><br><span class="line">	<span class="keyword">int</span> sufs[N] ; </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">		a = (a % P + P) % P ;</span><br><span class="line">		<span class="keyword">while</span> (b)&#123;</span><br><span class="line">			<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">				res = (ll)res * a % P ; </span><br><span class="line">			a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fz[N] ;</span><br><span class="line">	<span class="keyword">int</span> fm[N] ; </span><br><span class="line">	<span class="keyword">int</span> tmp[N] ;</span><br><span class="line">	<span class="keyword">int</span> res[N] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		a += b ;</span><br><span class="line">		<span class="keyword">if</span> (a &gt; P) a -= P ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		(a -= b) %= P ;</span><br><span class="line">		<span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += P ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fmul</span><span class="params">(<span class="keyword">int</span> *t, <span class="keyword">int</span> deg, <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = deg + <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">			tmp[i] = t[i], t[i] = t[i - <span class="number">1</span>] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= deg + <span class="number">1</span> ; ++ i)</span><br><span class="line">			add(t[i], (ll)opt * tmp[i] % P) ;   </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fdiv</span><span class="params">(<span class="keyword">int</span> *t, <span class="keyword">int</span> *ret, <span class="keyword">int</span> deg, <span class="keyword">int</span> opt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= deg ; ++ i) tmp[i] = t[i] ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = deg - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">			ret[i] = tmp[i + <span class="number">1</span>], dec(tmp[i], (ll)tmp[i + <span class="number">1</span>] * opt % P) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">get_xs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		fz[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			fmul(fz, i, (-x[i] + P) % P) ;</span><br><span class="line">		<span class="comment">//debug(fz, 1, n + 1, '\n') ;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">			<span class="keyword">int</span> fenmu = <span class="number">1</span> ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">				<span class="keyword">if</span> (i != j) fenmu = (ll)fenmu * (x[i] - x[j] + P) % P ;</span><br><span class="line">			fdiv(fz, fm, n + <span class="number">1</span>, -x[i]) ; </span><br><span class="line">			fenmu = (ll)y[i] * expow(fenmu, P - <span class="number">2</span>) % P ;</span><br><span class="line">		<span class="comment">//	cout &lt;&lt; fenmu &lt;&lt; endl ; </span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">				add(res[j], (ll)fenmu * fm[j] % P) ;</span><br><span class="line">		<span class="comment">//	debug(res, 1, n, '\n') ;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">		fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">			fac[i] = (ll)fac[i - <span class="number">1</span>] * i % P ;</span><br><span class="line">		inv[U] = expow(fac[U], P - <span class="number">2</span>) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">			inv[i - <span class="number">1</span>] = (ll)inv[i] * i % P ;</span><br><span class="line">		<span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line">		<span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">evenmark</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (x &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">get_dnx</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">bool</span> m)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m)&#123;</span><br><span class="line">			pre_do(n) ;</span><br><span class="line">			pres[<span class="number">0</span>] = <span class="number">1</span>, sufs[n + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">				pres[i] = ((ll)pres[i - <span class="number">1</span>] * (k - x[i]) % P + P) % P ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">				sufs[i] = ((ll)sufs[i + <span class="number">1</span>] * (k - x[i]) % P + P) % P ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">				now = (ll)pres[i - <span class="number">1</span>] * sufs[i + <span class="number">1</span>] % P ;</span><br><span class="line">				now = (ll)now * expow((ll)fac[i - <span class="number">1</span>] * fac[n - i] % P, P - <span class="number">2</span>) % P ;</span><br><span class="line">				now = (ll)evenmark(n - i) * y[i] % P * now % P ; ans = (ll)(ans + now) % P ; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> inow = <span class="number">1</span> ;</span><br><span class="line">			pres[<span class="number">0</span>] = <span class="number">1</span>, sufs[n + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">				pres[i] = ((ll)pres[i - <span class="number">1</span>] * (k - x[i]) % P + P) % P ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">				sufs[i] = ((ll)sufs[i + <span class="number">1</span>] * (k - x[i]) % P + P) % P ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">				inow = <span class="number">1</span>, now = (ll)pres[i - <span class="number">1</span>] * sufs[i + <span class="number">1</span>] % P ;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">					<span class="keyword">if</span> (i != j) inow = (ll)inow * ((x[i] - x[j]) % P + P) % P ; </span><br><span class="line">				ans = (ans + (ll)now * expow(inow, P - <span class="number">2</span>) % P * y[i] % P) % P ; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">namespace Linear_sieve&#123;</span></span><br><span class="line"><span class="comment">	int cnt ;</span></span><br><span class="line"><span class="comment">	int pr[N] ; </span></span><br><span class="line"><span class="comment">	int mu[N] ;</span></span><br><span class="line"><span class="comment">	int vis[N] ;</span></span><br><span class="line"><span class="comment">	void sieve(int U)&#123;</span></span><br><span class="line"><span class="comment">		mu[1] = 1 ;</span></span><br><span class="line"><span class="comment">		for (int i = 2 ; i &lt;= U ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">			if (!vis[i]) mu[i] = -1, pr[++ cnt] = i ; </span></span><br><span class="line"><span class="comment">			for (int j = 1 ; j &lt;= cnt ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">				if (i * pr[j] &gt; U) break ; </span></span><br><span class="line"><span class="comment">				vis[i * pr[j]] = 1 ; </span></span><br><span class="line"><span class="comment">				if (i % pr[j] == 0) break ; </span></span><br><span class="line"><span class="comment">				mu[i * pr[j]] = -mu[i] ; </span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">int</span> d, w, num ;</span><br><span class="line"><span class="keyword">int</span> base[N], cs[N] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; d &gt;&gt; w ; n = d + <span class="number">2</span> ; </span><br><span class="line"><span class="comment">//	using namespace Linear_sieve ; </span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> Interpolation ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">		x[i] = i, y[i] = (y[i - <span class="number">1</span>] + expow(x[i], d)) % P ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= w ; ++ i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; base[i] &gt;&gt; cs[i] ; get_xs(n) ; </span><br><span class="line"><span class="comment">//	debug(y, 1, n + 1, '\n') ;</span></span><br><span class="line"><span class="comment">//	debug(res, 1, n + 1, '\n') ;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">		now = <span class="number">0</span>, num = <span class="number">1</span> ;   </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= w ; ++ j)&#123;</span><br><span class="line">			now = expow(expow(base[j], cs[j] - <span class="number">1</span>), i - <span class="number">1</span>) ;</span><br><span class="line">			now = ((<span class="number">-1l</span>l * now * expow(base[j], d) % P) + P) % P ; </span><br><span class="line">			now = (now + expow(expow(base[j], cs[j]), i - <span class="number">1</span>)) % P ; </span><br><span class="line">			num = <span class="number">1l</span>l * num * now % P ; </span><br><span class="line">		&#125;</span><br><span class="line">		ans = (ans + (ll)num * res[i] % P) % P ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数学/积性函数/莫比乌斯反演</tag>
        <tag>多项式的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[bzoj3853] GCD Array</title>
    <url>/2020/03/31/GCD-Array/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>维护一个序列，支持以下操作：</p>
<p>1、给定 $n,d,v$ ，对每个 $(x,n)=d$ 的 $a_x\text{+=}v$ 。</p>
<p>2、询问 $\sum _{i=1}^k a_i$</p>
<p>$n\leq 10^5$</p>
</blockquote>
<p>很有意思的题目，解法也很简洁。</p>
<a id="more"></a>
<hr>
<p>妙妙题，建立一个辅助数组 $f$，让 $a_i=\sum _{d|i}f_d$ 。</p>
<p>考虑每次加的操作，对于每个 $i$ 实际上是加上这个东西：</p>
<script type="math/tex; mode=display">
\begin{align*}&[(n,i)=d]v\\= &[(\frac{n}{d},\frac{n}{i})=1]v\\= &\sum_{k|\frac{n}{d},k|\frac{n}{i}}\mu(k)v\end{align*}</script><p>考虑对 $f$ 反演:</p>
<script type="math/tex; mode=display">
f_d=\sum_{k|d}\mu(k)a_{\frac{d}{k}}</script><p>那么可以看出，其实每次操作就是对所有的 $k | \frac{n}{d}$ 的 $f_{kd}$ 加上了 $\mu(k)\cdot v$ .</p>
<p>考虑询问操作就是在询问</p>
<script type="math/tex; mode=display">
\sum_{i=1}^x\sum_{d|i}f_d=\sum_{d=1}^{x}\left[\frac{x}{d}\right] f_d</script><p>这个可以 $\sqrt n$ 分块来做。于是最后修改复杂度 $\sqrt[3] n\log n$，询问复杂度 $\sqrt n\log n$ 。 注意到可以调整块的大小，对于所有 $&lt;\sqrt {x\log x}$ 的位置暴力加，对于所有 $&gt;\sqrt {x\log x}$ 的位置，至多有 $\sqrt \frac{x}{\log x}$ 个。所以可以把 $\log $ 放到里面去。</p>
<p>当然我肯定是写 $\sqrt n\log n$ 的啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200110</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> L_s&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt ;</span><br><span class="line">	<span class="keyword">int</span> pr[N] ; </span><br><span class="line">	<span class="keyword">int</span> mu[N] ;</span><br><span class="line">	<span class="keyword">int</span> smu[N] ;</span><br><span class="line">	<span class="keyword">int</span> vis[N] ;</span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fc[N] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">		mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= U ; ++ i)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[i]) mu[i] = <span class="number">-1</span>, pr[++ cnt] = i ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i * pr[j] &gt; U) <span class="keyword">break</span> ; </span><br><span class="line">				vis[i * pr[j]] = <span class="number">1</span> ; </span><br><span class="line">				<span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ; </span><br><span class="line">				mu[i * pr[j]] = -mu[i] ; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">			smu[i] = smu[i - <span class="number">1</span>] + mu[i] ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= U ; ++ j)</span><br><span class="line">				fc[i * j].push_back(i) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ; </span><br><span class="line">ll _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &amp; (-x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; x &lt;= n ; x += low(x)) _bit[x] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	ll ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( ; x ; x -= low(x)) ret += (ll)_bit[x] ;</span><br><span class="line">	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> opt, x, d, v ; </span><br><span class="line">	L_s :: sieve(N - <span class="number">10</span>) ; </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ++ T ;</span><br><span class="line">		<span class="keyword">if</span> (!(m + n)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; T &lt;&lt; <span class="string">": "</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">		fill(_bit + <span class="number">1</span>, _bit + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">while</span> (m --)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;opt, &amp;x) ; </span><br><span class="line">			<span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;d, &amp;v) ; <span class="keyword">if</span> (x % d != <span class="number">0</span>) <span class="keyword">continue</span> ; </span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L_s :: fc[x / d].size() ; ++ i)</span><br><span class="line">					add(L_s :: fc[x / d][i] * d, L_s :: mu[L_s :: fc[x / d][i]] * v) ; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				ll ans = <span class="number">0</span> ;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)</span><br><span class="line">					r = x / (x / l), ans += (ask(r) - ask(l - <span class="number">1</span>)) * (ll)(x / l) ;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>数学/积性函数/莫比乌斯反演</tag>
        <tag>技巧/分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[UR#5 C]怎样跑的更快</title>
    <url>/2020/03/31/UR5-%E6%80%8E%E6%A0%B7%E8%B7%91%E7%9A%84%E6%9B%B4%E5%BF%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定 $n ≤ 10^5;c,d ≤ 10^9$ 。</p>
<p>现有长度为 $n$ 的序列 $b$ 满足 $b_{i} \equiv \sum_{i=1}^{n} \operatorname{gcd}(i, j)^{c}  \mathrm{lcm}(i, j)^{d} z_{j}(\bmod 998244353)$ 。</p>
<p>求 $\{z_n\}$ 。</p>
</blockquote>
<p>草，这真是一道神仙题。钛钛钛钛有趣辣！sto vfk .</p>
<a id="more"></a>
<p>先转化一下：</p>
<script type="math/tex; mode=display">
b_{i} \equiv \sum_{i=1}^{n} \operatorname{gcd}(i, j)^{c-d}\cdot i^d\cdot j^d\cdot  z_{j}(\bmod 998244353)</script><p>考虑形如 $\sum_{j=1}^{n}f(\gcd(i,j))\cdot g(i)\cdot h(j)\cdot z_j$ 等于某个值的东西，大概都是可做的。考虑先构造一个 $f’$ 满足</p>
<script type="math/tex; mode=display">
f(n)=\sum_{d|n}f'(d)</script><p>那么就可以化一下</p>
<script type="math/tex; mode=display">
\begin{aligned}&\sum_{j=1}^{n}f(\gcd(i,j))\cdot g(i)\cdot h(j)\cdot z_j\\=&\sum_{j=1}^n\sum_{d}[d|i]\cdot [d|j]\cdot f'(d)\cdot g(i)\cdot h(j)\cdot z_j\\=&\sum_{d|i}f'(d)\sum_{j=1}^n[d|j]\cdot g(i)\cdot h(j)\cdot z_j\end{aligned}</script><p>那么就相当于要验证</p>
<script type="math/tex; mode=display">
\sum_{d|i}f'(d)\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j =\frac{b_i}{g(i)}</script><p>如果能快速算 $\zeta(d)=\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j $ 的话，那么有</p>
<script type="math/tex; mode=display">
\sum_{d|i}f'(d)\zeta(d)=\frac{b_i}{g(i)}</script><p>考虑对于一个二元关系</p>
<script type="math/tex; mode=display">
\sum_{d|n} p(d)=q(n)</script><p>这东西，知道 $q$ 之后是可以很容易地容斥出 $p$ 的。那么也就是说可以很容易地得到 $f’(k)\zeta(k)$ 。那么同时由于知道了 $f(k)=k^{c-d}$ ，是很容易直接容斥出 $f’(k)$ 的。也就是现在 $\zeta$ 变成了已知。</p>
<p>考虑如何从 $\zeta(d)=\sum_{j=1}^n[d|j]\cdot h(j)\cdot z_j $ 反推出 $z_j$ 来，发现本质上是这样的：</p>
<script type="math/tex; mode=display">
\zeta(d)=\sum_{d|j} h(j)z_j</script><p>根据莫比乌斯反演的另一种形式</p>
<script type="math/tex; mode=display">
F(n)=\sum_{n | d} f(d)\Longrightarrow f(n)=\sum_{n | d} \mu\left(\frac{d}{n}\right) F(d)</script><p>反演一下变成</p>
<script type="math/tex; mode=display">
h(d)z_d=\sum_{d|j} \mu(\frac{j}{d})\zeta_j</script><p>然后就可以直接做了。</p>
<p>注意到以上每个推完的式子，求的时候都是 $nH(n)$ 的复杂度，$O(n\ln n)$ 。</p>
<p>神题神题，可能这是我接触过的最像莫比乌斯反演的莫比乌斯题。并且把反演的容斥作用很好地诠释了出来。</p>
<p>还有注意无解的情况，由于 $0$ 不存在逆元，所以在求逆元的时候需要判一下是否存在「求了0的逆元」这种情况，有就输出无解即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q ;</span><br><span class="line"><span class="keyword">int</span> b[N] ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> hz[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, c, d ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> zeta[N] ;</span><br><span class="line"><span class="keyword">int</span> fzeta[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	a += b ;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; P) a -= P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	(a -= b) %= P ;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) b += (P - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = (ll)res * a % P ;</span><br><span class="line">        a = (ll)a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Linear_s&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt ;</span><br><span class="line">	<span class="keyword">int</span> pr[N] ;</span><br><span class="line">	<span class="keyword">int</span> mu[N] ;</span><br><span class="line">	<span class="keyword">int</span> smu[N] ;</span><br><span class="line">	<span class="keyword">int</span> vis[N] ;</span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; fc[N] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">		mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= U ; ++ i)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[i]) mu[i] = <span class="number">-1</span>, pr[++ cnt] = i ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i * pr[j] &gt; U) <span class="keyword">break</span> ;</span><br><span class="line">				vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">				mu[i * pr[j]] = -mu[i] ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">			smu[i] = smu[i - <span class="number">1</span>] + mu[i] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= U ; ++ j)</span><br><span class="line">				fc[i * j].push_back(i) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> Linear_s ; </span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c &gt;&gt; d &gt;&gt; q ; sieve(n + <span class="number">10</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        g[i] = expow(i, d), f[i] = expow(i, c - d) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">            dec(f[i * j], f[i]) ;</span><br><span class="line">	<span class="keyword">while</span> (q --)&#123;</span><br><span class="line">		<span class="keyword">int</span> hasans = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; b[i], hz[i] = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			base[i] = (ll)expow(g[i], P - <span class="number">2</span>) * b[i] % P ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fzeta[i] = base[i] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">				dec(fzeta[i * j], fzeta[i]) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			<span class="keyword">if</span> (!f[i] &amp;&amp; fzeta[i]) &#123; hasans = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">		<span class="keyword">if</span> (!hasans) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">		<span class="comment">//debug(fzeta, 1, n, '\n') ; </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            zeta[i] = (ll)fzeta[i] * expow(f[i], P - <span class="number">2</span>) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">                add(hz[i], (mu[j] * zeta[i * j] % P + P) % P) ;</span><br><span class="line">		<span class="comment">//debug(zeta, 1, n, '\n') ; </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            ans[i] = (ll)hz[i] * expow(g[i], P - <span class="number">2</span>) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == n] ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>uoj</category>
      </categories>
      <tags>
        <tag>数学/积性函数/莫比乌斯反演</tag>
        <tag>数学/数值分析/调和级数</tag>
        <tag>思维题/容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>【听课笔记】Mobiüs反演听课笔记</title>
    <url>/2020/03/30/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是莫比乌斯反演这一块的听课笔记，由于记录的太长了<del>(不会的太多了)</del> 所以就分了一下。</p>
<p>反演好啊，有趣啊，不会啊！</p>
<a id="more"></a>
<h1 id="关于-mu-的有趣证明"><a href="#关于-mu-的有趣证明" class="headerlink" title="关于 $\mu$ 的有趣证明"></a>关于 $\mu$ 的有趣证明</h1><p>思考 $\mu$ 的本质，当 $n$ 含有平方因子的时候，$\mu(n)=0$；否则 $\mu(n)=(-1)^k$，其中 $k$ 是 $n$ 的本质不同质因子个数。</p>
<p>接下来考虑一步转化。设 $n=\sum p_i^{e_i},n’=\sum{p_i}$ 。那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{d|n}\mu(d)\\ 
= &\sum_{d|n'}\mu(d)\\
= &\sum_{i=0}^k \binom{k}{i}(-1)^i\\
= & ~(1+(-1))^k\\
= & ~[k=0]
\end{aligned}</script><h1 id="瞎反演记录"><a href="#瞎反演记录" class="headerlink" title="瞎反演记录"></a>瞎反演记录</h1><p>那大概使用来热身的。</p>
<ul>
<li>反演1</li>
</ul>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum _{i=1}^n\sum_{j=1}^m[i,j]
\\&=\sum _{d=1}^n\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{d}[(i,j)=d]
\\&=\sum _{d=1}^n\sum _{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor}i\cdot j\cdot d\cdot \sum_{p|i~\mathrm{and}~p|j}\mu(p) 
\\&=\sum _{d=1}^n d\sum_{p=1}^{\lfloor\frac{n}{d} \rfloor}\mu(p) \cdot p^2\sum_{i=1}^{\lfloor\frac{n}{pd} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{pd} \rfloor} j
\end{aligned}</script><ul>
<li>反演2</li>
</ul>
<script type="math/tex; mode=display">
\sum [n,i]\\
= \sum \frac{n\cdot i}{(n,i)}\\
= \sum_{d=1}^n\sum\frac{n\cdot i}{d}\cdot [(n,i)=d]\\
= \sum_{d=1}^n n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} i \sum \mu(k)\\
= \sum_{d=1}^nn\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\cdot k\cdot \sum_{i=1}^{\lfloor\frac{n}{dk}\rfloor} i</script><h1 id="各种题"><a href="#各种题" class="headerlink" title="各种题"></a>各种题</h1><h2 id="SPOJ-LCMSUM"><a href="#SPOJ-LCMSUM" class="headerlink" title="SPOJ LCMSUM"></a>SPOJ LCMSUM</h2><blockquote>
<p>求 $\sum _{i=1}^n \mathrm{lcm}(n,i)$ .</p>
<p>$n\leq 10^6,T\leq 10^5$ </p>
</blockquote>
<p>草，这真是个神仙题。考虑 $\rm lcm$ 自然是要转化成</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n} \operatorname{lcm}(i, n)=\sum_{i=1}^{n} \frac{i\cdot n}{\operatorname{gcd}(i, n)}</script><p>那么考虑快速计算这个东西。一个自然的想法考虑能不能筛，筛就要求必须要是狄利克雷卷积的形似。想要转化过去的话必须是对 $n$ 的因子求和，于是想到要按照 $\gcd $ 分类，那么 $\gcd(n,i)=d$ 的 $i$ 总共有 $\varphi(\frac{n}{d})$ 个。</p>
<p>但是注意到分类之后，由于每一项都带有 $i$ 所以无法快速计算。考虑一个性质，$\gcd(n,k)=\gcd(n,n- k)$ 。那么就是：</p>
<script type="math/tex; mode=display">
n\sum_{i=1}^n\frac{i}{\gcd(i,n)}=n\cdot \frac{1}{2}\left(\sum_{i=1}^n\frac{i}{\gcd(i,n)}+\sum_{i=1}^n\frac{n-i}{\gcd(n-i,n)}\right)=\frac{n}{2}\left(\sum_{i=1}^n\frac{i+(n-i)}{\gcd(i,n)}\right)=\frac{n^2}{2}\left(\sum_{i=1}^n\frac{1}{\gcd(i,n)}\right)</script><p>发现后面那一项就可以快速求和了：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n} \frac{1}{\operatorname{gcd}(i, n)}=\sum_{d|n} \frac{\varphi(\frac{n}{d})}{d}</script><p>那么答案就是</p>
<script type="math/tex; mode=display">
\frac{n}{2}\left(\sum_{d|n} \frac{n\cdot\varphi(\frac{n}{d})}{d}\right)=\frac{n}{2}\left(\sum_{d|n} d\cdot\varphi(d)\right)</script><p>就可以快速筛出来了。复杂度 $O(n)-O(1)$ 。</p>
<h2 id="HDU-4944"><a href="#HDU-4944" class="headerlink" title="HDU 4944"></a>HDU 4944</h2><blockquote>
<p>求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n} \sum_{j=i}^{n} \sum_{d | i, d|j} \frac{i j}{\operatorname{gcd}\left(\frac{i}{d}, \frac{j}{d}\right)}</script><p>$n,T\leq 5\times 10^5$</p>
</blockquote>
<p>首先看到 $d$ 知道要提出来</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^{n} \sum_{j=i}^{n} \sum_{d | i, d|j} \frac{i j}{\operatorname{gcd}\left(\frac{i}{d}, \frac{j}{d}\right)}\\
=&\sum_{i=1}^{n} \sum_{j=i}^{n} \mathrm{lcm}(i,j)\sum_{d|i,d|j}d\\
=&\sum_{d=1}^{n}d^2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=i}^{\lfloor\frac{n}{d}\rfloor} \mathrm{lcm}(i,j)
\end{aligned}</script><p>发现对于 $f(n)=\sum_{i=1}^n\sum_{j=i}^n \mathrm{lcm}(i,j)$ 可以转化成</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^i \mathrm{lcm}(i,j)</script><p> 也就是上面LCMSUM里面求得的东西。于是就可以整除分块做了。复杂度 $O(n+T\sqrt n)$ 。</p>
<p>注意到，预处理的时候还可以计算每个 $d$ 对于每个 $n$ 的贡献。具体一点，考虑本质上对于每个 $n$，$d$ 的贡献都是 $d^{2} f\left(\left\lfloor\frac{n}{d}\right\rfloor\right)$ ，至多有 $\left\lfloor\frac{n}{d}\right\rfloor$ 种不同的取值，且每个取值对应的 $n$ 的区间是连续的。于是就用一些差分技巧差分一下这个修改。注意到这个的复杂度是调和级数的，所以总复杂度 $O(n\ln n)-O(1)$ 。</p>
<p>其实这里还有一点题，但是因为觉得很有趣就单拿出来了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学/积性函数/莫比乌斯反演</tag>
        <tag>数学/积性函数/欧拉反演</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】同余</title>
    <url>/2020/03/29/%E6%95%B0%E8%AE%BA%E5%90%8C%E4%BD%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>发现当年学数论，4-6那本书第二三章基本上就是没学会，于是今天打算重学一遍。</p>
<p>发现还是很有意思的。并且发现读过的MO📚越多，这种东西就越好理解。</p>
<p>嗯，寓快于慢，藏巧于拙。</p>
<a id="more"></a>
<p>先定义一下解的「本质相同」：通常认为在模 $m$ 意义下的同余方程中 $x$ 和 $x+km(k\in\mathbb{Z_+})$ 是本质相同的。 </p>
<h1 id="同余的基本性质"><a href="#同余的基本性质" class="headerlink" title="同余的基本性质"></a>同余的基本性质</h1><p>1.</p>
<blockquote>
<p>若 $ac\equiv bc\pmod m$，且 $(m,c)=d$，则 $a\equiv b \pmod{\frac{m}{d}}$ 。</p>
</blockquote>
<script type="math/tex; mode=display">
ac\equiv bc\pmod m\Longrightarrow m|c(a-b)\Longrightarrow \frac{m}{d}|\frac{c}{d}(a-b)</script><p>因为 $(\frac{m}{d},\frac{c}{d})=1$ ，所以 $\frac{m}{d}|(a-b)$ 。</p>
<p>2、</p>
<blockquote>
<p>若给定 $m_i(i=1,2,3\cdots)$ ，且 $\forall i$ 有 $a\equiv b\pmod {m_i}$，则有</p>
<script type="math/tex; mode=display">
a\equiv b\pmod {[m_1,m_2,m_3\cdots ]}</script></blockquote>
<p>由 $\forall i,m_i|(a-b)$ 可知 $(a-b)$ 是 $m_1,m_2,m_3\cdots$ 的一个公倍数。所以 ${[m_1,m_2,m_3\cdots ]} |(a-b)$ 。</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1、证明</p>
<blockquote>
<p> $11$ 整除 $a$ 的充分必要条件是 $a$ 写成十进制表示后，从低位到高位，奇数位数字和减去偶数位数字和内被 $11$ 整除。</p>
</blockquote>
<p>我也不知道有啥好方法，编了一会儿觉得似乎 $100$ 进制的证法比较简单。就是考虑写成百进制的话会是这样：</p>
<script type="math/tex; mode=display">
\sum _{i=1}^ka_{i}100^{k-1}\equiv 0\pmod {11}</script><p>发现 $100 \bmod 11$ 是 $1$ ，就很快乐：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^ka_i\equiv 0\pmod {11}</script><p>然后考虑百进制转10进制，发现有</p>
<script type="math/tex; mode=display">
a_{i}=b^{2i-1}+10\cdot b^{2i}</script><p>那么考虑 $10$ 在 $\pmod {11}$ 时等价于 $-1$ ，于是就可以知道</p>
<script type="math/tex; mode=display">
\sum_{i=1}^ka_i=\sum_{i=1}^k(b^{2i-1}- b^{2i})\equiv 0 \pmod {11}</script><p>于是得证。</p>
<p>2、证明</p>
<blockquote>
<p>$7/11/13$ 整除 $a$ 的充分必要条件是，最后三位数字与删去最后三位以后组成的数，所作之差被 $7/11/13$ 整除。</p>
</blockquote>
<p>证明方法差不多？设后三位组成的数是 $b$ ，删去最后三位以后组成的数是 $c$ ，那么有</p>
<script type="math/tex; mode=display">
a=b+c\times 1000</script><p>若</p>
<script type="math/tex; mode=display">
a\equiv 0\pmod k</script><p>那么一定有</p>
<script type="math/tex; mode=display">
b+c\times (1000\bmod k)\equiv 0\pmod k</script><p>考虑 $1001=7\times 11\times 13$ ，所以可以知道 $1000 \bmod k\equiv -1 \pmod k$ 。于是得证。</p>
<h1 id="剩余类相关理论"><a href="#剩余类相关理论" class="headerlink" title="剩余类相关理论"></a>剩余类相关理论</h1><p>草，我是真觉得抽代入完门再来学这个比较合适。</p>
<p>于是因为内容太多了我就另开了一篇，想不到了吧？<del>机智如我</del></p>
<h1 id="一次同余方程"><a href="#一次同余方程" class="headerlink" title="一次同余方程"></a>一次同余方程</h1><blockquote>
<p>形如</p>
<script type="math/tex; mode=display">
ax\equiv b\pmod m\qquad (1)</script><p>的方程。</p>
</blockquote>
<h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote>
<p>若 $(a,m)=1$ ，则该式只有 $1$ 解。</p>
</blockquote>
<p>这是不难理解的。因为可以知道 $(1,2,3,\cdots m)$ 构成了模 $m$ 的一个完全剩余系，同时 $(a,2\cdot a,3\cdot a\cdots m\cdot a)$ 同样构成了模 $m$ 的一个完全剩余系。那么显然恰好一个整数使得 $aq\equiv b\pmod m$ . 所以解唯一。</p>
<h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote>
<p>(2.1) 若记 $(a,m)=d$ ，且 $d|b$ ，那么(1)式存在解。</p>
<p>(2.2) 在(2.1)的假设下，若(1)式存在解，那么解的个数为 $d$ 个。</p>
</blockquote>
<p>首先不难知道(1)等价于 $ax+my=b$ 这个不定方程。那么(2.1)是显然的。</p>
<p>对于(2.2)，考虑将(1)转化成</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{a}{d}x+\frac{m}{d}y&=\frac{b}{d}\\
\frac{a}{d}x&\equiv\frac{b}{d}\pmod {\frac{m}{d}}\qquad (2)\\
\end{aligned}</script><p>可知(1)和(2)的解是相同的。由定理1，且 $(\frac{a}{(a,m)},\frac{m}{(a,m)})=1$ 可知(2)的解是唯一的，设为 $t_0$</p>
<script type="math/tex; mode=display">
x_0\equiv t_0\pmod{\frac{m}{d}}</script><p>可知一定有 $0\leq t_0&lt;\frac{m}{d}$ 。</p>
<p>因此(1)的全部解一定都是 $t_0+k\frac{m}{d} (k\in \mathbb{Z_+})$ 的形式。考虑 $k=0,1,2\cdots d-1$ 的时候，有</p>
<script type="math/tex; mode=display">
t_0+k\frac{m}{d}<\frac{m}{d}</script><p>且由于其单调性可知这几个解互异。因此这 $d$ 个数在模 $m$ 下不同余。（证明了解至少有 $d$ 个）</p>
<p>另一方面，对(1)的任意一解 $t_0+k_0\frac{m}{d}$ ，令 $k_0=qd+r,0\leq r&lt;d$ 代入得：</p>
<script type="math/tex; mode=display">
t_0+k_0\frac{m}{d}\equiv t_0+(qd+r)\frac{m}{d}\equiv t_0+r\frac{m}{d} \pmod m</script><p>可知对于每个 $k_0$，均与某个 $0\leq k&lt;d$ 时的解本质相同。（证明了解至多有 $d$ 个）。</p>
<p>因此，该式共有恰好 $d$ 个解。</p>
<h2 id="一般解法技巧"><a href="#一般解法技巧" class="headerlink" title="一般解法技巧"></a>一般解法技巧</h2><p>有两种常用的技巧，都是基于将 $ax\equiv b\pmod m$ 转化为形式分式 $x\equiv \frac{b}{a}\pmod m$ 的基础上： </p>
<blockquote>
<p>1、分子分母同乘一个与 $m$ 互质的数。</p>
<p>2、当 $(a,m)=1$ 时，分子可以加上 $m$ 的倍数。</p>
</blockquote>
<p>注意到，限制「与 $m$ 互质」的目的是为了保证形式分式有意义，即只有 $(a,m)=1$，$a$ 在模 $m$ 意义下的逆元才有意义。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>一道毒瘤题</p>
<blockquote>
<p> 设 $p$ 为奇素数，$1&lt;a&lt;p$，则 $ax\equiv b\pmod p$ 的解为</p>
<script type="math/tex; mode=display">
x\equiv b (-1)^{a-1} \frac{(p-1)(p-2)\cdots (p-a+1)}{a!}\pmod p</script></blockquote>
<p>考虑把 $(-1)^{a-1}$ 乘到上面的括号里去</p>
<script type="math/tex; mode=display">
\begin{aligned}
&(-1)^{a-1} \frac{(p-1)(p-2)\cdots (p-a+1)}{a!}\\ \equiv&\frac{(1-p)(2-p)\cdots (a-1-p)}{a!}\\\equiv&\frac{(1)\cdot (2)\cdots (a-1)}{a!} \equiv\frac{1}{a}\pmod p
\end{aligned}</script><p>然后就证完了。毒瘤就毒瘤在…我太不会…/dk</p>
<p>个人认为写成这样帅一点</p>
<script type="math/tex; mode=display">
x\equiv b (-1)^{a-1} \binom{p}{a}\pmod p</script><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><blockquote>
<p>若 $m_1,m_2\cdots m_k$ 为两两互素的正整数，记 $M=\prod m$ ，$r_i=\frac{M}{m_i}$ ，则一次同余方程</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{cc}
x \equiv a_{1} & \left(\bmod m_{1}\right) \\
x \equiv a_{2} & \left(\bmod m_{2}\right) \\
\vdots \\
x \equiv a_{k} & \left(\bmod m_{k}\right)
\end{array}\right.</script><p>有唯一解 $x\equiv t$ ，且</p>
<script type="math/tex; mode=display">
t\equiv\sum _{i=1}^ka_ir_iq_i\pmod M</script><p>其中 $q_i=\frac{1}{r_i}\pmod {m_i}$ 。</p>
</blockquote>
<p><del>好难背啊</del></p>
<p>不过构造方式是很有趣的。大概就是考虑类似拉格朗日插值的构造方法，要找一堆 $\zeta_i$ 满足：</p>
<script type="math/tex; mode=display">
\zeta_i\equiv\left\{\begin{array}{cc}
1\pmod {m_j},\qquad j=i\\
0\pmod {m_j},\qquad j\not=i\\
\end{array}\right.</script><p>则可取</p>
<script type="math/tex; mode=display">
x_0=\sum_{i=1}^k\zeta_ia_i</script><p>作为一组解。那么显然据此构造的方案满足这个条件。</p>
<p>另一方面，对于另一个解 $x_1$ 有</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{cc}
x_0 \equiv x_{1} & \left(\bmod m_{1}\right) \\
x_0 \equiv x_{1} & \left(\bmod m_{2}\right) \\
\vdots \\
x_0 \equiv x_{1} & \left(\bmod m_{k}\right)
\end{array}\right.</script><p>由于 $m_1,m_2\cdots m_k$ 两两互素，可知 $x_1\equiv x_0\pmod M$。即全部的解都可以表示成</p>
<script type="math/tex; mode=display">
x\equiv x_0\pmod M</script><p>​                                                                              </p>
<h1 id="exCRT"><a href="#exCRT" class="headerlink" title="exCRT"></a>exCRT</h1><blockquote>
<p>大概就是给出的 $m_i$ 不再互质的情况。</p>
</blockquote>
<p>考虑此时普通的crt会出现什么问题。在 $m_i$ 彼此互质的情况下，可以知道 $r_i=\frac{M}{m_i}$ 保证 $(m_i,r_i)=1$，那也就保证了 $r_i$ 在模 $m_i$ 意义下存在逆元。但是当 $(m_i,r_i)&gt;1$ 时，$q_i$ 就没有意义了。</p>
<p>考虑增量法。一开始有两个方程</p>
<script type="math/tex; mode=display">
x\equiv a\pmod b\\
x\equiv c\pmod d \\</script><p>那么有 $bt+a≡c \pmod d$ 用 exgcd 解出 $t≡t_0 \pmod{\frac{d}{(b,d)}}$</p>
<p>代回得 $x ≡ x_0 \pmod{[b, d]} $。这样迭代做下去就好了。感觉写这种代码还是要把变量分清，尽量写的清楚、松散一点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll A[N] ;</span><br><span class="line">ll m[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">    ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">    x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">while</span> (b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			(res += a) %= mod ;</span><br><span class="line">		(a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll res, mod ;</span><br><span class="line">    ll a, b, c, d, M ;</span><br><span class="line">    ll x, y, t0, t, g, z ;</span><br><span class="line">    res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;	</span><br><span class="line">        a = res, b = mod ;</span><br><span class="line">        c = A[i], d = m[i] ;</span><br><span class="line">        g = exgcd(x, y, b, d) ;</span><br><span class="line">		z = ((c - a) % d + d) % d ;</span><br><span class="line">		M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">        res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; m[i] &gt;&gt; A[i] ;</span><br><span class="line">    ll op = excrt() ; <span class="keyword">if</span> (op &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"hahaha"</span>) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; op ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="神奇的例题"><a href="#神奇的例题" class="headerlink" title="神奇的例题"></a>神奇的例题</h1><h2 id="CF338D"><a href="#CF338D" class="headerlink" title="CF338D"></a>CF338D</h2><blockquote>
<p>给出一个 $n × m$ 的数表, 其中第 $i$ 行第 $j$ 个数是 $\gcd(i, j)$，再给定一个长度为 $k$ 的数列 $\{a_n\}$, 判断其是否在数表的某一行出现过。</p>
<p>$n,m ≤ 10^{12},k ≤ 10^4$</p>
</blockquote>
<p>一道有意思的题。考虑由于是要去寻找一行，所以行号是固定的。那么必须要有 $\mathrm{lcm}(a_1,a_2\cdots a_k)|x$ 。</p>
<p>考虑是否可以选用 $x=\mathrm{lcm}(a_1,a_2\cdots a_k)$ 做答案。注意到如果 $x=p\cdot \mathrm{lcm}(a_1,a_2\cdots a_k)$ 可行，那么一定有</p>
<script type="math/tex; mode=display">
\gcd(p,y) = 1</script><p>那么发现，对于 $p$ 的任意一个因子，都满足该性质。所以取 $p=1$ 完全没有问题。</p>
<p>之后考虑去检验 $y$ 的合法性。令第一个元素之前的那个元素(跟答案没关系的)为 $(x,y)$ 。发现 $y$ 需要满足</p>
<script type="math/tex; mode=display">
\gcd(y+1,x)=a_1,\gcd(y+2,x)=a_2,\gcd(y+3,x)=a_3\cdots</script><p>注意到 $x$ 是所有 $a_i$ 的 $\rm lcm$ 。那么可以知道 $y+i$ 一定需要是 $a_i$ 的倍数，也就是</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{l}
y+1\equiv 0\left(\bmod a_{1}\right) \\
y+2\equiv 0\left(\bmod a_{2}\right) \\
\vdots \\
y+k\equiv 0\left(\bmod a_{k}\right)
\end{array}\right.</script><p>那么用 excrt 求出这个 $y$ 来即可。需要注意的是，这样并不代表 $y$ 合法，因为 $y+i$ 是 $a_i$ 的倍数等价于 $\gcd(y+i,x)=a_i\cdot q$ 。 所以为了验证是否合法，需要再从头判一遍。</p>
<p>注意到如果此时不存在答案，那么也一定不存在其他的答案。这一点是比较显然的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Sunzi&#123;</span><br><span class="line">    ll A[N] ;</span><br><span class="line">    ll m[N] ;</span><br><span class="line">    <span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">        ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">        x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">	    ll res = <span class="number">0</span> ;</span><br><span class="line">	    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">		    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			    (res += a) %= mod ;</span><br><span class="line">	    	(a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ll res, mod ;</span><br><span class="line">        ll a, b, c, d, M ;</span><br><span class="line">        ll x, y, t0, t, g, z ;</span><br><span class="line">        res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">            a = res, b = mod ;</span><br><span class="line">            c = A[i], d = m[i] ;</span><br><span class="line">            g = exgcd(x, y, b, d) ;</span><br><span class="line">		    z = ((c - a) % d + d) % d ;</span><br><span class="line">		    M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">            t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">            res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Sunzi ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; k ; ll t = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]), m[i] = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i) A[i] = -i ; lcm = m[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">		t = m[i] * lcm, lcm = __gcd(lcm, m[i]), lcm = t / lcm  ;</span><br><span class="line">		<span class="keyword">if</span> (lcm &gt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; lcm &lt;&lt; " " &lt;&lt; t &lt;&lt; endl ; </span></span><br><span class="line">    t = excrt() ; <span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = t + <span class="number">1</span> ; i &lt;= t + k ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (__gcd(i, lcm) != base[i - t]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (t + k &lt;= p) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"YES"</span>), <span class="number">0</span> ; <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学/数论</tag>
      </tags>
  </entry>
  <entry>
    <title>【听课笔记】数论听课笔记</title>
    <url>/2020/03/28/%E6%95%B0%E8%AE%BA%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>听斯给普讲的有趣的数论问题，感觉海星？</p>
<p>顺便加上了一点自己之前随便整理的东西。</p>
<a id="more"></a>
<h1 id="瞎整理系列"><a href="#瞎整理系列" class="headerlink" title="瞎整理系列"></a>瞎整理系列</h1><h2 id="gcd-的实现"><a href="#gcd-的实现" class="headerlink" title="gcd 的实现"></a>gcd 的实现</h2><h3 id="一个必要的式子"><a href="#一个必要的式子" class="headerlink" title="一个必要的式子"></a>一个必要的式子</h3><blockquote>
<p> $a\geq b\to (a,b)=(b,a \bmod ~b)$</p>
</blockquote>
<p>令$a=bp+q~(0\leq 1&lt;b)$ 。若 $\exists d|a,d|b$，则有 $da’=db’p+q$，移项得 $q=d(a’-b’p)$，故$d|q\Longrightarrow d|(a\bmod~b)$。</p>
<p>考虑最后，$b’=0$，此时有 $a’=q’$，又因为 $\forall d$ 满足 $d|a,d|b$, $\exists d|q’\to d|a’$，即此时 $a’$ 是所有因子的倍数，故 $a’$ 为最大公因数。</p>
<p>说白了就是到最后有任意满足 $d|a,d|b$ 的 $d$ 都整除 $ans$ ，所以 $ans$ 是最大公因数。 </p>
<h3 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h3><p>考虑分类讨论，不妨令 $a&gt;b$.</p>
<ul>
<li>当 $\frac{a}{2}&gt;b$ 时，有 $a\bmod b&lt;b&lt;\frac{a}{2}$</li>
<li>当 $\frac{a}{2}\leq b$ 时，有 $a\bmod ~b=a-b&lt;\frac{a}{2}$</li>
</ul>
<p>所以复杂度是 $\log(\max(a,b))$ 的。</p>
<h2 id="exgcd-的实现"><a href="#exgcd-的实现" class="headerlink" title="exgcd 的实现"></a>exgcd 的实现</h2><p>考虑丢番图方程 $ax+by=(a,b)$ 。</p>
<p>发现迭代到 $x=1,y=0$ 时，上式依旧成立。因为迭代到此时 $a’=(a,b),b’=0$ 。</p>
<p>同时因为 $(a,b)=(b,a\bmod b)$，所以有 $bx+y\cdot (a\bmod ~b)=(a,b)$ ，化简：</p>
<script type="math/tex; mode=display">
\begin{aligned}
bx+y\cdot (a-b\cdot \lfloor \frac{a}{b}\rfloor)&= (a,b)\\
ay+b(x-y\cdot \lfloor \frac{a}{b}\rfloor) &=(a,b)
\end{aligned}</script><p>按照这种形式向上递归后，就会少一层$\bmod$ 然后就没有然后了。 </p>
<h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><blockquote>
<p>使得</p>
<script type="math/tex; mode=display">
a^x\equiv 1(\bmod p)</script><p>的最小的 $x$ 称为 $a$ 关于 $p$ 的<strong>阶</strong>。</p>
</blockquote>
<p>那么有结论 $x|\varphi(p)$ 。</p>
<p>考虑反证法。因为</p>
<script type="math/tex; mode=display">
a^x\equiv 1(\bmod p)\\
a^{\varphi(p)} \equiv 1(\bmod p)</script><p>且 $x$ 最小，故 $x&lt;\varphi(p)$ ，又因为假设 $x$ 不是 $\varphi(p)$ 的约数。那么不妨令 $\varphi(p)\equiv kx+q(0\leq q&lt;x)$ ，则有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{a^{\varphi(p)}}{(a^{x})^k}& \equiv a^q\\&\equiv 1(\bmod p)
\end{aligned}</script><p>但这显然不合理，因为 $x&gt;q$ 但根据定义 $x$ 应该是最小的满足 $a^o\equiv 1(\bmod p)$ 的数，QED。</p>
<h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><blockquote>
<p>对于素数 $p$，有</p>
<script type="math/tex; mode=display">
(p-1)!\equiv -1 (\bmod p)</script></blockquote>
<p>证明大概就是考虑，在$2,3,…,n-3,n-2$中，每个数有且仅有一个逆元，不会 $\geq p$ 且唯一，所以会互相抵消。</p>
<h1 id="exgcd的应用"><a href="#exgcd的应用" class="headerlink" title="exgcd的应用"></a>exgcd的应用</h1><h2 id="类欧几里得问题"><a href="#类欧几里得问题" class="headerlink" title="类欧几里得问题"></a>类欧几里得问题</h2><script type="math/tex; mode=display">
\sum_{x=1}^{n}\lfloor \frac{ax+b}{c}\rfloor</script><p>发现其实本质上求的是一条直线在 $x$ 正半轴和 $y$ 的正半轴的整点数量。那么考虑对于矩形区域可以随便求，对于三角形区域，可以让 $a$ 对 $c$ 取模之后依旧不影响结果，所以考虑沿着 $y=x$ 对称，那么会使得 $\frac{a}{c}$ 变成 $\frac{c}{a}$ ，这样就可以达到一个辗转相除的效果，复杂度 $\log n$ 。</p>
<h2 id="杂题1"><a href="#杂题1" class="headerlink" title="杂题1"></a>杂题1</h2><p>已知 $a_x=a_{x-1}+a_{x-2}$ ，给定 $a_1$, 求有多少个 $a_2\in[l,r]$ 使得 $a_k=b~(\bmod p)$. $k,p=O(10^9)$ 。</p>
<p>发现最后的 $a_k$ 一定可以写成 $ca_1+da_2=a_k=b(\mod p)$ ，然后就转化成一个瞎 $exgcd$ 问题了。</p>
<h1 id="多项式复合"><a href="#多项式复合" class="headerlink" title="多项式复合"></a>多项式复合</h1><blockquote>
<p> 已知 $f(x), g(x)$，求 $f(g(x))\mod x^n$ ，$1\leq n,m\leq 4000$。</p>
</blockquote>
<p>因为</p>
<script type="math/tex; mode=display">
f(g(x))=\sum_{i=0}^{n} f_{i} g(x)^{i}</script><p>于是考虑预处理 $g(x),g^2(x)\cdots g^p(x)$ ，和 $g^{2p}(x),g^{3p}(x)\cdots$ 这样，每块先对 $f_{i+kp}g(x)^i$ 求和再做多项式乘法。</p>
<p>最后复杂度就是 $O(nm+\sqrt mn\log n)$</p>
<h1 id="Stern-brocot-Tree"><a href="#Stern-brocot-Tree" class="headerlink" title="Stern-brocot Tree"></a>Stern-brocot Tree</h1><p>大概是把 $\frac{0}{1}$ 和 $\frac{1}{0}$ 当做两个虚根。然后每次在两个点 $\frac{n}{m}$ 和 $\frac{n’}{m’}$ 中间插入一个 $\frac{n’+n}{m’+m}$ 。之后大概是这样的：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<blockquote>
<p>bzoj 2852</p>
<p>给两个有理数 $a,b$，求最小的正整数 $k$, 使得 $(ak,bk)$ 里有整数。</p>
<p>$a$, $b$ 整数部分不超过 $2^{31}$ , 小数位数不超过 $300$ 位。</p>
</blockquote>
<p>发现 $(a,b)$ 的答案和 $(a-1,b-1)$ 的答案一样。所以考虑将 $(ak,bk)$ 移动到 $[0,1)$ 这个区间。此时如果 $b\geq 1$ 或者 $a=0$ 那么就可以找 $0/1$ 。否则就变成了解这样一个不等式：</p>
<script type="math/tex; mode=display">
a \times k \leq t \leq b \times k</script><p>也就是</p>
<script type="math/tex; mode=display">
a \leq \frac{t}{k} \leq b</script><p>那么就是找一个分母最小的夹在 $a,b$ 之间的分数。并且由于 $b&lt;1$ 所以一定是个真分数。那么就可以在stern-brocot Tree树上找LCA即可。</p>
<p>这个地方似乎是不用真的建出来树，因为存在某种神秘的树上二分方式，十分高妙。</p>
<h1 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h1><script type="math/tex; mode=display">
\left(\begin{array}{l}
n \\
m
\end{array}\right) \equiv\left(\begin{array}{l}
n \bmod p \\
m \bmod p
\end{array}\right) \times\left(\begin{array}{l}
\left\lfloor\frac{n}{p}\right\rfloor \\
\left\lfloor\frac{m}{p}\right\rfloor
\end{array}\right) \quad(\bmod p)</script><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>今天重学了一遍，发现证明好简单？</p>
<p>对于 $p$ 是质数而言，根据费马小定理一定有</p>
<script type="math/tex; mode=display">
(1+x)^p\equiv (1+x) \pmod p</script><p>和</p>
<script type="math/tex; mode=display">
x\equiv x^p  \pmod p</script><p>所以有</p>
<script type="math/tex; mode=display">
(1+x)^p\equiv 1+x^p \pmod p</script><p>如果设 $n=sp+t,~0\leq t&lt;p$ 。那么就有</p>
<script type="math/tex; mode=display">
\begin{aligned}
(1+x)^n\equiv &(1+x)^{sp+t}\\
\equiv &(1+x)^{sp}\cdot (1+x)^t\\
\equiv &(1+x^p)^s\cdot (1+x)^t\\
\equiv &(1+x^p)^{\left\lfloor\frac{n}{p}\right\rfloor}\cdot (1+x)^{x\bmod p}
\end{aligned}\pmod p</script><p>考虑两边都暴力二项式展开</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n\binom{n}{i}x^i=\left(\sum_{j=0}^{\left\lfloor\frac{n}{p}\right\rfloor}\binom{n}{j}x^{j\cdot p}\right)\times \left(\sum_{k=0}^{n\bmod p}\binom{n}{k}x^{k}\right)\pmod p</script><p>观察右边。发现因为后面那个括号里 $x$ 的次数 $&lt;p$，前面一个括号内 $x$ 的次数一定是 $p$ 的倍数 。所以对于每个 $i$ ，都有唯一的 $j\cdot p+k=i$ （带余除法的唯一性）。所以可知</p>
<script type="math/tex; mode=display">
\left(\begin{array}{l}
n\\
m
\end{array}\right) \equiv\left(\begin{array}{l}
n \bmod p \\
m \bmod p
\end{array}\right) \times\left(\begin{array}{l}
\left\lfloor\frac{n}{p}\right\rfloor \\
\left\lfloor\frac{m}{p}\right\rfloor
\end{array}\right) \quad(\bmod p)</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Lucas_T&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line">	ll ans, tn, tm, tp, fac[N], inv[N] ;</span><br><span class="line">	<span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">		ll ret = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">while</span> (b)&#123;</span><br><span class="line">			<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">				(ret *= a) %= mod ;</span><br><span class="line">			(a *= a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">my_assign</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">		tn = x ; tm = y ; tp = z ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">		fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">			fac[i] = fac[i - <span class="number">1</span>] * (ll)i % tp ;</span><br><span class="line">		inv[U] = expow(fac[U], tp - <span class="number">2</span>, tp) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">			inv[i - <span class="number">1</span>] = inv[i] * (ll)i % tp ;</span><br><span class="line">		<span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line">		<span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">comb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fac[a] * inv[b] % tp * inv[a - b] % tp ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">do_do</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0l</span>l ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; tp) <span class="keyword">return</span> comb(x, y) ; </span><br><span class="line">		<span class="keyword">return</span> do_do(x % tp, y % tp) * do_do(x / tp, y / tp) % tp ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Lucas</span><span class="params">()</span></span>&#123;</span><br><span class="line">		my_assign(n + m, n, p) ; </span><br><span class="line">		pre_do(tp - <span class="number">1</span>) ; ans = do_do(tn, tm) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以知道的是，Lucas定理还有另一种表示方式。如果把 $m,n$ 都看作 $p$ 进制数的话，即</p>
<script type="math/tex; mode=display">
m=(\overline{m_1m_2\cdots m_k})_p\\
n=(\overline{n_1n_2n_3\cdots n_k})_p</script><p>那么有</p>
<script type="math/tex; mode=display">
\binom{n}{m}\equiv\prod _{i=1}^k \binom{n_i}{m_i} \pmod p</script><p>其实不难理解，可以联想十进制数拆分出每一位的过程，也是 $\bmod 10$ 之后再除以 $10$ 。</p>
<h2 id="例题：古代猪文"><a href="#例题：古代猪文" class="headerlink" title="例题：古代猪文"></a>例题：古代猪文</h2><blockquote>
<p>求 $g^\sum\textstyle_{d|n}\binom{n}{d}\bmod 999911659$ 。</p>
</blockquote>
<p>发现 $999911658=2\times 3\times 4679\times 35617$ ，然后分别做 Lucas 再拿crt合并起来就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">999911659</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(ll *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000110</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Lucas_T&#123;</span><br><span class="line">	ll ans ;</span><br><span class="line">    ll tp, tn, tm ;</span><br><span class="line">    ll fac[N], inv[N] ;</span><br><span class="line">	<span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">		ll ret = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">while</span> (b)&#123;</span><br><span class="line">			<span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">				(ret *= a) %= mod ;</span><br><span class="line">			(a *= a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">my_assign</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">		tn = x ; tm = y ; tp = z ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pre_do</span><span class="params">(<span class="keyword">int</span> U)</span></span>&#123;</span><br><span class="line">		fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">			fac[i] = fac[i - <span class="number">1</span>] * (ll)i % tp ;</span><br><span class="line">		inv[U] = expow(fac[U], tp - <span class="number">2</span>, tp) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = U ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">			inv[i - <span class="number">1</span>] = inv[i] * (ll)i % tp ;</span><br><span class="line">		<span class="comment">//debug(fac, 1, U, '\n') ;</span></span><br><span class="line">		<span class="comment">//debug(inv, 1, U, '\n') ;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">comb</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fac[a] * inv[b] % tp * inv[a - b] % tp ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">do_do</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0l</span>l ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; tp) <span class="keyword">return</span> comb(x, y) ;</span><br><span class="line">		<span class="keyword">return</span> do_do(x % tp, y % tp) * do_do(x / tp, y / tp) % tp ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Lucas</span><span class="params">(ll x, ll y, ll z)</span></span>&#123;</span><br><span class="line">        my_assign(x, y, z) ;</span><br><span class="line">        ans = do_do(tn, tm) ; <span class="keyword">return</span> ans ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Sunzi&#123;</span><br><span class="line">    ll A[N], m[N] ;</span><br><span class="line">    <span class="function">ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line">        ll g = exgcd(x, y, b, a % b), tmp = x ;</span><br><span class="line">        x = y ; y = tmp - a / b * y ; <span class="keyword">return</span> g ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">exmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">	    ll res = <span class="number">0</span> ;</span><br><span class="line">	    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">		    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">			    (res += a) %= mod ;</span><br><span class="line">	    	(a += a) %= mod ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">excrt</span><span class="params">(<span class="keyword">int</span> pn)</span></span>&#123;</span><br><span class="line">        ll res, mod ;</span><br><span class="line">        ll a, b, c, d, M ;</span><br><span class="line">        ll x, y, t0, t, g, z ;</span><br><span class="line">        res = A[<span class="number">1</span>] ; mod = m[<span class="number">1</span>] ;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= pn ; ++ i)&#123;</span><br><span class="line">            a = res, b = mod ;</span><br><span class="line">            c = A[i], d = m[i] ;</span><br><span class="line">            g = exgcd(x, y, b, d) ;</span><br><span class="line">		    z = ((c - a) % d + d) % d ;</span><br><span class="line">		    M = d / g ; <span class="keyword">if</span> (z % g &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">            t = exmul(x, (z / g), M) ; mod = mod * M ;</span><br><span class="line">            res = ((res + exmul(t, b, mod)) % mod + mod) % mod ;</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line">ll n, g ;</span><br><span class="line">ll res[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line">ll p[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; g ;</span><br><span class="line">    <span class="keyword">if</span> (g % P == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="built_in">sqrt</span>(n) ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) base[++ cnt] = i ;</span><br><span class="line">    <span class="keyword">int</span> t = cnt ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= t ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n / base[i] &gt; <span class="built_in">sqrt</span>(n))</span><br><span class="line">            base[++ cnt] = n / base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">3</span> ; ++ i)&#123;</span><br><span class="line">        Lucas_T :: tp = p[i] ;</span><br><span class="line">		Lucas_T :: pre_do(p[i] - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)</span><br><span class="line">            (res[i] += Lucas_T :: Lucas(n, base[j], p[i])) %= (P - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">3</span> ; ++ i)</span><br><span class="line">        Sunzi :: A[i + <span class="number">1</span>] = res[i], Sunzi :: m[i + <span class="number">1</span>] = p[i] ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Lucas_T :: expow(g, Sunzi :: excrt(<span class="number">4</span>), P) &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题：组合数问题"><a href="#例题：组合数问题" class="headerlink" title="例题：组合数问题"></a>例题：组合数问题</h2><blockquote>
<p>求 $0≤j≤i≤n$ 且 $j≤m$ 的数对 $(i,j)$ 里有多少满足 $\binom{i}{j}≡0 \pmod p$</p>
<p>$T ≤ 100,n,m ≤ 10^{18},p ≤ 100$ 且是一个质数.</p>
</blockquote>
<p>根据上面那个性质，只要 $p$ 进制下 $i$ 的任何一位 $&lt;j$ 就 $\equiv 0$ 。然后就直接数位dp就完了。</p>
<h2 id="小-Q-的集合"><a href="#小-Q-的集合" class="headerlink" title="小 Q 的集合"></a>小 Q 的集合</h2><blockquote>
<p>求从 $n$ 元集合 $\rm S$ 中随机选择一个子集 $\rm T$ 。求 $|\mathrm{S−T}|^k −|\mathrm{T}|^k$ 的方差。</p>
<p>$n≤10^{10^6},k≤10$，答案对质数 $m≤10^6$ 取模。</p>
</blockquote>
<p>嗯，学习了一下方差的定义。记这个东西的期望是 $E(x)$ ，那么方差就是 $E([x-E(x)]^2)=E(x^2)-E^2(x)$。</p>
<p>嗯，得出结论，概率论这一套是学不懂的。</p>
<p>说做法吧。根据期望的线性性，可以得到这个东西的期望是</p>
<script type="math/tex; mode=display">
E(|\mathrm{S−T}|^k −|\mathrm{T}|^k)= E(|\mathrm{S−T}|^k)-E(|\mathrm{T}|^k)</script><p>那么显然这两项是对称的，所以这个东西的期望就是 $0$ 。所以就只需要求 $|\mathrm{S−T}|^k −|\mathrm{T}|^k$ 的平方的期望就可以了。那么答案也就是</p>
<script type="math/tex; mode=display">
\frac{\sum\limits_{i=0}^{n}\binom{n}{i}\left(i^{k}-(n-i)^{k}\right)^{2}}{2^n}</script><p>emmm然而并不可以直接做。然后有个很神仙的点就是考虑拿Lucas定理来展开一层得到：</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{\lfloor \frac{n}{m}\rfloor}\left(\begin{array}{c}
\left\lfloor\frac{n}{m}\right\rfloor \\
i
\end{array}\right) \sum_{j=0}^{n \bmod m}\left(\begin{array}{c}
n \bmod m \\
j
\end{array}\right)\left(j^{k}-(n-j)^{k}\right)^{2}</script><p>这么做是对的就在于每个 $\binom{n}{j}$ 都被分解成了唯一的 $\binom{\lfloor \frac{n}{m}\rfloor}{i}\cdot \binom{n\bmod m}{j}$ ，那么这两部分就可以<strong>分别算了</strong>。第一部分很显然就是 $2^n$ ，第二部分直接做就可以了。</p>
<p>嗯，这题真是十分高妙。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数论有意思！</p>
<p>exLucas是不可能学的…</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学/扩展欧几里德</tag>
        <tag>数学/数论</tag>
        <tag>数学/阶与原根</tag>
      </tags>
  </entry>
  <entry>
    <title>【听课笔记】带权二分(wqs二分)</title>
    <url>/2020/03/25/%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个东西大概好早就想学了，但是一直没学。这次就认真学一下吧。</p>
<a id="more"></a>
<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>当题目给了一个选物品的限制条件，要求刚好选 $m$ 个，要求最大化/最小化权值，然后其特点就是当选的物品越多的时候权值越大(越小)。</p>
<p><del>然后大概这个凸性一般都是靠猜的</del></p>
<p>考虑去二分一个 $w$，表示选一个满足限制的物品时附加的权值，如果 $w$ 越大，那么选的物品个数就会越多/越少，权值越大/小。考虑当这个函数是凸的时候，于是当选的物品个数大于 $m$ 时，减小 $w$，否则增大 $w$，最后计算答案的时候去掉 $w$ 值的影响即可。</p>
<p>考虑这么做的原理。如果设 $f(x)$ 表示选了 $x$ 个满足限制的物品时的最优解。那么根据凸性，$f(x)$ 随着 $x$ 的增大，斜率单调，所以一定会是一个下凸壳或者上凸壳。但问题就在于唯一知道的信息只是其凸性，无法求出 $f(m)$ 的准确值。</p>
<p>考虑凸壳的一个特点。假设这个凸壳是光滑的，那么对于每个斜率 $k$ ，凸壳上一定存在一点与某条该斜率的直线相切。同时假设斜率为 $k$ 但不限制截距的直线 $l$ 与该凸壳有交时，截距的极值一定是取到 $l$ 与凸壳相切的时候。</p>
<p>记截距为 $b$ 。可知有 $b=f(x) - kx$ 。考虑构造这个式子中 $b$ 的含义，发现本质上等价于每选一个物品，$f(x)$ 就要减掉 $k$ ，最终选了 $x$ 个物品，总答案就要减小 $kx$ 。 所以考虑如果把所有物品的权值一开始就减掉 $k$，那么当 $f(x)$ 最大时，$b$ 也一定最大。所以此时对于某个斜率 $k$，都可以线性或者低次 $poly(\log)$ 求出 $\min\{f(x)\}$ 并且求出决策点 $x$。</p>
<p>考虑如何加速这个过程。发现在凸的时候，斜率 $k$ 和 $x$ 同时单调，于是考虑二分这个斜率。例如在某个斜率 $k’$ 下选择的物品 $&gt;m$ ，那么就需要让 $x$ 变小，根据 $k$ 和 $x$ 的相对单调关系调整即可。</p>
<h1 id="12年集训队胡策-Tree-I"><a href="#12年集训队胡策-Tree-I" class="headerlink" title="12年集训队胡策 Tree I"></a>12年集训队胡策 Tree I</h1><blockquote>
<p>给你⼀个⽆向带权连通图，每条边是⿊⾊或⽩⾊。让你求⼀棵最⼩权的恰好有 $need$ 条⽩⾊边的⽣成树。</p>
<p>$1\leq n\leq 50000,1\leq m\leq 100000$ 。</p>
</blockquote>
<p>发现就是 $wqs$ 二分的裸题。那么考虑直接去二分每条白边加上的权值 $w$ 即可。注意到白边无论 $w$ 是多少，选取时的单调性不变。所以可以利用这个将复杂度从 $m(\log m+\log n) \log V$ 优化到 $m\log n\log v+m\log m $。注意到并查集的 $\log $ 是极小的。</p>
<p>但值得注意的是，这题构造方案的话并不存在一个很简单的方法。</p>
<p>还有一点细节需要注意。就是假设存在某几条黑边与加权之后的白边权值相同的话，不能随便选。本质上，优先选黑边和优先选白边都一样。也就是需要规定优先选白边或者优先选黑边，但是两者的处理方式是不同的。如果优先选黑边的话，那么判的时候就要判 $\leq$ ，优先选白边则需要判 $\geq$ 。</p>
<p>亲测似乎优先选白边会快一点。下面是优先选黑边的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fr ;</span><br><span class="line">	<span class="keyword">int</span> to ;</span><br><span class="line">	<span class="keyword">int</span> clr ;</span><br><span class="line">	<span class="keyword">int</span> val ; </span><br><span class="line">	<span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ; </span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ; </span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="keyword">int</span> head[N] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">	to(++ cnt) = y ;  </span><br><span class="line">	nxt(cnt) = head[x] ; head[x] = cnt ;</span><br><span class="line">	fr(cnt) = x ; val(cnt) = w ; clr(cnt) = c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge a, Edge b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.val == b.val ? a.clr &gt; b.clr : a.val &lt; b.val ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mst</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> re = <span class="number">0</span>, ret = <span class="number">0</span>, y = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (!clr(i)) val(i) += x ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fa[i] = i ;</span><br><span class="line">	sort(E + <span class="number">1</span>, E + cnt + <span class="number">1</span>, comp) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> f1 = find(fr(i)) ;</span><br><span class="line">		<span class="keyword">int</span> f2 = find(to(i)) ;</span><br><span class="line">		<span class="keyword">if</span> (f1 == f2) <span class="keyword">continue</span> ; </span><br><span class="line">		ret += val(i) ; fa[f1] = f2 ;  </span><br><span class="line">		re += (clr(i) ^ <span class="number">1</span>) ; ++ y ; </span><br><span class="line">		<span class="keyword">if</span> (y == n - <span class="number">1</span>) <span class="keyword">break</span> ;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (!clr(i)) val(i) -= x ; </span><br><span class="line">	<span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; re &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl ;</span></span><br><span class="line">	<span class="keyword">if</span> (re &lt;= k)&#123;</span><br><span class="line">		ans = ret - k * x ;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u, v, w, c ;</span><br><span class="line">	ios:: sync_with_stdio(<span class="literal">false</span>) ;</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; c, add(++ u, ++ v, w, c) ;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>, mid, res ;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">		mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">		<span class="keyword">if</span> (mst(mid)) r = mid - <span class="number">1</span> ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; res &lt;&lt; endl ; mst(res) ;</span></span><br><span class="line">	<span class="built_in">cout</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="IOI2000-邮局"><a href="#IOI2000-邮局" class="headerlink" title="IOI2000 邮局"></a>IOI2000 邮局</h1><blockquote>
<p>⼀条路有 $n$ 个村庄，你要建 $k$ 个邮局，每个村庄到最近邮局距离最小。</p>
<p>$k\leq 300,n\leq 3000$ 。</p>
</blockquote>
<p>这个东西，就显然是 $f_{i,j}$ 记一下，然后放 $k\to i$ 的中点就好了。这样复杂度是 $n^2k$ 的。然后编一下发现有决策单调性，就可以 $O(nk\log n)$ 甚至 $O(nk)$ 了。</p>
<p>然而这个地方打算记录一下怎么 $wqs$ 做。考虑去优化一下上面那种解法，发现 $k$ 这个限制可以通过wqs二分给消掉，就变成了如果建一次邮局需要额外支付 $mid$ 的代价，但是不限制建的次数时的最短距离和。这个东西就变成了一个1D/1D的 $dp$ ，并且也具有决策单调性。这一部分就可以继续单调栈+二分做到 $n\log V\log n$ </p>
<p>似乎有什么很优秀的单调队列做法可以做到线性。不过写了写发现似乎二分的常数还是很小的，$n=5\times 10^5$ 也只需要谷 $2.7s$ 、uoj $2s$ 左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define int long long </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tp ;</span><br><span class="line">ll res ;</span><br><span class="line">ll f[N] ;</span><br><span class="line">ll sum[N] ;</span><br><span class="line"><span class="keyword">int</span> lrg[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1</span> &lt;&lt; <span class="number">21</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (front == end) end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span> (front == end) ? <span class="number">-1</span> : *(front++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qr</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qra</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __n; ++i) qr(__ary[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qrs</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">  T *beg = p;</span><br><span class="line">  <span class="keyword">do</span> *p = GetChar(); <span class="keyword">while</span> (!<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  <span class="keyword">do</span> *(++p) = GetChar(); <span class="keyword">while</span> (<span class="built_in">isalnum</span>(*p));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qrdb</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = GetChar(), lst = x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) lst = ch, ch = GetChar();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + (ch - <span class="string">'0'</span>); ch = GetChar(); &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">    ch = GetChar();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> t = <span class="number">0.1</span>; <span class="built_in">isdigit</span>(ch); t *= <span class="number">0.1</span>) &#123;</span><br><span class="line">      x += (t * (ch - <span class="string">'0'</span>));</span><br><span class="line">      ch = GetChar();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> buf[L];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123; buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>); &#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (aft) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qwa</span><span class="params">(T *<span class="keyword">const</span> __ary, <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> e1, <span class="keyword">const</span> <span class="keyword">char</span> e2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; __n; ++i) qw(__ary[i], e1);</span><br><span class="line">  qw(__ary[__n], e2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">int</span> __n, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; __n; ++i) <span class="built_in">putchar</span>(p[i]);</span><br><span class="line">  <span class="keyword">if</span> (ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qws</span><span class="params">(T *p, <span class="keyword">const</span> <span class="keyword">char</span> ed)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (*p) <span class="built_in">putchar</span>(*p++);</span><br><span class="line">  <span class="keyword">if</span>(ed) <span class="built_in">putchar</span>(ed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IPT::qr;</span><br><span class="line"><span class="keyword">using</span> IPT::qra;</span><br><span class="line"><span class="keyword">using</span> IPT::qrs;</span><br><span class="line"><span class="keyword">using</span> IPT::qrdb;</span><br><span class="line"><span class="keyword">using</span> OPT::qw;</span><br><span class="line"><span class="keyword">using</span> OPT::qwa;</span><br><span class="line"><span class="keyword">using</span> OPT::qws;</span><br><span class="line"></span><br><span class="line"><span class="function">il ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    ll h = (l + r + <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">    ll ret = sum[r] - sum[h] ;</span><br><span class="line">    ll d1 = <span class="number">1l</span>l * (h - l) * base[h] ;</span><br><span class="line">    ll d2 = <span class="number">1l</span>l * (r - h) * base[h] ;</span><br><span class="line">    <span class="keyword">return</span> ret - d2 + d1 - sum[h] + sum[l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">trans</span><span class="params">(ll p, ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[p] + calc(p, x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    stk[tp = <span class="number">0</span>] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span> ; lrg[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; tp &amp;&amp; lrg[h] &lt; i)</span><br><span class="line">            ++ h ; <span class="keyword">if</span> (lrg[h] &gt; i) -- h ;</span><br><span class="line">        f[i] = trans(stk[h], i) + x, cnt[i] = cnt[stk[h]] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (tp &amp;&amp; trans(stk[tp], lrg[tp]) &gt;= trans(i, lrg[tp]))</span><br><span class="line">            stk[tp] = <span class="number">0</span>, lrg[tp] = n + <span class="number">1</span>, -- tp ;</span><br><span class="line">        <span class="keyword">int</span> l = lrg[tp], r = n, mid, ans = n + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (trans(stk[tp], mid) &gt;= trans(i, mid))</span><br><span class="line">                ans = mid, r = mid - <span class="number">1</span> ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt;= n) stk[++ tp] = i, lrg[tp] = ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    res = f[n] - x * m ; <span class="keyword">return</span> (<span class="keyword">bool</span>)(cnt[n] &lt; m) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    qr(n) ; qr(m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        qr(base[i]), sum[i] = sum[i - <span class="number">1</span>] + (ll)base[i] ;  </span><br><span class="line">    ll l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid, ans ; </span><br><span class="line">    lrg[<span class="number">0</span>] = <span class="number">1</span> ; sum[n + <span class="number">1</span>] = sum[n] ; </span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid - <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">else</span> ans = mid, l = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    check(ans) ; qw(res) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="IOI2000-邮局-环版本"><a href="#IOI2000-邮局-环版本" class="headerlink" title="IOI2000 邮局(环版本)"></a>IOI2000 邮局(环版本)</h1><blockquote>
<p>改成环上建 $k$ 个邮局了。数据范围还是不变的。</p>
</blockquote>
<p>考虑破环为链的问题在于，$n\to 1$ 那边可能存在没有考虑到的问题，同时由于限制了邮局数量而不能在后面接成 $2n$ 的链。于是比较暴力的方法自然是随机化，随机第一个邮局的位置，那么显然需要随机 $&gt;\frac{n}{k}$ 次，比如 $\frac{n}{k}\log n$ ，这样暴力做的复杂度就变成了  $O(nk\log n)\cdot O(\frac{n}{k}\log n)=O(n^2\log n)$ 。</p>
<p>考虑更好一点的做法。由于无论是在环上还是在链上，这个模型都满足四边形不等式，所以可以知道，任意两条不同起点的转移路径，一定要么重合，要么有 $k$ 个交点。所以可以随便选一个起点，跑一次dp，构造出转移路径来，假设是 $u_1\to u_2\to u_3\cdots\to u_k$ ，那么随便选择两个端点，比如 $u_p\to u_{p+1}$ ，可知最优解一定有一个转移点在 $u_p\to u_{p+1}$ 之间，那么只需要找到一组间隔最小的作为起点即可（环上的转移路径起点任意）。由于两点之间距离上界是 $O(\frac{n}{k})$ ，所以如果套用链里的 $O(n\log n\log V)$ 的做法，最终复杂度就是 $O(\frac{n^2}{k}\log n\log w)$ ，在 $k$ 很小的时候是不优的。</p>
<p>…思考了一下，似乎不知道当 $k$ 很小的时候有什么比较精妙的做法，因为无论怎么化，最后复杂度的大头都落在 $n$ 上emmm</p>
<p>好的吧，直接正解吧。考虑上面说的那个性质，假设最优解的转移路径为 $v_1\to v_2\to v_3\cdots v_k$ ，那么一定有 </p>
<script type="math/tex; mode=display">
u_1\leq v_1<u_2\\u_2\leq v_2 < u_3\\ \cdots \\u_k\leq v_k<u_1+n</script><p>类似这样。那么可以知道类似于每一层找一个决策点，同时也由于决策单调性，只会同时出现在 $mid$ 的同一边，那么最终的决策数是 $\frac{n}{k}\cdot k\cdot \log n=n\log n$ ，再套一层分治，最终复杂度 $O(n\log ^2 n+n\log n\log V) 。$ 。</p>
<p>一个小细节，就是第一层需要 $&lt;\frac{n}{k}$，这样才能保证决策数。</p>
<h1 id="LG4983忘情"><a href="#LG4983忘情" class="headerlink" title="LG4983忘情"></a>LG4983忘情</h1><blockquote>
<p>将一个长为 $n$ 的序列划分成 $m$ 段，每段 $[l,r]$ 的代价是</p>
<script type="math/tex; mode=display">
\frac{\left(\left(\sum_\limits{i=l}^{r} x_{i} \times \bar{x}\right)+\bar{x}\right)^{2}}{\bar{x}^{2}}</script><p>最小化这个代价。</p>
<p>$1\leq n\leq 10^5$ 。</p>
</blockquote>
<p>首先提一下平方化一下式子得到代价本质上是</p>
<script type="math/tex; mode=display">
\left(1+\sum_{i=l}^rx_i\right)^2</script><p>然后发现，这显然就是分的段越多越好，理想情况下(代价最小)就是分 $n$ 段。那么这个东西就显然是凸的，虽然是半凸壳但至少也是凸的。于是就去二分每分一段应该支付多少代价即可，似乎转移难度比上一道题还简单不少？</p>
<p>注意到二分内部写决策单调性是带 $\log$ 的，虽然我总觉得应该可以线性(但据dls说那种线性做法常数很大)，于是复杂度就是 $n\log n\log V$ 的。不开 <code>-O2</code> 在谷的表现并不好，开了之后性能有了超大的飞跃。</p>
<p>代码没啥可贴的，我就是copy了上道题的代码然后改了改转移（</p>
<h1 id="CF958E2"><a href="#CF958E2" class="headerlink" title="CF958E2"></a>CF958E2</h1><blockquote>
<p>给定 $n$ 个时间点。每个区间都以某两个时间点为左右端点，且每个区间的「代价」定义端点的时间之差。你要选择 $k$ 个连续的区间，保证这个 $k$ 个连续的区间没有交集，且代价总和最小。</p>
<p>$1\leq n\leq 500000,1\leq k\leq 5000$</p>
</blockquote>
<p>考虑一般 $dp$ 的话就是 $f_{i,j}$ ，这个地方由于不限制一定要取满，所以就可以有如下转移：</p>
<script type="math/tex; mode=display">
f_{i,j}=\min\{f_{i-1,j},f_{i-2,j-1}+len(i-1,i)\}</script><p>似乎常数小一点，暴力 $O(nk)$ 也是可以过的。于是就直接wqs二分一下，注意到由于此时最优的决策一定是少选，所以每选一次就需要减去 $mid$ 来维护这个限制。于是最后复杂度 $n\log V$ 。</p>
<p>需要注意的是，由于用了 $cnt_i$ 记录转移到 $i$ 这个状态至少要分成多少段，所以这个地方还是牵扯到一个，如果我可以有 $6/7/8$ 三种划分方式转移到最优解，那么到底应该用哪个。很显然的是要么用 $max$ 要么用 $min$，这取决于二分的方式。如果是取 $max$ 的话，那么可能 $cnt_n&gt;m$ ；取 $min$ 的话则会 $\leq m$ 。所以根据这个调整代码细节就好了。</p>
<p>┮﹏┭这个地方真的是坑了我好久。<del>画外音: 你Tree I那题白做了？？</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll res ;</span><br><span class="line">ll f[N] ;</span><br><span class="line"><span class="keyword">int</span> m, n ;</span><br><span class="line"><span class="keyword">int</span> df[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	x *= <span class="number">-1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i - <span class="number">1</span>] &lt; f[i - <span class="number">2</span>] + df[i] + x)</span><br><span class="line">			f[i] = f[i - <span class="number">1</span>], cnt[i] = cnt[i - <span class="number">1</span>] ; </span><br><span class="line">		<span class="keyword">else</span> f[i] = f[i - <span class="number">2</span>] + (ll)df[i] + (ll)x, cnt[i] = cnt[i - <span class="number">2</span>] + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">if</span> (f[i - <span class="number">1</span>] == f[i - <span class="number">2</span>] + df[i] + x) cnt[i] = max(cnt[i - <span class="number">1</span>], cnt[i - <span class="number">2</span>] + <span class="number">1</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	res = f[n] - (ll)x * m ; <span class="keyword">return</span> (<span class="keyword">bool</span>)(cnt[n] &gt;= m) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">	sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">		df[i] = base[i] - base[i - <span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid, ans ; </span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">		mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//		cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ; </span></span><br><span class="line">		<span class="keyword">if</span> (check(mid)) ans = mid, r = mid - <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">	&#125;	</span><br><span class="line">	check(ans) ; <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="国家集训队-种树"><a href="#国家集训队-种树" class="headerlink" title="[国家集训队]种树"></a>[国家集训队]种树</h1><blockquote>
<p>就是那个围着坑种树. 要求必须种 K 棵。</p>
</blockquote>
<p>首先由于 $m$ 的限制，加上权值会有负数所以多选和少选都有可能导致结果不优，所以很容易想到要去wqs二分。二分之后就变成了求解没有 $m$ 的限制的最大值问题。自然的想法是考虑 $f_i$ 表示前 $i$ 个坑种树的最大收益，那么转移就是考虑第 $i$ 个坑种不种，即 $f_i=\max\{f_{i-1},f_{i-2}+val_i\} $ 。</p>
<p>但是这个地方存在一个问题，就是第 $n$ 个和第 $1$ 个之间可能存在不合法。于是就理所应当地再记一维 $0/1$ 表示第 $1$ 个坑到底种不种树，转移到 $n$ 的时候特判一下。 这样就可以解决了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll res ;</span><br><span class="line"><span class="keyword">int</span> m, n ;</span><br><span class="line"><span class="keyword">int</span> df[N] ;</span><br><span class="line">ll f[N][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt[N][<span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ; cnt[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>] = base[<span class="number">1</span>] + x, cnt[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">0</span>] &gt; f[i - <span class="number">2</span>][<span class="number">0</span>] + x + base[i])</span><br><span class="line">			f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>], cnt[i][<span class="number">0</span>] = cnt[i - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">0</span>] &lt; f[i - <span class="number">2</span>][<span class="number">0</span>] + x + base[i]) </span><br><span class="line">			f[i][<span class="number">0</span>] = f[i - <span class="number">2</span>][<span class="number">0</span>] + x + base[i], cnt[i][<span class="number">0</span>] = cnt[i - <span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>], cnt[i][<span class="number">0</span>] = max(cnt[i - <span class="number">1</span>][<span class="number">0</span>], cnt[i - <span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">1</span>] &gt; f[i - <span class="number">2</span>][<span class="number">1</span>] + x + base[i])</span><br><span class="line">			f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>], cnt[i][<span class="number">1</span>] = cnt[i - <span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (f[i - <span class="number">1</span>][<span class="number">1</span>] &lt; f[i - <span class="number">2</span>][<span class="number">1</span>] + x + base[i]) </span><br><span class="line">			f[i][<span class="number">1</span>] = f[i - <span class="number">2</span>][<span class="number">1</span>] + x + base[i], cnt[i][<span class="number">1</span>] = cnt[i - <span class="number">2</span>][<span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">1</span>], cnt[i][<span class="number">1</span>] = max(cnt[i - <span class="number">1</span>][<span class="number">1</span>], cnt[i - <span class="number">2</span>][<span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	f[n][<span class="number">1</span>] = f[n - <span class="number">1</span>][<span class="number">1</span>] ; </span><br><span class="line">	cnt[n][<span class="number">1</span>] = cnt[n - <span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">if</span> (f[n - <span class="number">1</span>][<span class="number">0</span>] &gt; f[n - <span class="number">2</span>][<span class="number">0</span>] + x + base[n])</span><br><span class="line">		f[n][<span class="number">0</span>] = f[n - <span class="number">1</span>][<span class="number">0</span>], cnt[n][<span class="number">0</span>] = cnt[n - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (f[n - <span class="number">1</span>][<span class="number">0</span>] &lt; f[n - <span class="number">2</span>][<span class="number">0</span>] + x + base[n]) </span><br><span class="line">		f[n][<span class="number">0</span>] = f[n - <span class="number">2</span>][<span class="number">0</span>] + x + base[n], cnt[n][<span class="number">0</span>] = cnt[n - <span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">else</span> 			</span><br><span class="line">		f[n][<span class="number">0</span>] = f[n - <span class="number">1</span>][<span class="number">0</span>], cnt[n][<span class="number">0</span>] = max(cnt[n - <span class="number">1</span>][<span class="number">0</span>], cnt[n - <span class="number">2</span>][<span class="number">0</span>] + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (f[n][<span class="number">0</span>] &gt; f[n][<span class="number">1</span>])&#123;</span><br><span class="line">		res = f[n][<span class="number">0</span>] - (ll)x * m ; </span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">bool</span>)(cnt[n][<span class="number">0</span>] &gt;= m) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		res = f[n][<span class="number">1</span>] - (ll)x * m ; </span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">bool</span>)(cnt[n][<span class="number">1</span>] &gt;= m) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">	<span class="keyword">if</span> (m &gt; n / <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Error!"</span>), <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">-2e9</span>, r = <span class="number">2e9</span>, mid, ans ; </span><br><span class="line">	<span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">		mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//		cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ; </span></span><br><span class="line">		<span class="keyword">if</span> (check(mid)) ans = mid, r = mid - <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">	&#125;	</span><br><span class="line">	check(ans) ; <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，然后就没有然后了，感觉wqs二分还是偏套路的。</p>
<p>btw，我才发现原来LG上种树这题的两个版本不是同一道题，那个蓝色要求至多k个，所以不可以wqs随便搞.jpg</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>wqs二分</category>
      </categories>
      <tags>
        <tag>动态规划/决策单调性</tag>
        <tag>wqs二分</tag>
      </tags>
  </entry>
  <entry>
    <title>【听课笔记】决策单调性</title>
    <url>/2020/03/25/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7and%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>决策单调性是老朋友了，这次稍微系统地重学了一次，顺便做了做之前没做的题。</p>
<a id="more"></a>
<h1 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h1><p>如果是最小值问题，那大概长这样：</p>
<script type="math/tex; mode=display">
a\leq b<c\leq d\\
w(a,c)+w(b,d)\le w(a,d)+w(b,c)</script><p>那么如果满足这个，就说明其满足最小值时的决策单调性。证明起来很简单，因为 $a\to d,b\to c$ 的转移的值要更大些，所以 $a\to c,b\to d$ 的转移会更优，据此可得 $f$ 有决策单调性。</p>
<p>除此之外，该不等式存在一个变形。考虑对于 $a&lt;b$ 的如下 $4$ 个量 $a,a+1,b,b+1$ ，如果满足下式：</p>
<script type="math/tex; mode=display">
w(a,b)+w(a+1,b+1)\le w(a,b+1)+w(a+1,b)</script><p>那么也说明是满足四边形不等式的。证明的话可以考虑暴力归纳也好、换元消元也好，反正挺显然的。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="CF321E"><a href="#CF321E" class="headerlink" title="CF321E"></a>CF321E</h2><blockquote>
<p>你有⼀个 $n\times n$ 的对称矩阵表示不熟悉程度。</p>
<p>你要将它 $1\sim n$ 按顺序分成 $k$ 组，每组的代价为两两之间不熟悉程度的和。最小化这个东西。</p>
<p> $n \le 4000,k \le 800$</p>
</blockquote>
<p>考虑拿四边形不等式来证明。对于 $a\leq b&lt;c\leq d$ 而言，记 $s(a,c)$ 表示矩阵中左上角为 $(a,a)$ 右下角为 $(c,c)$ 的这么一个矩阵中元素的和，那么 </p>
<script type="math/tex; mode=display">
w(a,c)+w(b,d)=\frac{s(a,c)+s(b,d)}{2}\\
w(a,d)+w(b,c)=\frac{s(a,d)+s(b,c)}{2}</script><p>注意到</p>
<script type="math/tex; mode=display">
s(a,d) = s(a,c)+s(b,d)-s(b,c)+s(a,b)+s(c,d)</script><p>那么就显然</p>
<script type="math/tex; mode=display">
w(a,c)+w(b,d)\le w(a,d)+w(b,c)</script><p>十分满足决策单调性（其实画出图来更显然，就是多了两块矩阵）。</p>
<p>这个东西可以用分治来做。因为每一层决策与本层无关，即 $k-1\to k$ 。于是就可以 <code>solve(l,r,ql,qr)</code> 表示 $l\sim r$ 是从区间 $(ql\sim qr)$ 转移过来的。那么每次取 $mid=\frac{l+r}{2}$，然后找出 $f_{mid}$ 对应的最优决策所在位置，这样就可以分治了。复杂度 $O(nk\log n)$ 。</p>
<p>这题居然卡cin，气死我了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upb upper_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k ;</span><br><span class="line"><span class="keyword">int</span> s[N][N] ;</span><br><span class="line"><span class="keyword">int</span> f[N][K] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">char</span> c = getchar() ;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) </span><br><span class="line">		(res *= <span class="number">10</span>) += c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (s[r][r] + s[l - <span class="number">1</span>][l - <span class="number">1</span>] - s[r][l - <span class="number">1</span>] - s[l - <span class="number">1</span>][r]) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ; </span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, pos = ql ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ql ; i &lt;= qr &amp;&amp; i &lt;= mid ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i][g - <span class="number">1</span>] + do_do(i + <span class="number">1</span>, mid) &lt; f[mid][g])</span><br><span class="line">			f[mid][g] = f[i][g - <span class="number">1</span>] + do_do(i + <span class="number">1</span>, mid), pos = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; mid &lt;&lt; " " &lt;&lt; pos &lt;&lt; " " &lt;&lt; g &lt;&lt; endl ; </span></span><br><span class="line">	solve(l, mid - <span class="number">1</span>, ql, pos, g) ; </span><br><span class="line">	solve(mid + <span class="number">1</span>, r, pos, qr, g) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k ;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">			s[i][j] = qr() ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">			s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i) solve(<span class="number">1</span>, n, <span class="number">0</span>, n, i) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[n][k] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CF321E-的-O-n-2-做法"><a href="#CF321E-的-O-n-2-做法" class="headerlink" title="CF321E 的 $O(n^2)$ 做法"></a>CF321E 的 $O(n^2)$ 做法</h2><p>考虑记录一下每个点的决策范围。发现设状态 $(n,k)$ 最优决策位置记作 $opt(n,k)$ 的话，一定有</p>
<script type="math/tex; mode=display">
opt(n,k-1)\leq opt(n,k)\leq opt(n+1,k)</script><p>那么可以这么写：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j : <span class="number">1</span> to k</span><br><span class="line">  <span class="keyword">for</span> i : n to <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> p : opt(i, j - <span class="number">1</span>) <span class="function">to <span class="title">opt</span><span class="params">(i + <span class="number">1</span>, j)</span></span></span><br><span class="line">      if [f(p, j - 1) &lt; f(i, j)] opt(i, j) = p, f(i, j) := f(p, j - 1) ;</span><br></pre></td></tr></table></figure>
<p>考虑这么做的时间复杂度。</p>
<p>发现对于这个决策矩阵的每一条穿过 $opt(i,j)$  和 $opt(i+1,j+1)$ 的斜线，每条斜线的代价是 $O(n)$ 的，原因是考虑斜线 $opt(i,j),opt(i+1,j+1)$ 这条斜线的决策来自于 $opt(i,j-1),opt(i+1,j)$ 这条斜线。那么也就是说，每个斜线的转移都是 $O(n)$ 的，共有 $O(n+k)$ 条斜线，所以复杂度 $O(n^2)$ 。</p>
<h2 id="NOI2009-诗人小G"><a href="#NOI2009-诗人小G" class="headerlink" title="[NOI2009]诗人小G"></a>[NOI2009]诗人小G</h2><blockquote>
<p>有N个诗句需要被排版为若⼲⾏，顺序不能改变。⼀⾏内可以有若⼲个诗句，相邻诗句之间有⼀个空格。</p>
<p>定义⾏标准⻓度L，每⾏的不协调度为|实际⻓度-L|^P，整⾸诗的不协调度就是每⾏不协调度之和。</p>
<p>任务是安排⼀种排版⽅案，使得整⾸诗的不协调度最⼩。</p>
<p>$n\leq 10^5$ 。</p>
</blockquote>
<p>考虑还是 $dp$ 嘛。以下分析暂不考虑什么 $\pm1$ 的常数问题。</p>
<p>$f_{i} $ 表示考虑了前 $i$ 个句子的最小不协调度。那么就有 $f_{i}=\min\{f_{j-1}+|s(i,j)-L|^P\}$。</p>
<hr>
<p>考虑这个东西的性质。还是设 $a\leq b&lt;c\leq d$ ，那么可知 $|s(a,c)-L|^P+|s(b,d)-L|^P$  </p>
<script type="math/tex; mode=display">
|s(a,d)-L|^P+|s(b,c)-L|^P=|s(a,c)+s(c,d)-L|^P+|s(b,d)-s(c,d)-L|^P</script><p><del>草为什么我想直接打个表走人</del> 来让我瞎编一下。令 $x=s(a,c)-L,y=s(b,d)-L$。那么要证明</p>
<script type="math/tex; mode=display">
|x+s(c,d)|^P+|y-s(c,d)|^P\geq |x|^P+|y|^P</script><p>考虑当 $|P|$ 为偶数的时候……</p>
<hr>
<p>好的，上面的证明崩掉了。考虑另一种证明方法。考虑对于 $a&lt;b$ 的如下 $4$ 个量 $a,a+1,b,b+1$ ，考虑去证明 </p>
<script type="math/tex; mode=display">
|s(a,b)-L|^P+|s(a+1,b+1)-L|^P\le |s(a,b+1)-L|^P+|s(a+1,b)-L|^P</script><p>发现令 $p = len_a,q=len_b,x=s(a,b)$本质上就是在证明</p>
<script type="math/tex; mode=display">
|x|^P+|x-p+q|^P\le |x+q|^P+|x-p|^P</script><p>即</p>
<script type="math/tex; mode=display">
|x|^P-|x-p|^P\le|x+q|^P-|x+q-p|^P</script><p>那么也就是要证明 $f(x)=|x|^z-|x-p|^z$ 这个函数是单调不降的。可知一定有 $s(a,b)&gt;p+q$ ，所以可知括号内均 $&gt;0$，换言之 $f(x)=x^z-(x-p)^z$ ，这显然是单调不降的。于是证毕。</p>
<p>但是这个地方存在一个问题，就是转移有着严格的顺序，不能像上一道题一样来分治，因为 $l$ 必须要先于 $mid$ 来转移。<del>于是这显然就需要CDQ分治了</del> 然而CDQ分治是 $\log ^2$ 的并不可以过得去(并且显然没人会这么写)。</p>
<p>所以此处就需要用二分+单调栈的方式来维护。这两个过程严格意义上是分开的。大概就是考虑对于每个转移完的 $i$ ，我们用这个去更新后面的点的决策区间，更新方法是：1、先不断比较当前的决策区间和之前每个数的决策区间哪个更优，维护一个从底部到顶部单调递减的栈，依次弹掉这些不优的；2、之后考虑二分栈顶的这一段，确定新一个决策点的左区间。</p>
<p>然后是实现细节方面。注意需要在维护单调栈的时候顺便维护每个元素的决策左区间，并且还要维护一个指针，用来寻找当前点的决策点。</p>
<p>然后还有十分神必的一点，就是要记得不将那些无有效决策区间的决策点入栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">ll f[N] ;</span><br><span class="line"><span class="keyword">int</span> kts[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> n, p, k ;</span><br><span class="line"><span class="keyword">char</span> s[N][<span class="number">40</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ret *= a ;</span><br><span class="line">        a *= a ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">mabs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expow(mabs(sum[r] - sum[l - <span class="number">1</span>] - k), p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">trans</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calc(p + <span class="number">1</span>, x) + f[p] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;  <span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; p ;</span><br><span class="line">        stk[top = <span class="number">0</span>] = <span class="number">0</span> ; ++ k ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            pos[i] = <span class="number">0</span> ;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>) ;</span><br><span class="line">            base[i] = <span class="built_in">strlen</span>(s[i] + <span class="number">1</span>) ;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) sum[i] += i ;</span><br><span class="line">        <span class="comment">//debug(sum, 1, n, '\n') ;</span></span><br><span class="line">        kts[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">int</span> h = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (h &lt; top &amp;&amp; kts[h] &lt; i) ++ h ;</span><br><span class="line">            <span class="keyword">if</span> (kts[h] &gt; i) -- h ;</span><br><span class="line">            f[i] = trans(stk[h], i) ; pos[i] = stk[h] ;</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; trans(stk[top], kts[top]) &gt;= trans(i, kts[top]))</span><br><span class="line">                stk[top] = <span class="number">0</span>, kts[top] = n + <span class="number">1</span>, -- top ;</span><br><span class="line">            <span class="keyword">int</span> l = kts[top], r = n + <span class="number">1</span>, mid, ans = n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">if</span> (trans(stk[top], mid) &gt;= trans(i, mid))</span><br><span class="line">                    ans = mid, r = mid - <span class="number">1</span> ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; ans &lt;&lt; " * " &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (ans &lt;= n) stk[++ top] = i, kts[top] = ans ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">            <span class="comment">//debug(stk, 1, top, '\n') ;</span></span><br><span class="line">            <span class="comment">//debug(kts, 1, top, '\n') ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//debug(pos, 1, n, '\n') ;</span></span><br><span class="line">        <span class="keyword">if</span>(f[n] &gt; <span class="number">1e18</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"Too hard to arrange"</span>) ;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"--------------------"</span>) ; <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">long</span> <span class="keyword">long</span>)f[n] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">        <span class="keyword">int</span> t ; stk[top = <span class="number">0</span>] = t = n ;</span><br><span class="line">        <span class="keyword">while</span> (t) stk[++ top] = t = pos[t] ;</span><br><span class="line">        <span class="keyword">while</span> (top)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = stk[top] + <span class="number">1</span> ; i &lt; stk[top - <span class="number">1</span>] ; ++ i)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s "</span>, s[i] + <span class="number">1</span>) ; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s[stk[top - <span class="number">1</span>]] + <span class="number">1</span>) ; -- top ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"--------------------"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之呢，单调栈+二分这个做法是比较普适的，但是有时候也可以写分治，因为分治比较好写。</p>
<h2 id="IOI2013-wombats"><a href="#IOI2013-wombats" class="headerlink" title="IOI2013 wombats"></a>IOI2013 wombats</h2><blockquote>
<p>题意⼤概是，有 $r\times c$ 的⽹格图，每次只能朝左右下三个⽅向。</p>
<p>操作包括修改⼀条边的边权，然后查询某两点之间最短路。</p>
<p>$r\leq 5000,c\leq 200,q\leq 200000,m\leq 500$ 其中 $m$ 是修改次数，$q$ 是询问次数。</p>
</blockquote>
<p>草，这题真是从一开始就不会qaq</p>
<p>大概就是考虑以列为标号建线段树，然后每个区间维护最左边的点到最右边的所有点的最短距离。然后合并显然就是 $c^3$ 的，总复杂度 $O(rc^3+q\log r+mc^3\log r)$ 。(好像杜爷写的是 $O(rc^3+q+mc^3\log r)$</p>
<p>然后考虑这东西由于只能向右和向下走，所以是有单调性的，也就是对于右侧的两个点 $(x,y)$ 和 $(x,y+1)$ ，他俩的决策路线一定是不相交的。这个好像还是比较显然的？然后就可以暴力 $O(rc^3+q+mc^2\log c\log r)$ 做了。</p>
<p>不过显然根据上面那个 trick ，二维的决策单调性是可以消掉 $\log $ 的，还是上面那种做法。仔细想了想，其实 $nk$ 应该算是两维的决策单调性，所以或许这确实是二维决策单调性的通用解决方法吧。 </p>
<p>嗯，代码是不想写了，就这样吧。</p>
<h2 id="IOI2014-Holiday"><a href="#IOI2014-Holiday" class="headerlink" title="IOI2014 Holiday"></a>IOI2014 Holiday</h2><blockquote>
<p>有 n 个城市，每个城市有⼀个权值，起点在 s 。 每⼀天你可以往左或者往右⾛⼀步，或者选择游览这个城市。问 d 天能获得的最⼤权值和是多少？</p>
</blockquote>
<p>发现一共至多有四种走法，就是一直向右走、一直向左走、向左走折回起点然后向右走、向右走折回起点然后向左走。前两种就显然是枚举走了 $k$ 个城市，然后找其中的前 $d-k$ 大的城市游览即可。 </p>
<p>考虑另外两种的做法。先给出结论，假设我向右走到了点 $i$ ，再向左走到点 $j$ ，那么随着 $i$ 增大，$j$ 是不降的。</p>
<p>但这个地方很迷，迷在网上很多题解写的是决策单调性不是这东西单调，是前两种那个走法单调，我寻思这不是显然…</p>
<p>哦，想了想，发现本质是一样的。就是向右走 $0$ 再向左右显然也有单调性。那么现在唯一的问题就在于这个单调性似乎不是那么显然…</p>
<p>好的，那看起来是，随着 $l$ 不断向右，$r$ 不会向左(鬼知道我刚才怎么理解的)。这样就非常合理了。于是就可以分治去做了。复杂度 $m \log n$ 。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>决策单调性</category>
      </categories>
      <tags>
        <tag>动态规划/决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces [Gym 102354B] Yet Another Convolution</title>
    <url>/2020/03/25/gym102354B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给出两个长为 $n$ 的序列 $\{a_n\}$ 和 $\{b_n\}$ 。对于所有的 $k\in[1,n]\cap\mathbb Z_{+}$ ，求这样的 $c_k$：</p>
<script type="math/tex; mode=display">
c_k=\max_{\gcd(i,j)=k}\{a_i-b_j\}</script><p>$1\leq n\leq 10^5$</p>
</blockquote>
<p>题目来源于 2018-2019 Summer Petrozavodsk Camp, Oleksandr Kulkov Contest 2 。</p>
<p>发现这题居然还是那一场通过人数最多的题目之一…深深地感觉到了自己的弱小。</p>
<a id="more"></a>
<p>然后正片部分。考虑这个式子可以怎么化，发现对于一个给定的 $k$ ，要找的 $a_i$ 和 $b_i$ 应该至少是这样的：</p>
<script type="math/tex; mode=display">
a_k,a_{2k},a_{3k}\cdots a_{pk}</script><script type="math/tex; mode=display">
b_k,b_{2k},b_{3k}\cdots b_{pk}</script><p>于是直接把这些拿出来重编号为 $1,2,3\cdots p$。那么为了保证 $\gcd(i,j)=k$，就需要满足取出的一个 <code>pair</code> 满足 $\gcd(i,j)=1$ 。也就是现在转化成了这么一个问题：</p>
<script type="math/tex; mode=display">
\max_{i=1}^p\{(a_i-b_j)[(i,j)=1]\}</script><p>也就是</p>
<script type="math/tex; mode=display">
\max_{i=1}^p\{a_i-\min_{j=1}^p\{b_j\cdot[(i,j)=1]\}\}</script><p>然后似乎就没法做了。发现本题要求 $poly(\log)$ 的做法，但是本质上对于每个 $k$ ，都有 $O(\frac{n}{k})$ 组询问，这个询问量是十分巨大的。于是考虑有没有什么可以一起处理全部询问的方法。发现似乎整体二分可行。</p>
<p>首先把里面的 $\min$ 通过将 $b$ 全部取反变成 $\max$：</p>
<script type="math/tex; mode=display">
\max_{i=1}^p\{a_i+\min_{j=1}^p\{-b_j\cdot[(i,j)=1]\}\}</script><p>之后考虑整体二分。具体的来讲，先考虑一组询问（即一个固定的 $i$）怎么二分。对于一个 $\min_{j=1}^p\{b_j\cdot[(i,j)=1]\}$ ，将其转化成判定性问题。假设当前二分到的值是 $ans$ ，那么考虑，如果 $\sum_{j=1}^p[ans<b_j][(i,j)=1] >0$，那就代表存在一个值比 $ans$ 大，符合二分性质。</p>
<p>那么对于这个 $\sum$ 而言，就可以变一下形了：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^p[ans<b_j]\sum_{d|i\operatorname{and}d|j} \mu(d)>0</script><p>反演一下也就是</p>
<script type="math/tex; mode=display">
\sum_{d|i} \mu(d)\sum_{d|j}^p[ans<b_j]>0</script><p>那么考虑整体二分的时候，对于每一层都可以把 $<vmid$ 的位置赋为 $1$ ，或者反过来，本质都一样。之后就只需要查询某个 $i$ 的上式值。发现这东西需要维护每个值的倍数处的值（后一个 $\sum$），并且不是很好清空。于是考虑一个有趣的做法。假设以把 $>vmid$ 的位置都赋值为 $1$ 做例子。每次手动将一个指针移动 $vmid+1$ 处，然后对于途径的所有 $b_j$，如果 $&gt;vmid$ 的话就 $+1$ ，否则 $-1$ 。这样做之后，<strong>直接把自己的标记下传给所有自己的约数</strong>。这样最后去 $check(i)$ 的时候就可以直接枚举所有约数而不需要再去枚举约数的倍数。发现移动指针每层都是 $O(r-l)$ 的。</p>
<p>于是最后考虑算一下复杂度。大概是：</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n(\frac{n}{i} \log \frac{n}{i} d(\frac{n}{i}))</script><p>的复杂度。emmm，这大概是个什么复杂度呢…考虑 $d(n)&lt;O(\sqrt[3]n)$ ，所以最后应该不会超过 $(n\log n)^{\frac{4}{3}}\log n$</p>
<p>后面一个 $\log$ 是因为：</p>
<script type="math/tex; mode=display">
\int \frac{n}{x} \log \left(\frac{n}{x}\right) \mathrm{dx}=-\frac{n(\log x)^{2}-2 n \log n \log x+n(\log n)^{2}}{2}</script><p>似乎是因为 $\log (\frac{n}{x})&lt;0$ 的问题，所以需要忽略掉符号。最后大概也就是 $n\log^2 n$ 的级别。</p>
<p>然而实际积分出来也差不多？</p>
<script type="math/tex; mode=display">
\int \frac{n^{\frac{4}{3}} \log \left(\frac{n}{x}\right)}{x^{\frac{4}{3}}} \mathrm{d x}=\frac{n^{\frac{1}{3}}(3 n \log x-3 n \log n+9 n)}{x^{\frac{1}{3}}}</script><p>看上去就是 $(n\log n)^{\frac{4}{3}}\log n$ 的亚子。不过话说回来 $d(n)=O(\sqrt[3] n)$ 的近似误差有、大，所以还是 $O($能过$)$ 比较靠谱.jpg 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> upb upper_bound</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">int</span> *tp, <span class="keyword">int</span> minn, <span class="keyword">int</span> maxn, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = minn ; i &lt;= maxn ; ++ i)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tp[i] &lt;&lt; <span class="string">" "</span> ;	<span class="built_in">cout</span> &lt;&lt; c ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> xq ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> q[N] ;</span><br><span class="line"><span class="keyword">int</span> A[N] ;</span><br><span class="line"><span class="keyword">int</span> B[N] ;</span><br><span class="line"><span class="keyword">int</span> lq[N] ;</span><br><span class="line"><span class="keyword">int</span> rq[N] ;</span><br><span class="line"><span class="keyword">int</span> pr[N] ;</span><br><span class="line"><span class="keyword">int</span> ta[N] ;</span><br><span class="line"><span class="keyword">int</span> tb[N] ;</span><br><span class="line"><span class="keyword">int</span> Mu[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line"><span class="keyword">int</span> res[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; d[N] ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = d[x].size() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; ++ i)</span><br><span class="line">        sum[d[x][i]] += y ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (xq &gt; x) add(base[-- xq], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; xq) add(base[xq ++], <span class="number">-1</span>) ;</span><br><span class="line">	<span class="comment">//debug(sum, 1, 50, '\n') ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> p = d[x].size() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; p ; ++ i)</span><br><span class="line">        ret += Mu[d[x][i]] * sum[d[x][i]] ;</span><br><span class="line">  	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_it</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> vl, <span class="keyword">int</span> vr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            ans[q[i]] = vl ; <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">int</span> tl = <span class="number">0</span>, tr = <span class="number">0</span> ; upd(vmid + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (calc(q[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">            lq[++ tl] = q[i] ;</span><br><span class="line">        <span class="keyword">else</span> rq[++ tr] = q[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; tl &lt;&lt; " " &lt;&lt; tr &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tr ; ++ i) q[l + tl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    do_it(l, l + tl - <span class="number">1</span>, vl, vmid) ; do_it(l + tl, r, vmid + <span class="number">1</span>, vr) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        tmp[q[i] = i] = tb[i], sum[i] = <span class="number">0</span> ; </span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + k + <span class="number">1</span>) ; <span class="keyword">int</span> x ; xq = k + <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">          x = upb(tmp + <span class="number">1</span>, tmp + k + <span class="number">1</span>, tb[i]) - tmp ;</span><br><span class="line">          x -- ; base[x] = i ; tmp[x] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-2333333</span> ; do_it(<span class="number">1</span>, k, <span class="number">1</span>, k) ; <span class="comment">//debug(q, 1, k, '\n') ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        ret = max(ret, ta[i] + tmp[ans[i]] - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= n ; ++ j)</span><br><span class="line">            ta[j] = A[i * j], tb[j] = B[i * j] ;</span><br><span class="line">        res[i] = max(res[i], do_do(n / i)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = Mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= k ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) </span><br><span class="line">			pr[++ cnt] = i, Mu[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pr[j] * i &gt; k) <span class="keyword">break</span> ;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">            Mu[i * pr[j]] = - Mu[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; i * j &lt;= k ; ++ j)</span><br><span class="line">            d[i * j].p_b(i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sieve(N - <span class="number">10</span>) ;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; A[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; B[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) B[i] = -B[i] ;</span><br><span class="line">    solve() ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; res[i] &lt;&lt; " \n"[i == n] ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        A[i] = -A[i], B[i] = -B[i] ;</span><br><span class="line">    solve() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">" \n"</span>[i == n] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
        <category>gym</category>
      </categories>
      <tags>
        <tag>数学/积性函数/莫比乌斯反演</tag>
        <tag>好多好多细节</tag>
        <tag>数学/数值分析/调和级数</tag>
        <tag>离线算法/整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>【听课笔记】离线分治选整</title>
    <url>/2020/03/24/%E5%88%86%E6%B2%BB%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是一些听dls讲课的笔记。感觉好神仙啊<del>，这我怎么可能会。</del></p>
<a id="more"></a>
<h1 id="Part1-神奇的暴力"><a href="#Part1-神奇的暴力" class="headerlink" title="Part1 神奇的暴力"></a>Part1 神奇的暴力</h1><h2 id="bitset做-K-维数点"><a href="#bitset做-K-维数点" class="headerlink" title="bitset做 $K$ 维数点"></a>bitset做 $K$ 维数点</h2><p>令  $f(k,w)=\{i|x_{i,k}&lt; w\}$.</p>
<p>即第 $k$ 维小于 $w$ 的集合。</p>
<p>然后查询的话，对于第 $p$ 个点，就求一下 </p>
<script type="math/tex; mode=display">
\operatorname{and}_{i=1}^Kf_{i,x_{p,i}}</script><p>这东西即可。</p>
<p>预处理的话，考虑先 $O(Kn)$ 让每个 $x_{i,k}$ 都赋值到 $f_{k,x_{i,k}+1}$ 上，然后从头到尾 $or$ 下来，就变成了 $K\frac{n^2}{w}$ 的复杂度。查询复杂度就是 $O(K\frac{n}{w})$ 。</p>
<p>思考空间复杂度，大概是 $O(K\frac{n^2}{w})$ 。发现似乎有点卡空间。于是考虑设置一个阈值 $T$，换设一个 $f_{k,iT}$ 用来只记录 $T$ 的倍数的情况，这样空间复杂度就会降为 $\frac{Kn^2}{Tw}$ ；查询的时候就可以查询离 $x_{p,i}$ 最近的块，然后把后面的下脚料暴力加进去，时间复杂度变成了 $O(Kn(\frac{n}{w}+T))$ 。 </p>
<h1 id="Part2-CDQ分治"><a href="#Part2-CDQ分治" class="headerlink" title="Part2 CDQ分治"></a>Part2 CDQ分治</h1><h1 id="动态凸壳"><a href="#动态凸壳" class="headerlink" title="动态凸壳"></a>动态凸壳</h1><blockquote>
<p>给出一个平面，支持加点 $(x,y)$ ，给出 $(a,b)$ 查询最大的 $ax+by$ 。</p>
</blockquote>
<p>发现本质上是在求某个方向上最大的点积，本质上就是在动态维护凸壳。于是有两种做法：</p>
<p>（1）直接 <code>set&lt;point&gt;</code> 维护，支持按 $x$ 查询和按斜率查询。插入的时候按 $x$ 排序，询问按斜率排序。可以在 <code>cmp</code> 里记用个全局变量来判断当前按什么排序(神奇的是这样复杂度是对的)。反正就是维护凸壳就对了。</p>
<p>这个地方很迷的就是，如果每次查询的是 $kx+y$ 这种形式，那么斜率可以下取整。</p>
<p>（2）CDQ分治，变成了静态维护凸包。发现两边都排完序之后，中间就可以直接大力归并了，所以是可以做到 $n\log n$ 的。</p>
<h2 id="CF-848C"><a href="#CF-848C" class="headerlink" title="CF 848C"></a>CF 848C</h2><blockquote>
<p>给⼀个数列，定义⼀段的权值为每个不同的数值最后⼀次出现的位置减去第⼀次出现的位置和。</p>
<p>要求单点修改/求某⼀段的权值和。</p>
</blockquote>
<p>神仙找性质题。考虑令每个 $i$ 的贡献是 $i-\mathrm{pre}_{a_i}$，那么就是在二维数点： $\sum_{l \leq \text { pre}_{a_{i}}&lt;i\leq r} i-\text {pre}_{a_i}$ 。于是可以直接CDQ分治。</p>
<h2 id="UOJ-50-链式反应"><a href="#UOJ-50-链式反应" class="headerlink" title="UOJ#50 链式反应"></a>UOJ#50 链式反应</h2><blockquote>
<p>求解微分方程</p>
<script type="math/tex; mode=display">
f'(x)=f^2(x)p(x)+1</script><p>的前 $m$ 项。</p>
</blockquote>
<p>化一下式子</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum nf_{n}x^{n-1}&=\sum \sum_{0\leq i+j<n}f_{i}\cdot f_j\cdot p_{n-1-i-j}\\
f_{n}&=\frac{1}{n} \sum_{0 \leq i+j \leq n-1} f_{i} \cdot f_{j} \cdot p_{n-1-i-j}
\end{aligned}</script><p>然后考虑大概是一个分治FFT形式。于是考虑CDQ分治。然后考虑怎么看左边系数对右边的贡献。</p>
<p>考虑如果 $l=0$ 。那么本质上就是 $f_{0\sim mid}^2* p_{0\sim r-1}$ 卷起来，然后把 $&gt;mid$ 的那些贡献全部累加。</p>
<p>否则一定有 $2l&gt;r$ 。发现 $i\in [l,mid]$ 或  $j\in [l,mid]$ ，因为对于任意 $i\in [l,mid]$，均有 $r-1-i&lt;l$ 。所以最后就变成了 $f_{0\sim r-1-l},p_{0\sim r-1-l}$ 和 $f_{l\sim mid}$ 的卷积。</p>
<p>复杂度 $m\log ^2 m$ 。</p>
<h1 id="Part3-线段树分治"><a href="#Part3-线段树分治" class="headerlink" title="Part3 线段树分治"></a>Part3 线段树分治</h1><h2 id="动态图连通性"><a href="#动态图连通性" class="headerlink" title="动态图连通性"></a>动态图连通性</h2><blockquote>
<p>回溯的时候仍然需要删除某些边，但是发现删边的顺序等于加边的顺序的倒序。即，我们将无序的删除转化为了操作栈的压入和弹出。此时只需维护一个可回退并查集即可。注意此处的并查集需要按秩合并，因为路径压缩的复杂度是均摊的，无法保证回退时的复杂度。</p>
</blockquote>
<h2 id="不包含某个物品的背包"><a href="#不包含某个物品的背包" class="headerlink" title="不包含某个物品的背包"></a>不包含某个物品的背包</h2><p>普通的背包加入是 $O(m)$，合并是 $O(m^2)$，删除是 $O(nm)$ 的。</p>
<p>考虑线段树分治。一个物品的存活时间是 $[1,k-1]$ 和 $[k+1,n]$ 。令 <code>solve(l,r,f)</code> 表示把 $[l,r]$ 之外的物品加入背包时得到的是 $f$ 。于是就考虑分治下去，对于 <code>solve(l,mid,g)</code> 而言，<code>g</code> 是 <code>f</code> 和 $mid+1\sim r$ 之间信息的合并；反之 <code>solve(mid + 1,r,h)</code> 中 <code>h</code> 需要时 <code>f</code> 和 $l\sim mid$ 的信息的合并。分治下去即可。</p>
<p>最终复杂度 $O(nm\log n)$ .</p>
<h2 id="不经过某个点的最短路-方案数"><a href="#不经过某个点的最短路-方案数" class="headerlink" title="不经过某个点的最短路/方案数"></a>不经过某个点的最短路/方案数</h2><p>跟上个题本质一样？ 直接做显然是 $n^4$ 的嘛，所以就线段树分治一下就好了。</p>
<h2 id="HNOI城市建设"><a href="#HNOI城市建设" class="headerlink" title="HNOI城市建设"></a>HNOI城市建设</h2><blockquote>
<p>支持修改边权和查询MST。</p>
</blockquote>
<p>还是考虑线段树分治嘛，但是 LCT 做就显然复杂度不是那么靠谱。</p>
<p>考虑一种不用 LCT 的做法。发现假设要修改 $1$ 条边，那么这个修改至多会影响一条边，也就是对于 <code>solve(l,r)</code> 最多会影响 $O(r-l)$ 条边。发现这个变化量并不大，正好满足分治的复杂度。于是考虑图和把每一层的操作数都降到 $O(r-l)$ 。</p>
<p>考虑对于不在当前区间的边集的边进行分类，一类是一定不会在MST中的，一类是一定会在MST中的。具体的，对于分治的每一层，设当前层需要修改的边集为 $E$，那么首先把 $E$ 中的边权均设为 $-\infty$ 跑一次MST，这样MST中 $\not \in E$ 以外的边就是必选边；再设为 $+\infty$ ，这样MST中 $\not \in E$ 的就是必不选边。</p>
<p>注意到，如果每次将必选边连成的连通块缩起来，这样分治下去每层的点数就是 $O(r-l)$ 的；如果每次将所有必不选边删掉，那么由于至多是生成树上那些边，跟点数同阶，也是 $O(r-l)$ 的，再加上本层的 $O(r-l)$ 的边，最终边集也是 $O(r-l)$ 的。这样复杂度就对了。最终复杂度为 $n\log^2 n$ ，其中另一个 $\log$ 是可回退并查集的。</p>
<p>改天写一下这题吧quq</p>
<h2 id="嫖来的笔记"><a href="#嫖来的笔记" class="headerlink" title="嫖来的笔记"></a>嫖来的笔记</h2><p>山东队长swk写的吼哇！</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="236.png" alt=""></p>
<h2 id="UOJ-191-Unknown"><a href="#UOJ-191-Unknown" class="headerlink" title="UOJ#191 Unknown"></a>UOJ#191 Unknown</h2><blockquote>
<p>维护向量序列，支持末尾插入/删除元素，询问区间与输入的向量点积最大值。</p>
</blockquote>
<p>发现只有末尾插入和区间查询的话大概可以 <code>2048</code> 着做。这个 <code>2048</code> 大概是指每插入一个元素，都合并到最小的那一堆里，然后将这一堆二进制拆分，如果合并后存在和他一样大小的一堆就继续合并。查询的时候就每一堆分别查询，总查询复杂度会多一个 $\log $。从这个地方也可看出，由于只需要重构，所以不需要插入删除十分优秀。</p>
<p>考虑重构复杂度。重构的复杂度分析时大多都是均摊分析：每个元素最多被重构 $\log n$ 次，所以最多是 $n\log n$ 的。</p>
<p>由于线段树的合并操作有着较优的复杂度，于是考虑用线段树来维护。这样大概是 $O(n\log^2 n)$ 的复杂度。</p>
<p>接下来考虑带删除操作的问题。</p>
<p>如果是离线，由于只有末尾的插入和删除，可以用版本树的思想来做，大概是随着序列递增，建出一棵深度递增的树，对于 $i$ 号结点后面的 <code>Ins</code>, <code>Del</code> , <code>Ins</code>, <code>Ins</code> , <code>Del</code>, <code>Del</code>, <code>Ins</code> 而言，代表着该结点的三个分支(儿子)，然后每次算大概就是树剖一下，这样就是 $\log ^ 3n$ 的复杂度了：线段树里面两个 $\log $，凸包二分再要一个 $\log$ 。（这个地方复杂度还是不很会算，好像是如果将询问排序就可以少一个 $\log$ 所以最后是 $3$ 个 $\log$，好像很nb的样子）。</p>
<p>考虑在线如何用二进制分组来做。如果直接暴力做，就不能保证每个元素都被合并 $\log n$ 次，所以在某个块末尾反复插入删除就会人没了。</p>
<p>于是考虑两种方法解决这个问题。</p>
<p>第一种是类似 $\rm Treap$ 的随机化，插入每个元素时随机一个权值，并作为独立一组。若最后一组的最小权值小于前一组的最小权值，则将两组合并。删除时暴力将最后一块拆散，并按照插入的规则重构即可。可以证明期望复杂度仍是 $O(n\log^2n)$。</p>
<p>第二种是打标记。考虑对于每个被建出来的块，因为被删除的元素不会出现在区间询问内。问题出现在被删除的位置重新被填满时，此时对这个块打一个「坏」标记。查询的时候，如果这个块是坏的就向两边的儿子递归查。考虑如何让这个结构不退化，我们约定每一层至多有一个坏的块，并且要最靠右。否则就大力重构其中的另一个块。</p>
<p>这样就保证每一层只向一侧递归，询问的复杂度是对的。插入、删除都是在序列末尾进行，因此被打标记的节点也只存在于序列末尾。因此，要达到长度为 $len$ 的区间的重构标准，至少需要进行 $O(len)$ 次操作，重构的均摊复杂度为 $O(1)$。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>离线算法/CDQ分治</tag>
        <tag>离线算法/线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces [Global Round 7F] Wise Men</title>
    <url>/2020/03/22/GlobalRound7F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>有 $n$ 个人。给出 $n$ 个人的「认识情况」(双向且保证合法)。</p>
<p>定义 <code>bool</code> 值函数 $K(i,j)$ 表示两个人是否认识。考虑一个 $n$ 个人编号的排列 $p$ ，定义其生成的 $01$ 串 $\{s_{n-1}\}$ 为 $\forall i\in[1,n-1]\cap\mathbb{Z_+},s_i=K(p_{i},p_{i+1})$。</p>
<p>统计对于 $2^{n-1}$ 种不同的 $01$ 串，有多少种排列可以生成它。</p>
<p>F1: $2\leq n\leq 14$ 。</p>
<p>F2 : $2\leq n\leq 18$ 。</p>
</blockquote>
<p>神仙计数题，再一次深深地明白了自己的弱小。</p>
<a id="more"></a>
<p>首先考虑，对于一个串 $s$ 而言，直接统计比较麻烦，麻烦在难以体现「不认识」这个限制上。所以考虑如何忽略这个限制。考虑忽略限制后，就变成了统计 $ans(s)$ 表示<strong>至少</strong>含有集合 $s$ 的排列数。</p>
<p>那么对于 $ans(s)$ 存在一个性质：如果 $s$ 和 $s’$ 中，连通分量状态相同，那么两个集合的 $ans$ 是等价的。此处连通分量指的是连续一段互相认识的人，状态相同指的是 $s$ 和 $s’$ 的这些段大小相同，排布可以不同。（比如 $0100111\Longleftrightarrow0011101\Longleftrightarrow1000111$） 。</p>
<p>证明很简单，因为对于生成 $01$ 的串而言，其方案数只在于有多少排列可以凑出这些 $1$ 的连续段而已。换言之就是由于是全排列，所以对称。</p>
<p>值得注意的是，对于一个长度为 $k$ 的 $1$ 连续段，其包含 $k+1$ 个互相认识的人，也就是该连通块大小为 $k+1$ 。</p>
<p>考虑如何求 $ans(s)$ 。注意到现在已经转化成了统计每一种对 $n$ 的拆分方式，有多少种排列数。那么一个比较自然的想法就是求下式</p>
<script type="math/tex; mode=display">
\sum_{\begin{aligned}&t_1,t_2,t_3\cdots t_p\\ &\forall i,j,t_i\cap t_j=\empty \\&|t_1|+|t_2|+\cdots +|t_p|=n\end{aligned}} \prod_{k=1}^p f(t_k,|s_k|)</script><p>其中 $t_i$ 表示枚举的第 $i$ 个点集，$s_i$ 表示组成 $s$ 这个 $01$ 串的第 $i$ 个连通块(链形态的点集) ，$f_{i,j}$ 表示从 $size(i)=j$ 的集合 $i$ 里面选出一个大小为 $j$ 的<strong>链</strong>的方案数。不难知道这些限制的意义：划分必须恰好划分掉 $n$ 个点，且点集之间不存在交集(否则需要合并)。</p>
<p>上式的意义在于，对于 $s$ 的一个划分，每个连通块都需要从某个点集中选出，而点集之间是互不相交的，所以 $size$ 必须恰好是链长。于是可以从这个角度入手来求排列数。同时需要注意，由于我们是硬生生划定了 $p$ 个集合，并不关心集合之间是否有连边，也就代表了其中有些单点(也就是 $s$ 中的 $0$ 位置)可能是与其他连通块是一体的，这也就符合了我们对 $ans(s)$ 的定义：<strong>至少</strong>含有集合 $s$ 的排列数。</p>
<p>注意到 $f$ 是比较容易求得的。考虑 $g_{i,j}$ 表示集合 $i$ 以 $j$ 结尾的链的方案数，那么就是 $n^2$ 转移，保证每次都用最后一个点转移就可以使得形态是一条链。$f$ 就是对 $g$ 的一个累加。这一部分复杂度 $O(n^22^n)$ 。</p>
<p>考虑求出 $f$ 之后如何计算这个式子。一个比较直接的想法是暴力枚举子集的子集来转移，由于 $\Pi$ 对 $\Sigma$ 有分配律，可知转移是不难的。复杂度 $P(n)3^n$，其中 $P(n)$ 是本质不同的划分数。可以过掉 $n=14$ 的 $\rm F1$ 。</p>
<p>对于 $\rm F2$ ，考虑这么一个问题：如何保证一组相加起来 $size$ 等于全集的子集互不相交？很显然是如果他们的<strong>并</strong>就是全集，那么彼此之间一定不会有交。于是可以知道用 FMT 来优化这个过程。具体的，根据分配律，可以对每个 $s_i$ 分开计算其贡献，进行 $p$ 次 FMT 之后，答案就是第 $2^n-1$ 项系数。</p>
<p>那么就做完了。最后只需对于每个 $01$ 串，求出他的划分即可。注意到一开始 $ans$ 的定义，需要我们做一次子集差变换。大概类似于FMT处理and的逆过程。最终复杂度 $O(2^n(P(n)+n+n^2))$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_p pop_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vint vector<span class="meta-string">&lt;int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1200000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line">ll I[M] ;</span><br><span class="line">ll t[M] ;</span><br><span class="line">ll ans[M] ;</span><br><span class="line">ll f[M][N] ;</span><br><span class="line">ll g[N][M] ;</span><br><span class="line">ll res[N * N] ;</span><br><span class="line"><span class="keyword">int</span> know[N][N] ;</span><br><span class="line"><span class="built_in">map</span>&lt;vint, <span class="keyword">int</span>&gt; Id ;</span><br><span class="line">vint part[N * N], now ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_or</span><span class="params">(ll *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = f[j] + (ll)g * f[j ^ (<span class="number">1</span> &lt;&lt; i)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_part</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> big)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st == n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>(part[Id[now] = ++ tot] = now) ;</span><br><span class="line">    <span class="keyword">if</span> (n - st + <span class="number">1</span> &gt;= big)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = big ; i &lt;= n - st + <span class="number">1</span> ; ++ i)</span><br><span class="line">            now.p_b(i), dfs_part(st + i, i), now.p_p() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i) f[<span class="number">1</span> &lt;&lt; i][i + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; ~i) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!know[j][k]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>) &amp; i) <span class="keyword">continue</span> ;</span><br><span class="line">                f[i | (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))][k] += f[i][j] ;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ len ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; i) g[len][i] += f[i][j] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(t, I, <span class="keyword">sizeof</span>(I)) ;</span><br><span class="line">        <span class="keyword">int</span> o = (<span class="keyword">int</span>)part[i].size() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; o ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= m ; ++ k)</span><br><span class="line">                t[k] *= g[part[i][j]][k] ;</span><br><span class="line">        fmt_or(t, <span class="number">-1</span>) ; res[i] = t[m] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) cout &lt;&lt; res[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revalue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        now.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r ; l &lt; n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">            r = l ;</span><br><span class="line">            <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; r) &amp; i &amp;&amp; r &lt; n)</span><br><span class="line">                ++ r ; now.p_b(r - l + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(now.begin(), now.end()) ;</span><br><span class="line">        ans[i] = res[Id[now]] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ;</span><br><span class="line">    I[<span class="number">0</span>] = <span class="number">1</span> ; fmt_or(I, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;know[i][j]) ; dp1() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) fmt_or(g[i], <span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 1 ; j &lt;= m ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; g[i][j] &lt;&lt; " \n"[j == m] ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dfs_part(<span class="number">1</span>, <span class="number">1</span>) ; dp2() ; revalue() ;</span><br><span class="line">    <span class="comment">//for (int j = 1 ; j &lt;= m ; ++ j)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; I[j] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    ((m += <span class="number">1</span>) &gt;&gt;= <span class="number">1</span>) -= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (~j &gt;&gt; i &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                ans[j] = ans[j] - ans[j | (<span class="number">1</span> &lt;&lt; i)] ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" \n"</span>[i == m] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>撒花撒花！！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>思维题/计数</tag>
        <tag>好多好多细节</tag>
        <tag>快速莫比乌斯变换(FMT)</tag>
        <tag>快速沃尔什变换(FWT)</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】Codeforces[Global Round 7] $\rm A\to E$</title>
    <url>/2020/03/20/CFGlobalRound7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一场相对来说还是比较简单的，至少 $A\to E$ 都是比较传统的题目。</p>
<p>因为F对我来说不是很general，于是单开了一篇文章整理F了。</p>
<p>不知道为什么，感觉所有Global Round里面，最喜欢的还是第一场。</p>
<p>唉，过去的事情，也就只能让它过去了吧。</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote>
<p>构造一个 $n$ 位十进制数，保证不被该数的任意一位整除。</p>
<p>$1\leq n\leq 100000$</p>
</blockquote>
<p>感觉就是一个考反应能力的？？大概就是瞎构造。正确性似乎不是那么显然？唯一的不确定性就是这种做法可能出现末尾接上 $ 3\sim 9$ 都不合法的情况，然而似乎数据卡不了这一点。</p>
<p>仔细想一想的话，需要满足以下的条件：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(n-1)*7+3 \equiv0\pmod 3\\
\cdots
\end{aligned}</script><p>好的，我刚刚写完关于 $3$ 的就发现了，只要是 $77777…7774$ 就一定合法。我太弟弟了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ; </span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - <span class="number">1</span> ; ++ i)	<span class="built_in">printf</span>(<span class="string">"7"</span>) ;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote>
<p>对于一个序列 $\{a_n\}$，定义序列 $\{c_n\}$ ：$c_i=\max\{0,a_1,\cdots,a_{i-1}\}$ 。同时定义序列 $\{b_n\} :b_i=a_i-c_i$ 。</p>
<p>给定 $\{b_n\}$ ，求 $\{a_n\}$ 。</p>
<p>$1\leq n\leq 200,000$</p>
</blockquote>
<p>谔谔，完全就是一道模拟题，不知道这种题是怎么当B的，一点技术含量也没有啊？？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">500010</span>] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base[<span class="number">500010</span>] ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ; </span><br><span class="line">	ans[<span class="number">1</span>] = base[<span class="number">1</span>] ; m = ans[<span class="number">1</span>] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		ans[i] = base[i] + m, m = max(ans[i], m) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>给定一个长度为 $n$ 的<strong>排列</strong> $\{a_n\}$。要求将这个序列分成互不相交的 $k$ 段。记第 $p$ 段的左端点和右端点分别为 $l_p,r_p$ 。要求最大化 </p>
<script type="math/tex; mode=display">
\sum_{i=1}^k\max_{j=l_i}^{r_i}\{a_j\}</script><p>同时输出最大化该值的方案数。对 $998,244,353$ 取模。</p>
</blockquote>
<p>发现显然 $n-k+1\sim n$ 这几个数是一定能取到的。乘法原理算一算区间怎么拆即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k ; res = <span class="number">1l</span>l ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">		ans += (ll)(n - i + <span class="number">1</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (base[i] &gt; n - k)&#123; </span><br><span class="line">			<span class="keyword">if</span> (lst) </span><br><span class="line">				(res *= (ll)(i - lst)) %= P ; </span><br><span class="line">			lst = i ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h1><blockquote>
<p>给定一个字符串。要求选取他的一个前缀(可以为空)和与该前缀不相交的一个后缀(可以为空)拼接成回文串，且该回文串长度最大。求该最大长度。</p>
<p>多组数据。保证 $\sum n\leq 5000$ 。</p>
</blockquote>
<p>草，我做这题的时候就是nm离谱。感觉自己完全没带脑子。一开始读错题了，以为是个构造题，只要构造一个用了非空前缀和非空后缀拼出来回文串就好了，然后写完之后看完样例就蒙了。思考了半天才发现是最优化问题。然后此时还有大概2h左右，我就觉得大概不用仔细思考可以瞎写写。于是我就成功地用KMP很麻烦地求了这个串「最长的、拼在一起可以回文的前缀和后缀」，然后发现就是个Manacher板子题，然后又很麻烦地去判边界(不得不说这个manacher判边界的麻烦程度也是一绝)。</p>
<p>然后在我WA了好几发之后才发现「最长的、拼在一起可以回文的前缀和后缀」只要枚举一下就好了…惨惨…</p>
<p>然后就没有然后了。不过好在还是抢救回来了。中间很无奈D1写了个暴力，不过还是最后绝杀了D2…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line"><span class="keyword">char</span> I[N] ;</span><br><span class="line"><span class="keyword">int</span> Len[N] ;</span><br><span class="line"><span class="keyword">int</span> len[N], st ; </span><br><span class="line"><span class="keyword">int</span> T, L, n, res ; </span><br><span class="line"><span class="keyword">int</span> ns[N], base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ; </span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>) ; </span><br><span class="line">		n = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ; </span><br><span class="line">		res = <span class="number">0</span> ; st = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			<span class="keyword">if</span> (S[i] != S[n - i + <span class="number">1</span>]) <span class="keyword">break</span> ; <span class="keyword">else</span> st = i ;</span><br><span class="line">		<span class="keyword">int</span> p = n - st ; <span class="keyword">int</span> db = <span class="number">0</span> ; <span class="keyword">int</span> q = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = st + <span class="number">1</span> ; i &lt;= p ; ++ i)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = st + <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">				I[j - st] = S[j] ; <span class="keyword">int</span> k = i - st ;</span><br><span class="line">			reverse(I + <span class="number">1</span>, I + k + <span class="number">1</span>) ; <span class="keyword">bool</span> fg = <span class="number">0</span> ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j)</span><br><span class="line">				<span class="keyword">if</span> (I[j] != S[j + st]) &#123; fg = <span class="number">1</span> ; <span class="keyword">break</span> ;&#125;</span><br><span class="line">			<span class="keyword">if</span> (!fg &amp;&amp; k &gt; res) res = i - st, db = <span class="number">1</span> ;  </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = p ; i &gt;= st + <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &lt;= p ; ++ j)</span><br><span class="line">				I[j - i + <span class="number">1</span>] = S[j] ; <span class="keyword">int</span> k = p - i + <span class="number">1</span> ;</span><br><span class="line">			reverse(I + <span class="number">1</span>, I + k + <span class="number">1</span>) ; <span class="keyword">bool</span> fg = <span class="number">0</span> ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j)</span><br><span class="line">				<span class="keyword">if</span> (I[j] != S[j + i - <span class="number">1</span>]) &#123; fg = <span class="number">1</span> ; <span class="keyword">break</span> ;&#125;</span><br><span class="line">			<span class="keyword">if</span> (!fg &amp;&amp; k &gt; res) res = k, db = <span class="number">2</span> ;  </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!db)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; (S + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">			<span class="keyword">continue</span> ; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (db == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= st + res ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = n - st + <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (db == <span class="number">2</span>)&#123; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= st ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = n - st - res + <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h1><blockquote>
<p>给定一个字符串。要求选取他的一个前缀(可以为空)和与该前缀不相交的一个后缀(可以为空)拼接成回文串，且该回文串长度最大。求该最大长度。</p>
<p>多组数据。保证 $\sum n\leq 10^6$ 。</p>
</blockquote>
<p>嗯，jiangly确实是神仙。代码写的又快又整洁又有条理，比我高到不知道哪里去了…</p>
<p>感觉还是很难在做题的时候让自己保持清醒的头脑。还需要多加练习。</p>
<p>哦对，有个小细节需要说一下。就是用Manacher枚举每个位置，判断左界和右界能不能拼起来的时候，是需要取 $min$ 的。这也属于细节吧？？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3000010</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line"><span class="keyword">int</span> ns[N], base[N] ;</span><br><span class="line"><span class="keyword">int</span> T, L, n, res, st ; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id, fars, i ; </span><br><span class="line">	id = <span class="number">0</span>, fars = <span class="number">0</span> ; L = <span class="number">-1</span> ;</span><br><span class="line">	ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="comment">//id : 最靠右的回文串的中心位置 </span></span><br><span class="line">	<span class="comment">//fars : 迄今为止最靠右的回文串的最右侧 </span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		ns[++ L] = (<span class="keyword">int</span>)s[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (fars &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">else</span> base[i] = min(fars - i + <span class="number">1</span>, base[id * <span class="number">2</span> - i]) ;</span><br><span class="line">		<span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"> 		<span class="keyword">if</span> (i + base[i] &gt; fars) id = i, fars = i + base[i] - <span class="number">1</span> ;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> op = T ; </span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>) ; </span><br><span class="line">		n = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ; res = st = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			<span class="keyword">if</span> (S[i] != S[n - i + <span class="number">1</span>]) <span class="keyword">break</span> ; <span class="keyword">else</span> st = i ;</span><br><span class="line">		<span class="keyword">int</span> p = n - st ; <span class="keyword">int</span> db = <span class="number">0</span> ; </span><br><span class="line">		Manacher(S) ; <span class="comment">//cout &lt;&lt; st &lt;&lt; endl ;</span></span><br><span class="line">		<span class="comment">//for (int i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; base[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">			<span class="keyword">int</span> l = i / <span class="number">2</span> - base[i] / <span class="number">2</span> + <span class="number">1</span> ; </span><br><span class="line">			<span class="keyword">int</span> r = i / <span class="number">2</span> + base[i] / <span class="number">2</span> - <span class="number">1</span> + (<span class="keyword">bool</span>)(ns[i] == <span class="string">'#'</span>) ;</span><br><span class="line">			<span class="keyword">int</span> p = base[i] - <span class="number">1</span>, q = base[i] - <span class="number">1</span> ; </span><br><span class="line">			<span class="comment">//cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; base[i] &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl ;</span></span><br><span class="line">			<span class="keyword">if</span> (l &lt;= st) p -= <span class="number">2</span> * (st - l + <span class="number">1</span>) ;</span><br><span class="line">			<span class="keyword">if</span> (r &gt;= n - st + <span class="number">1</span>) p = min(p, q -= <span class="number">2</span> * (r - n + st)) ;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; base[i] &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl ;</span></span><br><span class="line">			l = i / <span class="number">2</span> - (p + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span> ; </span><br><span class="line">			r = i / <span class="number">2</span> + (p + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span> + (<span class="keyword">bool</span>)(ns[i] == <span class="string">'#'</span>) ;</span><br><span class="line">			<span class="keyword">if</span> (p &gt; res &amp;&amp; l &lt;= st + <span class="number">1</span>) db = <span class="number">1</span>, res = p ; </span><br><span class="line">			<span class="keyword">if</span> (p &gt; res &amp;&amp; r &gt;= n - st) db = <span class="number">2</span>, res = p ;</span><br><span class="line"> 		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; db &lt;&lt; endl ;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L + <span class="number">2</span> ; ++ i) </span><br><span class="line">			ns[i] = <span class="number">0</span>, base[i] = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!db)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; (S + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">			<span class="keyword">continue</span> ; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//cout &lt;&lt; res &lt;&lt; endl ; </span></span><br><span class="line">		<span class="keyword">if</span> (db == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= st + res ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = n - st + <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (db == <span class="number">2</span>)&#123; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= st ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = n - st - res + <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%c"</span>, S[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote>
<p>给定两个长度均为 $n$ 的排列 $p,q$ 。对一个初始为空的集合 $s$ 进行如下操作：对于每个 $i$ ，将 $p_i$ 放入集合；如果 $i$ 被<strong>标记</strong>了，则此时再将集合中最大的数删除。求 $n$ 次操作后集合中最大的数。</p>
<p>排列 $q$ 的意义是，对于每个 $i$ ，询问将 $q_1,q_2\cdots q_{i-1}$ 都标记之后的上述操作的结果。</p>
<p>$1\leq n\leq 300,000$。</p>
</blockquote>
<p>这是个神题。其实也不算严格意义上的神，只是我没注意到很多性质导致gg。</p>
<p>首先考虑答案最后一定是单调的。于是根据这个性质考虑何时应当把答案 $-1$ 。发现如果对于当前的一个答案 $x$ ，所有 $&gt;x$ 的数右边均有一个炸弹，那么答案就需要 $-1$ 。所以拆分下来的话，每次只需要考虑 $x$ 的右边是否存才一个未被占的炸弹即可。</p>
<p>考虑如何实现这个过程。对于每个 $i$ 记录包括 $i $ 在内的右边有多少 $&gt;x$ 的数，且有多少炸弹。如果前者减后者对于所有 $i$ 而言均 $\leq 0$ ，$ans$ 就 $-1$  。</p>
<p>于是可知这就变成了一个区间加+全局最大值的问题。线段树维护即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span> ; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n ; </span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> pos[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> s[N * <span class="number">3</span>] ; </span><br><span class="line"><span class="keyword">int</span> tg[N * <span class="number">3</span>] ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> x)&#123;</span><br><span class="line">	s[x] = max(s[x &lt;&lt; <span class="number">1</span>], s[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">	<span class="keyword">if</span> (tg[x])&#123;</span><br><span class="line">		s[x &lt;&lt; <span class="number">1</span>] += tg[x] ; </span><br><span class="line">		s[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[x] ;</span><br><span class="line">		tg[x &lt;&lt; <span class="number">1</span>] += tg[x] ;</span><br><span class="line">		tg[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tg[x] ;</span><br><span class="line">		tg[x] = <span class="number">0</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line">		<span class="keyword">return</span> s[rt] += v, tg[rt] += v, <span class="keyword">void</span>() ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, v) ;</span><br><span class="line">	<span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">	_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> q ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), pos[base[i]] = i ; </span><br><span class="line">	ans = n ; update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, pos[ans], <span class="number">1</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">' '</span> ; <span class="built_in">cin</span> &gt;&gt; q ; </span><br><span class="line">		<span class="keyword">if</span> (i == n) <span class="keyword">return</span> <span class="number">0</span> ; update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, q, <span class="number">-1</span>) ; </span><br><span class="line">		<span class="keyword">for</span> ( ; s[<span class="number">1</span>] &lt;= <span class="number">0</span> ; ) update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, pos[-- ans], <span class="number">1</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/找性质</tag>
        <tag>思维题/构造</tag>
        <tag>好多好多细节</tag>
        <tag>字符串/Manacher</tag>
        <tag>数据结构/线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】[ARC103] C~F</title>
    <url>/2020/03/18/ARC103/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做之前不知道这套题怎么样。做到一半发现后面三道都是构造题…都是构造…构造沙我.jpg</p>
<p>这好像就是ARC正式赛的最后一场了。可惜我一场ARC都没现场打过。</p>
<p>难度大概是 $\rm B&gt;C&gt;D&gt;A$ ？</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote>
<p>给定一个偶数长度的序列 $\{a_n\}$，定义「合法」表示 $\forall i&lt;n-1,a_{i}=a_{i+2}$ 且整个序列共有两种数字。</p>
<p>定义操作：每次选择一个数替换掉某个位置。</p>
<p>求最少需要操作多少次使得序列合法。</p>
<p>$1\leq n\leq 100000,1\leq a_i\leq 100000$。</p>
</blockquote>
<p>比较常规的最优化题目。不难发现如果某个数出现次数很多，就要用这个去替换别的数而不是被换掉。所以不难想到分别拿桶记录奇偶位置的出现次数，然后两个都选最多的即可。</p>
<p>然而显然这个做法是不对的。因为限制了必须有两种数字，所以奇偶位置的取值必须不同。定一找二即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> t[N] ;</span><br><span class="line"><span class="keyword">int</span> s[N] ;</span><br><span class="line"><span class="keyword">int</span> _odd[N] ;</span><br><span class="line"><span class="keyword">int</span> _eve[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _odd[x] &gt; _odd[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compe</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _eve[x] &gt; _eve[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; res = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) _odd[base[i]] ++ ;</span><br><span class="line">        <span class="keyword">else</span> _eve[base[i]] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i) s[i] = t[i] = i ;</span><br><span class="line">    sort(s + <span class="number">1</span>, s + N, compo) ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + N, compe) ;</span><br><span class="line">    ans = n / <span class="number">2</span> - _odd[s[<span class="number">1</span>]] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (t[i] != s[<span class="number">1</span>])&#123; ans += n / <span class="number">2</span> - _eve[t[i]] ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    res = min(res, ans) ;</span><br><span class="line">    ans = n / <span class="number">2</span> - _eve[t[<span class="number">1</span>]] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != t[<span class="number">1</span>])&#123; ans += n / <span class="number">2</span> - _odd[s[i]] ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    res = min(res, ans) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote>
<p>给定 $n$ 组坐标。构造长度为 $m$ 的序列 $\{c_n\}$ 和 $n$ 组包含 <code>LRUD</code> 的路径，满足对于每一组坐标：</p>
<ul>
<li>$c_i$ 表示第 $i$ 步「步长」。</li>
<li>对于每个坐标，从 $(0,0)$ 开始走，共走 $m$ 步。第 $i$ 步可以让 $(x,y)$ 变成 $(x±c_i,y)$ 或 $(x,y±c_i)$ 。</li>
<li>走完 $m$ 次之后，恰好走到这组坐标。</li>
<li>要求 $m\leq 40,c_i\leq 10^{12}$ 。</li>
</ul>
<p>$1\leq n\leq 1000$</p>
</blockquote>
<p>不会啊…感觉可能是对这种套路不是很熟啊。</p>
<p>首先无解很容易判断。因为多走一步和少走一步之间的差值总是 $2\times$步长 ，所以如果 $x_i+y_i$ 的奇偶性不同的话，就不能同时满足条件。</p>
<p>后来就不会了x</p>
<p>发现这个题的本质是拆分问题。那么大概可以引导到「二进制拆分」这种泛式的拆分方式上。不妨考虑对于一组 $\{1,2,4\cdots 2^k\}$ 可以拼出哪些坐标。那么考虑对于一组坐标 $(x,y)$ ，他可以被通达，那么可以知道如果想要减小某一维坐标，比如 $x\to x’$，那有两种情况：</p>
<p>1、只是单纯地拿掉几个元素。比如 $16\to11$ 就是简单地拆出 $4$ 和 $1$ 。</p>
<p>2、拿出几个元素并且换进去几个元素。比如 $12\to11$ 就是拆出 $2$ 和 $1$ 放进一个 $4$ 。</p>
<p>可以看出，这是可以相互通达的。</p>
<p>更详细一点。因为对于四个象限，情况都是等价的。所以只考虑第一象限。发现对于 $\{1,2,4\cdots 2^k\}$ ，它可以维护到的位置至少是所有 $|x+y|=\sum _{i=0}^k 2^i=2^{k+1}-1$。但是不仅限于此。发现如果将将其中某个元素的贡献取负，那么就可以访问到所有 $|x+y| - \sum 2^p$ 的格子。换句话说，这个方式可以访问到所有与 $2^{k+1}-1$ 奇偶性相同的格子。</p>
<p>到这一步就已经很完美了，但是依然存在问题。如果 $|x+y|$ 都是偶数，这就挂了。所以此时可以随便向 $x$ 轴或者 $y$ 轴偏移 $1$ ，比如把 $(1,0)$ 变换成原点，就解决了。</p>
<p>实现方面，发现最合法区域后是个内部镂空的菱形。找出来之后，对于一组坐标 $(x,y)$ ，考虑对称着找。反向从大到小枚举每一个步长，如果新的点的 $|x|+|y|$ 之和严格小于当前的步长，就是可以拼出来的。不难知道这样做是对的。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> _eve ;</span><br><span class="line">ll nx, ny ;</span><br><span class="line"><span class="keyword">int</span> bc[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l ;</span><br><span class="line">    <span class="keyword">int</span> r ;</span><br><span class="line">    <span class="keyword">int</span> t ;</span><br><span class="line">&#125;base[N] ; <span class="comment">//D  R  U  L</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125; ;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">4</span>] = &#123;<span class="string">'U'</span>, <span class="string">'L'</span>, <span class="string">'D'</span>, <span class="string">'R'</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    bc[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i].l &gt;&gt; base[i].r ;</span><br><span class="line">        base[i].t = <span class="built_in">abs</span>(base[i].l + base[i].r) &amp; <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (base[i].t != base[<span class="number">1</span>].t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">30</span> ; ++ i) bc[++ cnt] = <span class="number">1</span> &lt;&lt; i ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt + <span class="number">1</span> + (<span class="keyword">bool</span>)(!(base[<span class="number">1</span>].t &amp; <span class="number">1</span>)) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!(base[<span class="number">1</span>].t &amp; <span class="number">1</span>)) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt ; ~i ; -- i) <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, bc[i], <span class="string">" \n"</span>[!i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        nx = base[i].l ;</span><br><span class="line">        ny = base[i].r ;</span><br><span class="line">        <span class="keyword">if</span> (!(base[i].t &amp; <span class="number">1</span>))</span><br><span class="line">            ny -= <span class="number">1</span>, <span class="built_in">putchar</span>(<span class="string">'U'</span>) ;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; endl ;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = cnt ; ~j ; -- j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">                ll kx = nx + (ll)dx[k] * bc[j] ;</span><br><span class="line">                ll ky = ny + (ll)dy[k] * bc[j] ;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(kx) + <span class="built_in">abs</span>(ky) &lt; bc[j])&#123;</span><br><span class="line">                    nx = kx ; ny = ky ;</span><br><span class="line">					<span class="comment">//cout &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; endl ;</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c"</span>, s[k]) ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>给定一个长度为 $n$ 的 $01$ 序列 $\{s_n\}$。尝试构造一棵具有如下性质的 $n$ 个结点的树：</p>
<p>$\forall i\in[1,n]\cap\mathbb{Z_+}$，$s_i$ 若为 $1$ ，则一定存在大小为 $i$ 的连通块；$s_i$ 若为 $0$ ，则一定不存在大小为 $i$ 的连通块。</p>
<p>$1\leq n\leq10^5$ 。</p>
</blockquote>
<p>神仙构造orz。</p>
<p>首先显然的是 $s_n=0$，$s_1=1$ ，否则无解。并且这东西是有对称性的，割掉一个大小为 $k$ 的连通块一定也会割出一个大小为 $n-k$ 的连通块。所以可以如此判断是否存在解。</p>
<p>这种构造，如果强行定义的话，可能存在某种套路。思考这一种比较自然的构造方式：找到最大的连通块，让其成为 $1$ 的一棵子树，这样迭代做下去，最后再拿散点连上去，看上去有点合理，因为 $1$ 的连通块必然存在。但仔细思考就会发现这样做会使得很多不应该存在的大小的连通块出现。</p>
<p>但是至少发现，连散点是个比较好的方式，而上一个方法欠缺的就是难以准确构造连通块。这就可以把思路引到「菊花」上。发现对于一个 $k$ 阶菊花，只会产生大小为 $k-1$ 和 $1$ 的连通块。那么可以知道大概可以如此设计思路：枚举连通块大小 $p$ ，如果 $s_p=0$ ，那么就应该把 $p+2$ 号点也连在之前的某个菊花上 ，这样就不会出现 $size=p$ 的连通块；否则把 $p+2$ 连向单独拿出来作为一个新的新的菊花的重心连向 $p+1$ ，这样就会有 $size=p$ 的连通块了。</p>
<p>形式化地讲，考虑设 $1&lt;q_1&lt;q_2&lt;\cdots &lt;q_m&lt;n$ 表示 $\{s_n\}$ 中那些值为 $1$ 的位置。那么构造出来的只需要是一个链套菊花，每个菊花大小是 $q_k-q_{k-1}$ 即可（差分）。</p>
<p>显然这种构造方式能凑出所有 $s_p=1$ 的 $p$ 来。接下来只需要考虑这样做为什么也可以保证 $s_p=0$ 的位置不构造出来。发现如果砍掉的边是菊花边而不是链边，那么只会有 $n-1$ 和 $1$ 这两种连通块；如果是链边，那么只会是某个 $q_k$ 和 $n-q_k$ ，由于之前已经判过了对称性，所以不难证明这样做是对的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) ;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (s[n] == <span class="string">'1'</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[n - i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt; n ; ++ i)</span></span><br><span class="line"><span class="comment">        if (s[i] == '1') stk[++ top] = i ;</span></span><br><span class="line"><span class="comment">    stk[++ top] = n ; int k ; cnt = 0 ;</span></span><br><span class="line"><span class="comment">    while (top) sz[++ cnt] = stk[top --] ;</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt; cnt ; ++ i)</span></span><br><span class="line"><span class="comment">        printf("%d %d\n", i, i + 1), sz[i] -= sz[i + 1] ;</span></span><br><span class="line"><span class="comment">    k = cnt ;</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 1 ; j &lt;= sz[i] ; ++ j)</span></span><br><span class="line"><span class="comment">            printf("%d %d\n", i, ++ cnt) ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    m = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) m = i + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote>
<p>给定一棵树上每个点到其他点的距离和。保证均不相同。构造这样的一棵树。</p>
<p>$1\leq n\leq 200,000$ </p>
</blockquote>
<p>嗯。其实树上如果是考虑距离的话，也就那么点事儿。</p>
<p>首先要知道的是，一个经典的 $dp$ 。根据 $f_u$ 推出 $f_v$ ，此处假设 $fa_v=u$ 。那么有：</p>
<script type="math/tex; mode=display">
f_u=f_v+size_v-(n-size_v)=f_v-n+2\cdot size_v</script><p>并且考虑一个很自然的思路。对于树而言，其最特殊的节点就是根和叶子。</p>
<p>发现 $f$ 值最小的那个是重心。那么如果令重心当根，那么随深度增大，$f$ 是单增的。同时可以知道，如果根是重心的话，一定不会存在某棵子树的 $size&gt;\lfloor \frac{n}{2}\rfloor$ ，这就可以作为判断无解的依据。</p>
<p>于是就从底向上不断删叶子就可以了。合法随便判一判即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fuck_it_up return !puts(<span class="meta-string">"-1"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll minx ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line">ll dis[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    ll val ;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="built_in">map</span> &lt;ll, <span class="keyword">int</span>&gt; s ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(tree a, tree b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &gt; b.val ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        dis[to(k)] = dis[x] + n - <span class="number">2</span> * sz[to(k)], dfs(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) sz[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i].val) ;</span><br><span class="line">        s[base[i].val] = base[i].id = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = base[i].id ;</span><br><span class="line">        ll y = base[i].val ;</span><br><span class="line">        <span class="keyword">int</span> delta = n - <span class="number">2</span> * sz[x] ;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt;= <span class="number">0</span>) fuck_it_up ;</span><br><span class="line">        <span class="keyword">if</span> (!s.count(y - delta)) fuck_it_up ;</span><br><span class="line">        fa[x] = s[y - delta] ; minx += sz[x] ;</span><br><span class="line">        sz[fa[x]] += sz[x] ; add(fa[x], x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cout</span> &lt;&lt; fa[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">    dis[base[n].id] = minx ; dfs(base[n].id) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (dis[base[i].id] != base[i].val) fuck_it_up ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; base[i].id &lt;&lt; <span class="string">" "</span> &lt;&lt; fa[base[i].id] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>atcoder</category>
      </categories>
      <tags>
        <tag>思维题/找性质</tag>
        <tag>思维题/构造</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络流24题专题】6 · 有趣的费用流</title>
    <url>/2020/03/15/%E8%B4%B9%E7%94%A8%E6%B5%81Hard/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>24题中比较新颖有趣的费用流题目：</p>
<p>分别是 <code>loj#6014</code> 最长可重区间集、<code>loj#6227</code> 最长可重线段集问题 和  <code>loj#6008</code> 餐巾计划。</p>
<p>啊，24道题里面，1道假题，还有两道状压bfs，因为与网络流无瓜就忽略了。</p>
<p>总之呢，总算是做完了啊。</p>
<a id="more"></a>
<h1 id="最长-k-可重区间集"><a href="#最长-k-可重区间集" class="headerlink" title="最长 k 可重区间集"></a>最长 k 可重区间集</h1><blockquote>
<p>给定实直线 $ L $ 上 $ n $ 个开区间组成的集合 $ I $，和一个正整数 $ k $，试设计一个算法，从开区间集合 $ I $ 中选取出开区间集合 $ S \subseteq I $，使得在实直线 $ L $ 的任何一点 $ x $，$ S $ 中包含点 $ x $ 的开区间个数不超过 $ k $。且 $ \sum\limits_{z \in S} | z | $ 达到最大。这样的集合 $ S $ 称为开区间集合 $ I $ 的最长 $ k $ 可重区间集。$ \sum\limits_{z \in S} | z | $ 称为最长 $ k $ 可重区间集的长度。</p>
<p>对于给定的开区间集合 $ I $ 和整数 $ k $，计算开区间集合 $ I $ 的最长 $ k $ 可重区间集的长度。</p>
<p>$ 1 \leq n \leq 500, 1 \leq k \leq 3 $</p>
</blockquote>
<p>首先一拿出来，这不就是匹配问题嘛？一个点最多匹配 $k$ 个区间。于是每个位置建一个点，然后连向覆盖自己的点，然后…好像不太对？其一他没给下标的取值范围，其二一个线段覆盖多个点，要么都覆盖要么都不覆盖，这个限制很难表示…</p>
<p>于是好像不知道从何处入手了。发现一个这样的性质，就是永远不会选择 $k$ 个以上交于 $1$ 点的区间。也就是说，如果两个区间彼此之间没有交，就可以同时选；否则能不能同时选，看情况。这像极了「限制」，也就是如果两个区间之间没有交，那两者不存在限制；否则存在 $k$ 的限制。</p>
<p>根据一开始的匹配，可以猜到大致上用网络流是可行的。并且似乎网络流很适合用流量来表征限制。那么考虑，如果两个区间不存在限制，那么应该怎么办——网络流类似电流，所以此时如果串联的话，就代表着可以同时选；那么如果存在限制，就意味着不能串联。根据这一点，考虑如何串联。发现本质上是将两个不交的区间中间连 $f=\infty,c=0$ 的边。</p>
<p>这一点就引申出两个建图方法，其本质是相同的：</p>
<p>1、建立一个超级源 $\rm S$ 和一个源 $\rm S’$ ，中间连 $f=k,c=0$ 的边，目的是提供初始流量。$\rm S’$ 向每个区间的左端点连一条 $f=1,c=-1$ 边。然后区间左端点向右端点连边 $f=1,c=-len$ 表示贡献，每个右端点再向 $\rm T $ 连边即可。如果两个区间不交，就由一个区间的 $r$ 连向另一个区间的 $l$ （当然要按秩啦）。思考这样做的合理性，对于相交的区间，一定是并联；否则的话就是串联（其实叫做混连，但是问题不大）。</p>
<p>2、建立一个源 $\rm S$ 连向数轴上的 $0$ 位置，$f=k,c=0$。然后数轴上每个 $i&gt;0$ 向 $i+1$ 连边 $f=k,c=0$。最后 $maxright$ 向 $\rm T$ 连边。对于一个区间，连法跟1相同。</p>
<p>注意：</p>
<p>1、为什么要拆点？此处拆点的作用值得注意。对于一个区间，本质上应该抽象成一个点。但是在流图里是不存在「点权」这个概念的。所以需要把点权转边权，拆点的作用便在于此。</p>
<p>2、其实上面两个方法，可以通过初中物理里面什么「判断两个电路图是否等价」的知识来解决的233</p>
<p>3、由于本题保证了「开区间」，所以可以直接 $l\to r,len=r-l$ 。当然如果是闭区间，只需要改成 $l\to r+1$ 即可。</p>
<p>4、上面的第二个方案，发现最终可能存在很多数轴上的点 $i$ 只与 $i-1,i+1$ 连了 $f=k,c=0$ 的边，所以是没用的，离散化掉就好了。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> I = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ft first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ct(k) e[k].cost</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> cost ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _s ;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> dis[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> _last[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    fw(cnt) = f ; ct(cnt) = c ;</span><br><span class="line">    fr(cnt) = u ; head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fill(g, g + n + <span class="number">1</span>, I) ;</span><br><span class="line">    fill(dis, dis + n + <span class="number">1</span>, I) ;</span><br><span class="line">    fill(vis, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(_s) ; vis[_s] = <span class="number">1</span> ; dis[_s] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ;</span><br><span class="line">        q.pop() ; vis[x] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (dis[to(k)] &gt; dis[x] + ct(k) &amp;&amp; fw(k))&#123;</span><br><span class="line">                dis[to(k)] = dis[x] + ct(k) ;</span><br><span class="line">                g[to(k)] = min(fw(k), g[x]) ;</span><br><span class="line">                pre[to(k)] = x ; _last[to(k)] = k ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">                    q.push(to(k)) ;</span><br><span class="line">                    vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(dis[<span class="keyword">_t</span>] &lt; I) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (spfa())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">_t</span> ;</span><br><span class="line">        res += g[<span class="keyword">_t</span>] ;</span><br><span class="line">        ans += g[<span class="keyword">_t</span>] * dis[<span class="keyword">_t</span>] ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; g[_t] &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (x != _s)&#123;</span><br><span class="line">            fw(_last[x]) -= g[<span class="keyword">_t</span>] ;</span><br><span class="line">            fw(_last[x] ^ <span class="number">1</span>) += g[<span class="keyword">_t</span>] ;</span><br><span class="line">            x = pre[x] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[N] ;</span><br><span class="line">pint base[N] ;</span><br><span class="line"><span class="keyword">int</span> _n, _k, tot ;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Id, buc ;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; :: iterator t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, f, c ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _n &gt;&gt; _k ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i].ft &gt;&gt; base[i].sc ;</span><br><span class="line">        len[i] = base[i].sc - base[i].ft ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Id.count(base[i].ft)) buc[base[i].ft] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (!Id.count(base[i].sc)) buc[base[i].sc] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">1</span>, _k, <span class="number">0</span>) ; add(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (t = buc.begin() ; t != buc.end() ; ++ t)</span><br><span class="line">        Id[t-&gt;ft] = ++ tot ; _s = <span class="number">0</span> ; <span class="keyword">_t</span> = tot + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        add(i, i + <span class="number">1</span>, I, <span class="number">0</span>), add(i + <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; Id[base[i].ft] &lt;&lt; " " &lt;&lt; Id[base[i].sc] &lt;&lt; endl ;</span></span><br><span class="line">        add(Id[base[i].ft], Id[base[i].sc], <span class="number">1</span>, -len[i]) ;</span><br><span class="line">        add(Id[base[i].sc], Id[base[i].ft], <span class="number">0</span>, len[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="keyword">_t</span> + <span class="number">1</span> ; ek() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长-k-可重线段集问题"><a href="#最长-k-可重线段集问题" class="headerlink" title="最长 k 可重线段集问题"></a>最长 k 可重线段集问题</h1><blockquote>
<p>给定平面 $\text{x-o-y}$上 $n$ 个开线段组成的集合 $\text{I}$，和一个正整数 $\rm k$ 从开线段集合 $\text{I}$ 中选取出开线段集合 $\text{S}\in \text{I}$, 使得在 x 轴上的任何一点 $\text{p}$ ， $\text{S}$ 中与直线 $\text{x}=\text{p}$ 相交的开线段个数不超过 $\text{k}$ ，且 $\sum_{\text{z} \in \text{S}}|z|$ 达到最大。这样的集合 $\text{S}$ 称为开线段集合 $\text{I}$ 的最长 $\text{k}$ 可重线段集的长度。</p>
<p>对于任何开线段 $\text{z}$，设其端点坐标为 $( x_0 , y_0 )$ 和 $( x_1 , y_1 )$，则开线段 $\text{z}$ 的长度 $|\text{z}|$ 定义为： $|z| = \lfloor \sqrt{ ( x_1 - x_0 ) ^ 2 + ( y_1 - y_0 )^2 } \rfloor$。对于给定的开线段集合 $\text{I}$ 和正整数 $\text{k}$ ，计算开线段集合 $\text{I}$ 的最长 $\text{k}$ 可重线段集的长度。</p>
<p>$1\leq n\leq500,$ $1 \leq k \leq 13$.</p>
</blockquote>
<p>发现和「区间集」那题没啥区别，只用关心 $x$ 轴，换一下长度的求法…好像有点不对？因为如果存在两条线段均垂直于 $x$ 轴，且两条线的左右端点分别都是 $x_i$ ，这样的话，建出图来这俩线段是串在一起不交的，但是本质上应该交。</p>
<p>于是自然想到，要换种表示方法在 $x$ 轴上表示一个线段。那么如果是在数轴上，比较简单的方式就是扩域。每个线段 $i$ 的左右端点 $(l_i,r_i)$ 变换成 $(2\times l_i,2\times r_i)$——听上去很不错，这样的话就相当于每个下标多了一个空间。那么对于一个左右端点相同的区间 $(x,x)$ ，就可以连边成 $(2\cdot x,2\cdot x + 1)$。这样的话，原本左右端点不用的区间也要改——由于那些相同的区间右端点加了 $1$，所以如果存在这样两个线段 $(p,p)$ 、 $(p,q)$ ，那么原本不交的两个区间，在扩域之后变成了相交的 $(2p,2p+1)$、$(2p,2q)$ 。</p>
<p>处理方式很简单，对于一个 $p\not=q$ 的区间 $(p,q)$，连边 $(2p+1,2q)$ 即可。思考这么做为啥是对的。对于原本存在的两个均不垂直 $x$ 轴的线段，他们如果相交，那么交的那一端，$r_1-l_2\geq 1$ ；如果不交，那么有 $l_2-r_1\geq 1$ 。扩域之后就变成了 $\geq 2$ 。所以如果只是左端点增加 $1$ ，根本不影响判定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len[N] ;</span><br><span class="line">pint base[N] ;</span><br><span class="line"><span class="keyword">int</span> _n, _k, tot ;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Id, buc ;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; :: iterator t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((ll)(a - c) * (a - c) + (ll)(b - d) * (b - d)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _n &gt;&gt; _k ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d ;</span><br><span class="line">        len[i] = calc(a, b, c, d) ;</span><br><span class="line">        base[i].ft = a &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">        base[i].sc = c &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (a == c)</span><br><span class="line">            ++ base[i].sc ;</span><br><span class="line">        <span class="keyword">else</span> ++ base[i].ft ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Id.count(base[i].ft)) buc[base[i].ft] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (!Id.count(base[i].sc)) buc[base[i].sc] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    add(<span class="number">0</span>, <span class="number">1</span>, _k, <span class="number">0</span>) ; add(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (t = buc.begin() ; t != buc.end() ; ++ t)</span><br><span class="line">        Id[t -&gt; ft] = ++ tot ; _s = <span class="number">0</span> ; <span class="keyword">_t</span> = tot + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        add(i, i + <span class="number">1</span>, I, <span class="number">0</span>), add(i + <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; Id[base[i].ft] &lt;&lt; " " &lt;&lt; Id[base[i].sc] &lt;&lt; endl ;</span></span><br><span class="line">        add(Id[base[i].ft], Id[base[i].sc], <span class="number">1</span>, -len[i]) ;</span><br><span class="line">        add(Id[base[i].sc], Id[base[i].ft], <span class="number">0</span>, len[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="keyword">_t</span> + <span class="number">1</span> ; ek() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="餐巾计划"><a href="#餐巾计划" class="headerlink" title="餐巾计划"></a>餐巾计划</h1><blockquote>
<p>一个餐厅在相继的 $ n $ 天里，每天需用的餐巾数不尽相同。假设第 $ i $ 天需要 $ r_i $ 块餐巾。餐厅可以购买新的餐巾，每块餐巾的费用为 $ P $ 分；或者把旧餐巾送到快洗部，洗一块需 $ M $ 天，其费用为 $ F $ 分；或者送到慢洗部，洗一块需 $ N $ 天，其费用为 $ S $ 分（$ S &lt; F $）。</p>
<p>每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。</p>
<p>试设计一个算法为餐厅合理地安排好 $ n $ 天中餐巾使用计划,使总的花费最小。</p>
<p>$ 1 \leq n \leq 1000 $</p>
</blockquote>
<p>一道有趣的题。</p>
<p>嗯，本来想整理一下自己错的那几版是怎么错的，然后发现我忘了…</p>
<p>然后最近错的一版我是这么建的边：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line">	<span class="keyword">int</span> p, m, f, n, s ; </span><br><span class="line">	S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ; </span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;p, &amp;m, &amp;f, &amp;n, &amp;s) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		Add(S, i, Inf, <span class="number">0</span>), Add(i + N, T, base[i], <span class="number">0</span>) ; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; N ; ++ i) Add(i, i + <span class="number">1</span>, Inf, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		Add(i, i + N, base[i], p) ;</span><br><span class="line">		<span class="comment">//Add(S, i + N, base[i], p) ;</span></span><br><span class="line">		<span class="keyword">if</span> (i + m &lt;= N) Add(i, i + m + N, base[i], f) ; </span><br><span class="line">		<span class="keyword">if</span> (i + n &lt;= N) Add(i, i + n + N, base[i], s) ;</span><br><span class="line">	&#125;</span><br><span class="line">	MCMF() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/Users/pengkunshuo/Desktop/pks/blogggg/source/_posts/233.png" alt=""></p>
<p>那么实质上这个题应该怎么做呢？zay鸽鸽教育我：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/Users/pengkunshuo/Desktop/pks/blogggg/source/_posts/233.jpg" alt=""></p>
<p>大概就是 $\rm S$ 到晚上的边实际上是当天餐巾用完之后要提供 $r_i$ 块脏的餐巾——这个思路，是逆常识的，单纯是为了让每个点到 $T$ 的边满流才这么做。</p>
<p>于是最后就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; </span><br><span class="line">	<span class="keyword">int</span> p, m, f, n, s ; </span><br><span class="line">	S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ; </span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;p, &amp;m, &amp;f, &amp;n, &amp;s) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		Add(S, i + N, base[i], <span class="number">0</span>), Add(i, T, base[i], <span class="number">0</span>) ; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; N ; ++ i) Add(i, i + <span class="number">1</span>, Inf, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; N ; ++ i) Add(i + N, i + N + <span class="number">1</span>, Inf, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="comment">//Add(i, i + N, base[i], p) ;</span></span><br><span class="line">		Add(S, i, base[i], p) ;</span><br><span class="line">		<span class="keyword">if</span> (i + m &lt;= N) Add(i + N, i + m, Inf, f) ; </span><br><span class="line">		<span class="keyword">if</span> (i + n &lt;= N) Add(i + N, i + n, Inf, s) ;</span><br><span class="line">	&#125;</span><br><span class="line">	MCMF() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唉，青春不再，纪念一下好久之前写过的代码，也为这篇文章画上个句号吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1005000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, f, c ;</span><br><span class="line">&#125;E[MAXN] ;<span class="keyword">int</span> head[MAXN], cnt = <span class="number">-1</span>, x ;</span><br><span class="line"><span class="keyword">int</span> Ans, S, T, N, base[MAXN], i, j, k, dist[MAXN], F[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dist, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now) <span class="keyword">const</span>&#123; <span class="keyword">return</span> dist &gt; now.dist ; &#125;</span><br><span class="line">&#125; ; priority_queue &lt;state&gt; q ; <span class="keyword">bool</span> vis[MAXN] ; <span class="keyword">int</span> H[MAXN], Pre[MAXN], Last[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijks</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) </span><br><span class="line">        dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">    dist[S] = <span class="number">0</span> ; q.push((state)&#123;dist[S], S&#125;) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        state now = q.top() ; q.pop() ; </span><br><span class="line">        <span class="keyword">int</span> num = now.num, dis = now.dist ;</span><br><span class="line">        <span class="keyword">if</span> (vis[num]) <span class="keyword">continue</span> ; vis[num] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (k = head[num] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = dis + H[num] - H[to(k)] + E[k].c ;</span><br><span class="line">            <span class="keyword">if</span> (qwq &lt; dist[to(k)] &amp;&amp; !vis[to(k)] &amp;&amp; E[k].f)&#123;</span><br><span class="line">                dist[to(k)] = qwq, F[to(k)] = min(F[num], E[k].f), </span><br><span class="line">                q.push((state)&#123;dist[to(k)], to(k)&#125;), Pre[to(k)] = num, Last[to(k)] = k ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> dist[T] &lt; Inf ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].c = c ;</span><br><span class="line">    E[cnt].f = f, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    E[++ cnt].to = u, E[cnt].c = -c ;</span><br><span class="line">    E[cnt].f = <span class="number">0</span>, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (dijks())&#123;</span><br><span class="line">        <span class="keyword">int</span> Ed = T ; Ans += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line">        <span class="keyword">while</span> (Ed) E[Last[Ed]].f -= F[T], E[Last[Ed] ^ <span class="number">1</span>].f += F[T], Ed = Pre[Ed] ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] = dist[i] ; <span class="comment">/*cout &lt;&lt; dist[T] &lt;&lt; endl ; */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p, m, f, n, s ; <span class="built_in">cin</span> &gt;&gt; N ; <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ; S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;p, &amp;m, &amp;f, &amp;n, &amp;s), i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line"><span class="comment">//	for (scanf("%d%d%d%d%d", &amp;p, &amp;m, &amp;f, &amp;n, &amp;s), i = 1 ; i &lt;= N ; ++ i) Add(S, i, base[i], 0), Add(i + N, T, base[i], 0) ; </span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, base[i], <span class="number">0</span>),  Add(i + N, T, base[i], <span class="number">0</span>) ; <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; N ; ++ i) Add(i, i + <span class="number">1</span>, Inf, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) &#123;Add(S, i + N, Inf, p), Add(i, i + N, Inf, p) ; <span class="keyword">if</span> (i + m &lt;= N) Add(i, i + m + N, Inf, f) ; <span class="keyword">if</span> (i + n &lt;= N) Add(i, i + n + N, Inf, s) ;&#125;</span><br><span class="line">	<span class="comment">/*for (i = 1 ; i &lt; N ; ++ i) Add(i, i + 1, Inf, 0) ; //1</span></span><br><span class="line"><span class="comment">	for (i = 1 ; i &lt;= N ; ++ i) &#123;Add(S, i + N, Inf, p), Add(i, i + N, base[i], p) ; if (i + m &lt;= N) Add(i, i + m + N, Inf, f) ; if (i + n &lt;= N) Add(i, i + n + N, Inf, s) ;&#125;</span></span><br><span class="line"><span class="comment">	*/</span>MCMF() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
        <tag>网络流/费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络流24题专题】5 · 费用流进阶</title>
    <url>/2020/03/15/%E8%B4%B9%E7%94%A8%E6%B5%81%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>似乎是比较进阶的费用流问题。</p>
<p>分别是 <code>loj#6013</code> 负载平衡、<code>loj#6122</code> 航空路线 、 <code>loj#6010</code> 数字梯形 和 <code>loj#6223</code> 汽车加油行驶问题。</p>
<a id="more"></a>
<h1 id="负载平衡"><a href="#负载平衡" class="headerlink" title="负载平衡"></a>负载平衡</h1><blockquote>
<p>G 公司有 $ n $ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $ n $ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。</p>
<p>$n\leq 100$。</p>
</blockquote>
<p>一道个人感觉有点东西的建图题。首先不难发现这是个均分纸牌问题。这个贪心说实话我理解的还不够深入。于是考虑怎么建图。</p>
<p>首先不难想到，由于每个点最后都要回到平均值，即一部分点需要将值给出去，一部分需要接受，那么就应该是一个类二分图的样子。但问题在于，怎么添加流量和(可能有的)费用呢？一开始想的是两个点之间差值为 $k$ 的话就连 $f=k,c=1$ 的边，然后超级源和超级汇都连 $+\infty,0$ 的边。但是这样根本无法限制每个点的流量。</p>
<p>现在考虑思路化地去思考这道题。</p>
<p>首先考虑流量之于这一题是什么存在——流量即限制，那么此题的限制就在于每个点最多只要增/减 $|\overline{a}-a_i|$ 的值；费用就显然是 $1$ 了。</p>
<p>那么考虑怎么连边。注意到点之间怎么流，是没有限制的，也就是说限制流图的中部是错的。于是考虑限制流图的前部和后部，发现只需要让 $\rm S$ 连向每个 $a_i&gt;\overline{a}$ 的点 $i$ ，容量为 $a_i-\overline{a}$ ；让每个 $a_j\leq \overline{a}$ 的点 $j$ 连向 $\rm T$ ，容量为 $\overline{a}-a_j$ 。中部的连法需要考虑实际意义，由于只要是相邻就可传递，所以直接向每个与自己相邻的点连边即可。</p>
<p>嗯，尤其需要注意的是，每个点都需要有一个替身(也就是需要拆点)。此处拆点的目的不再是限制了(因为自身和自身之间不连边)，而是题目意义(每个点可以作为中介接受比自己小的点的转运)。</p>
<p>然后这里放一下新版的 MCMF 的板子吧。上面的都是好久之前写的了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> I = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ct(k) e[k].cost</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> cost ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _s ;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> dis[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> _last[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    fw(cnt) = f ; ct(cnt) = c ;</span><br><span class="line">    fr(cnt) = u ; head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fill(g, g + n + <span class="number">1</span>, I) ;</span><br><span class="line">    fill(dis, dis + n + <span class="number">1</span>, I) ;</span><br><span class="line">    fill(vis, vis + n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(_s) ; vis[_s] = <span class="number">1</span> ; dis[_s] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ;</span><br><span class="line">        q.pop() ; vis[x] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (dis[to(k)] &gt; dis[x] + ct(k) &amp;&amp; fw(k))&#123;</span><br><span class="line">                dis[to(k)] = dis[x] + ct(k) ;</span><br><span class="line">                g[to(k)] = min(fw(k), g[x]) ;</span><br><span class="line">                pre[to(k)] = x ; _last[to(k)] = k ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">                    q.push(to(k)) ;</span><br><span class="line">                    vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(dis[<span class="keyword">_t</span>] &lt; I) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (spfa())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">_t</span> ;</span><br><span class="line">        res += g[<span class="keyword">_t</span>] ;</span><br><span class="line">        ans += g[<span class="keyword">_t</span>] * dis[<span class="keyword">_t</span>] ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; g[_t] &lt;&lt; " " &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (x != _s)&#123;</span><br><span class="line">            fw(_last[x]) -= g[<span class="keyword">_t</span>] ;</span><br><span class="line">            fw(_last[x] ^ <span class="number">1</span>) += g[<span class="keyword">_t</span>] ;</span><br><span class="line">            x = pre[x] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _n ;</span><br><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> bbar ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, f, c ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _n ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], sum += base[i] ;</span><br><span class="line">    bbar = sum / _n ;</span><br><span class="line">    _s = <span class="number">0</span>, <span class="keyword">_t</span> = <span class="number">2</span> * _n + <span class="number">1</span> ;</span><br><span class="line">    add(<span class="number">1</span>, _n, I, <span class="number">1</span>) ;</span><br><span class="line">    add(_n, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">2</span> * _n, I, <span class="number">1</span>) ;</span><br><span class="line">    add(<span class="number">2</span> * _n, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    add(_n, <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, _n, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    add(_n, <span class="number">1</span> + _n, I, <span class="number">1</span>) ;</span><br><span class="line">    add(<span class="number">1</span> + _n, _n, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            add(i, i - <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">            add(i - <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">            add(i, i + _n - <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">            add(i + _n - <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; _n)&#123;</span><br><span class="line">            add(i, i + <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">            add(i + <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">            add(i, i + _n + <span class="number">1</span>, I, <span class="number">1</span>) ;</span><br><span class="line">            add(i + _n + <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (base[i] &gt; bbar)&#123;</span><br><span class="line">            add(i, _s, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            add(_s, i, base[i] - bbar, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            add(<span class="keyword">_t</span>, i + _n, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            add(i + _n, <span class="keyword">_t</span>, - base[i] + bbar, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int k = 0 ; k &lt;= cnt ; ++ k)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; fr(k) &lt;&lt; " " &lt;&lt; to(k) &lt;&lt; " " &lt;&lt; fw(k) &lt;&lt; " " &lt;&lt; ct(k) &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    n = <span class="keyword">_t</span> + <span class="number">1</span> ; ek() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="航空路线问题"><a href="#航空路线问题" class="headerlink" title="航空路线问题"></a>航空路线问题</h1><blockquote>
<p>给定一张航空图，图中顶点代表城市，边代表两个城市间的直通航线。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。  </p>
<ol>
<li>从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。  </li>
<li>除起点城市外，任何城市只能访问一次。</li>
</ol>
<p>对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。</p>
<p>对于所有数据，$n &lt; 100$</p>
</blockquote>
<p>其实这题不是很难。但是好像很多题解不是很负责任，于是自己写了一下Sol表示想要d其他题解（雾</p>
<p>感觉是个很妙(感觉自己应该会，但是就是想不起来)的转化，就是如果让找一条从 $1$ 出发经过 $n$ 回到 $1$ 的无重复点回路，那本质就是在找两条 $1$ 到 $n$ 的不相交路径。</p>
<hr>
<p>说一点实现上的小细节吧。主要内容是「跟其他题解不一样的东西」。</p>
<p>发现大家在做这个题的时候，都是特判的「是否存在一条直接连通 $1$ 和 $n$」 的路径，然后直接输出。首先这么做，较为麻烦(虽然也就只多了一两二三行)，其次正确性有待考究。</p>
<p>这个地方就需要思考，为什么大家的实现需要特判这个细节？原因是假设只有 $1\leftrightarrow n$ 这一条边，那么这条路需要走两次。但是连边 $(u,v)$ 的时候大家都是写的 <code>add(u&#39;,v,1,0)</code>，导致只能走一次。个人认为，由于这是个基础题，所以每个细节都需要写的十分合理，但这个地方显然就不合理。</p>
<p>网络流题讲究对着限制找<code>flow</code>，对着代价找<code>cost</code>。这个题目里显然只限制了一个点至多走一次，但是没限制一条边至多走一次——虽然本质上，没啥很大区别，因为点至多一次决定了边至多一次——但是这从某种程度上决定了对这个题建模的理解程度。所以我认为，为了更好地实现「网络流24题」的网络流教学任务，应该在连边 $(u,v)$ 时如是写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">add(u',v,Inf,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这样有两个好处：</p>
<p>1、只需要特判无解，根本不需要那些无聊的判来判去判流量多少，影响代码的美观和简练。</p>
<p>2、体现了这个题建模的本质意义。因为已经有拆点保证了题目中的要求的限制，如果再硬生生加上一个「边也至多走一次」，就是在无中生有、暗度陈仓(雾)。而精准的建模是网络流学习阶段所必须掌握的东西。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _n &gt;&gt; _m ;</span><br><span class="line">    x = _n * <span class="number">2</span> ; y = <span class="number">1</span> + _n ;</span><br><span class="line">    _s = <span class="number">0</span> ; <span class="keyword">_t</span> = _n + _n + <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    add(_s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>) ; add(x, <span class="keyword">_t</span>, <span class="number">2</span>, <span class="number">0</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, y, <span class="number">2</span>, <span class="number">-1</span>) ; add(_n, x, <span class="number">2</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s, rt[t[s] = i] = s ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        add(i, i + _n, <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; ss ;</span><br><span class="line">        <span class="keyword">int</span> p = t[s] ;</span><br><span class="line">        <span class="keyword">int</span> q = t[ss] ;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; q) swap(p, q) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl ;</span></span><br><span class="line">        add(p + _n, q, I, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    buc[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    n = <span class="keyword">_t</span> + <span class="number">1</span> ; ek() ;</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; -res - <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    dfs(<span class="number">1</span>, l) ; <span class="built_in">cout</span> &lt;&lt; rt[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rt[ans[i]] &lt;&lt; <span class="string">'\n'</span> ; l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ct(i) == <span class="number">-1</span> &amp;&amp; !fw(i) &amp;&amp; !buc[fr(i)])</span><br><span class="line">            ans[++ l] = fr(i) ;</span><br><span class="line">    sort(ans + <span class="number">1</span>, ans + l + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= l ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rt[ans[i]] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; rt[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>btw，其实只需要dfs一遍即可。由于访问过程一定是单调的，所以将走完一遍后那些没走过的节点排序输出即可。</p>
<hr>
<p>然后需要注意的是，由于本身 $1$ 和 $n$ 都可以经过多次，所以和自己的替身连边要连 $f=2$ 的。</p>
<p>哦，对了，这题其实跟「双调巡游(bitonic tour)」差不多，唯独就是找的不是哈密顿回路且不保证是完全图。多加一维枚举和 $i,j$ 连通的点即可。</p>
<h1 id="数字梯形问题"><a href="#数字梯形问题" class="headerlink" title="数字梯形问题"></a>数字梯形问题</h1><blockquote>
<p>给定一个 $n$ 行的数字梯形，从第一行到最后一行分别有 $2,3,\cdots,n+1$ 个数字。每个数字可以向左下或者右下第一个数字的地方移动。求：</p>
<p>1、$m$ 条互不相交路径的数值最大总和；</p>
<p>2、$m$ 条可以存在点相交时的路径数值最大总和；</p>
<p>3、$m$ 条可以存在点相交或者边相交时的路径数值最大总和；</p>
</blockquote>
<h2 id="第一问-·-完全不相交的路径"><a href="#第一问-·-完全不相交的路径" class="headerlink" title="第一问 · 完全不相交的路径"></a>第一问 · 完全不相交的路径</h2><p>发现本质上，就是最小权路径覆盖问题。那么常规做法是，限制选的次数要通过限制流量来模拟，但是一个单点不存在流量，所以需要拆点。</p>
<p>大概就是每个点拆成两个点，然后对于某个点和它的副本连一条 $f=1,c=-base[x]$ 的边表示选了，毕竟是求最大值。然后 $\rm S$ 和最顶上的连 $f=1,c=0$ 的边，$\rm T$ 和最下面一层连 $f=1,c=0$，原图中点 $i,j$ 相连用 $i’\to j$ 刻画即可。 </p>
<h2 id="第二问-·-边不相交的路径"><a href="#第二问-·-边不相交的路径" class="headerlink" title="第二问 · 边不相交的路径"></a>第二问 · 边不相交的路径</h2><p>我们考虑此时其实是删除了每个点被选取次数的限制。那么我们就将每个点和自己的副本之间的边容量改成$+ \infty$，并把 $\rm T$ 与最底下的所有点的容量扩为 $+ \infty$ 即可。注意后半部分的扩容，<strong>其目的在于防止中间节点的扩容被限制</strong>。</p>
<h2 id="第三问-·-随便的路径"><a href="#第三问-·-随便的路径" class="headerlink" title="第三问 · 随便的路径"></a>第三问 · 随便的路径</h2><p>既然都随便了，就直接把所有的边都设置成$+ \infty$，但是显然的是我们不能扩 $\rm S$ 连出去的边。这样就永远保证了，从 $\rm S$ 走出来一定是一系列链，而不是一个类树形图。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> L1, R1, L ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N ; S = <span class="number">0</span>, T = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j) </span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; base[i][j], Id[i][j] = (tot += <span class="number">2</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) Add(S, Id[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>) ; L = cnt + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (L1 = cnt + <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N + M ; ++ i) Add(Id[N][i] + <span class="number">1</span>, T, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line">			Add(Id[i][j], Id[i][j] + <span class="number">1</span>, <span class="number">1</span>, -base[i][j]) ; R1 = cnt ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line">			<span class="keyword">if</span> (i &lt; N) Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>), Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ; </span><br><span class="line">	<span class="keyword">for</span> (i = L1 ; i &lt; R1 ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line">	<span class="keyword">for</span> (i = L1 + <span class="number">1</span> ; i &lt;= R1 ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ;</span><br><span class="line">	MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ;  </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ;</span><br><span class="line">	<span class="keyword">for</span> (i = L ; i &lt; cnt ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line">	<span class="keyword">for</span> (i = L + <span class="number">1</span> ; i &lt;= cnt ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ; </span><br><span class="line">	MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="comment">/*  以下是错误的建边 </span></span><br><span class="line"><span class="comment">	for (i = 1 ; i &lt;= M ; ++ i) </span></span><br><span class="line"><span class="comment">		cin &gt;&gt; base[++ tot], Add(S, tot, 1, -base[tot]) ;</span></span><br><span class="line"><span class="comment">	for (i = 1 ; i &lt; N ; ++ i)</span></span><br><span class="line"><span class="comment">		for (j = 1 ; j &lt;= M + i ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">			cin &gt;&gt; base[++ tot] ; int sd = (2 * M + i - 2) * (i - 1) / 2 + 1 ;</span></span><br><span class="line"><span class="comment">			for (int k = sd ; k &lt;= (2 * M + i - 1) * i / 2 ; ++ k) Add(k, tot, + Inf, -base[tot]) ;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	for (T = tot + 1, i = tot - (N + M - 1) + 1 ; i &lt;= tot ; ++ i) Add(i, T, 1, 0) ; ++ tot, MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line">	<span class="comment">/*MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="汽车加油行驶问题"><a href="#汽车加油行驶问题" class="headerlink" title="汽车加油行驶问题"></a>汽车加油行驶问题</h1><blockquote>
<p>给定一个 $\text{N}\times \text{N}$ 的方形网格，设其左上角为起点◎，坐标为  $\text{(1,1)} $ ，$\text{X}$ 轴向右为正， $\text{Y}$ 轴向下为正，每个方格边长为 <code>1</code> ，如图所示。</p>
<p>一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(\text{N},\text{N})$ 。</p>
<p>在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则:</p>
<ul>
<li>汽车只能沿网格边行驶，装满油后能行驶 $\text{K}$ 条网格边。</li>
<li>出发时汽车已装满油，在起点与终点处不设油库。</li>
<li>汽车经过一条网格边时，若其 $\text{X}$ 坐标或 $\text{Y}$ 坐标减小，则应付费用 $\text{B}$ ，否则免付费用。</li>
<li>汽车在行驶过程中遇油库则应加满油并付加油费用 $\text{A} $。</li>
<li>在需要时可在网格点处增设油库，并付增设油库费用 $\text{C} $ (不含加油费用 $\text{A} $ )。</li>
<li>$\rm N , K , A , B , C$ 均为正整数， 且满足约束: $2\leq \text{N} \leq 100, 2 \leq \text{K} \leq 10$。</li>
</ul>
<p>设计一个算法，求出汽车从起点出发到达终点的一条所付费用最少的行驶路线。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://www.oj.swust.edu.cn/upload/image/problem/1750.png" alt="233"></p>
</blockquote>
<p>这题第一眼看上去条件很多。考虑状态的设计。发现对于每个状态 $(i,j)$ ，当前的油量 $k$ 都决定了每一步的决策，所以不难看出应该把 $k$ 也放到状态里形成分层图。那么就直接模拟一下走的过程，按分层图建图，流一下即可。</p>
<p>然而此题就是考了个分层图。因为本身所有边流量都是 $1$，所以费用流就是在做最短路233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cnt = <span class="number">-1</span> ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; A &gt;&gt; B &gt;&gt; C ;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head))  ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; Ma[i][j] ;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= K ; ++ k) Id[i][j][k] = ++ tot ;	</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">			<span class="keyword">if</span> (Ma[i][j]) </span><br><span class="line">				<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; K ; ++ k)&#123;</span><br><span class="line">					<span class="keyword">if</span> (i &lt; N) Add(Id[i][j][k], Id[i + <span class="number">1</span>][j][K - <span class="number">1</span>], <span class="number">1</span>, A) ;</span><br><span class="line">					<span class="keyword">if</span> (j &lt; N) Add(Id[i][j][k], Id[i][j + <span class="number">1</span>][K - <span class="number">1</span>], <span class="number">1</span>, A) ;</span><br><span class="line">					<span class="keyword">if</span> (i &gt; <span class="number">1</span>) Add(Id[i][j][k], Id[i - <span class="number">1</span>][j][K - <span class="number">1</span>], <span class="number">1</span>, A + B) ;</span><br><span class="line">					<span class="keyword">if</span> (j &gt; <span class="number">1</span>) Add(Id[i][j][k], Id[i][j - <span class="number">1</span>][K - <span class="number">1</span>], <span class="number">1</span>, A + B) ;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; K ; ++ k) Add(Id[i][j][k], Id[i][j][K], <span class="number">1</span>, A + C) ;</span><br><span class="line">				<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= K ; ++ k)&#123;</span><br><span class="line">					<span class="keyword">if</span> (i &lt; N) Add(Id[i][j][k], Id[i + <span class="number">1</span>][j][k - <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">					<span class="keyword">if</span> (j &lt; N) Add(Id[i][j][k], Id[i][j + <span class="number">1</span>][k - <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">					<span class="keyword">if</span> (i &gt; <span class="number">1</span>) Add(Id[i][j][k], Id[i - <span class="number">1</span>][j][k - <span class="number">1</span>], <span class="number">1</span>, B) ;</span><br><span class="line">					<span class="keyword">if</span> (j &gt; <span class="number">1</span>) Add(Id[i][j][k], Id[i][j - <span class="number">1</span>][k - <span class="number">1</span>], <span class="number">1</span>, B) ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	S = <span class="number">0</span>, T = tot + <span class="number">1</span>, Add(S, Id[<span class="number">1</span>][<span class="number">1</span>][K], <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) Add(Id[N][N][i], T, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">	MFMC() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
        <tag>网络流/费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】[ARC100]C~E</title>
    <url>/2020/03/09/arc100c-e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>整理 ARC100 的 C~E。F题由于太神仙被我拿出去单列了一篇。</p>
<p>写完才发现，这仨题也太水了吧？一点意思都没有啊？<del>不管了，能水一篇是一篇。</del></p>
<a id="more"></a>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>给定一个长为 $n$ 的序列 $\{A\}$，找一个 $b$ 使得下式最小：</p>
<script type="math/tex; mode=display">
a b s\left(A_{1}-(b+1)\right)+a b s\left(A_{2}-(b+2)\right)+\ldots+a b s\left(A_{N}-(b+N)\right)</script></blockquote>
<p>根据小学生结论，一条数轴上离每个点距离和最小的那个点就是这些点最中间那个点。证明的话用微扰法就可以发现这是个下凸函数。</p>
<p>nmd，一开始记成了平均数WA了两次，实际上应该是中位数啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> p ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), k[i] = base[i] - i ;</span><br><span class="line">    sort(k + <span class="number">1</span>, k + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) p = k[n / <span class="number">2</span> + <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">else</span> p = (k[n / <span class="number">2</span>] + k[n / <span class="number">2</span> + <span class="number">1</span>]) / <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ans += <span class="number">1l</span>l * <span class="built_in">abs</span>(base[i] - p - i) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote>
<p>给定一个序列。要求把这个序列分成连续的四份，记这四份内数字和分别为 $a,b,c,d$ ，最小化 $a,b,c,d$ 的极差。</p>
</blockquote>
<p>znm，长得一脸可三分的样子然而并不可三分，因为很容易知道在这种多峰函数三分本质上和爬山没啥区别。可能会有什么神必的退火或者遗传做法。但是个人感觉这个数据范围似乎不是很允许。</p>
<p>考虑暴力怎么做。尝试去枚举中间的第二段的右端点，这样再去枚举 $a,c,d$ ，复杂度是 $O(n^3)$ 的。</p>
<p>观察题目所给的性质。发现所有数都 $&gt;0$。于是考虑枚举第二段的时候，对于一个与自己极差最小的第一段，由于第二段数一直在增多，所以第一段的右端点下标必然是不降的；对于第三、四段，这个性质同样成立。</p>
<p>于是可以想到枚举第二段，第一段和第三段都变成了 $O(1)$ 。最终复杂度 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">ll ans ;</span><br><span class="line">ll S[<span class="number">4</span>] ;</span><br><span class="line">ll minx ;</span><br><span class="line">ll maxx ;</span><br><span class="line">ll sum[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">gt</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmin</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    minx = x &gt;= minx ? minx : x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    maxx = x &gt;= maxx ? x : maxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    ans = (<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>, r = <span class="number">4</span> ;</span><br><span class="line">    S[<span class="number">0</span>] = base[<span class="number">1</span>] ; S[<span class="number">2</span>] = base[<span class="number">3</span>] ;</span><br><span class="line">    S[<span class="number">1</span>] = base[<span class="number">2</span>] ; S[<span class="number">3</span>] = sum[n] - sum[<span class="number">3</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; i &amp;&amp; gt(S[<span class="number">0</span>] - S[<span class="number">1</span>]) &gt; gt(S[<span class="number">0</span>] + base[l] - S[<span class="number">1</span>] + base[l]))&#123;</span><br><span class="line">            S[<span class="number">0</span>] += base[l], S[<span class="number">1</span>] -= base[l], ++ l ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n &amp;&amp; gt(S[<span class="number">3</span>] - S[<span class="number">2</span>]) &gt; gt(S[<span class="number">2</span>] + base[r] - S[<span class="number">3</span>] + base[r]))&#123;</span><br><span class="line">            S[<span class="number">2</span>] += base[r], S[<span class="number">3</span>] -= base[r], ++ r ;</span><br><span class="line">        &#125;</span><br><span class="line">        minx = (<span class="number">1l</span>l &lt;&lt; <span class="number">61</span>) ; maxx = -(<span class="number">1l</span>l &lt;&lt; <span class="number">61</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">3</span> ; ++ j) chkmin(S[j]), chkmax(S[j]) ;</span><br><span class="line">        ans = min(ans, maxx - minx) ; S[<span class="number">1</span>] += base[i] ; S[<span class="number">2</span>] -= base[i] ;</span><br><span class="line">        <span class="comment">//for (int j = 0 ; j &lt;= 3 ; ++ j) cout &lt;&lt; S[j] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote>
<p>给定一个长度为 $2^k-1$ 的序列 $\{a_n\}$。对于每个 $1\leq p\leq 2^k-1$ ，求</p>
<script type="math/tex; mode=display">
\max_{i \operatorname{or} j\operatorname{\leq} p}\{a_i+a_j\}</script><p>$k\leq 18$</p>
</blockquote>
<p>发现似乎是在做一个FMT，但是直接转移最大值需要 $k ^2$ 甚至更高的代价。所以考虑对于每个集合 $s$ 记一下这个集合中的最最大数和次大数，不难发现这样转移是方便的。复杂度 $2^kk$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll ans ;</span><br><span class="line"><span class="keyword">int</span> m, n ;</span><br><span class="line">pint f[N] ;</span><br><span class="line">ll base[N] ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base[x] &gt; base[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; n = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">        f[i] = make_pair(i, n + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    base[n + <span class="number">1</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; j) &amp; i))&#123;</span><br><span class="line">                <span class="keyword">int</span> k = (<span class="number">1</span> &lt;&lt; j) | i ;</span><br><span class="line">                <span class="keyword">int</span> t[<span class="number">4</span>] = &#123;fr(i), sc(i), fr(k), sc(k)&#125; ;</span><br><span class="line">                sort(t, t + <span class="number">4</span>, comp) ; unique(t, t + <span class="number">4</span>) ;</span><br><span class="line">                f[k] = make_pair(t[<span class="number">0</span>], t[<span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        ans = max(ans, base[fr(i)] + base[sc(i)]) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>atcoder</category>
      </categories>
      <tags>
        <tag>快速莫比乌斯变换(FMT)</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[ARC100F]Colorful Sequences</title>
    <url>/2020/03/08/ARC100F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定一个长为 $m$ 的序列，保证每个数都 $\leq k$。同时定义，如果一个全部元素均 $\leq x$ 的序列中存在一个长度为 $x$ 子序列，恰好是 $1\sim x$ 的排列，那么称这个序列为 「$x-$好序列」。</p>
<p>给定长度 $n$ 。求所有长度为 $n$ 的 $k-$好序列共包含了多少个长度为 $m$ 的子序列。</p>
<p>$1\leq n\leq 25000,1\leq k\leq 400$ 。</p>
</blockquote>
<p>神仙计数题，考察了许多很(我)有(不)趣(熟)的技术技巧。</p>
<a id="more"></a>
<p>记这个给定的序列为 $s$ .</p>
<p>首先发现，如果暴力计数统计的话似乎不是很简单，可能只允许状压。所以正难则反( <code>trick1</code>) ，考虑不加 「好序列」的限制，答案就是平凡的 $k^{n-m}(n - m + 1)$，$n-m+1$ 用来确定 $s$ 放在哪个位置。</p>
<p>接下来需要分类讨论：</p>
<p>1、$s$ 本身就是一个 $k-$好序列。</p>
<p>那么所有包含 $s$ 的序列，一定包含 $k$ 。此时所有情况都是合法的。</p>
<p>2、$s$ 中含有一对重复元素。</p>
<p>此时需要注意的是，绝对不会有跨过 $s$ 的 $k-$连续段。所以想到在左右两边分别计算有多少个序列使得与 $s$ 拼接之后，不存在 $k-$连续段。</p>
<p>具体一点。考虑记 $f_{i,j}$ 表示已经考虑了 $i$ 个数，末尾存在一个 $j$ 连续段的序列排列数。发现一共两种转移：</p>
<script type="math/tex; mode=display">
\begin{align*}
(k-j)\cdot f_{i,j}\to f_{i+1,j+1}\\
f_{i,j}\to f_{i+1,p}\quad (p\leq j)
\end{align*}</script><p>第一个转移显然是找一个新的元素放进来，第二个转移则表示永远可以选一个 $k-$连续段中的数字来调整长度。朴素的 $dp$ 是 $nk^2$ 的，考虑如何快速计算第二个转移。发现对于 $i$ 下的一个第二维 $j$，根据第二个转移需要加上所有 $i-1$ 且 $q\geq i$ 的 $f_{i-1,q}$ 的和，是一个后缀和的形式。</p>
<p>考虑如何在刷表的时候维护后缀和(<code>trick2</code>)：假设当前状态 $(i,j)$ 要转移到 $(i+1,j+1)$ ，转移了 $v$ 。那么考虑再从 $(i,j)$ 转移到 $(i+1,j+2)$，转移 $-v$ 。这样对于每个状态 $(i,j)$，其真实值都是一个 $1\to j$ 的累加过程，可以前缀和，也就是把第一个转移给前缀和化；对于第二个转移，考虑向 $(i+1,1)$ 这个状态转移 $\sum _jf_{i,j}$ ，然后在每个 $(i+1,j)$ 处减掉 $(i,j-1)$ 。原因是根据第二个转移，对于 $i$ 而言，只有 $\geq j$  的 $f_{i,p}$ 才能产生贡献，所以相当于提前减掉了这一部分。  </p>
<p>转移的时候保证不让 $j=k$ 参与进来，那么就可以保证合法。</p>
<p>扯回正题。发现计算这个东西，如果一开始在 $s$ 中确定了 $f_0$ 的哪个状态合法，就应当对其设初值。具体的，以左半边为例，找出左半边最长的连续段长度为 $l$，那么 $f_{0,l}$ 初值便应该为 $1$ 。整个计算过程相当于从 $s_1$ 向左延伸和从 $s_m$ 向右延伸。最后的合并显然是一个卷积的形式。</p>
<p>3、$s$ 中不含有重复元素。</p>
<p>一个很神仙的点。考虑不含重复元素，可以转化成随便一个长度为 $n$ 的<strong>非</strong> $k-$好序列，含有多少 $m-$好序列的方案数，除以 $A_{k}^m$。因为显然每个序列都是等价的，所以可以如是转化。这个东西的 $dp$ 过程和 <code>2、</code> 中的差不多，也是「记 $f_{i,j}$ 表示已经考虑了 $i$ 个数，末尾存在一个 $j$ 连续段的序列排列数」——不同点在于这个 $dp$ 记录的是个数，那么再拿一个数组，和 $f$ 一样转移，但是每次都需要加上 $f$ 对应的方案数，表示计算多次。</p>
<p>然后就没有然后了。注意可能存在 $k&gt;n$ 的sb情况，判掉即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">410</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">30010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line">ll ans ;</span><br><span class="line">ll X[N] ;</span><br><span class="line">ll Y[N] ;</span><br><span class="line">ll I[N] ;</span><br><span class="line">ll fac[N] ;</span><br><span class="line">ll g[N][K] ;</span><br><span class="line">ll f[N][K] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> n, k, m ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll &amp;x, ll y)</span></span>&#123;</span><br><span class="line">    (x += y) %= P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(ll &amp;x, ll y)</span></span>&#123;</span><br><span class="line">    (x -= y) %= P ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, j = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!buc[base[i]]) now ++ ; buc[base[i]] ++ ;</span><br><span class="line">        <span class="keyword">while</span> (buc[base[j]] &gt; <span class="number">1</span>) -- buc[base[j ++]] ;</span><br><span class="line">        <span class="keyword">if</span> (i - j + <span class="number">1</span> == k &amp;&amp; now == k) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (buc[base[i]]) <span class="keyword">return</span> <span class="number">1</span> ; <span class="keyword">else</span> ++ buc[base[i]] ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dp1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p, q, j = <span class="number">0</span> ; j &lt; k ; ++ j)&#123;</span><br><span class="line">            p = f[i][j] * (k - j) % P ;</span><br><span class="line">            q = g[i][j] * (k - j) % P ;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; k)&#123;</span><br><span class="line">                add(f[i + <span class="number">1</span>][j + <span class="number">1</span>], p) ;</span><br><span class="line">                add(g[i + <span class="number">1</span>][j + <span class="number">1</span>], q) ;</span><br><span class="line">                dec(f[i + <span class="number">1</span>][j + <span class="number">2</span>], p) ;</span><br><span class="line">                dec(g[i + <span class="number">1</span>][j + <span class="number">2</span>], q) ;</span><br><span class="line">            &#125;</span><br><span class="line">            add(f[i + <span class="number">1</span>][<span class="number">1</span>], f[i][j]) ;</span><br><span class="line">            add(g[i + <span class="number">1</span>][<span class="number">1</span>], g[i][j]) ;</span><br><span class="line">            dec(f[i + <span class="number">1</span>][j + <span class="number">1</span>], f[i][j]) ;</span><br><span class="line">            dec(g[i + <span class="number">1</span>][j + <span class="number">1</span>], g[i][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; k ; ++ j)&#123;</span><br><span class="line">            add(g[i + <span class="number">1</span>][j], g[i + <span class="number">1</span>][j - <span class="number">1</span>]) ;</span><br><span class="line">            add(f[i + <span class="number">1</span>][j], f[i + <span class="number">1</span>][j - <span class="number">1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &lt; k ; ++ j)</span><br><span class="line">            add(f[i + <span class="number">1</span>][j], g[i + <span class="number">1</span>][j]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; k ; ++ i) add(ret, f[n][i]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp2</span><span class="params">(ll res[N], ll s[N][K], <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">if</span> (!mk)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!buc[base[i]]) buc[base[i]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> &#123; s[<span class="number">0</span>][i - <span class="number">1</span>] = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (!buc[base[i]]) buc[base[i]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> &#123; s[<span class="number">0</span>][m - i] = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t, j = <span class="number">1</span> ; j &lt; k ; ++ j)&#123;</span><br><span class="line">            t = s[i][j] * (k - j) % P ;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; k)&#123;</span><br><span class="line">                add(s[i + <span class="number">1</span>][j + <span class="number">1</span>], t) ;</span><br><span class="line">                dec(s[i + <span class="number">1</span>][j + <span class="number">2</span>], t) ;</span><br><span class="line">            &#125;</span><br><span class="line">            add(s[i + <span class="number">1</span>][<span class="number">1</span>], s[i][j]) ;</span><br><span class="line">            dec(s[i + <span class="number">1</span>][j + <span class="number">1</span>], s[i][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; k ; ++ j)&#123;</span><br><span class="line">            add(s[i + <span class="number">1</span>][j], s[i + <span class="number">1</span>][j - <span class="number">1</span>]) ;</span><br><span class="line">            add(res[i + <span class="number">1</span>], s[i + <span class="number">1</span>][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = I[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> mx = max(n, max(k, m)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mx + <span class="number">1</span> ; ++ i)</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * (ll)i % P ;</span><br><span class="line">    I[mx + <span class="number">1</span>] = expow(fac[mx + <span class="number">1</span>], P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mx ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        I[i] = (ll)(i + <span class="number">1</span>)* I[i + <span class="number">1</span>] % P ;</span><br><span class="line">    ans = expow(k, n - m) * (ll)(n - m + <span class="number">1</span>) % P ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (check()) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (check2())&#123; <span class="comment">//there is a same pair of number</span></span><br><span class="line">        X[<span class="number">0</span>] = Y[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        dp2(X, f, <span class="number">0</span>) ; dp2(Y, g, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n - m ; ++ i)</span><br><span class="line">            dec(ans, X[i] * Y[n - m - i] % P) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dec(ans, dp1() * I[k] % P * fac[k - m] % P) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>atcoder</category>
      </categories>
      <tags>
        <tag>思维题/计数</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】CF OTC2020 A~F Sol</title>
    <url>/2020/03/05/Ozon-Tech-Challenge-2020/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>碍于自身实力，只能整理到 $\rm F$ 了233.</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote>
<p>给定两个均不含相同数字的序列，分别重排之后使得 $\forall i,a_i+b_i$ 均不同。</p>
</blockquote>
<p>排序。排序的正确性在于令 $c_i=a_i+b_i$，$\forall i&gt;1,c_i&gt;c_{i-1}$ 保证了不同。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote>
<p>给定一个括号序列，求至少删除多少次使得原序列中不存在「好子序列」并输出删除方案，如果本身就没有「好子序列」则输出 $0$。</p>
<p>「好子序列」的定义是长度为 $2k$ 且 $1\sim k$ 都为 <code>(</code> ，$k+1\sim 2k$ 都是 <code>)</code> 的子序列。删除操作规定每次只能选择原序列中的一个「好子序列」并删除其中的全部元素。</p>
<p>$n\leq 5000$</p>
</blockquote>
<p>发现显然至少删除一次即可。那么只需要记录每个左括号和右括号的位置，找一个位置 $p$ 使得前面的左括号和右面的右括号一样多且最大。$0$ 的情况是存在某个 $p$ 使得 $p$ 前缀都是 <code>)</code> 并且 $p+1$ 后缀都是 <code>(</code> 。判断一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) l[++ l[<span class="number">0</span>]] = i, sum[i] = sum[i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) r[++ r[<span class="number">0</span>]] = i, sum[i] = sum[i - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (sum[i] == i &amp;&amp; sum[i] == sum[n]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = r[<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (l[L] &gt; r[R]) <span class="keyword">break</span> ; ++ ans;</span><br><span class="line">        stk[++ tp] = l[L], stk[++ tp] = r[R] ;</span><br><span class="line">        L ++ ; R -- ; <span class="keyword">if</span> (L &gt; l[<span class="number">0</span>] || !R) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stk + <span class="number">1</span>, stk + tp + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ans * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= ans * <span class="number">2</span> ; ++ i) <span class="built_in">cout</span> &lt;&lt; stk[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>给定序列 $a_i$，求 $\prod _{1\leq i&lt;j\leq n}|a_i-a_j|\bmod m$ 。</p>
<p>$1\leq n\leq 10^5,m\leq 1000$ 。</p>
</blockquote>
<p>妙妙题。发现直接做不容易并且 $m$ 很小，于是选择观察性质。考虑鸽笼原理，当 $n&gt;m$ 时，必有两项 $a_i,a_j$ 模 $m$ 同余。所以如果 $n&gt;m$ 答案就是 $0$，否则暴力即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            (ans *= (LL)<span class="built_in">abs</span>(base[i] - base[j])) %= m ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote>
<p>交互题。给定一个树，每次可以随便询问两个点 $p,q$ 的 $lca$ 。在询问至多 $\frac{n}{2}$ 次后找出树的根。</p>
<p>$1\leq n\leq 1000$</p>
</blockquote>
<p>考虑从何处入手。发现对于一棵无根树，最容易辨别的就是叶子。那么只需要每次找出两个当前 $\deg$ 为 $1$ 的点，询问 $lca$ 并删除即可。这样次数一定是 $\lfloor\frac{n}{2}\rfloor$。如果 $p,q$ 有一个点为根，那么存在一个是两一个的祖先，这时输出即可。</p>
<p><del>这还是第一次在CF写交互题233</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ctn ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt, n ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    head[u] = cnt ; ++ deg[v] ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v) ;</span><br><span class="line">        add(u, v) ; add(v, u) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (deg[i] == <span class="number">1</span>) q.push(i) ;</span><br><span class="line">    <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">int</span> y = q.front() ; q.pop() ; <span class="keyword">int</span> w ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">        <span class="comment">//cout.flush() ;</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w ;</span><br><span class="line">        <span class="keyword">if</span> (w == x || w == y)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; w &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">            <span class="built_in">cout</span>.flush() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x] ; i ; i = next(i))</span><br><span class="line">            <span class="keyword">if</span> ((-- deg[to(i)]) == <span class="number">1</span>) q.push(to(i)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[y] ; i ; i = next(i))</span><br><span class="line">            <span class="keyword">if</span> ((-- deg[to(i)]) == <span class="number">1</span>) q.push(to(i)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span> &lt;&lt; q.front() &lt;&lt; <span class="built_in">endl</span> ;<span class="comment">// cout.flush() ; return 0 ;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote>
<p>构造一个序列 $a$ 满足如下：</p>
<p>1、长度为 $n$ 。</p>
<p>2、$\forall i, 1\leq a_i\leq 10^9$ 。</p>
<p>3、$\forall i&gt;1,a_i&gt;a_{i-1}$。</p>
<p>4、满足 $i&lt;j&lt;k$ 且 $a_i+a_j=a_k$ 的三元组 $(i,j,k)$ 数量恰好为 $m$。</p>
<p>$n\leq 5000,m\leq 10^9$ 。</p>
</blockquote>
<p>比较自然的想法是从头开始填 $1,2,3\cdots$，因为这样容易填且满足条件。同时可以发现，这种构造方式是使得每个位置作为 $k$ 时，贡献三元组最多的方式：由于序列满足单调性，所以一定不存在前面的 $i,j$ 彼此有交。那么对于一个 $a_k=k$ 他可以贡献 $\lfloor \frac{k-1}{2}\rfloor$ 的答案。</p>
<p>考虑如果超出 $m$ 如何处理。假设当前答案超出了 $x$ 。对于一个 $k$ ，按照上述方式能够贡献 $\lfloor \frac{k-1}{2}\rfloor$ 的答案，那么如果想要只贡献 $\lfloor \frac{k-1}{2}\rfloor-x$ 的答案，就需要让其中的 $x$ 对 $(i,j)$ 无效。具体的，考虑令当前的 $k$ 变为 $k+2x$ ，那么考虑前 $k-1$ 个数里面最大的是 $k-1$ ，只能去匹配 $2x+1$，这样就会少掉 $2x$ 个可以用的数，答案变成了 $\lfloor\frac{k-1-2x}{2}\rfloor=\lfloor \frac{k-1}{2}\rfloor-x$ 。</p>
<p>那么补齐 $n$ 个数也很简单。只需要考虑如果当前填了的最大的数是 $j$ ，从 $10^9$ 向下按照 $2\cdot j$ 的步长递减即可。不难证明这样做是对的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        ans[i] = i ; cnt += (i - <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= m)&#123;</span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">1000000000</span> ;</span><br><span class="line">            ans[i] += <span class="number">2</span> * (cnt - m) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n ; j &gt; i ; -- j)</span><br><span class="line">                ans[j] = (s -= (ans[i] + <span class="number">1</span>)) ;</span><br><span class="line">            gf = <span class="number">1</span> ; <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gf)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><blockquote>
<p>给定 $n$ 个数。每次可以选择将一个数 $+1$ 或 $-1$ 。求至少多少次使得整个序列的 $\gcd&gt;1$ 。</p>
<p>$n\leq 10^5,a_i\leq 10^{12}$ 。</p>
</blockquote>
<p>首先有一个结论，就是至多需要 $O(\frac{n}{2})$ 次操作就可以使得整个序列的 $\gcd&gt;1$，因为永远可以把 $2$ 当做因子。那么就可以得出一个结论，至多只会有 $\frac{n}{2}$ 个数会被改掉，那么也就说明如果随机一个数的话，有 $\frac{1}{2}$ 的概率不会被改。所以可以将整个序列 <code>shuffle</code> 一下取前几十个check一下即可。</p>
<p>还有，cf的评测系统是windows，<code>rand()</code> 做种子的时候只能打乱前 $32767$ 项。所以需要 <code>mt19937</code> 做种子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000100</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> pr[M] ;</span><br><span class="line">LL base[N] ;</span><br><span class="line"><span class="keyword">bool</span> chk[M] ;</span><br><span class="line"><span class="built_in">set</span> &lt;LL&gt; facs ;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i]) pr[++ cnt] = i ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pr[j] * i &gt;= M) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (x % pr[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            facs.insert(pr[i]) ;</span><br><span class="line">            <span class="keyword">while</span> (!(x % pr[i])) x /= pr[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) facs.insert(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        ret += base[i] &gt;= x ? min(base[i] % x, - (base[i] % x) + x) : x - base[i] ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ret &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    sieve() ; ans = n ;</span><br><span class="line">    random_device seed ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="function">mt19937 <span class="title">gg</span><span class="params">(seed())</span></span>; shuffle(base + <span class="number">1</span>, base + n + <span class="number">1</span>, gg);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">30</span> &amp;&amp; i &lt;= n ; ++ i)</span><br><span class="line">        Ins(base[i]), Ins(base[i] + <span class="number">1</span>), Ins(base[i] - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (LL res : facs) ans = min(ans, calc(res)) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/找性质</tag>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>思维题/随机化</tag>
        <tag>交互题/微元撕裂法</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】ARC099 Sol</title>
    <url>/2020/03/04/ARC099/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从atcoder某天virtual的一场比赛。发现比起之前做过的场次，似乎 $\rm A$ 还是有点弱菜，$\rm B$ 还是有点奇怪，$\rm C$ 还是比较中规中矩<del>比较不会</del> ，$\rm D$ 还是不很会…</p>
<p>问题不大.jpg</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote>
<p>给定 $n,k$ ，一个 $1\sim n$ 的排列 $\{a_n\}$。每次选择一个长度为 $k$ 的区间 $[l,r]$，向下推平为 $\min_{i=l}^r\{a_i\}$ 。求最少多少次操作可以使得所有值相同。</p>
<p>$n\leq 100,000$ </p>
</blockquote>
<p>很多人写的比较麻烦。要去扫整个 $\{a_n\}$ 。然而这题 $n$ 是可以开到 $1e18$ 的。</p>
<p>考虑由于所有数不相同，所以最优决策一定是从最小的那个位置开始拓展。之后每次选择区间，必然是选择一个最多与之前那个区间相交为 $1$ 个元素的区间开始。所以最后答案就是 $1+\lceil\frac{n-k}{k-1}\rceil$。跟 $\{a_n\}$ 无关。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote>
<p>定义函数 $\rm S(x)$ 表示 $x$ 各个位上数字之和。求前 $k$ 个这样的 $n$：</p>
<script type="math/tex; mode=display">
\forall m>n,\frac{n}{\mathrm{S}(n)}\leq \frac{m}{\mathrm{S}(m)}</script><p>$k$ 的范围…$\geq 1$。</p>
</blockquote>
<p>首先这个是可以猜出一部分结论的，大概就是考虑如果数字里面 $9$ 比较多的话肯定会比较符合，因为这样 $\rm S$ 值就会显然更大。其次也是可以打表的。</p>
<p>但是这个题本质上不存在规律。所以以上两种方式可能会挂的很惨。</p>
<p>考虑一种可行的构造方式。首先知道，$1$ 一定是可行的。对于每个当前的 $x$ ，选择那个使得 $y&gt;x$ 且 $\frac{y}{\rm S(y)}$ 最小的 $y$ 来替代当前的 $x$ 。不难理解这样做是可行的。</p>
<p>那大概考虑如何去证明第一个性质，或者稍微形式化一点：</p>
<blockquote>
<p>假设 $y$ 是 $&gt;x$ 且 $\frac{y}{\rm S(y)}$ 最小的那个 $y$，且假设从高位到低位，$x$ 和 $y$ 第一次出现不同的地方是<strong>从低到高的</strong> 第 $p$ 位，那么会有 $y$ 的从低到高 $1\sim p$ 位均为 $9$ 。 </p>
</blockquote>
<p>证明时考虑如下：</p>
<p>1、对于 $1\sim p-1$ 位的证明是不难的。考虑假设 $y$ 不符合上述规则，那么设出一个 $y’$ ，其中 $1\sim p-1$ 均是 $9$ ，且 $y’$ 的第 $p$ 位是 $y$ 的第 $p$ 位 $-1$ 的数值。那么可以知道 $x\leq y’&lt;y$ 且 $\mathrm{S}(y’)\geq \mathrm S(y)$ 。这样的话 $\frac{y}{\mathrm S(y)}&gt;\frac{y’}{\mathrm S(y’)}$ 与 $y$ 的定义矛盾。所以 $1\sim p-1$ 均为 $9$。</p>
<p>2、再考虑第 $p$ 位。设 $y$ 的第 $p$ 位值为 $s$，设 $y’=y-10^{p-1}\cdot s$ ，那么有</p>
<script type="math/tex; mode=display">
\frac{y}{\mathrm S(y)}=\frac{y'+10^{p-1}s}{\mathrm S(y')+s}</script><p>那么考虑此时 $y’$ 不变，等式右边是一个凹函数(先不考虑怎么凹)，在 $s=9$ 或者 $s=0$ 时取得最值。根据定义可知此处应该选择 $s=9$ （因为 $y$ 的第 $p$ 位至少要比 $x$ 的第 $p$ 位大 $1$）</p>
<hr>
<p>综上，可知后缀必然是某些 $999…999$ 的形式。从个位数向上推就好了。复杂度在 $\Omega(n)\sim O(n\log n)$ 左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">s</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ; <span class="keyword">long</span> <span class="keyword">long</span> y = x ;</span><br><span class="line">    <span class="keyword">while</span> (x) ret += (x % <span class="number">10l</span>l), x /= <span class="number">10l</span>l ;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span> * y) / (<span class="number">1.0</span> * ret) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s(ans + base) &gt; s(ans + base * <span class="number">10l</span>l))</span><br><span class="line">                base *= <span class="number">10l</span>l ; <span class="keyword">else</span> <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += base ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>给定一张图。求将这张图分成两个完全子图后，最少会有多少条边的端点属于同一个完全子图。</p>
<p>$n\leq 700$</p>
</blockquote>
<p>一道比较妙的题。首先考虑建出补图来，那么发现，如果有两个点连通，就说明不能分在一个子图里面，恰好是二分图染色的流程。</p>
<p>之后考虑按补图的连通块 $dp$。注意到如果补图中连通块 $A$ 和 $B$ 不连通，说明原图中所有点都连通。所以根本不需要考虑连通块之间的连边。具体的，设状态 $f_{i,j}$ 表示考虑了前 $i$ 个连通块，是否存在二分图集合的某一部（左部or右部）大小是 $j$ 。根据前面的性质这就是个背包。所以 <code>bitset</code> 优化转移一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N * N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ctn ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> nienie ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> clr[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">bool</span> A[N][N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;N * N&gt; ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    to(++ ctn) = y ;</span><br><span class="line">    next(ctn) = head[x] ;</span><br><span class="line">    head[x] = ctn ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span> ; clr[x] = c ; cnt[c] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (!vis[to(k)]) dfs(to(k), c ^ <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (clr[to(k)] == c) <span class="keyword">return</span> nienie = <span class="number">1</span>, <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * (x - <span class="number">1</span>) + (n - x) * (n - x - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ans[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> u, v ; res = <span class="number">1000000000</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v) ;</span><br><span class="line">        A[u][v] = A[v][u] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!A[i][j] &amp;&amp; (i ^ j)) add(i, j) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])&#123;</span><br><span class="line">            cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] = <span class="number">0</span> ; dfs(i, <span class="number">0</span>) ;</span><br><span class="line">            ans = (ans &lt;&lt; cnt[<span class="number">0</span>]) | (ans &lt;&lt; cnt[<span class="number">1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nienie) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i]) res = min(res, calc(i)) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; res / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote>
<p>给定一个下标范围在 $[-\infty,\infty]$ 的数组。一开始指针在 $0$ 处。给定一段操作序列。求有多少个子序列的操作结果等价于整个序列的操作结果。操作有四种，左移/右移/某个位置$+1$/某个位置$-1$ 。</p>
<p>$1\leq n\leq 250,000$</p>
</blockquote>
<p>一拿到题首先考虑 $dp$ ，发现 $dp$ 不是很可做…</p>
<p>于是就发现，类似这种题目可以使用哈希。四种操作分别对应 $\times base^{-1}$、$\times base$、$+base$、$-base$ 。</p>
<p>考虑这样做如何去求某一段的哈希值。普通的求法原理如下：</p>
<p>对于每个 $p$ ，截止到 $p$ 的哈希值，如果将 $x$ 看做 $base$ 的一个等价，那么就是是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^ps_ix^{p-i}</script><p>考虑将上式记作 $o(p)$ 。则片段 $[l,r]$ 的哈希值可以如此得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&o(r)-o(l-1)\times x^{r-l+1}\\
=&\sum_{i=1}^rs_ix^{r-i}-x^{r-l+1}\sum_{i=1}^{l-1}s_ix^{l-i-1}\\
=&\sum_{i=1}^rs_ix^{r-i}-\sum_{i=1}^{l-1}s_ix^{r-i}\\
=&\sum_{i=1}^rs_ix^{r-i}-\sum_{i=1}^{l-1}s_ix^{r-i}\\
=&\sum_{i=l}^rs_ix^{r-i}\\
=&\sum_{i=1}^{t}s_ix^{t-i}\quad (t=r-l+1)
\end{aligned}</script><p>考虑如果整个串的哈希值为 $q$，那么需要统计的是 $o(r)-o(l-1)\cdot x^{r-l+1}=q$ 。考虑从前至后用 $map$ 完成这个过程。由于不知道右端点的信息，需要对原式进行变形，即：</p>
<script type="math/tex; mode=display">
\frac{q+o(r)}{x^r}=\frac{o(l-1)}{x^{l-1}}</script><p>这样就可以做到 $l,r$ 无关了。随便选前缀或者后缀统计就好了。</p>
<p>但是注意到本题有个额外限制，最后只需要结果相同而不需要指针位置相同。所以需要稍微处理一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;LL, LL&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL B1 = <span class="number">237l</span>l ;</span><br><span class="line"><span class="keyword">const</span> LL B2 = <span class="number">637l</span>l ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL P1 = <span class="number">998244353</span> ;</span><br><span class="line"><span class="keyword">const</span> LL P2 = <span class="number">1004535809</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line">LL I1, I2 ;</span><br><span class="line">LL g[N][<span class="number">2</span>] ;</span><br><span class="line">LL S[N], T[N] ;</span><br><span class="line"><span class="built_in">map</span> &lt;pll, LL&gt; buc ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL ret = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (ret *= a) %= p ;</span><br><span class="line">        (a *= a) %= p ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; (s + <span class="number">1</span>) ;</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = g[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1l</span>l ;</span><br><span class="line">    I1 = expow(B1, P1 - <span class="number">2</span>, P1) ;</span><br><span class="line">    I2 = expow(B2, P2 - <span class="number">2</span>, P2) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">            g[i][<span class="number">1</span>] = g[i - <span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">            S[i] = (S[i - <span class="number">1</span>] - g[i][<span class="number">0</span>] + P1) % P1 ;</span><br><span class="line">            T[i] = (T[i - <span class="number">1</span>] - g[i][<span class="number">1</span>] + P2) % P2 ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>] ;</span><br><span class="line">            g[i][<span class="number">1</span>] = g[i - <span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">            S[i] = (S[i - <span class="number">1</span>] + g[i][<span class="number">0</span>]) % P1 ;</span><br><span class="line">            T[i] = (T[i - <span class="number">1</span>] + g[i][<span class="number">1</span>]) % P2 ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'&lt;'</span>)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>] * I1 % P1 ;</span><br><span class="line">            g[i][<span class="number">1</span>] = g[i - <span class="number">1</span>][<span class="number">1</span>] * I2 % P2 ;</span><br><span class="line">            S[i] = S[i - <span class="number">1</span>] ; T[i] = T[i - <span class="number">1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>] * B1 % P1 ;</span><br><span class="line">            g[i][<span class="number">1</span>] = g[i - <span class="number">1</span>][<span class="number">1</span>] * B2 % P2 ;</span><br><span class="line">            S[i] = S[i - <span class="number">1</span>] ; T[i] = T[i - <span class="number">1</span>] ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ buc[mkp(S[i], T[i])] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ++ buc[mkp(<span class="number">0</span>, <span class="number">0</span>)] ; LL x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)&#123;</span><br><span class="line">        buc[mkp(S[i] , T[i])] -- ;</span><br><span class="line">        x = (S[i] + S[n] * g[i][<span class="number">0</span>] % P1) % P1 ;</span><br><span class="line">        y = (T[i] + T[n] * g[i][<span class="number">1</span>] % P2) % P2 ;</span><br><span class="line">        ans += buc[mkp(x, y)] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>atcoder</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>图论/二分图</tag>
        <tag>字符串/哈希</tag>
        <tag>动态规划/背包模型</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】CodeForces Round#625</title>
    <url>/2020/03/02/CFround625/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是赛时整理？但是赛时发挥的一点也不好…第二天早上一起来就A掉了赛时没A的两个题…</p>
<p>总结：还是太菜。</p>
<p>没整理1E和1F。顺序按照Div2的顺序写的——</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote>
<p>给定两个 $01$ 串。设给每个位置一个正整数权 $p_i$ ，权被算到贡献里当且仅当对应位置为 <code>true</code> 。要求第一个串的权和要严格大于第二串。构造这样的 $p_i$ ，求 $\min\{\max_{i=1}^n\{p_i\}\}$ ，或者输出不可能。</p>
</blockquote>
<p>签到题。感觉可能直接放代码比嘴巴更好用？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; b[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">cin</span> &gt;&gt; c[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt; b[i]) ++ t1 ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c[i] &lt; b[i]) ++ t2 ;</span><br><span class="line">    <span class="keyword">if</span> (!t2 || t1 == n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    t1 ++ ; <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span> * t1 / (<span class="number">1.0</span> * t2)) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><blockquote>
<p>给定一个序列 $\{a_n\}$ ，要求选出来一个下标序列 $\{s_m\} ~ s.t. \forall i &lt; n,s_{i+1}-s_{i}=a_{s_{i+1}}-a_{s_i}$。</p>
<p>最大化选出来的 $a_i$ 的数值和。</p>
<p>$\{a_n\}&gt;0$</p>
</blockquote>
<p>大概是和差分那种题差不多的思路。令 $b_i=a_i-i$ ，那么发现 $b_i$ 同样的位置产生同一组贡献。由于每个位置的 $a_i$ 都 $&gt;0$ ，所以拿一个桶记一下即可。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>给定一个小写字母串 $s$，对于一个位置 $c$，如果相邻位置有音序掐好比它小 $1$ 的字母就可以删。问最多删多少个。</p>
<p>$1\leq |s|\leq 100$</p>
</blockquote>
<p>nmd，这题真是十分sb。给了个 $|s|=100$ 的范围这是在坑鬼？于是我就写了个 <code>while(1)</code> 无限删除，感觉这个复杂度应该很对。但是一直 <code>WA on 11</code> ，期间编了编感觉很对…冷静了一会儿发现，<code>dcbcd</code> 这种就可以卡掉，只有从大到小删才是好的。所以就是个贪心。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> a[N] ;</span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line"><span class="keyword">int</span> pd[N] ;</span><br><span class="line"><span class="keyword">int</span> sd[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N] ;</span><br><span class="line"><span class="keyword">int</span> nxt[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="comment">//int f[N][N][27][27] ;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; (S + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        a[i] = S[i] - <span class="string">'a'</span> ; nxt[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        pre[i] = i - <span class="number">1</span>, nxt[i] = i + <span class="number">1</span> ;</span><br><span class="line">    a[<span class="number">0</span>] = a[n + <span class="number">1</span>] = <span class="number">23333333</span> ; nxt[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="string">'z'</span> ; c &gt;= <span class="string">'a'</span> ; -- c)&#123;</span><br><span class="line">        flag = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            flag = <span class="number">0</span> ;<span class="comment">// cout &lt;&lt; nxt[1] &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nxt[<span class="number">0</span>] ; i ; i = nxt[i])</span><br><span class="line">                <span class="keyword">if</span> (a[i] == c - <span class="string">'a'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[pre[i]] + <span class="number">1</span> == a[i] || a[nxt[i]] + <span class="number">1</span> == a[i])</span><br><span class="line">                        ans ++, flag = <span class="number">1</span>, pre[nxt[i]] = pre[i], nxt[pre[i]] = nxt[i] ;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">/*for (int i = 1 ; i &lt;= n ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">                if (!vis[i])&#123;</span></span><br><span class="line"><span class="comment">                    pd[i] = a[i] - a[pre[i]] ;</span></span><br><span class="line"><span class="comment">                    sd[i] = a[i] - a[nxt[i]] ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                else pd[i] = sd[i] = -1 ;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            int ret = 0 ;</span></span><br><span class="line"><span class="comment">            for (int i = 1 ; i &lt;= n ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">                //for (in i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; pre[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">                if (vis[i]) continue ;</span></span><br><span class="line"><span class="comment">                if (a[nxt[i]] != a[i])&#123;</span></span><br><span class="line"><span class="comment">                    for (int j = nxt[i] ; j ; j = nxt[j])</span></span><br><span class="line"><span class="comment">                        if (j &amp;&amp; pd[j] &lt;= 1 &amp;&amp; pd[j] &gt;= 0)</span></span><br><span class="line"><span class="comment">                            ++ ret, pre[nxt[j]] = pre[j], nxt[pre[j]] = nxt[j], vis[j] = 1 ; else break ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ans += ret ; //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">                if (ret) flag = 1 ; ret = 0 ;</span></span><br><span class="line"><span class="comment">                if (a[pre[i]] != a[i])&#123;</span></span><br><span class="line"><span class="comment">                    for (int j = pre[i] ; j ; j = pre[j])</span></span><br><span class="line"><span class="comment">                        if (j &amp;&amp; sd[j] &lt;= 1 &amp;&amp; sd[j] &gt;= 0)</span></span><br><span class="line"><span class="comment">                            ++ ret, pre[nxt[j]] = pre[j], nxt[pre[j]] = nxt[j], vis[j] = 1 ; else break ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                ans += ret ; //cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ret &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">                if (ret) flag = 1 ; ret = 0 ;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>弱智题。是真的没有一点意思的弱智题。甚至比不上A。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote>
<p>给定一系列有代价的装备，第一种提供 $x$ 值，第二种提供 $y$ 值。给出一些怪兽，如果怪兽的 $x_i$ 和 $y_i$ 都小于选定的 $x$ 和 $y$ ，那么会有 $z_i$ 的奖励。最大化收益。</p>
<p>$1\leq n\leq 2\times 10^5$ 。</p>
</blockquote>
<p>一个比较自然的想法是排序之后枚举一维坐标，然后去算另一维。然而另一维并不具备单调性。考虑对于一个确切的 $x$ ，如何选择一个最优的 $y$ 取到最大值。考虑快速查找一个 $y$ 的最优值，需要快速计算当前 $y$ 可以提供击败哪些怪兽的贡献。</p>
<p>考虑将询问按照 $x$ 排序，就转化和成了一个二维扫描线问题。考虑用线段树维护每个 $y$ 值处的最大值。枚举第一种装备，每次用双指针扫到当前的 $x_i$，提前用线段树进行 $y$ 坐标的后缀加计算贡献。最后答案就是所有 $y$ 的最大值减去使用当前 $x$ 的代价。</p>
<p>感觉现在语言越来越苍白无力，还是代码比较容易说明道理。</p>
<p>感觉自己没做过太多这种类似的题，可能见多了就是套路了吧233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowb lower_bound</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uppb upper_bound</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">1000000101</span> ;</span><br><span class="line"> </span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arm</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x ;</span><br><span class="line">    <span class="keyword">int</span> c ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> arm &amp; t)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> t.x == x ? t.c &gt; c : t.x &gt; x ; &#125;</span><br><span class="line">&#125;a[N], b[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">monster</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, v ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> monster &amp; t)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> t.y == y ? t.x &gt; x : t.y &gt; y ; &#125;</span><br><span class="line">&#125;base[N] ;</span><br><span class="line">LL s[N * <span class="number">3</span>] ;</span><br><span class="line">LL tag[N * <span class="number">3</span>] ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> _up(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    s[x] = max(s[x &lt;&lt; <span class="number">1</span>], s[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x])&#123;</span><br><span class="line">        s[x &lt;&lt; <span class="number">1</span>] += tag[x] ;</span><br><span class="line">        s[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[x] ;</span><br><span class="line">        tag[x &lt;&lt; <span class="number">1</span>] += tag[x] ;</span><br><span class="line">        tag[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[x] ;</span><br><span class="line">    &#125;</span><br><span class="line">    tag[x] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chkmax</span><span class="params">(LL&amp; a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    a = b &gt; a ? b : a ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) </span><br><span class="line">		<span class="keyword">return</span> chkmax(s[rt], v) ;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, v, p) ;</span><br><span class="line">    <span class="keyword">else</span> update (rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, v, p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        <span class="keyword">return</span> s[rt] += v, tag[rt] += v, <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, v, ul, ur) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, v, ul, ur) ;</span><br><span class="line">    _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">-63</span>, <span class="keyword">sizeof</span>(s)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].x, &amp;a[i].c) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;b[i].x, &amp;b[i].c) ;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + m + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;base[i].x, &amp;base[i].y, &amp;base[i].v) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + k + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) tmp[i] = a[i].x ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ; </span><br><span class="line">    len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - (tmp + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        base[i].x = uppb(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i].x) - tmp ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        a[i].x = lowb(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, a[i].x) - tmp ;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, len, - a[i].c, a[i].x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt;s[1]&lt;&lt;endl;//, cout &lt;&lt; base[i].y&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span> ; ans = - (S + S) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; b[i].x &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (now &lt;= k &amp;&amp; base[now].y &lt; b[i].x)</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, len, base[now].v, base[now].x, len), ++ now ;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; now &lt;&lt; endl, cout &lt;&lt; s[1] &lt;&lt; " ---------- " &lt;&lt; endl ;</span></span><br><span class="line">        ans = max(ans, s[<span class="number">1</span>] - b[i].c) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><blockquote>
<p>给定一个 $01$ 串。每次询问两个等长的子串，询问是否可以从一个变换到另一个。变换操作的定义是每次选定一个子段，让 $110\to 011$ 或者 $011\to110$ 。</p>
<p>$n,q\leq 2\times 10^5$</p>
</blockquote>
<p>很有趣的一道观察性质题。考虑对于一次变换之后，位于 $p$ 位置的 $0$ 会变到 $p-2$ 或者 $p+2$ ，也就是 <strong>前缀 $1$ 的奇偶性没有发生改变</strong>。所以实质上每次是在查询，对于两个串，是否有相同数量的 $0$ ，且对应位置的 $0$ 之前 $1$ 的数量的奇偶性是否相同。这一部分可以用哈希实现。哈希时按奇偶性分类哈希，即可保证区间哈希的正确性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> a[N] ;</span><br><span class="line"><span class="keyword">int</span> sum[N] ;</span><br><span class="line">LL base[N] ;</span><br><span class="line">LL S[N], T[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL Base = <span class="number">217l</span>l ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((a - b) % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p0 = p + L - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> q0 = q + L - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> e1 = p0 - sum[p0] ;</span><br><span class="line">    <span class="keyword">int</span> e2 = q0 - sum[q0] ;</span><br><span class="line">    <span class="keyword">int</span> s1 = p - <span class="number">1</span> - sum[p - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">int</span> s2 = q - <span class="number">1</span> - sum[q - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">if</span> (sum[p0] - sum[p - <span class="number">1</span>] != sum[q0] - sum[q - <span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> ((sum[p - <span class="number">1</span>] &amp; <span class="number">1</span>) ^ (sum[q - <span class="number">1</span>] &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">bool</span>)(sub(T[e1], T[s1] * base[e1 - s1] % P) == sub(S[e2], S[s2] * base[e2 - s2] % P)) ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">bool</span>)(sub(S[e1], S[s1] * base[e1 - s1] % P) == sub(S[e2], S[s2] * base[e2 - s2] % P)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> x, y, l ; base[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;a[i]), sum[i] = sum[i - <span class="number">1</span>] + a[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])&#123;</span><br><span class="line">            ++ len ; base[len] = (base[len - <span class="number">1</span>] * Base) % P ;</span><br><span class="line">            S[len] = (S[len - <span class="number">1</span>] * Base % P + (sum[i] &amp; <span class="number">1</span>)) % P ;</span><br><span class="line">            T[len] = (T[len - <span class="number">1</span>] * Base % P + ((sum[i] &amp; <span class="number">1</span>) ^ <span class="number">1</span>)) % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;l) ;</span><br><span class="line">        <span class="keyword">if</span> (check(x, y, l)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉这场CF办的就跟闹着玩一样.jpg</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/找性质</tag>
        <tag>贪心</tag>
        <tag>数据结构/线段树</tag>
        <tag>字符串/哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络流24题专题】4 · 最大流模型进阶</title>
    <url>/2020/02/29/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%C2%B7%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E5%9E%8B%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>包括以下稍微进阶一点的、可以用最大流解决的问题：</p>
<p><code>loj#6003 魔术球</code> 、 <code>loj#6005 最长递增子序列</code> 和 <code>loj#6015 星际转移</code>.</p>
<a id="more"></a>
<h1 id="魔术球问题"><a href="#魔术球问题" class="headerlink" title="魔术球问题"></a>魔术球问题</h1><blockquote>
<p>假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1, 2,3, . . .$ 的球。</p>
<p>(1) 每次只能在某根柱子的最上面放球。</p>
<p>(2) 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。</p>
<p>试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球.</p>
<p>$n\leq 55$</p>
</blockquote>
<p>考虑对于一组 $(i,j)$ ，如果 $i+j$ 是完全平方数，就由较小的那个向较大的那个连一条边。之后考虑本质上每根柱子上就是一个路径覆盖，所以持续加边，一直加到最小路径覆盖数 $&gt; $ 柱子数为止。</p>
<p>有一个很有意思的性质，就是网络流可以在线加边并且不用考虑之前的决策。</p>
<p>这题真nm是写到吐血。板子也改了一下如果不完全连通时的写法，需要特判每个点是否连通。这题神烦的是需要一遍一遍地清空，然后边的编号很容易就写错。</p>
<p>最后zay教育我只需要二分就可以了，这样每次就可以把全部的边都加进去，这样就可以瞎清空。我太dd了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h[N] ;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> gap[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> h &lt; now.h ; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue &lt;state&gt; p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ;</span><br><span class="line">    fw(cnt) = c ; fr(cnt) = a ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push(<span class="keyword">_t</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (h[to(k)] &gt;= n + <span class="number">1</span>)</span><br><span class="line">                h[to(k)] = h[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    h[_s] = <span class="number">100000000</span> ; h[<span class="keyword">_t</span>] = <span class="number">0</span> ; bfs() ;</span><br><span class="line">    <span class="keyword">if</span> (h[_s] &gt;= <span class="number">10000000</span>) <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ; <span class="keyword">else</span> h[_s] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[_s] ; ~k ; k = next(k))&#123;</span><br><span class="line">        extra[to(k)] += fw(k) ;</span><br><span class="line">        fw(k ^ <span class="number">1</span>) = fw(k), fw(k) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != <span class="keyword">_t</span> &amp;&amp; h[to(k)] &lt;= n)</span><br><span class="line">            vis[to(k)] = <span class="number">1</span>, p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt;= n + <span class="number">1</span>) gap[h[i]] ++ ;</span><br><span class="line">    <span class="keyword">while</span> (!p.empty())&#123;</span><br><span class="line">        state y = p.top() ;</span><br><span class="line">        <span class="keyword">int</span> minh = <span class="number">1000000000</span> ;</span><br><span class="line">        <span class="keyword">int</span> x = y.num ; p.pop() ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (h[x] == <span class="number">100000000</span>) <span class="keyword">break</span> ; vis[x] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">int</span> val = min(fw(k), extra[x]) ;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span> &amp;&amp; h[to(k)] + <span class="number">1</span> == h[x])&#123;</span><br><span class="line">                fw(k) -= val ;</span><br><span class="line">                extra[x] -= val ;</span><br><span class="line">                fw(k ^ <span class="number">1</span>) += val ;</span><br><span class="line">                extra[to(k)] += val ;</span><br><span class="line">                <span class="keyword">if</span> (to(k) == _s || to(k) == <span class="keyword">_t</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">                    p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!extra[x]) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (fw(k)) minh = min(minh, h[to(k)]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (extra[x] &amp;&amp; minh&lt;=n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (! -- gap[h[x]])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span> (i != _s &amp;&amp; i != <span class="keyword">_t</span> &amp;&amp; h[i] &gt; h[x] &amp;&amp; h[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">                        h[i] = n + <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            gap[h[x] = minh + <span class="number">1</span>] ++ ; p.push((state)&#123;h[x], x&#125;) ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x ; <span class="keyword">return</span> fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[p] ; ~k ; k = e[k].next)</span><br><span class="line">        <span class="keyword">if</span> (!fw(k) &amp;&amp; to(k) != <span class="number">2</span> &amp;&amp; !(to(k) &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, (to(k) - <span class="number">2</span>) / <span class="number">2</span>), output(to(k) - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    _s = <span class="number">1</span>, <span class="keyword">_t</span> = n = <span class="number">2</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    h[<span class="number">1</span>] = <span class="number">1</span>, h[<span class="number">2</span>] = <span class="number">0</span>, head[<span class="number">1</span>] = head[<span class="number">2</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">1</span> ; ; ++ res)&#123;</span><br><span class="line">        head[++ n] = <span class="number">-1</span> ;</span><br><span class="line">        h[n] = <span class="number">100000000</span> ;</span><br><span class="line">        add(<span class="number">1</span>, n, <span class="number">1</span>), add(n, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        head[++ n] = <span class="number">-1</span> ;</span><br><span class="line">        h[n] = <span class="number">100000000</span> ;</span><br><span class="line">        add(n, <span class="number">2</span>, <span class="number">1</span>), add(<span class="number">2</span>, n, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; res ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sqrt</span>(res + j) == (<span class="keyword">int</span>)(<span class="built_in">sqrt</span>(res + j)))</span><br><span class="line">                add(<span class="number">2</span> * j + <span class="number">1</span>, n, <span class="number">1</span>), add(n, <span class="number">2</span> * j + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            h[i] = <span class="number">100000000</span>, vis[i] = gap[i] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> ans = HLPP() ; <span class="keyword">if</span> (res - ans &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; "--------------------" &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res -- ; <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i) fa[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (fr(i) &gt; <span class="number">1</span> &amp;&amp; (fr(i) &amp; <span class="number">1</span>) &amp;&amp; !(to(i) &amp; <span class="number">1</span>)  &amp;&amp; to(i) != <span class="number">2</span> &amp;&amp; !fw(i))</span><br><span class="line">            fa[find((to(i) - <span class="number">2</span>) / <span class="number">2</span>)] = find(fa[(fr(i) - <span class="number">1</span>) / <span class="number">2</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (fa[i] == i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, i), output(i * <span class="number">2</span> + <span class="number">1</span>), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><blockquote>
<p>给定正整数序列 $x_1 \ldots, x_n$。</p>
<p>1、计算其最长不下降子序列的长度 $s$。</p>
<p>2、如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。</p>
<p>3、如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个<strong>不同的</strong>长度为 $s$ 的不下降子序列。</p>
<p>$n\leq 500$</p>
</blockquote>
<p>考虑第一问可以直接拿来跑一个 $n^2$ 的 $dp$ 。对于第二问，考虑网络流。对于每个数，有限制只能用 $1$ 次，且必须要保证每个 LIS 长度都为 $s$ 。所以如果单纯地拿每个 $i$ 与起点和终点连边，对于一组 $i&lt;j$ 且 $a_i&lt;a_j$ 且 $f_j=f_{i}+1$ 的 $(i,j)$ ，中间连流量为 $1$ 的边。</p>
<p>这样建图就很有问题：</p>
<p>1、考虑这样建图，加谁一个点的入度为 $d_1$，出度为 $d_2$ ，那么实质上它会被使用 $\min\{d_1,d_2\}$ 次。为了防止这种情况出现，所以把一个点拆成两个点，一个点用来接收入度，一个点用来接收出度，$i\to i’$ 连流量为 $1$ 的边。</p>
<p>2、同时，由于并不能很容易地确定一条流经过多少条边，所以不是很容易得到长度为 $s$ 的 LIS。所以考虑换一种建图方式。即只让 $f_i=s$ 的每个 $i$ 与 $\rm T$ 连边。这样就保证走出来的只会是长度为 $s$ 的 LIS。</p>
<p>那么第三问，考虑再加上 $s\stackrel{f = +\infty}{\longrightarrow}1,1\stackrel{f = +\infty}{\longrightarrow}1’$ 这种边。如果 $f_n=s$ 的话也类似处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    _s = <span class="number">2</span> * n + <span class="number">1</span>, <span class="keyword">_t</span> = <span class="number">2</span> * n + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], f[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[j] &lt;= base[i])</span><br><span class="line">                f[i] = max(f[i], f[j] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) res = max(res, f[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        add(i, i + n, <span class="number">1</span>), add(i + n, i, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == <span class="number">1</span>) add(<span class="number">2</span> * n + <span class="number">1</span>, i, <span class="number">1</span>), add(i, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (f[i] == res) add(i + n, <span class="number">2</span> * n + <span class="number">2</span>, <span class="number">1</span>), add(<span class="number">2</span> * n + <span class="number">2</span>, i + n, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (base[i] &lt;= base[j] &amp;&amp; f[i] + <span class="number">1</span> == f[j])</span><br><span class="line">                add(i + n, j, <span class="number">1</span>), add(j, i + n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">int</span> t = n ; n = <span class="number">2</span> * n + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        h[i] = <span class="number">100000000</span>, vis[i] = <span class="number">0</span>, gap[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> &lt;&lt; HLPP() &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">if</span> (f[t] == res)&#123;</span><br><span class="line">        add(t, <span class="keyword">_t</span>, <span class="number">100000000</span>), add(<span class="keyword">_t</span>, t, <span class="number">0</span>) ;</span><br><span class="line">        add(t, t + t, <span class="number">100000000</span>), add(t + t, t, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    add(_s, <span class="number">1</span>, <span class="number">100000000</span>), add(<span class="number">1</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">    add(<span class="number">1</span>, t + <span class="number">1</span>, <span class="number">100000000</span>), add(t + <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        h[i] = <span class="number">100000000</span>, vis[i] = <span class="number">0</span>, gap[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; HLPP() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="星际转移"><a href="#星际转移" class="headerlink" title="星际转移"></a>星际转移</h1><blockquote>
<p>现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而每艘太空船 $i$ 只可容纳 $p_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如：$\{1,3,4\}$ 表示该太空船将周期性地停靠太空站 134134134 …</p>
<p>每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站（或月球、地球）时上、下船。</p>
<p>初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。</p>
<p>$n,m\leq 50$ 。</p>
</blockquote>
<p>很神奇的分层图建图。考虑本身似乎是路径规划问题，但是具有以下性质：1、边的限制跟网络流图的限制几乎相同；2、每条边的代价都是 $1$  ; 3、数据范围 $n,m\leq 50$ ，可以知道如果有解，最多就是在 $0\to -1$ 路径上的每个点都停一遍，考虑每次停最多停 $n$ 个市场，那么最终答案的上界就是 $O(n^2)$ 。</p>
<p>根据以上性质，可以发现似乎枚举答案复杂度不高，可以转化为判定性问题。而网络流恰好可以解决判定性问题。所以考虑现在要做的就是如何建一个流图，使得跑出来的最大流就是当前能够运输的最多的人数。</p>
<p>发现决策对时间负责，那么每个时间，一个点可以走出去或者原地傻愣。根据状态最原始的表示方式，可知如果将每个时刻的每个点都单列一个状态，恰好可以转移。</p>
<p>所以建一个超级 $\rm S$ 连向每个 $t$ 的 $0$ ，建一个超级 $\rm T $ 让每个 $t$ 的 $-1$ 连向它，剩下的就按照转移来建就好了。</p>
<p>最后写了个 dinic…还是dinic好…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].from</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-9</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> dis[N] ;</span><br><span class="line"><span class="keyword">int</span> cur[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> from ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ;</span><br><span class="line">    fw(cnt) = c ; fr(cnt) = a ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        dis[i] = <span class="number">0</span>, cur[i] = head[i] ; dis[<span class="keyword">_t</span>] = <span class="number">0</span> ;</span><br><span class="line">    dis[_s] = <span class="number">1</span> ; q.push(_s) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (!dis[to(k)] &amp;&amp; fw(k) &gt; <span class="number">0</span>)</span><br><span class="line">                dis[to(k)] = dis[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">bool</span>)(dis[<span class="keyword">_t</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> aim, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, minf ;</span><br><span class="line">    <span class="keyword">if</span> (x == aim || !f) <span class="keyword">return</span> f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;k = cur[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[to(k)] != dis[x] + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (( minf = dfs(to(k), aim, min(f, fw(k))) ) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ret += minf, fw(k) -= minf, fw(k ^ <span class="number">1</span>) += minf ;</span><br><span class="line">            f -= minf ; <span class="keyword">if</span> (f &lt;= <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N] ;</span><br><span class="line"><span class="keyword">int</span> rn[N] ;</span><br><span class="line"><span class="keyword">int</span> ctn[N] ;</span><br><span class="line"><span class="keyword">int</span> ways[M][M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    _s = <span class="number">0</span> ; <span class="keyword">_t</span> = <span class="number">50000</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm &gt;&gt; s ; n = nn + <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i) fa[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; rn[i] &gt;&gt; ctn[i] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; ctn[i] ; ++ j)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ways[i][j] ; ways[i][j] += <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) fa[find(ways[i][j])] = find(ways[i][j - <span class="number">1</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (find(<span class="number">2</span>) != find(<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ; <span class="keyword">else</span> nn += <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">for</span> (res = <span class="number">0</span> ; ; ++ res)&#123;</span><br><span class="line">        add(<span class="keyword">_t</span>, res * nn + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        add(res * nn + <span class="number">2</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">        add(res * nn + <span class="number">1</span>, <span class="keyword">_t</span>, <span class="number">100000000</span>) ;</span><br><span class="line">        add(_s, res * nn + <span class="number">2</span>, <span class="number">100000000</span>) ;</span><br><span class="line">		<span class="keyword">if</span> (res)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">    	        add(res * nn + i, (res - <span class="number">1</span>) * nn + i, <span class="number">0</span>) ;</span><br><span class="line">    	        add((res - <span class="number">1</span>) * nn + i, res * nn + i, <span class="number">100000000</span>) ;</span><br><span class="line">    	    &#125;</span><br><span class="line">   	   		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)&#123;</span><br><span class="line">        	    <span class="keyword">int</span> r = ctn[i] ;</span><br><span class="line">        	    <span class="keyword">int</span> x = ways[i][res % r] ;</span><br><span class="line">        	    <span class="keyword">int</span> y = ways[i][(res - <span class="number">1</span>) % r] ;</span><br><span class="line">            	x += nn * res, y += nn * (res - <span class="number">1</span>) ;</span><br><span class="line">            	add(y, x, rn[i]), add(x, y, <span class="number">0</span>) ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        n = <span class="number">1</span> + (res + <span class="number">1</span>) * nn ;</span><br><span class="line">		<span class="keyword">while</span> (bfs()) ans += dfs(_s, <span class="keyword">_t</span>, <span class="number">100000000</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= s) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
        <tag>网络流/最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络流24题专题】3 · 最小割模型</title>
    <url>/2020/02/29/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%C2%B7%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是比较神奇的最小割模型。</p>
<p>涉及的题目有 <code>loj#6007 方格取数</code> 、 <code>loj#6001 太空飞行计划</code> 和 <code>loj#6226 骑士共存问题</code>。 </p>
<a id="more"></a>
<h1 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a>方格取数</h1><blockquote>
<p>有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。</p>
</blockquote>
<p>考虑对于方格中，取格子要求“没有公共边”，那么需要想到就是在进行一个黑白染色，不能选与之四连通的格子。所以最后本质上就是一个二分图，不能选有边相连的点，也就是对于每一条边 $\rm e$， 两个端点至多选一个。</p>
<p>然后就是很神奇的建图方式。考虑为了模拟出这个过程，建一个 $\rm S$ 连向所有黑点，流量即为点权；建一个 $\rm T$ 让所有白点连向它，流量同样是点权。中间根据连通性来连流量为 $+\infty$ 的边。这样建模之后，考虑最小割的本质含义。对于一条边 $(u,v)$ ，$\mathrm S\to u$ 和 $v\to\rm T$ 必定有一个需要被割，满足「两个端点至多选一个」的限制。那么如果用最小割的话，就可以将挑出来的边作为删去的点从总权中减去即为答案。</p>
<p>那么大概最小割的建模技巧，就是考虑用连通性这个东西来操作。比如什么「A和B至多选一个使得最终权值最大/小」，就可以用类似的技巧来建模。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; tot = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[++ tot]), Ans += base[tot],</span><br><span class="line">            (i + j &amp; <span class="number">1</span>) ? white[++ w] = tot : black[++ b] = tot, <span class="built_in">map</span>[i][j] = tot ;</span><br><span class="line">    S = <span class="number">1</span>, T = tot + <span class="number">1</span> ; <span class="comment">/*cout &lt;&lt; tot &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= w ; ++ i) Add(S, white[i], base[white[i]])  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= w ; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">ceil</span>((<span class="keyword">double</span>)(white[i] - <span class="number">1</span>) / M) ;</span><br><span class="line">        <span class="keyword">int</span> y = (white[i] - <span class="number">1</span>) - (x - <span class="number">1</span>) * M ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= <span class="number">4</span> ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = x + dx[j], ky = y + dy[j] ;</span><br><span class="line">            <span class="keyword">if</span> (kx &lt;= <span class="number">0</span> || ky &lt;= <span class="number">0</span> || ky &gt; M || kx &gt; N) <span class="keyword">continue</span> ;</span><br><span class="line">            Add(white[i], <span class="built_in">map</span>[kx][ky], INF) ;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= b ; ++ i) </span><br><span class="line">      Add(black[i], T, base[black[i]]) ; </span><br><span class="line">  	<span class="built_in">cout</span> &lt;&lt; Ans - HLPP() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="太空飞行计划"><a href="#太空飞行计划" class="headerlink" title="太空飞行计划"></a>太空飞行计划</h1><blockquote>
<p>现已确定了一个可供选择的实验集合 $E = \{ E_1, E_2, \cdots, E_m \}$，和进行这些实验需要使用的全部仪器的集合$ I = \{ I_1, I_2, \cdots, I_n \}$。实验 $E_j$ 需要用到的仪器是 $I$ 的子集 $R_j \subseteq I$。</p>
<p>配置仪器 $I_k$ 的费用为 $c_k$ 美元。实验 $E_j$ 的赞助商已同意为该实验结果支付 $p_j$ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。</p>
<p>对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。</p>
</blockquote>
<p>这个题的模型似乎是什么「最大权闭合子图」，大概就是如果选了某个点 $v$ ，那么 $v$ 指向的所有点都必须要选，最大化点权和。</p>
<p>考虑以这么一种方式建图。$\rm S$ 连向所有正权点，流量为该点的点权；所有负权点连向 $\rm T$ ，流量为该点的绝对值；原本图中的点按照原来的方式连上去，流量为 。跑一个最小割，然后正权点和-最小割就是最终的答案。</p>
<p>考虑这么做的正确性。对于最小割而言，既然是割，那么要么会去割一个正权点，代表正权点连接点集都不选；或者选择割掉与之相连的所有负权点，代表选了这个点集。那么这样两种决策的本质上都是在倒扣代价。所以是成立的。</p>
<p>这题还要憨憨地输出方案。这个地方有个神奇的输出方式，就是判断每个点是否与 $\rm S$ 相连，如果一个点指向的某个点不与 $\rm S$ 连通，那么他就它俩之间的边就是一条割边。</p>
<p>首先不难知道，这些边都是满流的。考虑之所以这些满流的边就是被割的边，原因是他们恰好是 $\rm S$ 到 $\rm T$ 每条路径的瓶颈边，所以他们的流量加起来就是最大流(因为即使有更多也不能流了)，那么也就是最小割。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum ;</span><br><span class="line"><span class="keyword">int</span> newline ;</span><br><span class="line"><span class="keyword">int</span> E[M * <span class="number">2</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span> ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        res = res * <span class="number">10</span> + ch - <span class="number">48</span> , ch = getchar() ;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'\n'</span>) newline = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y ;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm ;</span><br><span class="line">    _s = <span class="number">0</span>, <span class="keyword">_t</span> = <span class="number">100000</span> ; cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">        x = read() ;</span><br><span class="line">        sum += x ; newline = <span class="number">0</span> ;</span><br><span class="line">        add(_s, i, x) ; add(i, _s, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (!newline)&#123;</span><br><span class="line">            y = read() ;</span><br><span class="line">            add(y + nn, i, <span class="number">0</span>) ;</span><br><span class="line">            add(i, y + nn, <span class="number">100000000</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; y, add(i + nn, <span class="keyword">_t</span>, y), add(<span class="keyword">_t</span>, i + nn, <span class="number">0</span>) ;</span><br><span class="line">    n = nn + mm ; res = sum - dinic() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i) ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nn + <span class="number">1</span> ; i &lt;= mm + nn ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - nn) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>, res), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="骑士共存"><a href="#骑士共存" class="headerlink" title="骑士共存"></a>骑士共存</h1><blockquote>
<p>给定 $n^2$ 个方格的国际象棋棋盘和障碍标志，有障碍的不能放，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。</p>
<p>$n\leq 200$ </p>
</blockquote>
<p>大概这种题一开始被我当作一般图最大独立集做了…然后不会…</p>
<p>感觉在网格图搞事情，还是需要有种观察性质的直觉的。比如就会发现，骑士跳的每两步，都不会是同一个颜色。那么这就会转化成一个二分图问题，同种颜色之间没有边相连，有两种颜色，符合二分图的限制。所以最后只需要求一发二分图最大独立集即可。</p>
<p>考虑把原二分图转为流图，中间的边流量为 inf ，其余为 1 。这个网络的最小割满足，对于中间每一条边，两端的点必定选择了一个，否则 S 与 T 仍连通。故最小割对应最小点覆盖。而最小点覆盖与最大独立集互为对偶问题，所以算一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> x, y, kx, ky ;</span><br><span class="line">    _s = <span class="number">0</span>, <span class="keyword">_t</span> = <span class="number">60001</span>, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y, mark[x][y] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span> ; x &lt;= n ; ++ x)</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="number">1</span> ; y &lt;= n ; ++ y)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[x][y]) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> ((x + y) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">7</span> ; ++ k)&#123;</span><br><span class="line">                    kx = x + dx[k] ;</span><br><span class="line">                    ky = y + dy[k] ;</span><br><span class="line">                    <span class="keyword">if</span> (mark[kx][ky]) <span class="keyword">continue</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span> || ky &gt; n || kx &gt; n) <span class="keyword">continue</span> ;</span><br><span class="line">                    add(kx * (n + <span class="number">1</span>) + ky, x * (n + <span class="number">1</span>) + y, <span class="number">0</span>) ;</span><br><span class="line">                    add(x * (n + <span class="number">1</span>) + y, kx * (n + <span class="number">1</span>) + ky, <span class="number">100000000</span>) ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">                add(x * (n + <span class="number">1</span>) + y, _s, <span class="number">0</span>) ;</span><br><span class="line">                add(_s, x * (n + <span class="number">1</span>) + y, <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(<span class="keyword">_t</span>, x * (n + <span class="number">1</span>) + y, <span class="number">0</span>) ;</span><br><span class="line">                add(x * (n + <span class="number">1</span>) + y, <span class="keyword">_t</span>, <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> t = n ; n = (n + <span class="number">1</span>) * (n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t * t - m - dinic() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方大概需要注意，两个点之间不要连双向的边。这样最小割就会错，因为最大流的意义不对了。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
        <tag>网络流/最大流</tag>
        <tag>网络流/最小割</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络流24题专题】2 · 较简单的最大流</title>
    <url>/2020/02/28/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%982%C2%B7%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>包括以下较为简单的可以用最大流解决的问题：</p>
<p><code>loj#6000 搭配飞行员</code>、<code>loj#6006 试题库</code>、 <code>loj#6004 圆桌聚餐</code> 和 <code>loj#6002 最小路径覆盖</code> 。</p>
<a id="more"></a>
<h1 id="搭配飞行员"><a href="#搭配飞行员" class="headerlink" title="搭配飞行员"></a>搭配飞行员</h1><blockquote>
<p>飞行大队有若干个来自各地的驾驶员，专门驾驶一种型号的飞机，这种飞机每架有两个驾驶员，需一个正驾驶员和一个副驾驶员。由于种种原因，例如相互配合的问题，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。</p>
<p>因为驾驶工作分工严格，两个正驾驶员或两个副驾驶员都不能同机飞行。</p>
</blockquote>
<p>这显而易见的就是一个二分图匹配的问题。考虑 $\rm S$ 向左部每个点连 $f=1$ 的边，右部的向 $\rm T$ 连 $f=1$ 的边。考虑一组匹配会贡献 $1$ 的流量，且每个点只有 $1$ 的原始流保证了只可使用一次，所以不难证明是但俺就是最大流。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;  </span><br><span class="line">	fill(head, head + N + <span class="number">30</span>, <span class="number">-1</span>); S = <span class="number">0</span>, T = N + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B)  add(A, B, <span class="number">23333</span>), add(B, A, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M ; i ++) add(S, i, <span class="number">1</span>), add(i, S, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span>(i = M + <span class="number">1</span>; i &lt;= N ; i ++) add(i, T, <span class="number">1</span>), add(T, i, <span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Dinic() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题库"><a href="#试题库" class="headerlink" title="试题库"></a>试题库</h1><blockquote>
<p>假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。</p>
</blockquote>
<p>很水的建模，$\rm S$ 向每个题连 $f=1$ 的边表示只能用一次，每个题向对应的类型连边，每个类型向 $\rm T$ 连 $f=need_x$ 的边。然后输出方案就只需要看一下每个类型连的边有谁 $f$ 被流成 $0$ 了即可。</p>
<p>很久之前的 Dinic 代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; K &gt;&gt; N, T = N + K + <span class="number">1</span> ;</span><br><span class="line">	cnt = <span class="number">-1</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, <span class="number">1</span>) ; L1 = cnt + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + K ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), w1 += x, Add(i, T, x) ; </span><br><span class="line">	R1 = cnt ; L2 = R1 + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x) ; </span><br><span class="line">		<span class="keyword">while</span> (x --) <span class="built_in">cin</span> &gt;&gt; y, Add(i, N + y, <span class="number">1</span>) ; </span><br><span class="line">	&#125; R2 = cnt ;</span><br><span class="line">	<span class="keyword">while</span>(BFS())&#123; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) cur[i] = head[i] ;</span><br><span class="line">		w += dfs(S, T, Inf) ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (w != w1) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>), <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = L2 ; i &lt; R2 ; i += <span class="number">2</span>) </span><br><span class="line">    <span class="keyword">if</span> (!E[i].f) Ans[to(i) - N].push_back(E[i].fr) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i, <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>) </span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span>, j = <span class="number">0</span> ; j &lt; Ans[i].size() ; ++ j) <span class="built_in">cout</span> &lt;&lt; Ans[i][j] &lt;&lt; <span class="string">" "</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="圆桌聚餐"><a href="#圆桌聚餐" class="headerlink" title="圆桌聚餐"></a>圆桌聚餐</h1><blockquote>
<p>假设有来自 $n$ 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 $r_i$。会议餐厅共有 $m$ 张餐桌，每张餐桌可容纳 $c_i$ 个代表就餐。</p>
<p>为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。</p>
</blockquote>
<p>发现是一个特殊的匹配问题，考虑从 $\rm S$ 到每个单位连 $f=r_i$ 的边，每个桌子向 $\rm T$ 连一条 $f=c_i$ 的边，同时每个单位和每张桌子之间连 $f=1$ 的边。这样就可以控制每个单位至多一个在某个餐桌。同样，如果限制同一张餐桌不能做超过 $k$ 个同一单位的人，只需要把 $f$ 从 $1$ 改成 $k$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fw(k) e[k].flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) e[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> h[N] ;</span><br><span class="line"><span class="keyword">int</span> gap[N] ;</span><br><span class="line"><span class="keyword">int</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> _s, <span class="keyword">_t</span> ;</span><br><span class="line"><span class="keyword">int</span> A[M][M] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> extra[N] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ed</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> flow ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;e[N * <span class="number">2</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now)</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">return</span> h &lt; now.h ; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line">priority_queue &lt;state&gt; p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = b ; fw(cnt) = c ;</span><br><span class="line">    next(cnt) = head[a] ; head[a] = cnt ;</span><br><span class="line">    <span class="keyword">return</span> cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push(<span class="keyword">_t</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (h[to(k)] &gt;= n + <span class="number">1</span>)</span><br><span class="line">                h[to(k)] = h[x] + <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    h[<span class="keyword">_t</span>] = <span class="number">0</span> ; bfs() ; h[_s] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[_s] ; ~k ; k = next(k))&#123;</span><br><span class="line">        extra[to(k)] += fw(k) ;</span><br><span class="line">        fw(k ^ <span class="number">1</span>) = fw(k), fw(k) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != <span class="keyword">_t</span>) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">            p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (h[i] &lt;= n + <span class="number">1</span>) gap[h[i]] ++ ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; h[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">while</span> (!p.empty())&#123;</span><br><span class="line">        state y = p.top() ;</span><br><span class="line">        <span class="keyword">int</span> minh = <span class="number">1000000000</span> ;</span><br><span class="line">        <span class="keyword">int</span> x = y.num ; vis[x] = <span class="number">0</span> ; p.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; ~k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">int</span> val = min(fw(k), extra[x]) ;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; <span class="number">0</span> &amp;&amp; h[to(k)] + <span class="number">1</span> == h[x])&#123;</span><br><span class="line">                fw(k) -= val ;</span><br><span class="line">                extra[x] -= val ;</span><br><span class="line">                fw(k ^ <span class="number">1</span>) += val ;</span><br><span class="line">                extra[to(k)] += val ;</span><br><span class="line">                <span class="keyword">if</span> (to(k) == _s || to(k) == <span class="keyword">_t</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>,</span><br><span class="line">                    p.push((state)&#123;h[to(k)], to(k)&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!extra[x]) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (fw(k)) minh = min(minh, h[to(k)]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (extra[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (! -- gap[h[x]])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span> (i != _s &amp;&amp; i != <span class="keyword">_t</span> &amp;&amp; h[i] &gt; h[x] &amp;&amp; h[i] &lt; n + <span class="number">1</span>)</span><br><span class="line">                        gap[h[i]] --, h[i] = n + <span class="number">1</span>, gap[h[i]] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            gap[h[x] = minh + <span class="number">1</span>] ++ ; p.push((state)&#123;h[x], x&#125;) ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> extra[<span class="keyword">_t</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        head[i] = <span class="number">-1</span>, h[i] = <span class="number">1000000000</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nn, mm ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; nn &gt;&gt; mm ;</span><br><span class="line">    n = nn + mm + <span class="number">2</span> ;</span><br><span class="line">    _s = <span class="number">1</span>, <span class="keyword">_t</span> = n ; Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w, res += w,</span><br><span class="line">        add(_s, i + <span class="number">1</span>, w), add(i + <span class="number">1</span>, _s, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= mm ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w, add(i + nn + <span class="number">1</span>, <span class="keyword">_t</span>, w), add(<span class="keyword">_t</span>, i + nn + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= mm ; ++ j)</span><br><span class="line">            A[i][j] = add(i + <span class="number">1</span>, j + nn + <span class="number">1</span>, <span class="number">1</span>), add(j + nn + <span class="number">1</span>, i + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (HLPP() &lt; res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"1"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= nn ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= mm ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (fw(A[i][j]) == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小路径覆盖问题"><a href="#最小路径覆盖问题" class="headerlink" title="最小路径覆盖问题"></a>最小路径覆盖问题</h1><blockquote>
<p>给定有向图 $\rm G=\{V,E\}$。设 $\rm P$ 是 $\rm G$ 的一个简单路（顶点不相交）的集合。如果 $\rm V$ 中每个顶点恰好在 $\rm P$ 的一条路上，则称 $\rm P$ 是 $\rm G$ 的一个路径覆盖。 $\rm P$ 中路径可以从 $\rm V$ 的任何一个顶点开始，长度也是任意的，特别地，可以为 $0$。 的最小路径覆盖是 $\rm G$ 的所含路径条数最少的路径覆盖。</p>
</blockquote>
<p>嗯，这道题大概是教了一下怎么拆点。考虑对于每个点 $v$，新建一个替身点 $v’$ 。原图中的路径 $(u,v)$ 变换为 $(u,v’)$ ，然后 $\rm S$ 向所有 $v$ 连边，所有 $v’$ 向 $\rm T$ 连边。思考这么做本质上是在求一个匹配，最后没有匹配的到左部的一个有部点可以看做是一条路径的结尾。那么考虑这样跑完一组匹配之后，所有没有匹配上的点都是一条路径的结尾，也就是路径的数量。所以跑一个最大流，就可以得到最少的路径数量，也就是最小路径匹配。</p>
<p>这代码还是上古时期拿 dinic 写的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, S = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    Add(S, i, <span class="number">1</span>), Add(i + N, T, <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B + N, <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">while</span> (BFS()) &#123; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) cur[i] = head[i] ; </span><br><span class="line">    Ans += dfs(S, T, Inf) ; </span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = i ; </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (fr(i) &gt;= <span class="number">1</span> &amp;&amp; fr(i) &lt;= N &amp;&amp; to(i) &lt; T &amp;&amp; to(i) &gt; N &amp;&amp; !E[i].f) </span><br><span class="line">			fa[find(to(i) - N)] = find(fa[fr(i)]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    <span class="keyword">if</span> (fa[i] == i) begin_output(i), <span class="built_in">puts</span>(<span class="string">""</span>) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; N - Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么不难看出建虚点这个操作的目的，就是限制每个点的经过次数。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
        <tag>网络流/最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[ARC066]C/D/E Sol</title>
    <url>/2020/02/26/ARC066C-E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是正好做到了这一场的F，就顺便把前三个题给做了。</p>
<p>嗯，感觉思维能力还是很重要的。所以不能再这么沉沦了啊。</p>
<a id="more"></a>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>有编号为 $1\sim N$ 号的 $N$ 个人，给你第 $i$ 个人的「自己的左排列的人数和自己的右排列的人数的差的绝对值」$A_i$。 请根据他们的报告，求出原来的排列方法有几种。对 $10^9+7$ 取模 。</p>
<p>$A_i\leq 10^9,N\leq 10^5$</p>
</blockquote>
<p>或许可以根据样例猜出来，大概是一点性质吧，比如什么数值必须对称分布。那么想到这一点，再深入想一下就可以发现对于每个 $n$ 而言，他们的 $A_i$ 是固定的。所以直接生成这个标准答案序列，然后把给出的 $A$ 排一遍序，比较是否相同即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        yes[<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; i += <span class="number">2</span>)</span><br><span class="line">            yes[i] = yes[i + <span class="number">1</span>] = <span class="number">2</span> * (++ cnt) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (base[i] != yes[i]) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        yes[<span class="number">1</span>] = yes[<span class="number">2</span>] = ++ cnt ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span> ; i &lt;= n ; i += <span class="number">2</span>)</span><br><span class="line">            yes[i] = yes[i + <span class="number">1</span>] = (cnt += <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (base[i] != yes[i]) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, expow(<span class="number">2</span>, n / <span class="number">2</span>)), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><blockquote>
<p>求出整数对 $u$ 和 $v$ $(0≤u,v≤N)$ 的数目，使得存在两个非负整数 $a$ 和 $b$ 满足 $a xor b = u$ 和 $a + b= v$.</p>
<p>要求对答案取模 $10^9 + 7$ 。$N\leq 10^{18}$。</p>
</blockquote>
<p>这个题好像有一堆十分有趣的做法…但是碍于智商并不是很想去学qaq，就放个链接吧 <a href="https://qiita.com/259_Momone/items/86e90d17e4efe3b22433" target="_blank" rel="noopener">戳</a> 。</p>
<p>然后自己就对着一个神奇的做法编了一下原理。<del>发现自己果然是马后炮选手</del> 。</p>
<p>考虑 </p>
<script type="math/tex; mode=display">
a+b=((a~\mathrm{and}~b)<<1)+(a~\mathrm{xor}~b)</script><p>这个式子的意义在于，后半部分是因为异或运算是二进制下不进位的加法，前半部分则是在描述二进制下的进位。反正无论怎么样，我们可以轻松得到 $a+b\geq  a~\mathrm{xor}~b$ 这样的结论。</p>
<p>那么如果由于 $u\leq v$，所以如果 $v$ 不越界那么 $u$ 一定不越界。于是考虑按 $v$ 进行 $dp$。具体的，考虑状态 $f_{i,j}$ 表示考虑了 $a$ 和 $b$ 二进制下的前 $i$ 位，当前 $v=a+b=j$ 的方案数。</p>
<p>考虑如何转移。对于 $a$ 和 $b$ 而言，第 $i$ 位有三种情况，$(0,0),(0,1),(1,1)$ 。那么也就是假设原来的和为 $j’$，和当前的和 $j$ 可能有以下关系：</p>
<p>1、$2\cdot (j’+1)=j$，对应着都补一位 $1$。</p>
<p>2、$2\cdot j’=j$，对应着都补一位 $0$ 。</p>
<p>3、$j’+ (j’ + 1)=j$，对应着一个补 $1$ 一个补 $0$ 。</p>
<p>那么也就是</p>
<script type="math/tex; mode=display">
f_{i,j}=f_{i-1,\lfloor\frac{j}{2}\rfloor}+f_{i-1,\lfloor\frac{(j-1)}{2}\rfloor}+f_{i-1,\lfloor\frac{(j-2)}{2}\rfloor}</script><p>发现本质上，第一维状态随着第二维递减，且都是 $\Delta(\log)$ 级别，并且每次计算，必定存在三项中有两项是相等的，所以可知最后状态数一定介于 $\Omega(2\log N)\sim O(\log N)$ 之间，可以通过本题。</p>
<p>然后第一维就可以直接压掉了。</p>
<p>不过话说回来，关于这个状态数，我还是不知道该怎么算，最终还是打表打出来的这么一个界，大概是在 $2^k-1$ 时达到下界，$2^k$ 时达到上界。想了想这么分布似乎很合理，但是还是不知道为啥。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">f</span><span class="params">(<span class="keyword">int</span> p, LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m.count(x)) <span class="keyword">return</span> m[x] ; <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> m[x] = <span class="number">1</span> ; <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> m[x] = <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">return</span> m[x] = ((f(p - <span class="number">1</span>, x / <span class="number">2</span>) + f(p - <span class="number">1</span>, (x - <span class="number">1</span>) / <span class="number">2</span>)) % P + f(p - <span class="number">1</span>, (x - <span class="number">2</span>) / <span class="number">2</span>)) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(log2(n) + <span class="number">1</span>, n) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><blockquote>
<p>给你一个只包含 $’+’$ 、$’-‘$、正整数的式子，你需要在式子中添加一些括号，使运算结果最大，输出最大的结果。</p>
<p>$n\leq 10^5,a_i\leq 10^9$ 。 </p>
</blockquote>
<p>大概是个观察性质题。首先可以知道，加号后面不会右括号，或者说可以被忽略掉；其次，最多有两层括号嵌套，多了没有意义，因为比如 $-((a-b)-(a-(a-b)-b))$ 这个就可以写成 $-((a-b)-(a-a)-(b-b))$ 的形式。</p>
<p>考虑 $dp$ 实现，状态大概设计为 $f_{i,j}$ 表示考虑了前 $i$ 个数，一共有 $j$ 个左括号没有闭合的最大结果。可以知道第二维只会是 $0,1,2$ 。思考如何转移，大概就是分类讨论左括号数量。一开始带符号地读入 $x$ ，那么可知可以先赋初值： $f_{i,0}=x,f_{i,1}=-x,f_{i,2}=x$ 这样。然后考虑转移。发现我们可以通过加一个右括号使得未匹配的左括号数量减少，那么也就是 $f_{i,0}$ 可以加上 $\max\{f_{i-1,0},f_{i-1,1},f_{i-1,2}\}$ ，$f_{i,1}$ 可以加上 $\max\{f_{i-1,1},f_{i-1,2}\}$ ， $f_{i,2}$ 就只能原地转移。然后就是考虑，如果当前的 $x &lt;0$ ，也就是读进来一个符号，那么可以考虑放一个左括号，所以需要 <code>chkmax</code> 一下 <code>(f[i][2],f[i][1]),(f[i][1],f[i][0])</code> 。 </p>
<p>注意最后要输出 $\max\{f_{i-1,0},f_{i-1,1},f_{i-1,2}\}$ ，原因是根据状态的定义，我们没有考虑在第 $n$ 个数最后添上右括号的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; LL x ;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = f[<span class="number">0</span>][<span class="number">2</span>] = -(<span class="number">1l</span>l &lt;&lt; <span class="number">52</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        x = qr() ;</span><br><span class="line">        f[i][<span class="number">0</span>] = x ;</span><br><span class="line">        f[i][<span class="number">2</span>] = x ;</span><br><span class="line">        f[i][<span class="number">1</span>] = -x ;</span><br><span class="line">        f[i][<span class="number">2</span>] += f[i - <span class="number">1</span>][<span class="number">2</span>] ;</span><br><span class="line">        f[i][<span class="number">1</span>] += max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]) ;</span><br><span class="line">        f[i][<span class="number">0</span>] += max(f[i - <span class="number">1</span>][<span class="number">0</span>], max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>])) ;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            f[i][<span class="number">2</span>] = max(f[i][<span class="number">2</span>], f[i][<span class="number">1</span>]) ;</span><br><span class="line">            f[i][<span class="number">1</span>] = max(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(f[n][<span class="number">1</span>], max(f[n][<span class="number">0</span>], f[n][<span class="number">2</span>])) &lt;&lt; <span class="built_in">endl</span>  ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>思路题还是要自己先认真想，不然真的做了效果不大。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>atcoder</category>
      </categories>
  </entry>
  <entry>
    <title>【题解】[AGC012E]Camel and Oases</title>
    <url>/2020/02/25/AGC012E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定 $n$ 个绿洲，第 $i$ 个绿洲的坐标为 $x_i$，保证 $-10^{9}\le x_1&lt;x_2…&lt;x_n\le 10^9$</p>
<p>现在有一个人在沙漠中进行旅行，他初始的背包的水容积为 $V$ 升，同时他初始拥有 $V$ 升水，每次到达一个绿洲时，他拥有的水的量将自动重置为容积上限。他现在可以选择两个操作来进行旅行：</p>
<ol>
<li><p>走路，行走距离为 $d$ 时，需要消耗 $d$ 升水。清注意，任意时刻你拥有的水的数量不能为负数。</p>
</li>
<li><p>跳跃，令 $v$ 为你当前拥有的水量，若 $v&gt;0$，则你可以跳跃至任意一个绿洲，然后重置容积上界和所拥有的水量为 $v/2$ （四舍五入取整）。</p>
</li>
</ol>
<p>对于每一个 $i$ 满足 $1\le i\le n$，你需要求当你在第 $i$ 个绿洲作为起点时，你能否依次遍历其他所有绿洲。如果可以，输出 <code>Possible</code>，否则输出 <code>Impossible</code>。</p>
<p>$1\leq n,v\leq 2\times10^5$。</p>
</blockquote>
<p>神仙状态设计题orz</p>
<a id="more"></a>
<p>定义 $G$ 为全集，具体定义后文详谈。</p>
<p>首先考虑一点，就是本质上最多有 $\log V$ 种容积，可以把这个看做 $\log V$ 层，每层都有 $n$ 个点。定义层与层之间的方向「从上至下」代表容积不断变小，同上从上至下给每一层一个递增的编号。考虑对于每一层，可以把所有能够互相到达的连通块缩成几条线段，这样每层就是几条线段了。那么题目要求的就是，在限制第一层选某个线段时，每层至多选一个线段，是否可以讲整个 $[1,n]$ 覆盖。</p>
<p>考虑首先预处理出来 $L[s][1\sim n]$ 和 $R[s][1\sim n]$ ，分别表示在第 $s$ 层内，某个点所在线段的左端点和右端点。然后考虑预处理出这么两个状态：$expanL_t$ 和 $expanR_t$ ，表示只考虑集合 $t$ 内的那几层，最多从 $1$ 向右扩展至什么地方和最多从 $n$ 向左扩展到什么地方。考虑先把所有包含第一层的集合忽略，那么存在转移：</p>
<script type="math/tex; mode=display">
expanL_t=\max_{s\in t}\{R[t][expanL_{t-\{s\}} +1] \}\\
expanR_t=\min_{s\in t}\{L[t][expanR_{t-\{s\}} -1] \}\\</script><p>这个转移十分神奇。以 $expanL$ 的转移为例，本质上对于一个集合 $t-\{s\}$，为了求出连续块，应该去枚举第  $s$ 层内第一个不包含在 $expanL_{t-\{s\}}$ 内的线段，然后用这个线段是右端点来更新，所以或许需要一个二分。但是其实根本不需要，直接可以用上面推出来的 $L[s][1\sim n]$ 和 $R[s][1\sim n]$ 进行转移，还是很巧妙的。</p>
<p>最后就可以枚举每条线段，去找是否存在一个不包含第一层的状态 $t$ ， $expanL_t$ 覆盖了 $1\sim l_t$ ，同时 $expanR_{G-t}$ 覆盖了 $r_{G-t}\sim n$ ，那么如果这个线段的左右端点 $l,r$ 分别满足 $l-1\leq l_t$ 和 $r+1\geq r_{G-t}$，那么这个线段内部的点都是合法的。</p>
<p>最终复杂度 $O(\max\{(n+v)\log v, n\log n\})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">40</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1001000001</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep ;</span><br><span class="line"><span class="keyword">int</span> maxn ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> L[M][N] ;</span><br><span class="line"><span class="keyword">int</span> R[M][N] ;</span><br><span class="line"><span class="keyword">int</span> farfrl[N] ;</span><br><span class="line"><span class="keyword">int</span> farfrr[N] ;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; rg[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m ; j &gt;= <span class="number">0</span> ; j &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        R[++ dep][n + <span class="number">1</span>] = n + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            L[dep][i] = (base[i] - base[i - <span class="number">1</span>] &gt; j) ? i : L[dep][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">            R[dep][i] = (base[i + <span class="number">1</span>] - base[i] &gt; j) ? i : R[dep][i + <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">if</span> (!j) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Auxiliary_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= maxn ; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= dep ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>) &amp; i)&#123;</span><br><span class="line">                farfrl[i] = max(farfrl[i], R[j][ farfrl[i ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] + <span class="number">1</span>]) ;</span><br><span class="line">                farfrr[i] = min(farfrr[i], L[j][ farfrr[i ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))] - <span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    base[<span class="number">0</span>] = -MAX ;</span><br><span class="line">    base[n + <span class="number">1</span>] = MAX ; k = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; Init_dp() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        rg[i].l = L[<span class="number">1</span>][i], rg[i].r = R[<span class="number">1</span>][i] ;</span><br><span class="line">    sort(rg + <span class="number">1</span>, rg + n + <span class="number">1</span>) ; maxn = (<span class="number">1</span> &lt;&lt; dep) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= maxn ; ++ i) farfrr[i] = n + <span class="number">1</span> ;</span><br><span class="line">    k += unique(rg + <span class="number">1</span>, rg + n + <span class="number">1</span>) - rg ; Auxiliary_dp() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= maxn ; j += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (farfrl[j] + <span class="number">1</span> &gt;= rg[i].l &amp;&amp; farfrr[(maxn ^ j) ^ <span class="number">1</span>] - <span class="number">1</span> &lt;= rg[i].r)</span><br><span class="line">                &#123; <span class="keyword">for</span> (<span class="keyword">int</span> o = rg[i].l ; o &lt;= rg[i].r ; ++ o) ans[o] = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">puts</span>(ans[i] ? <span class="string">"Possible"</span> : <span class="string">"Impossible"</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">1 7</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">1 7</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>atcoder</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>动态规划/有技巧的DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】loj#6433 [PKUSC2018]最大前缀和</title>
    <url>/2020/02/25/PKUSC2018%E6%9C%80%E5%A4%A7%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>一个长为 $n$ 的序列 $a_n$，求这个序列随机打乱后最大前缀和的期望值。</p>
<p> $n ≤ 20, |a_i | ≤ 10^9$</p>
</blockquote>
<p>一道让人更透彻地理解动态规划的好题orz</p>
<a id="more"></a>
<p>这是个神仙题…</p>
<p>考虑从这个 $dp$ 的本质入手。以下记 $\{a_m\}$ 表示长度为 $m$ 的序列 $a_1,a_2,\cdots a_m$ 。</p>
<p>首先，对于一个最大前缀和 $(p,\{s_n\})$ 表示的是 $s_1,s_2\cdots s_p$ 构成这个序列的最大前缀和，那么有两个性质：</p>
<p>1、对于 $\{s_n\}$ 的任意 $k&gt;p$ 的 $k\sim n$ 后缀，都有 $sum(k\sim n) \leq 0$ 。</p>
<p>2、对于 $\{s_p\}$ （即 $\{s_n\}$ 的 $1\sim p$ 前缀）的任意 $k&gt;1$ 的 $k\sim p$ 后缀，有 $sum(k\sim p)\geq 0$ 。</p>
<p>那么考虑枚举集合 $t$，表示这个集合的全部元素都用来贡献最大前缀和，记 $f_t$ 为满足条件2的排列方案数，$g_t$ 为满足条件1的方案数，那么考虑如何按秩转移。对于已经有的一个排列，考虑在序列最前端加一个数or在序列最后端加一个数，这样我们保证了按秩的同时，可以比较方便地讨论：</p>
<p>1、如果 $sum_t&lt;0$ ，那么就可以向 $\forall \{k\}\operatorname{and} t=\empty,k$ 的 $g_{t\cup\{k\}}$ 贡献 $g_t$ 的方案数，也就是向序列后方添一个数。</p>
<p>2、如果 $sum_t\geq 0$ ，那么就可以向 $\forall \{k\}\operatorname{and} t=\empty,k$ 的 $f_{t\cup\{k\}}$ 贡献 $f_{t}$ 的方案数，也就是向序列前端添一个数。</p>
<p>但是这个地方有个问题，就是如果最大的前缀和为负，他依然有贡献，但是没有统计。考虑一个贪心的性质如果最大前缀和为负，那么肯定最大前缀和只有第一个元素。所以一开始把所有只有一个元素的 $f$ 都置为 $1$ 即可。</p>
<p>这个地方有个很需要学习的地方，就是 <strong>刷表法在此处由于和dp的推法一致，也就是在模拟加入一个数的过程，所以刷表会比较自然，而朴素地填表就会出错</strong>。</p>
<p>嗯，拿小本本记下来了/kel</p>
<p>于是最后答案就是： </p>
<script type="math/tex; mode=display">
\sum_{t⊆ m} sum_{\mathrm{t}}\cdot f_{\mathrm{t}}\cdot g_{\mathrm{m}-\mathrm{t}}</script><p>以下是向srz学习的dp方式，本质上也是在枚举 $&gt;0$ 后缀：</p>
<p>考虑另一种推 $f$ 的方式，考虑本质上 $f_t$ 计算的是有多少种方案使得 $sum_t$ 成为最大前缀和，那么就可以这么转移：</p>
<script type="math/tex; mode=display">
f_t=|t|!-\sum_{s⊆t}f_s\cdot g_{t-s}</script><p>也就是枚举有多少种不合法的方案，通过子集转移。裸的转移是 $3^n$ 的，但观察到本质上是在做一个集合的对称差，于是可以用 $\rm FWT$ 优化到 $2^nn^2$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">22</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line">LL ans ;</span><br><span class="line">LL f[M] ;</span><br><span class="line">LL g[M] ;</span><br><span class="line">LL sum[M] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    m = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> ; g[<span class="number">0</span>] = <span class="number">1l</span>l ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i) f[<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], sum[<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)] = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        sum[i] = (sum[low(i)] + sum[i ^ low(i)]) % P ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!((<span class="number">1</span> &lt;&lt; j) &amp; i)) (f[i | (<span class="number">1</span> &lt;&lt; j)] += f[i]) %= P ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; j) &amp; i) (g[i] += g[(<span class="number">1</span> &lt;&lt; j) ^ i]) %= P ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        (ans += sum[i] * f[i] % P * g[m ^ i] % P) %= P ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (((ans % P) + P) % P) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>动态规划/有技巧的DP</tag>
        <tag>数学/概率,期望</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[ARC066F]Contest with Drinks(Hard)</title>
    <url>/2020/02/23/ARC066F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>有 $n$ 个点，选择第 $i$ 个点有 $a_i$ 的代价。如果一个极大的、长度为 $L$ 的区间内的点都被选了，这个区间会带来$\frac{L^2+L}{2}$ 的收益。</p>
<p>询问共 $q$ 组，为对 $a_i$ 的单点修改。 询问彼此独立。</p>
<p>形式化地讲，给定 $\{t_n\}$ ，求一组 $\{x_n\},\forall i \in[1, n], x_{i} \in[0,1]$ 使可以得到：</p>
<script type="math/tex; mode=display">
\max \left\{\sum_{i=1}^{n} \sum_{j=i}^{n}\left(\prod_{k=i}^{j} x_{k}\right)-\sum_{i=1}^{n} x_{i} t_{i}\right\}</script><p>$n, q ≤ 3 × 10^5$</p>
</blockquote>
<p>一道神题…本质上虽然不是很难，但是碍于个人对斜率优化这个东西掌握的实在十分差劲，所以几乎把所有能踩的坑全踩了一遍。</p>
<a id="more"></a>
<h1 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h1><p>首先考虑对于每个询问，主要思想是维护一个前缀的 $f_i$ 表示不选 $i$ ，前 $i-1$ 个元素的最优解；$g_i$ 则是用来维护一个后缀，表示不选 $i$，$i+1\sim n$ 中元素的最优解。同时，再维护一个 $h_i$ 表示选了 $i$ 的全局最优解。那么这样就可以如此回答询问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (m --)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;x) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(f[p] + g[p], o[p] + base[p] - x)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是考虑这三个东西应该怎么转移。先考虑 $f$ :</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_i&=\max\{f_j+\frac{(i-j)(i-j-1)}{2}-(s_i-s_j)\}\\
f_i&=\max\{f_i,f_{i-1}\}
\end{aligned}</script><p>枚举的是 $[j,i-1]$ 这段区间。</p>
<p>变形可得</p>
<script type="math/tex; mode=display">
f_j+s_j+\frac{j^2+j}{2}=i\cdot j+f_i+s_i- \frac{i^2-i}{2}</script><p>于是就发现，这是一个以 $f_j+s_j+\frac{j^2+j}{2}$ 为纵坐标，$i$ 为斜率的斜率优化。观察可知，横坐标 $j$ 单增，同时斜率 $i$ 也单增。所以对于这种类型的 $dp$ 只能用<strong>单调栈</strong>来维护。</p>
<p>同时，关于 $g$，只需要倒着做一遍 $f$ 的 $dp$ 即可。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">calc0</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y - <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y(x) - <span class="number">1.0</span> * Y(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY(x) - <span class="number">1.0</span> * YY(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">stk[++ t] = <span class="number">0</span> ; s[n + <span class="number">1</span>] = s[n] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    f[i] = max(f[i - <span class="number">1</span>], f[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    stk[++ t] = i ;</span><br><span class="line">&#125;</span><br><span class="line">reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i) s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line"><span class="keyword">while</span> (t) stk[t --] = <span class="number">0</span> ; t = <span class="number">0</span> ; stk[++ t] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    g[i] = max(g[i - <span class="number">1</span>], g[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">    stk[++ t] = i ;</span><br><span class="line">&#125;</span><br><span class="line">reverse(g + <span class="number">1</span>, g + n + <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure>
<p>考虑关于于 $h$ 的转移，朴素的转移是 $O(n^3)$ 的，类似这样：</p>
<script type="math/tex; mode=display">
h_i=\max_{x\leq i\leq y}\{f_x+\frac{(y-x+1)(y-x+2)}{2}-s_y+s_x+g_y\}</script><p>发现并不可以过。发现转移是一个区间的形式，于是考虑分治。但是这个分治有个 $bug$ ，就是不是很容易维护跨过 $mid$ 的信息。</p>
<p>但发现一个性质，对于 $[mid+1,r]$ 之间的所有 $h$ 值，左边的所有点仅仅是帮助其成为最优解，也就是左边对右边的点满足单调性。那么我们就可以用单调栈来维护上一个不选的（即维护 $x$）同时枚举最后选的（枚举 $y$），即用 $[l,mid]$ 的值去更新 $[mid+1,r]$；同理对于右半边我们也可以这么做。</p>
<p>具体的，以用 $[l,mid]$ 的值去更新 $[mid+1,r]$ 为例，在算左半边的决策集合的时候，不需要考虑 $g_y$ 的贡献，所以就是一个裸的斜率优化；之后转移就只需要弹栈转移即可。</p>
<p>发现在转移 $h$ 时，由于固定了其中一个端点，依然满足斜率优化，故复杂度为 $\max\{n\log n, Q\}$。</p>
<p>以下是坑点：</p>
<p>1、注意如果按照上述方式来转移，两个转移常数有些微不同（但是这些不同很致命</p>
<p>2、注意因为一开始 $\{g_n\}$ 这个东西是按照 <code>reverse</code> 的前缀和来转移的，所以在分治的时候需要重新计算前缀和。</p>
<p>3、在分治的时候，斜率啊什么的变换频繁，所以如果想要推明白，可以在维护上凸壳的时候偷懒这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define tranl(b,a) g[a + 1] - s[a] + S[b] + F[b] + 1ll * ((a - b)*(a - b + 1)&#x2F; 2ll)</span><br><span class="line">#define tranr(b,a) f[a - 1] - s[a] + S[b] + G[b] + 1ll * ((b - a)*(b - a + 1)&#x2F; 2ll)</span><br></pre></td></tr></table></figure>
<p>然后每次比较就不需要斜率了，只需要 <code>while (top &gt; 1 &amp;&amp; tranl(stk[top], i) &lt;= tranr(stk[top - 1], i)) -- top</code> ;  虽然显然本质上没什么不同，但这样或许会简单很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line">LL f[N] ;</span><br><span class="line">LL g[N] ;</span><br><span class="line">LL o[N] ;</span><br><span class="line">LL s[N] ;</span><br><span class="line">LL tmp[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> stk[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y + <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc0</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - y) * (x - y - <span class="number">1</span>) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x + x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y(x) - <span class="number">1.0</span> * Y(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY(x) - <span class="number">1.0</span> * YY(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Y2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x] + s[x] + (x * x - x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">YY2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g[x] + s[x] + (x * x - x) / <span class="number">2l</span>l ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * Y2(x) - <span class="number">1.0</span> * Y2(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * (<span class="number">1.0</span> * YY2(x) - <span class="number">1.0</span> * YY2(y)) / (<span class="number">1.0</span> * x - <span class="number">1.0</span> * y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> o[l] = max(o[l], f[l - <span class="number">1</span>] + g[r + <span class="number">1</span>] + <span class="number">1</span> - base[l]), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; LL ans ;</span><br><span class="line">    solve(l, mid) ; solve(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    s[l - <span class="number">1</span>] = s[r + <span class="number">1</span>] = <span class="number">0</span> ; t = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        tmp[i] = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>), s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span> ; i &lt;= mid ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; Slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        tmp[i] = f[stk[t]] + calc(i, stk[t]) - s[i] + s[stk[t]] + g[i + <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= mid + <span class="number">1</span> ; -- i)</span><br><span class="line">        ans = max(ans, tmp[i]), o[i] = max(o[i], ans) ;</span><br><span class="line">    t = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= l ; -- i) s[i] = s[i + <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r + <span class="number">1</span> ; i &gt; mid ; -- i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &gt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid ; i &gt;= l ; -- i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; Slope2(stk[t], stk[t - <span class="number">1</span>]) &gt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        tmp[i] = g[stk[t]] + calc(stk[t], i) - s[i] + s[stk[t]] + f[i - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = -(<span class="number">1l</span>l &lt;&lt; <span class="number">62</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= mid ; ++ i)</span><br><span class="line">        ans = max(ans, tmp[i]), o[i] = max(o[i], ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"2.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"1.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    t = <span class="number">0</span> ; <span class="keyword">int</span> p, x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]),</span><br><span class="line">        o[i] = - (<span class="number">1l</span>l  &lt;&lt;  <span class="number">62</span>),</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ t] = <span class="number">0</span> ; s[n + <span class="number">1</span>] = s[n] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        f[i] = max(f[i - <span class="number">1</span>], f[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope1(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope1(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i) s[i] = s[i - <span class="number">1</span>] + base[i] ;</span><br><span class="line">    <span class="keyword">while</span> (t) stk[t --] = <span class="number">0</span> ; t = <span class="number">0</span> ; stk[++ t] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= i) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        g[i] = max(g[i - <span class="number">1</span>], g[stk[t]] + calc0(i, stk[t]) - s[i - <span class="number">1</span>] + s[stk[t]]) ;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">1</span> &amp;&amp; slope2(stk[t], stk[t - <span class="number">1</span>]) &lt;= slope2(i, stk[t])) stk[t --] = <span class="number">0</span> ;</span><br><span class="line">        stk[++ t] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(g + <span class="number">1</span>, g + n + <span class="number">1</span>) ;</span><br><span class="line">    g[<span class="number">0</span>] = g[n + <span class="number">1</span>], g[n + <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    reverse(base + <span class="number">1</span>, base + n + <span class="number">1</span>) ;</span><br><span class="line">    <span class="comment">//for (int i = 0 ; i &lt;= n + 1 ; ++ i) cout &lt;&lt; f[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="comment">//for (int i = 0 ; i &lt;= n + 1 ; ++ i) cout &lt;&lt; g[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    solve(<span class="number">1</span>, n) ; <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; o[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;x) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(f[p] + g[p], o[p] + base[p] - x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这题我从 <code>2020.2.22</code> 的晚上7点开始写，<del>中间看了两个小时C菌直播行尸走肉并且睡了一个小时</del>，本来写的很顺，后来发现一堆细节没考虑就开始自闭了，<del>感觉就是行尸走肉太带劲了思路断了</del>，$1$ 点垂死梦中惊坐起之后在黑黑的房间里 <code>debug</code> 到了早上4点，睡了3.5h之后起来发现只剩一个「 $g$ 当时是倒着求的」这么一个问题了，但不幸走了很多弯路，不过最终还是AC了…</p>
<p>其实有时候根本不知道自己为啥要这么做，这么做的意义似乎也不是很大，中途破坏了自己本来想早睡早起的计划、浪费了一场300iq出的比赛外加和老妈吵了一架。</p>
<p>但可能人生中没意义的事情还多的多，并且一件更比一件没意义，所以可能也不需要这么伤心。</p>
<p>安啦安啦，还要继续走下去啊。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>atcoder</category>
      </categories>
      <tags>
        <tag>技巧/分治</tag>
        <tag>生活碎片</tag>
        <tag>动态规划/斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛学笔记】动态规划杂项</title>
    <url>/2020/02/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实就是听课笔记，但后来发现没啥可听的就变成了做题笔记(?)</p>
<a id="more"></a>
<h1 id="单调队列部分"><a href="#单调队列部分" class="headerlink" title="单调队列部分"></a>单调队列部分</h1><p>单调队列主要用来优化，对于状态 $\rm S$ 的某个后继状态 $\rm S’$，如果 $\rm S’$ 比 $\rm S$ 更优就可以舍弃掉 $\rm S$ 的转移。通常表现形式为会有限制，比如</p>
<script type="math/tex; mode=display">
f_{i}=\max\{f_j\}+w_i \quad(j\in[L_i,i-1]\cap\mathbb Z)</script><p>其中 $\{L\}$ 是一个给定常数，且 $\forall i, L_i\geq L_{i-1}$ 。那么可知对于后续状态 $s_i$ ，他的可转移范围一定更大，至少比 $s_j$ 大，所以可以删除  $s_j$.</p>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>考虑原本的转移</p>
<script type="math/tex; mode=display">
f_{i,j}=\max\{f_{i-1,j-k\cdot w_i}\}+k\cdot v_i\quad (1\leq k\leq c_i)</script><p>其中需要优化掉的是 $k$ 这一维，发现他原本并没有任何对于转移单调的限制，于是考虑变一下形。</p>
<p>令 $d=j\bmod w_i$，$s=\lfloor\frac{j}{w_i}\rfloor$，那么转移就可以写作</p>
<script type="math/tex; mode=display">
f_{i,j}=\max\{f_{i-1,d+k\cdot w_i}-k\cdot v_i\}+s\cdot v_i \quad (s-k\leq c_i)</script><p>发现转移条件 $s-k\leq c_i\Longrightarrow k\geq s-c_i=\lfloor\frac{j}{w_i}\rfloor-c_i$ ，可知 $L_j$ 不降，于是就对每个 $d$ 用单调队列即可。</p>
<h1 id="斜率优化部分"><a href="#斜率优化部分" class="headerlink" title="斜率优化部分"></a>斜率优化部分</h1><p>这部分虽然简单但是不熟，所以可能需要多做点题。</p>
<h2 id="傻狗题"><a href="#傻狗题" class="headerlink" title="傻狗题"></a>傻狗题</h2><blockquote>
<p>把一个长为 $n$ 的正整数序列划分成若干段，每一段的代价是内部元素和的平方加上一个定值 $m$。求划分整个序列的最小代价。</p>
</blockquote>
<p>可知转移</p>
<script type="math/tex; mode=display">
f_i=\min\{f_j+(s_i-s_j)^2\}+m</script><script type="math/tex; mode=display">
f_j+s_j^2=2s_is_j+f_i-s_i^2-m</script><p>于是就变成了有一个以 $s_i$ 为斜率，$f_j+s_j^2$ 为纵坐标，$s_i$ 为横坐标的斜率优化。考虑横坐标和斜率都是单调的，就可以直接队尾删/队尾插入。</p>
<h2 id="USACO08MAR-Land-Acquisition"><a href="#USACO08MAR-Land-Acquisition" class="headerlink" title="[USACO08MAR]Land Acquisition"></a>[USACO08MAR]Land Acquisition</h2><blockquote>
<p>有 $n$ 块长方形的土地需要购买，你每次可以选择一组土地一起购买，价 格为这些土地中最大的长乘以最大的宽。求购买所有土地的最小费用。 </p>
<p>$n ≤ 50000$</p>
</blockquote>
<p>考虑先排序，然后考虑如果直接 $dp$，那么本身需要枚举 $i\sim j$ 之间的元素取 $\max$，这样显然复杂度就多了一维 $n$。仔细思考后发现，如果对于一组 $(i,j)$，满足 $w_i\geq w_j$ 且 $h_i\geq j_j$ ，那么就可以删掉 $j$ 。具体的，考虑按照 $h$ 排序之后，用一个单调栈来维护这个东西。</p>
<p>那么这样最后剩下的一定满足 $w$ 单调。所以就会得到类似</p>
<script type="math/tex; mode=display">
f_i=\min\{f_{j}+h_{j+1}\cdot w_i\}\\
f_j=-h_{j+1}\cdot w_i+f_i</script><p>那么令 $h_{j+1}$ 作为横坐标，横坐标单调；$w_i$ 作为斜率，斜率单调。于是就变成了最 <code>general</code> 的斜率优化问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> top ;</span><br><span class="line">LL f[N] ;</span><br><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grid</span>&#123;</span></span><br><span class="line">    LL x, y ;</span><br><span class="line">&#125;base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(grid a, grid b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x == b.x ? a.y &gt; b.y : a.x &gt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;base[i].x, &amp;base[i].y) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + n + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!top || t[top].y &lt; base[i].y) t[++ top] = base[i] ;</span><br><span class="line"><span class="comment">//	for (int i = 1 ; i &lt;= 50 ; ++ i) cout &lt;&lt; t[i].x &lt;&lt; " " &lt;&lt; t[i].y &lt;&lt; endl ;</span></span><br><span class="line">    n = top ; q.push_back(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">         <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> o, p ; p = q.front() ; q.pop_front() ; o = q.front() ;</span><br><span class="line">            <span class="keyword">if</span> (f[p] - f[o] &lt;= t[i].y * (t[o + <span class="number">1</span>].x - t[p + <span class="number">1</span>].x))</span><br><span class="line">                &#123; q.push_front(p) ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         f[i] = f[q.front()] + t[q.front() + <span class="number">1</span>].x * t[i].y ;</span><br><span class="line">         <span class="keyword">while</span> (q.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> o, p ; p = q.back() ; q.pop_back() ; o = q.back() ;</span><br><span class="line">            <span class="keyword">if</span> ((f[p] - f[o]) * (t[p + <span class="number">1</span>].x - t[i + <span class="number">1</span>].x) &lt;= (f[i] - f[p]) * (t[o + <span class="number">1</span>].x - t[p + <span class="number">1</span>].x))</span><br><span class="line">                &#123; q.push_back(p) ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         q.push_back(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BTW，如何推凸包的维护方式，可以考虑是维护下凸壳还是上凸壳，但是似乎又一种方式更简便：</p>
<p>令 $0\leq k&lt;j&lt;i$ ，那么如果 $j$ 比 $k$ 好，那么需要满足</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_{j}+w_{j+1} \times l_{i} & \leq f_{k}+w_{k+1} \times l_{i} \\
f_{j}-f_{k} & \leq l_{i} \times\left(w_{k+1}-w_{j+1}\right)\\
l_{i} &\geq \frac{f_{j}-f_{k}}{w_{k+1}-w_{j+1}}
\end{aligned}</script><p>这么做就会比较直观？</p>
<p>值得注意的是，斜率优化的时候很可能会因为移项的时候符号变错了而GG。</p>
<p>还有，似乎如果斜率和横坐标的单调方式相同，那么就可以用单调栈替换掉单调队列。虽然…没啥用233</p>
<h1 id="期望相关"><a href="#期望相关" class="headerlink" title="期望相关"></a>期望相关</h1><h2 id="Red-is-Good"><a href="#Red-is-Good" class="headerlink" title="Red is Good"></a>Red is Good</h2><blockquote>
<p>$n$ 张红牌，$m$ 张黑牌随机打乱顺序放在桌面上，你可以翻牌，翻到红色则得到 $1$ 元，黑色则失去 $1$ 元。求在最优策略下平均能得到多少钱。</p>
<p>$n,m\leq 5000$</p>
</blockquote>
<p>考虑如何设状态为 “已经xxx了”，不是很容易转移。于是考虑令 $f_{i,j}$ 为剩下 $i$ 张红的，$j$ 张黑的时的最大值。注意到由于是最优决策，所以有</p>
<script type="math/tex; mode=display">
f_{i,j}=\max\{0,\frac{i}{i+j}(f_{i-1,j}+1)+\frac{j}{i+j}(f_{i,j-1}-1)\}</script><h2 id="HNOI2015-亚瑟王"><a href="#HNOI2015-亚瑟王" class="headerlink" title="[HNOI2015]亚瑟王"></a>[HNOI2015]亚瑟王</h2><blockquote>
<p>有 $n$ 张卡牌，玩 $r$ 轮游戏。每轮游戏从左向右轮流考虑每张没有发动过的卡牌，考虑到第 $i$ 张卡时，它有 $p_i$ 的概率发动并产生 $d_i$ 的贡献， 然后本轮立即结束并进入下一轮。若没有卡牌发动则直接进入下一轮。 $T$ 组数据，求期望贡献。</p>
<p>$T\leq 500, n\leq 300,r\leq 200$</p>
</blockquote>
<p>考虑分别计算出每张卡牌的发动概率，然后分别乘上每张卡牌的权值得到答案。</p>
<p>具体的，令 $f_{i,j}$ 表示当前只在考虑第 $i$ 张牌，还剩 $j$ 次游戏没有开始的概率。考虑转移：</p>
<script type="math/tex; mode=display">
f_{i,j}=f_{i-1,j+1}\cdot(1-(1-p_{i-1})^{j+1})+f_{i-1,j}\cdot(1-p_{i-1})^j</script><p>其实就是在计算牌 $i-1$ 是否被发动了，前半部分计算了第 $i$ 张牌在之后的 $j$ 次以及当前这一次中任意一次发动成功的概率，所以是 $1-一次也没发动成功的概率$；后半部分以此类推。注意，此处忽略了题目中「直接结束本轮」的约束。本质上，$f$ 保证了还有 $j$ 轮时，前 $i$ 张卡牌不会被选。</p>
<p>那么考虑如何计算第 $i$ 张牌是否发动了的概率：</p>
<script type="math/tex; mode=display">
P_i=\sum_{j=1}^rf_{i,j}\cdot (1-(1-p_i)^j)</script><p>之后用线性性算一下就好了。复杂度 $O(nTr)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> n, r ;</span><br><span class="line"><span class="keyword">double</span> ans ;</span><br><span class="line"><span class="keyword">double</span> d[N] ;</span><br><span class="line"><span class="keyword">double</span> p[N] ;</span><br><span class="line"><span class="keyword">double</span> f[N][N] ;</span><br><span class="line"><span class="keyword">double</span> xs[N][N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r ; <span class="keyword">double</span> res ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i], &amp;d[i]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n + <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= r + <span class="number">1</span> ; ++ j)</span><br><span class="line">                f[i][j] = xs[i][j] = <span class="number">0</span> ;</span><br><span class="line">        f[<span class="number">0</span>][r] = <span class="number">1</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            res = <span class="number">1.0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= r ; ++ j)</span><br><span class="line">                xs[i][j] = res, res *= (<span class="number">1.0</span> - p[i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = r ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j + <span class="number">1</span>] * (<span class="number">1.0</span> - xs[i - <span class="number">1</span>][j + <span class="number">1</span>]) + f[i - <span class="number">1</span>][j] * xs[i - <span class="number">1</span>][j] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= r ; ++ j)</span><br><span class="line">                ans += d[i] * f[i][j] * (<span class="number">1.0</span> - xs[i][j]) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.9lf\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>数学/概率,期望</tag>
        <tag>动态规划/单调队列</tag>
        <tag>动态规划/斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】bzoj1559 [JSOI2009]密码</title>
    <url>/2020/02/20/JSOI2009%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定长度为 $L$ 的 $m$ 个子串，要求拼出一个长度为 $L$ 的长串使之包含所有的子串。</p>
<p>如果方案数 $\leq42$ 则输出全部方案，否则只输出方案数。</p>
<p>$L\leq 25,m\leq 10$。</p>
</blockquote>
<a id="more"></a>
<p>…这题大概也就是蓝~紫左右，这个黑实在太虚了。</p>
<p>但这不影响我还是不太会233</p>
<p>观察题意，由 <code>good+day=gooday</code> 可知应该放在 $\rm AC$ 自动机上做，因为存在重合。观察范围可知是状压。于是考虑在 $\rm$ AC 自动机上 $dp$。</p>
<p>记 $f_{i,j,s}$ 表示匹配到串的第 $i$ 位，走到了自动机上的第 $j$ 个节点，当前已经拼完了集合 $s$ 中的模式串的方案数。转移的话就考虑直接枚举当前状态的所有子状态，暴力转移即可（用来计数的状压 $dp$ 还能怎么转移啊喂）。值得提一句的的是，由于本身 $\rm AC$ 自动机存在路径压缩，所以是 <code>认子不认父</code> 的结构，只能刷表而不能填表。</p>
<p>之后考虑输出方案。发现如果直接搜 $\rm AC$ 自动机上的每个方案十分暴力，于是考虑加一个可行性剪枝。即由于很容易 $dfs$ 出每个状态 $(i,j,s)$ 是否可以转移到终点，所以不需要考虑 $42$ 的限制，预处理一个 $g_{i,j,s}$是否可以拼出最终状态，剪完枝直接输出即可。</p>
<p>同时，只要在 $\rm AC$ 自动机上保证每次走最小的字母，就一定是字典序最优的方案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> o ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> t[N] ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line">LL f[N][W][Z] ;</span><br><span class="line"><span class="keyword">bool</span> g[N][W][Z] ;</span><br><span class="line"><span class="keyword">bool</span> v[N][W][Z] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> _ed[W] ;</span><br><span class="line">    <span class="keyword">int</span> fail[W] ;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> trans[W][<span class="number">26</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">char</span> *t, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, len ;</span><br><span class="line">        len = <span class="built_in">strlen</span>(t + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, i = <span class="number">1</span> ; i &lt;= len ; ++ i)&#123;</span><br><span class="line">            x = t[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trans[rt][x])</span><br><span class="line">                trans[rt][x] = ++ size ;</span><br><span class="line">            rt = trans[rt][x] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[rt] |= (<span class="number">1</span> &lt;&lt; num) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trans[<span class="number">0</span>][i]) q.push(trans[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front() ;</span><br><span class="line">            q.pop() ; _ed[x] |= _ed[fail[x]] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trans[x][i]) trans[x][i] = trans[fail[x]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[trans[x][i]] = trans[fail[x]][i], q.push(trans[x][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == n)&#123;</span><br><span class="line">        v[x][y][z] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> g[x][y][z] = (<span class="keyword">bool</span>)(z == o) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> p = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (v[x][y][z])</span><br><span class="line">        <span class="keyword">return</span> g[x][y][z] ;</span><br><span class="line">    <span class="keyword">else</span> v[x][y][z] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">        p |= search(x + <span class="number">1</span>, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;</span><br><span class="line">    <span class="keyword">return</span> g[x][y][z] = p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!g[x][y][z]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, t[i] + <span class="string">'a'</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">""</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">        t[x + <span class="number">1</span>] = i, output(x + <span class="number">1</span>, S.trans[y][i], z | S._ed[S.trans[y][i]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; S.size = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), S.Ins(s, i - <span class="number">1</span>) ;</span><br><span class="line">    S.build() ; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; o = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= S.size ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= o ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (f[i][j][k])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span> ; l &lt; <span class="number">26</span> ; ++ l)</span><br><span class="line">                        f[i + <span class="number">1</span>][S.trans[j][l]][k | S._ed[S.trans[j][l]]] += f[i][j][k] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= S.size ; ++ i) ans += f[n][i][o] ;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">42</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>, search(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), output(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>字符串/AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】[bzoj2555] Substring</title>
    <url>/2020/02/20/bzoj2555/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>要求实现两种操作：</p>
<p>(1): 在当前字符串的后面插入一个字符串</p>
<p>(2): 询问字符串 $s$ 在当前字符串中出现了几次？(作为连续子串)</p>
<p>你必须在线支持这些操作。</p>
<p>长度 $\leq 600000$，询问次数 $\leq 10000$，询问总长度 $\leq 3,000,000$。 </p>
</blockquote>
<a id="more"></a>
<p>一直听说有 $\rm LCT$ 维护 $parent$ 树的题，没想到真做到了233。</p>
<p>考虑字符串 $s$ 出现的次数，在SAM中，一个节点里面的某个子串的出现次数就是它的子树的出现次数和，因为长的后缀与短的后缀之间信息不共享，所以修改操作本质上是在进行 $parent$ 树上的链加。</p>
<p>考虑一种神奇的写法。每次对于新建的节点 $np$ ，他的贡献应该是 $parent$ 树上 $1\sim np$ 这条路径上的所有点。于是考虑先 <code>merge(1, np)</code> ，把 $np$ 给 <code>splay</code> 上去之后内部就变成了一棵以 $np$ 为根的一条链，这样就可以不用考虑链加，直接在 $np$ 处打标记即可。</p>
<p>似乎查询操作更为神奇。因为查询的时候只需要对于走到的一个点 $x$ ，直接把他 <code>splay</code> 掉就可以维护信息。看上去似乎不是很对，因为对 $x$ 产生贡献的是一颗子树而不是一条链。但这样做其实有他独特的正确性保证，即每个点都存在且仅存在于一棵 <code>splay</code> ，换 <code>splay</code> 的时候势必要 <code>access</code>，而 <code>access</code> 时本质上就已经把原来的标记给下放干净了，所以每次只有可能是当前的 <code>splay</code> 还有信息没有维护清楚。也就是每次只需要管一条链，剩下的链的标记已经清完了。这样就只需要 <code>splay</code> 一下即可。</p>
<p>写的时候，为了卡常发现了个更神奇的地方，就是在SAM里面抠点插子树/插点这两个操作，由于都保证了父亲不存在，所以 <code>Link</code> 这个操作，本质上是不需要 <code>make_root</code> 的，实测这样就会快很多很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl(x) t[x].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tg(x) t[x].tag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1500010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> tag ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[M] ;</span><br><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> tp ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">char</span> s[N] ;</span><br><span class="line"><span class="keyword">char</span> o[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lc(fa(x)) == x) || (rc(fa(x)) == x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span> ; swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tg(x))&#123;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) vl(lc(x)) += tg(x), tg(lc(x)) += tg(x) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) vl(rc(x)) += tg(x), tg(rc(x)) += tg(x) ;</span><br><span class="line">        tg(x) = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (nroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    fa( t[x].son[w ^ <span class="number">1</span>] ) = f1 ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = x ;</span><br><span class="line">    stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (nroot(y))</span><br><span class="line">        stk[++ tp] = (y = fa(y)) ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (nroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (nroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((rc(f1) == x) == (rc(f2) == f1))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span>(lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    make_root(x) ;</span><br><span class="line">    access(y) ; splay(y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    fa(x) = y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    merge(x, y) ;</span><br><span class="line">    fa(x) = t[y].son[<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">Input</span><span class="params">(<span class="keyword">int</span> mk)</span> </span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; len ; ++ j)</span><br><span class="line">        mk = (mk * <span class="number">131</span> + j) % len, swap(s[j], s[mk]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> last ;</span><br><span class="line">    <span class="keyword">int</span> len[M] ;</span><br><span class="line">    <span class="keyword">int</span> fal[M] ;</span><br><span class="line">    <span class="keyword">int</span> trans[M][<span class="number">2</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last = ++ size ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> q, nq, p = last ;</span><br><span class="line">        len[last = np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][x])</span><br><span class="line">            trans[p][x] = np, p = fal[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!p)&#123;</span><br><span class="line">            fal[np] = <span class="number">1</span> ;</span><br><span class="line">            link(np, <span class="number">1</span>), merge(<span class="number">1</span>, np) ;</span><br><span class="line">            vl(np) ++, tg(np) ++ ; <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        q = trans[p][x] ;</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)&#123;</span><br><span class="line">            fal[np] = q ;</span><br><span class="line">            link(np, q), merge(<span class="number">1</span>, np) ;</span><br><span class="line">            vl(np) ++, tg(np) ++ ; <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        nq = ++ size ;</span><br><span class="line">        cut(fal[q], q) ;</span><br><span class="line">        fal[nq] = fal[q] ;</span><br><span class="line">        link (q, nq) ;</span><br><span class="line">        link (np, nq) ;</span><br><span class="line">        link (nq, fal[q]) ;</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        fal[q] = fal[np] = nq ;</span><br><span class="line">        splay(q) ; vl(nq) = vl(q) ;</span><br><span class="line">        <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="number">8</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q)</span><br><span class="line">            trans[p][x] = nq, p = fal[p] ;</span><br><span class="line">        merge(<span class="number">1</span>, np), vl(np) ++, tg(np) ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ; S.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i) S.Ins(s[i] - <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, o + <span class="number">1</span>) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s), Input(ans) ;</span><br><span class="line">        <span class="keyword">if</span> (o[<span class="number">1</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; ++ i)</span><br><span class="line">                S.Ins(s[i] - <span class="string">'A'</span>) ; <span class="comment">//, cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rt = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; ++ i)&#123;</span><br><span class="line">                rt = S.trans[rt][s[i] - <span class="string">'A'</span>] ;</span><br><span class="line">                <span class="keyword">if</span> (!rt) <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!rt) res = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">else</span> splay(rt), res = vl(rt) ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res) ; ans = ans ^ res ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>字符串/后缀自动机(SAM)</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】loj#2059 [HEOI/TJOI2016]字符串</title>
    <url>/2020/02/20/HEOI-TJOI2016%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定一个串，每次给出区间 $[a,b]$ 和 $[c,d]$，询问 $[a,b]$ 中的子串与 $s[c…d]$ 的 $lcp$ 最大值。</p>
<p>要求做法 $n~\mathrm{poly}(\log)$，其中 $\deg(\mathrm{poly}(\log))\leq 3$ 。 </p>
</blockquote>
<a id="more"></a>
<p>考虑二分，那么就变成了一个判定性问题，即考虑 $s[c…c+mid-1]$ 在 $[a…b]$ 中是否出现过。那么考虑倍增，对于每个点可以倍增出 $s[1…c+mid-1]$ 的 $endpos$ 所在的那个节点，那么现在就是要求这个 $endpos$ 中是否存在某个元素 $\in$ $[a+mid-1,b]$ 。 那么这个东西就可以插入时维护每个点当前的 $endpos$，之后对当前的 $parent$ 树做一次线段树合并即可。</p>
<p>需要注意的是这种写法的线段树合并可能会炸空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> Id[N] ;</span><br><span class="line"><span class="keyword">char</span> t[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N] ;</span><br><span class="line"><span class="keyword">int</span> dad[N][<span class="number">21</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size ;</span><br><span class="line">    <span class="keyword">int</span> lc[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> rc[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> rt[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="keyword">int</span> sum[N * <span class="number">15</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!rt) rt = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        sum[rt] ++ ; <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (v &lt;= mid) Ins(lc[rt], l, mid, v) ;</span><br><span class="line">        <span class="keyword">else</span> Ins(rc[rt], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> sum[rt] ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res += query(lc[rt], l, mid, ql, qr) ;</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res += query(rc[rt], mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = ++ size ;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">return</span> y ;</span><br><span class="line">        <span class="keyword">if</span> (!y) <span class="keyword">return</span> x ;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> p ;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        sum[p] = sum[x] + sum[y] ;</span><br><span class="line">        lc[p] = merge(lc[x], lc[y], l, mid) ;</span><br><span class="line">        rc[p] = merge(rc[x], rc[y], mid + <span class="number">1</span>, r) ;</span><br><span class="line">        <span class="keyword">return</span> p ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    next(cnt) = head[u] ;</span><br><span class="line">    head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">20</span> ; ++ k)</span><br><span class="line">        dad[x][k] = dad[dad[x][k - <span class="number">1</span>]][k - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        dad[to(k)][<span class="number">0</span>] = x, dfs(to(k)) ;</span><br><span class="line">        T.rt[x] = T.merge(T.rt[x], T.rt[to(k)], <span class="number">1</span>, n) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N] ;</span><br><span class="line">    <span class="keyword">int</span> len[N] ;</span><br><span class="line">    <span class="keyword">int</span> last, size ;</span><br><span class="line">    <span class="keyword">int</span> trans[N][<span class="number">26</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last = ++ size ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> np = ++ size ;</span><br><span class="line">        <span class="keyword">int</span> p = last, q, nq ;</span><br><span class="line">        len[last = np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][x])</span><br><span class="line">            trans[p][x] = np, p = fa[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = <span class="number">1</span>, last ;</span><br><span class="line">        q = trans[p][x] ;</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = q, last ;</span><br><span class="line">        nq = ++ size ;</span><br><span class="line">        fa[nq] = fa[q] ;</span><br><span class="line">        fa[q] = fa[np] = nq ;</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="number">104</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (n &amp;&amp; trans[p][x] == q)</span><br><span class="line">            trans[p][x] = nq, p = fa[p] ;</span><br><span class="line">        <span class="keyword">return</span> last ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= size ; ++ i) add(fa[i], i) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;S ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("str5.in", "r", stdin) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (t + <span class="number">1</span>), S.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        Id[i] = S.Ins(t[i] - <span class="string">'a'</span>) ;</span><br><span class="line">        T.Ins(T.rt[Id[i]], <span class="number">1</span>, n, i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    S.Add() ; dfs(<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d) ;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = min(b - a + <span class="number">1</span>, d - c + <span class="number">1</span>), mid, ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; l &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">int</span> x = Id[c + mid - <span class="number">1</span>] ;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; mid &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                <span class="keyword">if</span> (dad[x][j] &amp;&amp; S.len[dad[x][j]] &gt;= mid)</span><br><span class="line">                    x = dad[x][j] ;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (T.query(T.rt[x], <span class="number">1</span>, n, a + mid - <span class="number">1</span>, b))</span><br><span class="line">                ans = mid, l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>技巧/倍增</tag>
        <tag>字符串/后缀自动机(SAM)</tag>
        <tag>数据结构/数据结构方法/线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】矩阵加速转移</title>
    <url>/2020/02/20/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82dp%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是整理“[HNOI2008]GT考试”和“[SNOI2017]礼物”两道题。由于实在找不出什么共同点来，所以就随便找了个理由把两道题放在一起了233</p>
<p>从各个角度来看，都算是比较妙的设计方式了？</p>
<a id="more"></a>
<h1 id="HNOI2008-GT考试"><a href="#HNOI2008-GT考试" class="headerlink" title="[HNOI2008]GT考试"></a>[HNOI2008]GT考试</h1><blockquote>
<p>求 $n$ 位数字串不连续包括某个长度为 $m$ 的数字串的方案数。</p>
<p>$n\leq 10^9,m\leq 20$</p>
</blockquote>
<p>考虑直接 $dp$ 。个人认为这个地方还是有一点 trivial 的。首先就是考虑一种状态设计，记 $f_{i,j}$ 表示长串匹配到第 $i$ 位，短串匹配到第 $j$ 位的合法方案数。那么考虑可以转移：</p>
<script type="math/tex; mode=display">
f_{i,j}=\sum_{k=0}^{9}f_{i-1,o}</script><p>其中 $o=0\sim j-1$，取决于怎么个失配法。这样转移似乎并不可以。于是考虑另一种方式转移</p>
<script type="math/tex; mode=display">
f_{i,j}=\sum_{k=0}^{m-1}f_{i-1,k}\cdot g_{k,j}</script><p>其中 $g_{x,y}$ 表示现在已经匹配到了第 $x$ 位，有多少种方案使得在加了一个数字后变成匹配到 $y$ 位的方案数。</p>
<p>发现本质上这就是在做一个 KMP。于是可以用 KMP 预处理处这样的一张数表 $\{g\}$ 。同时，发现对于原来的式子，右边的 $g$ 不变，且转移方式就是矩阵的转移方式，于是考虑直接用矩阵优化掉。最终复杂度 $m^3\log n$。</p>
<p>btw，由于本质上转移已经写在那里了，所以不用费劲去构造一个矩阵了…wsdd</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> fail[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, p ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> M[N][N] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++ i) M[i][i] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;a, <span class="keyword">const</span> Matrix &amp;b)&#123;</span><br><span class="line">        Matrix ans ; ans.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    (ans.M[i][j] += a.M[i][k] * b.M[k][j] % p) %= p ;</span><br><span class="line">        <span class="keyword">return</span> ans ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> ^ (Matrix a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        Matrix res ; res.reset() ;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                res = res * a ;</span><br><span class="line">            a = a * a ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; g ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p ; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = fail[j] ;</span><br><span class="line">        <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) ++ j ; fail[i] = j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span> ; i &lt; m ; j = ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="string">'0'</span> ; c &lt;= <span class="string">'9'</span> ; j = i, ++ c)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; (<span class="keyword">int</span>)s[j + <span class="number">1</span>] != c) j = fail[j] ;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)s[j + <span class="number">1</span>] == c) ++ j ; g.M[i][j] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    g = g ^ n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; m ; ++ i)</span><br><span class="line">        (ans += g.M[<span class="number">0</span>][i]) %= p ;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>, <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SNOI2017-礼物"><a href="#SNOI2017-礼物" class="headerlink" title="[SNOI2017]礼物"></a>[SNOI2017]礼物</h1><blockquote>
<p> 给定 $k$，设 $f_i$ 的递推式如下：</p>
<script type="math/tex; mode=display">
f_{i}=i^k+\sum_{j=1}^{i-1}f_j</script><p>$k\leq 500,n\leq 10^{18}$</p>
</blockquote>
<p>当然这题有什么其余的大力多项式算法，复杂度是什么 $O(k+\log n)$ 的…要知道原原本本这题 $k$ 只有 $10$ 这么大啊/kk</p>
<p>考虑先设 $s_n=\sum_{i=1}^nf_i$ ，那么发现</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_n&=s_{n-1}+n^k\\
s_n&=s_{n-1}+f_n\\
&=2\cdot s_{n-1}+n^k
\end{aligned}</script><p>于是发现可以递推 $s_n$。那么发现这个地方有一个常系数 $n^k$，尝试依靠</p>
<script type="math/tex; mode=display">
(m+1)^k=\sum_{i=1}^k\binom{k}{i}m^i</script><p>这个东西来得到，即</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccccc}
{2} & {\binom{k}{0}} & {\binom{k}{1}} & {\binom{k}{2}} & {\cdots} & {\binom{k}{k}} \\
{0} & {\binom{k}{0}} & {\binom{k}{1}} & {\binom{k}{2}} & {\cdots} & {\binom{k}{k}} \\
{0} & {0} & {\binom{k-1}{0}} & {\binom{k-1}{1}} & {\cdots} & {\binom{k-1}{k-1}} \\
{0} & {0} & {0} & {\binom{k-2}{0}} & {\cdots} & {\binom{k-2}{k-1}} \\
{\vdots} & {\vdots} & {\vdots} & {\vdots} & {\vdots} & {\vdots} \\
{0} & {0} & {0} & {0} & {0} & {\binom{0}{0}}
\end{array}\right]
\times\left[\begin{array}{c}
{s_n} \\
{n^{k}} \\
{n^{k-1}} \\
{n^{k-2}} \\
{\vdots} \\
{n^{0}}
\end{array}\right]=\left[\begin{array}{c}
{s_{n+1}} \\
{(n+1)^{k}} \\
{(n+1)^{k-2}} \\
{\vdots} \\
{(n+1)^{0}}
\end{array}\right]</script><p>然后就可以愉快地矩乘了。</p>
<p>不过似乎有个性质值得注意，就是本身这个转移矩阵就是一个上三角的形式，所以可能会存在什么有趣的东西…不得而知不得而知…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAK 43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line">ll N, K, Ans, T, C[MAK][MAK]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span> ; x %= Mod ;  </span><br><span class="line">	<span class="keyword">while</span> (y)&#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x % Mod ; </span><br><span class="line">		x = x * x % Mod, <span class="comment">/* pks */</span> y &gt;&gt;= <span class="number">1</span> ;   </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		Ans = (T + expow(i, K)) % Mod, T = (T + Ans) % Mod ;</span><br><span class="line">	<span class="keyword">return</span> Ans ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Ma&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k ; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> M[<span class="number">50</span>][<span class="number">50</span>] ; </span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123; <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123; clear() ; <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= K + <span class="number">1</span> ; ++ i) M[i][i] = <span class="number">1</span> ; &#125;</span><br><span class="line">		Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">     	   Matrix Ans ; Ans.clear() ; <span class="keyword">int</span> P = K + <span class="number">2</span> ;</span><br><span class="line">     	   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= P ; ++ i)</span><br><span class="line">     	       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= P ; ++ j)</span><br><span class="line">     	           <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= P ; ++ k)</span><br><span class="line">     	               Ans.M[i][j] = (Ans.M[i][j] + <span class="number">1l</span>l * A.M[i][k] * B.M[k][j] % Mod ) % Mod ;</span><br><span class="line">     	   <span class="keyword">return</span> Ans ;</span><br><span class="line">    	&#125;</span><br><span class="line">   		Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        	Matrix Ans ; Ans.clear() ; </span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line">            	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">                    Ans.M[i][j] = (A.M[i][j] + B.M[i][j]) % Mod ;</span><br><span class="line">        	<span class="keyword">return</span> Ans ;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;P, Ans ; <span class="keyword">int</span> C[MAK][MAK] ;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		P.M[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>, C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K + <span class="number">2</span> ; ++ i) C[i][<span class="number">0</span>] = <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">				C[i][j] = (<span class="number">1l</span>l * C[i - <span class="number">1</span>][j] + <span class="number">1l</span>l * C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ;</span><br><span class="line"> 		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K + <span class="number">2</span> ; ++ i) P.M[<span class="number">1</span>][i + <span class="number">1</span>] = C[K][i - <span class="number">1</span>] ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= K + <span class="number">2</span> ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (j = i ; j &lt;= K + <span class="number">2</span> ; ++ j)</span><br><span class="line">				P.M[i][j] = C[K + <span class="number">2</span> - i	][j - i] ;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (i = K + <span class="number">2</span> ; i &gt;= <span class="number">1</span> ; -- i) Ans.M[i][<span class="number">1</span>] = <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Matrix <span class="title">expow</span><span class="params">(Matrix x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">		Matrix res ; res.reset() ;</span><br><span class="line">		<span class="keyword">while</span> (y)&#123;</span><br><span class="line">			<span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x ;</span><br><span class="line">			x = x * x, <span class="comment">/*pkspkspks*/</span> y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">while</span> (y)&#123;</span><br><span class="line">			<span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = <span class="number">1l</span>l * res * x % Mod ;</span><br><span class="line">			x = <span class="number">1l</span>l * x * x % Mod, <span class="comment">/*pkspkspks*/</span> y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		P.clear() ; Init() ; </span><br><span class="line">		Matrix A1, A2, N1, N2 ;</span><br><span class="line">		N1 = expow(P, N - <span class="number">2</span>), N2 = N1 * P ;  <span class="comment">/*</span></span><br><span class="line"><span class="comment">		for (i = 1 ; i &lt;= K + 2 ; ++ i, cout &lt;&lt; endl)</span></span><br><span class="line"><span class="comment">			for (j = 1 ; j &lt;= K + 2 ; ++ j)</span></span><br><span class="line"><span class="comment">				 cout &lt;&lt; P.M[i][j] &lt;&lt; " " ; */</span></span><br><span class="line"><span class="comment">//		Matrix t = Ans * P ; 	</span></span><br><span class="line">		A1 = N1 * Ans, A2 = N2 * Ans ; </span><br><span class="line">		<span class="keyword">return</span> (A2.M[<span class="number">1</span>][<span class="number">1</span>] - A1.M[<span class="number">1</span>][<span class="number">1</span>] + Mod) % Mod ; </span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; </span><br><span class="line">	<span class="keyword">if</span> (N &lt;= <span class="number">1000000</span>) <span class="built_in">cout</span> &lt;&lt; Solve1() ;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (Ma :: Solve2()) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唉，比人会的我都不会，没有前途啊。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>动态规划/有技巧的DP</tag>
        <tag>数学/线性代数/矩阵</tag>
        <tag>字符串/KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】uoj#221 [NOI2016]循环之美</title>
    <url>/2020/02/18/NOI2016%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定 $n, m, k$，求有多少数值上互不相等的可以表示成 $\frac{x}{y}$ 的数， 满足 $1 ≤ x ≤ n$，$1 ≤ y ≤ m$，且其在 $k$ 进制下是纯循环小数。 </p>
<p>特别的，整数是纯循环小数。  $1 ≤ n, m ≤ 10^9,2 ≤ k ≤ 2000$ 。</p>
</blockquote>
<a id="more"></a>
<p>考虑本质上小数是如何产生的，发现就是当 $x/y$ 除到不能除时，$k$ 进制下，$x\times k$ 之后继续除下去。那么假设循环节长度为 $L$ ，那么会有 $x\bmod y=x\cdot k^L\bmod y$ 。也就是解得 $k^L\equiv1(\bmod y)$ 。那么由于逆元唯一，所以存在这样的一个 $L$，也就是存在逆元的充要条件就是 $k \perp y$ 。</p>
<p>并且由于不算重，还要求 $x\perp y$ 。所以最后本质上是要求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n} \sum_{j=1}^{m}[j \perp k][i \perp j]</script><p>随便反演一下</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^{n} \sum_{j=1}^{m}[j \perp k][i \perp j]\\
=&\sum_{i=1}^n\sum_{j=1}^m[j\perp k]\sum_{d|i\operatorname{and}d|j} \mu(d)\\
=&\sum_{d=1}^n\mu(d)\cdot \lfloor\frac{n}{d}\rfloor\cdot [d\perp k] \cdot \sum_{j=1}^{\lfloor\frac{m}{d}\rfloor} [j\perp k]
\end{aligned}</script><p>考虑后面那个 $\sum$ 。若令</p>
<script type="math/tex; mode=display">
f_n=\sum_{i=1}^n[i\perp k]</script><p>那么由于 $\gcd$ 的优秀性质 $\gcd(a,b)=\gcd(b,a\bmod b)$ 所以</p>
<script type="math/tex; mode=display">
f_n=\lfloor\frac{n}{k}\rfloor\cdot f_{k}+f_{n\bmod k}</script><p>这个转移本质上是在做一个分块。</p>
<p>那么考虑前半部分这个 $\sum $ 。发现如果要数论分块的话，需要快速求</p>
<script type="math/tex; mode=display">
s(n,k)=\sum_{i=1}^n\mu(i)\cdot [i\perp k]</script><p>这个东西。根据一个神奇的 $\mu$ 函数的性质 $\mu(ab)=[a\perp b]\mu(a)\mu(b)$，可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
s(n,k)&=\sum_{i=1}^n\mu(i)\cdot [i\perp k]\\
&=\sum_{i=1}^n\mu(i)\sum_{d|i\operatorname{and}d|k} \mu(d)\\
&=\sum_{d|k} \mu(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(d\cdot i) \\
&=\sum_{d|k} \mu(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(d)\cdot \mu(i)\cdot[i\perp d]\\
&=\sum_{d|k} \mu^2(d) \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\mu(i)\cdot[i\perp d] \\
&=\sum_{d|k} \mu^2(d) \cdot s(\lfloor\frac{n}{d}\rfloor,d) 
\end{aligned}</script><p>那么这东西显然可以用一个类杜教筛状物来做，大致就是当 $k=1$ 时本质上就是在做一个杜教筛，当 $k&gt;1$ 时只需要枚举 $x$ 的全部因子，这样转移最多有 $\sigma_0(k)$ 种，$k$ 也只会有 $\sigma_0(k)$ 个，递归做下去就好了。这样复杂度的上界是 $O(n^{\frac{2}{3}}+\sigma_0^2(k)\sqrt n)$ ，是一个极其松的上界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1001000</span> ;</span><br><span class="line"></span><br><span class="line">LL f[N] ;</span><br><span class="line">LL G[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> mu[M] ;</span><br><span class="line"><span class="keyword">int</span> pr[M] ;</span><br><span class="line"><span class="keyword">int</span> smu[M] ;</span><br><span class="line"><span class="keyword">int</span> chk[M] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k ;</span><br><span class="line"><span class="built_in">map</span>&lt;pint, <span class="keyword">int</span>&gt; S ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (!y) ? x : gcd(y, x % y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">F</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * ((n / k) * f[k] + f[n % k]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= x ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i, mu[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; x) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">            mu[i * pr[j]] = -mu[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= x ; ++ i)</span><br><span class="line">        smu[i] = smu[i - <span class="number">1</span>] + mu[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">s</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n || (k == <span class="number">1</span> &amp;&amp; n &lt; M))</span><br><span class="line">        <span class="keyword">return</span> smu[n] ; <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    pint t = mkp(n, k) ;</span><br><span class="line">    <span class="keyword">if</span> (S.count(t)) <span class="keyword">return</span> S[t] ;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">        ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">            r = n / (n / l) ;</span><br><span class="line">            ans -= (r - l + <span class="number">1</span>) * s(n / r, k) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i * i &lt;= k ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mu[i]) ans += s(n / i, i) ;</span><br><span class="line">                <span class="keyword">if</span> (i * i != k &amp;&amp; mu[k / i])</span><br><span class="line">                    ans += s(n / (k / i), k / i) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S[t] = ans ; <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>, last = <span class="number">0</span>, now ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = min(n / (n / l), m / (m / l)) ; now = s(r, k) ;</span><br><span class="line">        ans += (now - last) * (LL)(n / l) * F(m / l, k) ; last = now ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sieve(M - <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + (<span class="keyword">bool</span>)(gcd(i, k) == <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve()) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>uoj</category>
      </categories>
      <tags>
        <tag>数学/积性函数/莫比乌斯反演</tag>
        <tag>数学/积性函数求和/杜教筛</tag>
        <tag>数学/数论</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛学笔记】组合计数杂项</title>
    <url>/2020/02/17/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是听课听来的组合计数相关.jpg</p>
<a id="more"></a>
<h2 id="广义二项式定理"><a href="#广义二项式定理" class="headerlink" title="广义二项式定理"></a>广义二项式定理</h2><p>$a\in \mathbb{R}$</p>
<script type="math/tex; mode=display">
(x+y)^{a}=\sum_{k=0}^{\infty} \frac{a^{\underline k}}{k!} x^{k} y^{a-k}\\\</script><p>泰勒展开证明。</p>
<h2 id="抽屉原理一个比较有意思的表达"><a href="#抽屉原理一个比较有意思的表达" class="headerlink" title="抽屉原理一个比较有意思的表达"></a>抽屉原理一个比较有意思的表达</h2><p>把 $kx+b$ 个物品放进 $x$ 个盒子里 $(0&lt;b\leq k)$，必有 $1$ 个盒子里面至少有 $k+1$ 个物品。</p>
<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><script type="math/tex; mode=display">
h_n=\binom{2n}{n}-\binom{2n}{n-1}</script><p>方格行走数。</p>
<p>瞎jb走，从$0,0$到$n,0$，共$2n$次决策，选$n$次向下。</p>
<p>减去走错了的，考虑我们第一次走到 $y=-1$ 这条直线上，关于这条直线把 $(n,0)$ 对称下来，然后就变成了从 $(0,0)$ 走到 $(n,-2)$ 的问题，即选择 $n-1$ 步向上，$n+1$ 步向下。</p>
<p>然后，我sd了，原因在于我思考了半天为什么减去的贡献不用 $\times 2$，因为这不对称，结果发现原来走到 $y=1$ 是合法的，艹，脑袋莫得了。</p>
<h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><p>有符号的第一类斯特林数记作$\rm \mathrm{S}_s$，无符号记作$\rm \mathrm{S}_u$。</p>
<script type="math/tex; mode=display">
\mathrm{S}_s(n,m)=(-1)^{n+m}\mathrm{S}_u(n,m)</script><p>圆排列方案数。</p>
<p>同时 $\rm \mathrm{S}_s$ 的生成函数是 $x^{\underline{n}}$，即固定 $n$ 不变时，$\rm \mathrm{S}_s$ 的 $m$ 在 $1\to \infty$ 时的生成函数是 $x$ 的 $n$ 次下降幂。</p>
<p>（$n$ 固定下来之后的某一行）</p>
<h2 id="第二类斯特林数："><a href="#第二类斯特林数：" class="headerlink" title="第二类斯特林数："></a>第二类斯特林数：</h2><script type="math/tex; mode=display">
\begin{array}{l}{\mathrm{S}(n, m)=\mathrm{S}(n-1, m-1)+m * \mathrm{S}(n-1, m)} \\\ {\mathrm{S}(n, m)=\frac{1}{m !} \sum(-1)^{k}\left(\begin{array}{c}{m} \\ {k}\end{array}\right)(m-k)^{n}}\end{array}</script><p>贝尔数为第二类斯特林数之和，即把 $n$ 个数拆成 $k~(k\in \mathbb{N+})$ 集合的方案数之和。</p>
<p>ps：二斯都是不带标号的，似乎因为定义出来也没啥意义吧。</p>
<h2 id="拆分数的非OGF做法"><a href="#拆分数的非OGF做法" class="headerlink" title="拆分数的非OGF做法"></a>拆分数的非OGF做法</h2><p>第二类斯特林数实际上是<strong>$\boldsymbol{n}$带标号（n个不同物品），$\boldsymbol{m}$不带标号</strong>。</p>
<p>当$n,m$都无标号时，这个问题实际上就是<strong>拆分数</strong>问题，即$3=2+1$只代表一种情况，而如果有标号的话应该是三种情况（$C_3^2$）.</p>
<p>那么对于这个问题，考虑两种$dp$.</p>
<ul>
<li>1、令 $f_{i,j}$ 表示对于 $i$ 拆分成若干个不大于 $j$ 的数的方案数。则有转移：<script type="math/tex; mode=display">
f_{i,j}=f_{i,j-1}+f_{i-j,j}</script>后面一项 $f_{i-j,j}$ 可以看成一个背包一样，后面的状态对前面的状态有天然的累加效应，所以只需要考虑丢到一个 $j$ 的情况；而前面一项则把我们转移从后一项的<strong>等于</strong> $j$ 升级成为<strong>不大于</strong> $j$ 。</li>
<li>2、令 $g_{i,j}$ 表示对于 $i$ 拆分成 $j$ 个数的方案数。则有转移：<script type="math/tex; mode=display">
g_{i,j}=g_{i-1,j-1}+g_{i-j,j}</script>前面一项表示新拆出一个 $1$ 来，还是背包的那种“累加”思想，所以只需要考虑拆出一个 $1$ 的情况；后面一项则表示不拆，而是把拆出的数全体都 $+1$，即本来的 $5=3+1+1$ 转移到 $8=4+2+2$ 。注意此处不会存在“部分拆出来的数加了但是剩下的没加”或者“加的不一样”，因为这两个状态都是可以归约到 $i$ 较小的 $g$ 上去所以不需要额外转移。</li>
</ul>
<p>嗯，所以有时候状态的转移与设计存在“高阶状态对低阶状态有天然的累加效应”，换个不严谨的措辞就是<code>+</code>运算使得存在状态间的的相互归约。这是设计状态中需要考虑的一个新奇的东西。</p>
<p>ps：似乎某硬币xx的容斥题就用到了这个思想来着。。。实际上就是个背包吧qaq</p>
<h2 id="LOJ-6268-分拆数"><a href="#LOJ-6268-分拆数" class="headerlink" title="LOJ 6268 分拆数"></a>LOJ 6268 分拆数</h2><p>发现是 <code>#6</code> 的升级版。</p>
<p>考虑根号分治。先用 $f$ 求出来 $j\leq \sqrt n$ 的方案数，再魔改一下 $g$，让 $g$ 只转移那些 $\geq \sqrt n$ 的数字，具体就是第一维把 $\sqrt n$ 当作步长转移即可。</p>
<p>之后考虑合并这两个转移。发现最后转移完做一个累加，统计出两个多项式来，分别代表凑出体积 $i$ 的方案数。那么两个多项式的合并就是一个卷积的形式，就直接 $\rm NTT$ 做就完了。</p>
<h2 id="连通图计数"><a href="#连通图计数" class="headerlink" title="连通图计数"></a>连通图计数</h2><p>定义连通图的 $\rm EGF$ 为 $F(x)$，任意图的 $\rm EGF$ 为 $G(x)$ 。</p>
<p>考虑</p>
<script type="math/tex; mode=display">
G(x)=\sum_{n \geq 0} \frac{2^{n(n-1) / 2}}{n !} x^{n}</script><p>那么考虑一定有 $G(x)=e(F(x))$ ，即 $F(x)=\ln G(x)$ 。</p>
<p>这是因为任意图本身由任意个连通图构成，即考虑 $G$ 的另一种组成方式，从分成的连通块个数进行讨论。那么由 $n$ 个连通块构成的图，应该至少有 $F^n$ ，并且由于带标号且无序，所以 $F$ 应该用指数生成函数来刻画。</p>
<p>也就是从连通块的角度来考虑：</p>
<script type="math/tex; mode=display">
G=\sum\frac{F^n}{n!}</script><p>然后就可以肥宅快乐 $\exp$ 了。</p>
<p>大概类似于变换组合对象构造恒等式这种操作。</p>
<h2 id="Best-Theorem"><a href="#Best-Theorem" class="headerlink" title="Best Theorem"></a>Best Theorem</h2><p>一个有向图G，欧拉回路的数量是</p>
<script type="math/tex; mode=display">
t_{1}(G) * \prod_{i=1}^{n}(\operatorname{deg}(i)-1) !</script><p>其中 $t_1(G)$ 表示 $G$ 中以 $1$ 为根的生成树的数量。</p>
<h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><blockquote>
<p>给定一个 $n$ 个点 $m$ 条边的图，每条边有长度 $d_i$ 和价值 $v_i$。 随机选出一个长度和最小的生成树，求价值和的期望。 </p>
<p>$n, m ≤ 50$</p>
</blockquote>
<p>考虑如果长度都是 $1$（或者所有边长度均相同，本质是一样的），那么可以很方便地从每条边的贡献入手。大致就是考虑删掉一条边，用剩下的求一遍生成树计数，那么就可以算出这条边被选上的概率，这样就可以一条边一条边的计算贡献。复杂度 $mn^3$。</p>
<p>如果不是，那么考虑按照权值递增的顺序做如下过程：把当前最小的边拿出来，这样会是多个联通块。考虑在最后的生成树中，这样的边的权值一定会体现在其中，所以相当于每个联通块内选出一棵树，由于现在边权相等所以做法可以先用上一段里的方法。之后考虑把这个联通块缩成一个点，继续做下去，直到边满了为止。</p>
<p>似乎这样做不是很需要注意细节。因为本质上就是在重复一个贪心MST的过程。</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote>
<p>给定一张 $n$ 个点，$m$ 条边的无向图，每条边有红绿蓝三种颜色，要求绿边数量不超过 $g$, 蓝边不超过 $b$ 的生成树数量，答案对 $10^9 + 7$ 取模 </p>
<p>$n ≤ 40$</p>
</blockquote>
<p>考虑给每条绿边一个权值变量 $x$, 每条蓝边一个权值变量 $y$，根据扩展 MT 定理，最终只需要对着 $xy$ 的次数找系数即可。</p>
<p>而问题在于如何求这样一个行列式。考虑带入 $n^2$ 对点值给 $x$ 和 $y$，最终使用这些点值进行二维插值，恢复出本来的多项式。复杂度似乎是 $O(n^5)+O(n^4\sim n^6)$ 。</p>
<p><del>二维插值怎么可能会的嘛，所以复杂度不重要，反正我也不会去写。</del></p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><blockquote>
<p>给定一个带权无向图，定义一棵生成树的权值是边权和的 $k$ 次方，求所有生成树的权值和，答案对 $10^9 + 7$ 取模。 </p>
<p>$n, k ≤ 50$</p>
</blockquote>
<p>一步转化，考虑一堆数的 $k$ 次方等价于从这堆数里选出 $k$ 个可重复的数字的积 (考虑顺序)，再求和。 </p>
<p>那么可以将每条边的边权重新定义一个多项式 </p>
<script type="math/tex; mode=display">
∑^k_{i=0}\frac{(vx)^i}{i!}</script><p>表示一条边所代表的权值具体被选了若干次的权值。对新的权值使用 <code>Matrix-tree</code>, 得到一个 $nk$ 次的多项式，$x_k$ 的系数乘上 $k!$ 就是答案。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>泛学</category>
      </categories>
      <tags>
        <tag>思维题/计数</tag>
        <tag>组合计数/生成函数</tag>
        <tag>组合计数/有技巧的计数</tag>
        <tag>组合计数/斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】母函数Part3</title>
    <url>/2020/02/15/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是整理一下「伯努利数」吧…</p>
<p>其实还有一块关于切比雪夫不等式的内容，但是我觉得不是很有意思，决定不整理了.jpg</p>
<a id="more"></a>
<h1 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>考虑用母函数的方式定义。此处直接定义伯努利数的指数型母函数是：</p>
<script type="math/tex; mode=display">
\mathbf B=\frac{x}{e(x)-1}</script><p>那么考虑如何展开。记伯努利数为 $\{B_n\}$。发现移一下项</p>
<script type="math/tex; mode=display">
x=\left(B_0+B_1x+\frac{B_2}{2!}x^2\cdots\right) * \left(e(x)-1\right)</script><p>如果记右边卷出来的结果是 $\{a_n\}$，那么发现</p>
<script type="math/tex; mode=display">
a_n=\sum_{k=0}^{n-1}\binom{n}{k}B_k</script><p>此处上界为 $n-1$ 的原因是 $\left(e(x)-1\right)_0=0$ ，其余项均为 $1$ 。 </p>
<p>比较同次项系数可知</p>
<script type="math/tex; mode=display">
B_0=1\\
\sum_{k=0}^{n-1}\binom{n}{k}B_k=0\qquad (n=2,3,4\cdots)</script><p>考虑用这个方程去递推每一项。大致思路是左右两边同时加上 $B_n$ 。</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{n}\binom{n}{k}B_k=B_n</script><p>然后就可以发现，比如拿 $n=2$ 举例：</p>
<script type="math/tex; mode=display">
B_0+2B_1+B_2=B_2</script><p>就可以消掉 $B_2$ 求出 $B_1$。以此类推，每次用 $n$ 可以消出 $B_{n-1}$ 。</p>
<h2 id="一个小性质"><a href="#一个小性质" class="headerlink" title="一个小性质"></a>一个小性质</h2><p>考虑 $B_n$ 的性质，发现推出来的大概长这样：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&B_0=1\\
&B_1=-\frac{1}{2}\\
&B_2=\frac{1}{6}\\
&B_3=0\\
&B_4=-\frac{1}{30}\\
&B_5=0\\
&B_6=\frac{1}{42}\\
&B_7=0\\
&B_8=-\frac{1}{30}\\
&B_9=0\\
&B_{10}=\frac{5}{66}\\
&\cdots
\end{aligned}</script><p>发现似乎，除了 $B_1$ 之外，其余 $n$ 为奇数的时候均为 $0$ 。证明考虑：</p>
<script type="math/tex; mode=display">
\frac{x}{e(x)-1}=\sum \frac{B_n}{n!}x^n=1-\frac{x}{2}+\sum_{k=2}^{\infty}\frac{B_k}{k!}x^k</script><p>那么如果令</p>
<script type="math/tex; mode=display">
f(x)=\frac{x}{e(x)-1}+\frac{x}{2}</script><p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(-x)&=\frac{-x}{e(-x)-1}-\frac{x}{2}\\
&=\frac{-x}{\frac{1}{e(x)}-1}-\frac{x}{2}\\
&=\frac{-xe(x)}{1-e(x)}-\frac{x}{2}\\
&=x-\frac{x}{1-e(x)}-\frac{x}{2}\\
&=\frac{x}{e(x)-1}+\frac{x}{2}\\
&=f(x)
\end{aligned}</script><p>可知 $f(x)$ 是偶函数，那么也就是 </p>
<script type="math/tex; mode=display">
1+\sum_{k=2}^{\infty}\frac{B_k}{k!}x^k</script><p>是偶函数。考虑他是偶函数的条件，当且仅当所有奇次幂系数都为 $0$ 的时候，才会是偶函数。所以可以证明上面的结论。</p>
<h2 id="伯努利多项式"><a href="#伯努利多项式" class="headerlink" title="伯努利多项式"></a>伯努利多项式</h2><p>考虑观察下列两个EGF的卷积：</p>
<script type="math/tex; mode=display">
\frac{x}{e(x)-1}*e(tx)</script><p>其中 $t$ 是任意常数。考虑记卷积结果为 $\beta(t)$ 。那么显然</p>
<script type="math/tex; mode=display">
\beta_n(t)=\sum_{k=0}^n\binom{n}{k}B_kt^{n-k}</script><p>记这样的多项式为伯努利多项式。这个多项式有个很有用的性质：</p>
<script type="math/tex; mode=display">
\beta_{n+1}(t + 1)-\beta_{n+1}(t)=t^n(n+1)\qquad(n=0,1,2,3\cdots)</script><p>考虑直接做差法证明。首先设出两个式子：</p>
<script type="math/tex; mode=display">
\frac{xe(tx)}{e(x)-1}=\sum\frac{\beta_n(t)}{n!}x^n\qquad(1)\\
\frac{xe((t+1)x)}{e(x)-1}=\sum\frac{\beta_n(t+1)}{n!}x^n\qquad(2)\\</script><p>$(2)-(1)$ 得到</p>
<script type="math/tex; mode=display">
\frac{xe(tx)[e(x)-1]}{e(x)-1}=\sum\frac{\beta_n(t+1)-\beta_n(t)}{n!}x^n</script><p>即</p>
<script type="math/tex; mode=display">
xe(tx)=\sum\frac{\beta_n(t+1)-\beta_n(t)}{n!}x^n</script><p>比较系数可知</p>
<script type="math/tex; mode=display">
\frac{\beta_n(t+1)-\beta_n(t)}{n!}=\frac{t^{n-1}}{(n-1)!}</script><p>变一下形就可以得到：</p>
<script type="math/tex; mode=display">
\beta_{n+1}(t + 1)-\beta_{n+1}(t)=t^n(n+1)</script><h2 id="用伯努利多项式求自然数的-k-次方和"><a href="#用伯努利多项式求自然数的-k-次方和" class="headerlink" title="用伯努利多项式求自然数的 $k$ 次方和"></a>用伯努利多项式求自然数的 $k$ 次方和</h2><p>考虑决定自然数 $k$ 次方的要素在于下标 $n$ 。于是考虑所有自然数的 $k$ 次方和就是这样：</p>
<script type="math/tex; mode=display">
(k+1)\mathbf S^{(k)}=\sum_{i=1}^{\infty}\left(\beta_{k+1}(i+1)-\beta_{k+1}(i)\right)</script><p>展开之后</p>
<script type="math/tex; mode=display">
\mathbf S_n^{(k)}=\frac{\left(\beta_{k+1}(n+1)-\beta_{k+1}(1)\right)}{k+1}</script><p>也就是</p>
<script type="math/tex; mode=display">
\mathbf S_n^{(k)}=\frac{1}{k+1}\sum_{r=1}^{k+1}\binom{k+1}{r}B_{k+1-r}(n+1)^{r}</script><p>其中 $r=0$ 时减掉了 $\beta_{k+1}(1)$ 这一项。</p>
<p>发现本质上可以 $k\log k$ 用 $\exp$ 来预处理伯努利数，然后就可以 $O(k)$ 算不限制 $n$ 时的 $k$ 次方和了。</p>
<p>emmm似乎预处理也不用 $\rm exp$ ，$e(x)-1$ 直接写出来，然后直接多项式求逆就可以了？</p>
<p>但显然这个方法被线性插值给爆锤了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>组合计数/生成函数</tag>
        <tag>数学/伯努利数</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】母函数Part2</title>
    <url>/2020/02/14/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一部分大概是从「特征多项式」整理到「指数型母函数及其应用」。</p>
<a id="more"></a>
<h1 id="特征多项式"><a href="#特征多项式" class="headerlink" title="特征多项式"></a>特征多项式</h1><h2 id="齐次"><a href="#齐次" class="headerlink" title="齐次"></a>齐次</h2><p>考虑对于一个以 $\{c_i\}$ 为递推转移的 $k$ 阶线性循环数列 $\{a_i\}$ 的母函数，根据构造似乎可以被写成这样的形式：</p>
<script type="math/tex; mode=display">
\frac{b_0+b_1x+b_2x^2\cdots b_{m}x^{m}}{1-c_1x-c_2x^2-c_3x^3\cdots -c_kx^k}</script><p>$\{b_i\},m$ 都是根据实际情况会变的参数。</p>
<p>那么可以发现这样的恒等的关系：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{b_0+b_1x+b_2x^2\cdots b_{m}x^{m}}{1-c_1x-c_2x^2-c_3x^3\cdots -
c_kx^k}&=a_0+a_1x+a_2x^2\cdots +a_nx^n+\cdots\\
b_0+b_1x+b_2x^2\cdots b_{m}x^{m}&=(a_0+a_1x+a_2x^2\cdots +a_nx^n+\cdots)\times(1-c_1x-c_2x^2-c_3x^3\cdots -
c_kx^k)\\
\end{aligned}</script><p>即</p>
<script type="math/tex; mode=display">
\begin{aligned}
&b_0=a_0,\\
&b_1=a_1-c_1a_0,\\
&b_2=a_2-c_1a_1-c_2a_0\\
&\cdots,\\
&b_{k-1}=a_{k-1}-\sum_{i=1}^{k-1}c_ia_{k-1-i},\\
&\cdots,\\ 
&b_p=a_p-\sum_{i=1}^{k}c_i=0\quad \mathrm{if}~(p\geq k) 
\end{aligned}":</script><p>可以发现分子上的多项式至多有 $k-1$ 次.</p>
<p>像这种根据递推方式快速确定的一个线性循环数列母函数的方法，称为特征法。而多项式</p>
<script type="math/tex; mode=display">
1-c_1x-c_2x^2-\cdots c_kx^k</script><p>则称为 $\{a_i\}$ 的特征多项式。</p>
<p>e.g.</p>
<blockquote>
<p>求</p>
<script type="math/tex; mode=display">
a_n=a_{n-1}+9a_{n-2}-9a_{n-3},a_0=1,a_1=1,a_2=2</script><p>的通项。</p>
</blockquote>
<hr>
<p>首先分解因式</p>
<script type="math/tex; mode=display">
(1-x-9x^2-9x^3)=(1-3x)(1+3x)(1-x)</script><p>并且观察到 $b_0=1,b_1=0,b_2=-8$。</p>
<p>那么不妨设</p>
<script type="math/tex; mode=display">
\frac{a}{1-3x}+\frac{b}{1+3x}+\frac{c}{1-x}=\frac{1-8x^2}{1-x-9x^2-9x^3}</script><p>解得</p>
<script type="math/tex; mode=display">
a=\frac{1}{12},b=\frac{1}{24},c=\frac{7}{8}</script><p>那么就可以知道 $\frac{1-8x^2}{1-x-9x^2-9x^3}$ 的展开是：</p>
<script type="math/tex; mode=display">
\sum_{n=1}^{\infty}(\frac{1}{12}\cdot 3^n+\frac{1}{24}(-1)^n3^n+\frac{7}{8})x^n</script><p>那么通项就是</p>
<script type="math/tex; mode=display">
a_n=\frac{1}{12}\cdot 3^n+\frac{1}{24}(-1)^n3^n+\frac{7}{8}</script><h2 id="非齐次"><a href="#非齐次" class="headerlink" title="非齐次"></a>非齐次</h2><p>非齐次的话，可以直接把常数构造在系数里，本质上没什么不同的。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><blockquote>
<p>（1）用 $1,2,3$ 三个数来构造一个 $n$ 位数。不允许两个 $1$ 相邻，求方案数。</p>
</blockquote>
<p>发现如果第一位放 $2$ 或 $3$ ，那么有 $2\cdot a_{n-1}$ 的方案；如果放 $1$，那么第二维只能放 $2$ 或 $3$ ，那么有 $2\cdot a_{n-2}$ 的方案。所以有 $a_n=2a_{n-1}+2a_{n-2}$ 。</p>
<blockquote>
<p>（2）有一行方格，每个格子可以放黑色或者白色，白色不能相邻地放。求方案树。</p>
</blockquote>
<p>发现还是讨论第一个位置放的是不是白色。$f_n=f_{n-1}+f_{n-2}$ 。</p>
<h1 id="高阶差分"><a href="#高阶差分" class="headerlink" title="高阶差分"></a>高阶差分</h1><h2 id="一点定义"><a href="#一点定义" class="headerlink" title="一点定义"></a>一点定义</h2><p>定义 $\{a_i\}$ 的一阶差分 $\Delta^1\{a_i\}$ 是这样的数列 $\{a_1-a_0,a_2-a_1,\cdots,a_n-a_{n-1}\}$ 。</p>
<p>那么 $k$ 阶差分指的是 $\Delta^k\{a_i\}=\Delta\{\Delta^{k-1}\{a_i\}\}$ 。</p>
<p>假设一个数列 $\{a_i\}$ 在 $k$ 阶差分时不是全 $0$ 数列，在 $k+1$ 阶差分时是全 $0$ 数列，那么称这个数列为 $k$ 阶等差数列。</p>
<h2 id="一个定理"><a href="#一个定理" class="headerlink" title="一个定理"></a>一个定理</h2><blockquote>
<p> 如果记 $\Delta^k\{a_i\}:\{a_0^{(k)},a_1^{(k)},a_2^{(k)},\cdots,a_n^{(k)}\cdots \}$，那么有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
a_n^{(k)}&=a_{n+k}-\binom{k}{1}a_{n+k-1}+\binom{k}{2}a_{n+k-2}-\cdots+(-1)^ka^n\\
&=\sum_{i=0}^k(-1)^i\binom{k}{i}a_{n+k-i}
\end{aligned}</script></blockquote>
<p>这个显然可以直接归纳。就懒得证了。</p>
<h2 id="k-阶等差数列-a-n-的前-n-项和。"><a href="#k-阶等差数列-a-n-的前-n-项和。" class="headerlink" title="$k$ 阶等差数列 $\{a_n\}$ 的前 $n$ 项和。"></a>$k$ 阶等差数列 $\{a_n\}$ 的前 $n$ 项和。</h2><p>考虑对于数列 $\{s_n\}$ ，满足 $s_i=\sum_{j=0}^ia_i$，那么发现可以直接让 $\{a_n\}*(\frac{1}{1-x})$ 得到 $\{s_n\}$</p>
<script type="math/tex; mode=display">
\left(\sum a_nx^n\right)*\left(\sum x^n\right)=\sum_{n=0}^{\infty}\left(\sum_{j=0}^n a_j\right)x=\sum s_nx^n</script><p>所以假设 $\{a_n\}$ 的母函数是 $f(x)$，那么 $\{s_n\}$ 的母函数就是 $\frac{f(x)}{1-x}$。</p>
<p>那么考虑如何计算 $f(x)$ 。根据性质可知：</p>
<script type="math/tex; mode=display">
a_n^{(k+1)}=a_{n+k+1}-\binom{k+1}{1}a_{n+k}+\binom{k+1}{2}a_{n+k-1}-\cdots+(-1)^{k+1}a^n</script><p>那么由于 $a_{n}^{(k+1)}=0$ ，所以可以得到：</p>
<script type="math/tex; mode=display">
a_{n+k+1}=\binom{k+1}{1}a_{n+k}-\binom{k+1}{2}a_{n+k-1}+\cdots-(-1)^{k+1}a^n</script><p>发现本质上 $\binom{k+1}{x}$ 属于常数项。所以可以知道 $\{a_n\}$ 是一个 $k+1$ 个线性循环数列。所以可以用特征法直接求出。</p>
<p>但其实这种方法有时候比归纳要麻烦很多。这种方法主要用来解决一些比较妙的问题。</p>
<h2 id="一点应用"><a href="#一点应用" class="headerlink" title="一点应用"></a>一点应用</h2><p>e.g.</p>
<blockquote>
<p> 给定 $n$ ，求坐标系中 $|x|+|y|=m,(m=0,1,2,3\cdots n)$ 的 $(x,y)$ 点对数。</p>
</blockquote>
<p>考虑设 $\{a_i\}$ 表示 $i=m$ 时的方案数，$\{s_i\}$ 即为所求。那么可以知道 $a_i$ 的母函数为：</p>
<script type="math/tex; mode=display">
f(x)=(1+2x+2x^2+2x^3+\cdots +2x^n+\cdots)^2</script><p>看上去十分 $easy$，因为每个坐标有$+-$ 两种取值，所以加一个系数 $2$ 。</p>
<p>那么发现可以这么转化：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)&=(1+2x+2x^2+2x^3+\cdots +2x^n+\cdots)^2\\
&=(1+2x(1+x+x^2+\cdots+x^n+\cdots))^2\\
&=(1+\frac{2x}{1-x})^2\\
&=(\frac{1+x}{1-x})^2
\end{aligned}</script><p>所以 $\{s_n\}$ 的母函数 $f_s(x)$ 为</p>
<script type="math/tex; mode=display">
f_s(x)=\frac{f(x)}{1-x}=\frac{(x+1)^2}{(1-x)^3}</script><p>发现 $(1-x)$ 是它的 $3$ 重根，所以有：</p>
<script type="math/tex; mode=display">
f_s(x)=\frac{4}{(1-x)^3}-\frac{4}{(1-x)^2}+\frac{1}{1-x}</script><p>那么可以展开得到：</p>
<script type="math/tex; mode=display">
f_s(x)=\sum_{i=0}^{\infty}\left[4\binom{n+2}{2}-4(n+1)+1\right]x^n</script><p>于是可知 $s_n=2n^2+2n+1$ 。</p>
<h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>首先发现卡特兰数的定义式就是</p>
<script type="math/tex; mode=display">
a_n=\sum_{k=1}^{n}a_{n-k}a_{k}</script><p>那么这东西的母函数大概可以这么求（默认第 $0$ 为位是 $0$ 而不考虑）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f^2(x)&=\left(\sum a_ix^i\right)^2\\
&= a_1^2x^2+(a_1a_2+a_2a_1)x^3+(a_1a_3+a_2a_2+a_3a_1)x^4\cdots+\left(\sum_{i=1}^{n}a_{i}a_{n-i}\right) x^n+\cdots\\
&=f(x)-a_1x

\end{aligned}</script><p>那么解一下方程可以得到俩根：</p>
<script type="math/tex; mode=display">
f_1(x)=\frac{1-\sqrt{1-4x}}{2},f_2(x)=\frac{1+\sqrt{1-4x}}{2}</script><p>验一下发现应该取 $f_1$.</p>
<p>在不考虑牛顿迭代的情况下，不加证明地给出一个等式：</p>
<script type="math/tex; mode=display">
\sqrt{1+x}=1+\sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n 2^{2 n-1}} \binom{2(n-1)}{n-1} x^{n}</script><p>那么代换一下可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sqrt{1-4 x} &=1+\sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n 2^{2 n-1}} \binom{2(n-1)}{n-1}(-4 x)^{n} \\
&=1+\sum_{n=1}^{\infty} \frac{(-1)^{2 n-1}}{n 2^{2 n-1}} 4^{n} \binom{2(n-1)}{n-1} x^{n} \\
&=1-\sum_{n=1}^{\infty} \frac{2}{n} \binom{2(n-1)}{n-1} x^{n}
\end{aligned}</script><p>再带回去得到：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{n=1}^{\infty}\frac{\binom{2(n-1)}{n-1}}{n} x^n</script><p>那么可知卡特兰数第 $n$ 项 $\mathrm{Cat}_n=\frac{\binom{2(n-1)}{n-1}}{n}$。</p>
<p>当然一般情况下 $\rm Cat$ 的定义有从 $0$ 开始的，只是把这种方式向前平移了一项而已。</p>
<h1 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h1><h2 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h2><p>出于需要，定义另一种生成函数，即指数型母函数 $(\mathbf{EGF})$ 。对于数列 $\{a\}$，他的 $\rm EGF$  是：</p>
<script type="math/tex; mode=display">
\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n</script><p>那么可以得出两个 $\rm EGF$ 卷积的结果是：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n
&= \left(\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n\right)\cdot \left(\sum_{n=0}^{\infty}\frac{b_n}{n!}x^n\right)\\
&= \sum_{n=0}^{\infty} x^n\sum_{i+j=n}\frac{a_ib_j}{i!j!}\\
&= \sum_{n=0}^{\infty} \frac{1}{n!}x^n\sum_{i+j=n}\left(a_ib_j\cdot\frac{n!}{i!j!}\right)\\
\end{aligned}</script><p>可以发现有</p>
<script type="math/tex; mode=display">
c_n=\sum_{k=0}^n\binom{n}{k}a_kb_{n-k}</script><p>那么之所称之为指数型母函数，则依赖于下面的性质：</p>
<p>令</p>
<script type="math/tex; mode=display">
e(x)=1+x+\frac{x^2}{2!}+\cdots +\frac{x^n}{n!}+\cdots</script><p>可以发现有</p>
<script type="math/tex; mode=display">
e(x)e(y)=e(x+y)</script><p>证明大概是可以把 $e(y)$ 改写成</p>
<script type="math/tex; mode=display">
e(y)=\sum \frac{1}{n!}(\frac{y}{x})^nx^n</script><p>然后</p>
<script type="math/tex; mode=display">
\begin{aligned}
e(x)e(y)&=\left(\sum \frac{1}{n!}x^n\right)\cdot \left[\sum \frac{1}{n!}(\frac{y}{x})^nx^n\right]\\
&=\sum \frac{\sum_{k=0}^n\binom{n}{k}\cdot (\frac{y}{x})^k}{n!}x^n\\
&=\sum \frac{(1+\frac{y}{x})^n}{n!}x^n\\
&=\sum \frac{\frac{1}{x^n}(x+y)^n}{n!}x^n\\
&=\sum \frac{(x+y)^n}{n!}\\
&= e(x+y)
\end{aligned}</script><p>发现这种性质类似于指数运算的性质，所以称之为指数型母函数。</p>
<p>同时可知，令 $y=-x$ 则有 $e(x)=\frac{1}{e(-x)}$ 。</p>
<h2 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h2><blockquote>
<p>设 $\{a_n\}$ 给定，且</p>
<script type="math/tex; mode=display">
b_n=\sum_{i=0}^n\binom{n}{i}(-1)^ia_i</script><p>则必有</p>
<script type="math/tex; mode=display">
a_n=\sum_{i=0}^n\binom{n}{i}(-1)^ib_i</script></blockquote>
<p>考虑让数列 $\{(-1)^na_n\}$ 的母函数卷上 $e(x)$ 得到：</p>
<script type="math/tex; mode=display">
e(x)*\sum\frac{(-1)^na_n}{n!}x^n=\sum\frac{\sum_{k=0}^n\binom{n}{k}(-1)^ka_k}{n!}x^n=\sum\frac{b_n}{n!}x^n</script><p>也就是</p>
<script type="math/tex; mode=display">
\sum\frac{(-1)^na_n}{n!}x^n=\frac{1}{e(x)}*\sum\frac{b_n}{n!}x^n</script><p>因为 $\frac{1}{e(x)}=e(-x)$ ，所以有：</p>
<script type="math/tex; mode=display">
\sum\frac{(-1)^na_n}{n!}x^n=\sum(-1)^n\frac{\sum_{k=0}^n\binom{n}{k}(-1)^kb_k}{n!}x^n</script><p>对比第 $n$ 项即可得到</p>
<script type="math/tex; mode=display">
a_n=\sum_{k=0}^n\binom{n}{k}(-1)^kb_k</script><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><script type="math/tex; mode=display">
\sum_{k=1}^n(-1)^k\binom{n}{k}\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{k}\right)=-\frac{1}{n}</script><p>首先有一个比较 <code>general</code> 的结论：</p>
<script type="math/tex; mode=display">
\sum_{k=0}^n\frac{(-1)^k}{k+1}\binom{n}{k}=\frac{1}{n+1}\qquad(1)</script><p>这是由于</p>
<script type="math/tex; mode=display">
\binom{n+1}{k+1}=\frac{n+1}{k+1}\binom{n}{k}</script><p>那么稍微变一下形态：</p>
<script type="math/tex; mode=display">
\sum_{k=0}^n(-1)^k\frac{n+1}{k+1}\binom{n}{k}=\sum_{k=1}^{n+1}(-1)^k\binom{n+1}{k}=1+(1-1)^n=1</script><p>移个项就完了。</p>
<p>那么根据这个可以再证明出一个更强一点的结论：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^n\frac{(-1)^{k-1}}{k}\binom{n}{k}=1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\qquad (2)</script><p>考虑直接归纳。不难验证 $n=1$ 成立。那么考虑 $n\to n+1$ 的过程</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{k=1}^{n+1}\frac{(-1)^{k-1}}{k}\binom{n+1}{k}
\\=&\sum_{k=1}^{n+1}\frac{(-1)^{k-1}}{k}\left(\binom{n}{k}+\binom{n}{k-1}\right)
\\=&\sum_{k=1}^{n}\frac{(-1)^{k-1}}{k}\binom{n}{k}+\sum_{k=0}^{n}\frac{(-1)^{k+1}}{k}\binom{n}{k}
\\=&\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\right)+\frac{1}{n+1}
\end{aligned}</script><p>其中最后一步用的就是上面的 $(1)$。</p>
<p>那么回到本题，考虑设 $a_0=0, a_n=-\frac{1}{n}\quad (n=1,2,3\cdots )$ 。同时设 $b_0=0$，</p>
<script type="math/tex; mode=display">
b_n=\sum_{i=0}^n\binom{n}{i}(-1)^ia_i=\sum_{i=0}^n\frac{(-1)^{i+1}}{i}\binom{n}{i}</script><p>那么根据 $(2)$ 和二项式反演可以得到</p>
<script type="math/tex; mode=display">
b_n=\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{n}\right)\\
\sum_{k=1}^n(-1)^k\binom{n}{k}\left(1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{k}\right)=\sum_{k=1}^n(-1)^kb_k=a_n=-\frac{1}{n}</script><h1 id="指数型母函数的应用"><a href="#指数型母函数的应用" class="headerlink" title="指数型母函数的应用"></a>指数型母函数的应用</h1><h2 id="有限制的可重排列问题"><a href="#有限制的可重排列问题" class="headerlink" title="有限制的可重排列问题"></a>有限制的可重排列问题</h2><blockquote>
<p>给定 $n$ 个物品，从中取 $r$ 个进行排列，第 $k~(k=1,2,3\cdots m)$ 种物品有 $n_k$ 个，求排列方案数。</p>
</blockquote>
<p>首先给出这东西的母函数：</p>
<script type="math/tex; mode=display">
f_e(x)=\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_1}}{n_1!}\right)*\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_2}}{n_2!}\right)*\cdots*\left(1+x+\frac{x^2}{2!}+\cdots+\frac{x^{n_m}}{n_m!}\right)</script><p>考虑这样表示的意义。对于 $f_e(x)$ 的第 $r+1$ 项，有：</p>
<script type="math/tex; mode=display">
[x^r]f_e(x)=\frac{x^{d_1}}{d_1!}\cdot\frac{x^{d_2}}{d_2!}\cdot\frac{x^{d_3}}{d_3}\cdots\frac{x^{d_m}}{d_m!}</script><p>其中 $\{d_m\}$ 可以看做是满足 $d_1+d_2+\cdots+d_m=r$ 的一组枚举量。</p>
<p>考虑这样做的可行性。首先变一下形</p>
<script type="math/tex; mode=display">
\begin{aligned}
&[x^r]f_e(x)\\
&=\frac{x^{d_1}}{d_1!}\cdot\frac{x^{d_2}}{d_2!}\cdot\frac{x^{d_3}}{d_3}\cdots\frac{x^{d_m}}{d_m!}\\
&=\frac{r!}{\prod d_i!}\cdot\frac{x^r}{r!}
\end{aligned}</script><p>发现第 $r+1$ 项的系数 $\frac{r!}{\prod d_i!}$，正好是从 $r$ 个物品中，共 $m$ 中，每种分别有 $d_i$ 个，取满 $r$ 个的方案数。所以正确性显然。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote>
<p>用 $1,2,3,4$ 四个数字能组成多少五位数？要求 $1$ 只能出现 $2$ 或 $3$ 次，$2$ 出现 $0$ 或 $1$ 次，$3$ 没有限制， $4$ 出现偶数次。</p>
</blockquote>
<p>这个问题的母函数显然就是这个：</p>
<script type="math/tex; mode=display">
f_e(x)=\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot \left(1+x\right)\cdot e(x)\cdot \left[1+\frac{x^2}{2!}+\frac{x^4}{4!}+\cdots+\frac{x^{2n}}{(2n)!}+\cdots\right]</script><p>考虑一个性质</p>
<script type="math/tex; mode=display">
1+\frac{x^2}{2!}+\frac{x^4}{4!}+\cdots+\frac{x^{2n}}{(2n)!}+\cdots=\frac{e(x)+\frac{1}{e(x)}}{2}</script><p>那么原式就变成了</p>
<script type="math/tex; mode=display">
\begin{aligned}f_e(x)&=\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)\cdot e(x)\cdot \frac{1}{2}\left(e(x)+\frac{1}{e(x)}\right)\\&=\frac{e(2x)}{2}\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)+\frac{1}{2}\left(\frac{x^2}{2!}+\frac{x^3}{3!}\right)\cdot\left(1+x\right)\end{aligned}</script><p>发现本质上右边不存在 $x^5$ 这一项，所以忽略。</p>
<p>于是最后通过化简可知答案是 $140$ .</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>数学/常系数齐次线性递推</tag>
        <tag>组合计数/生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】母函数Part1</title>
    <url>/2020/02/13/%E3%80%8A%E6%AF%8D%E5%87%BD%E6%95%B0%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是好久之前的学习笔记？</p>
<p>边复习边发吧。其实MO再不做题的时候，拿来磨磨脑子也挺有意思的。</p>
<p>这一部分大概是从「基础组合计数」到「一般型母函数」，再到「线性循环数列」。</p>
<a id="more"></a>
<h1 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h1><h2 id="一点瞎扯"><a href="#一点瞎扯" class="headerlink" title="一点瞎扯"></a>一点瞎扯</h2><p>考虑二项式定理 $(x+y)^n=\sum\binom{n}{i}x^iy^{n-i}$，由于展开成了二元多项式的形式，所以存在卷积性质。利用此或可证明一些东西。</p>
<h2 id="一点有趣的证明题"><a href="#一点有趣的证明题" class="headerlink" title="一点有趣的证明题"></a>一点有趣的证明题</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><blockquote>
<p>证明：</p>
<script type="math/tex; mode=display">
\sum_{x=1}^n x\cdot\binom{n}{x}=n\cdot 2^{n-1}</script></blockquote>
<p>考虑一个式子：$\binom{n}{k}=\frac{n}{k}\binom{n-1}{k-1}$。那么对于原式的右边就可以化成</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{x=1}^n x\cdot\binom{n}{x}\\
=&\sum_{x=1}^n n\cdot \binom{n-1}{x-1}\\
=&n\cdot 2^{n-1}
\end{aligned}</script><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote>
<p>证明</p>
<script type="math/tex; mode=display">
\binom{n}{k}=\binom{n-1}{k-1}+\binom{n-1}{k}</script></blockquote>
<p>考虑 $(1+x)^{n+1}$ 的两种展开方式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
(1+x)^{n+1}=&\sum \binom{n+1}{i+1}x^{i+1}\\
(1+x)^{n+1}
=&(1+x)\sum \binom{n}{i}x^{i}\\
=&\sum \binom{n}{i}\left(x^{i}+x^{i+1}\right)\\
=&\sum \left(\binom{n}{i}+\binom{n}{i+1}\right)x^{i+1}
\end{aligned}</script><p>比较两个多项式中 $i+1$ 项的系数，可知证毕。</p>
<h1 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h1><h2 id="关于-frac-1-1-x"><a href="#关于-frac-1-1-x" class="headerlink" title="关于 $\frac{1}{1-x}$"></a>关于 $\frac{1}{1-x}$</h2><p>设该商为 $\sum c_nx^n$。那么有</p>
<script type="math/tex; mode=display">
1=(1-x)\sum c_ix^i\\
1=c_0+\sum(c_i-c_{i-1})x^i\\</script><p>可知 $c_0=1,c_i=c_{i-1}$ 。所以每一项的系数都为 $1$ 。故有形式幂级数基本定理：</p>
<script type="math/tex; mode=display">
1+x+x^2+x^3\cdots=\frac{1}{1-x}</script><h2 id="一系列求母函数例子"><a href="#一系列求母函数例子" class="headerlink" title="一系列求母函数例子"></a>一系列求母函数例子</h2><script type="math/tex; mode=display">
\begin{aligned}
\{C_n^{n},C_{n+1}^n,C_{n+2}^{n}\cdots\}&\to\sum \binom{n+i}{n}x^i=\frac{1}{(1-x)^{n+1}}\\
\{1,5,25,125\cdots\}&\to\sum 5^ix^i=\sum{5x^i}=\frac{1}{(1-5x)}\\
\{0,1\times 2,2\times 3,3\times 4\cdots\}&\to\sum (i+1)\cdot i\cdot x^i=\sum x^i\cdot 2\sum_{j=1}^ij=(\sum i\cdot x^i)*(\sum 2x^i)=\frac{2}{1-x}\cdot\frac{x}{(1-x)^2}\\
\{0,0,0,-1,1,-1,1\cdots\} & \to \sum_{i=3}^{\infty}(-1)^ix^i=x^3\sum(-x)^i=\frac{x^3}{1+x}\\

\end{aligned}</script><h1 id="部分分式"><a href="#部分分式" class="headerlink" title="部分分式"></a>部分分式</h1><p>这一章的作用在于把一个复杂的计数问题转化为许多个简单的 $\rm OGF$ 的形式。</p>
<h2 id="预备定理"><a href="#预备定理" class="headerlink" title="预备定理"></a>预备定理</h2><blockquote>
<p>设 $\frac{P(x)}{Q(x)}$ 是一个真分式，$a$ 是 $Q(x)$ 的一个 $k$ 重根，那么存在一个数列 $A_{1\sim k}$ 使得</p>
<script type="math/tex; mode=display">
\frac{P(x)}{Q(x)}=\sum_{i=1}^k\frac{A_i}{(x-a)^i}+\frac{P'(x)}{Q'(x)}</script><p>其中 $\frac{P’(x)}{Q’(x)}$ 依旧是真分式。</p>
</blockquote>
<p>懒得证了。感性理解。</p>
<h2 id="部分分式定理"><a href="#部分分式定理" class="headerlink" title="部分分式定理"></a>部分分式定理</h2><blockquote>
<p>设 $\frac{P(x)}{Q(x)}$ 是一个真分式，如果 $a_1,a_2,\cdots a_m$ 分别是多项式 $Q(x)$ 的 $k_1,k_2,\cdots k_m$ 重根。那么存在一张数表 $\mathbf A$ ，使得</p>
<script type="math/tex; mode=display">
\frac{P(x)}{Q(x)}=\sum_{i=1}^m\sum_{j=1}^{k_i}\frac{\mathbf A_{i,j}}{(x-a_i)}</script></blockquote>
<p>由预备定理可知显然。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h3><blockquote>
<p> 分解 $\frac{1}{x^3-x^2-x+1}$ 为部分分式。</p>
</blockquote>
<p>首先因式分解可以知道 $1$ 是他的二重根，$-1$ 是他的一重根。那么可以根据部分分式定理得到</p>
<script type="math/tex; mode=display">
\frac{1}{x^3-x^2-x+1}=\frac{a}{(x-1)^2}+\frac{b}{x-1}+\frac{c}{x-1}</script><p>两边通分后发现是个恒等式，于是就可以对 $x$ 用特殊值法得到 </p>
<script type="math/tex; mode=display">
a=\frac{1}{2},b=-\frac{1}{4},c=\frac{1}{4}</script><p>然后就没有然后了。</p>
<h3 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h3><blockquote>
<p>将分解 $\frac{6x^2+22x+18}{x^3+6x^2+11x+6}$ 为部分分式</p>
</blockquote>
<p>继续考虑将分母因式分解。即</p>
<script type="math/tex; mode=display">
x^3+6x^2+11x+6=(x+1)\cdot (x+2)\cdot (x+3)</script><p>那么之后就变成sb题了，分解为 $\frac{1}{x+1}+\frac{2}{x+2}+\frac{3}{x+3}$。</p>
<h1 id="简单组合问题"><a href="#简单组合问题" class="headerlink" title="简单组合问题"></a>简单组合问题</h1><h2 id="一般组合问题"><a href="#一般组合问题" class="headerlink" title="一般组合问题"></a>一般组合问题</h2><blockquote>
<p> 设有 $n$ 种不同的物体，分别只能取 $a_1,a_2,a_3\cdots a_n$ 个，如果要取 $r$ 个，有多少种方案。</p>
</blockquote>
<p>形式幂级数大概就是</p>
<script type="math/tex; mode=display">
\prod _{i=1}^n(1+x+x^2+\cdots+x^{a_i})</script><p>这样。或者考虑一个更特殊的问题，从 $n$ 个不同物品里可以重复地取出 $r$ 个的方案数：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^n(1+x+x^2+\cdots)=\frac{1}{(1-x)^n}</script><p>由上面的形式幂级数展开可以知道，这个东西的第 $r$ 项是 $\binom{n-1+r}{n-1}=\binom{n+r-1}{r}$，是个常见的结论。</p>
<h2 id="砝码模型"><a href="#砝码模型" class="headerlink" title="砝码模型"></a>砝码模型</h2><blockquote>
<p>设有 $n$ 种砝码，质量分别为 $c_1,c_2\cdots c_n$，分别有 $b_1,b_2\cdots b_n$ 枚，求一共可以称出多少种不同质量的物品。</p>
</blockquote>
<p>这个东西的形式幂级数大概是</p>
<script type="math/tex; mode=display">
\prod_{i=1}^n (1+x^{c_i}+x^{2\cdot c_i}+x^{3\cdot c_i}+\cdots+x^{b_i\cdot c_i})</script><h2 id="不定方程相关"><a href="#不定方程相关" class="headerlink" title="不定方程相关"></a>不定方程相关</h2><blockquote>
<p>求</p>
<script type="math/tex; mode=display">
p_1x_1+p_2x_2+\cdots+p_nx_n=r</script><p>的非负整数解个数。</p>
</blockquote>
<p>很显然是 </p>
<script type="math/tex; mode=display">
\prod_{i=1}^n (1+x^{p_i}+x^{2\cdot p_i}+\cdots)</script><p>这里继续把 $1$ 当作一个物品，每个变量只能拿 $p_i$ 的倍数个就很好理解了。</p>
<p>那么这东西的母函数显然是</p>
<script type="math/tex; mode=display">
\frac{1}{(1-x^{p_1})(1-x^{p_2})(1-x^{p_3})\cdots(1-x^{p_n})}</script><h2 id="有关分拆数的拓展"><a href="#有关分拆数的拓展" class="headerlink" title="有关分拆数的拓展"></a>有关分拆数的拓展</h2><p>在正整数 $r$ 的所有分拆中， 不超过 $n$ 的有几种？</p>
<p>发现本质上是在求这样一个不定方程</p>
<script type="math/tex; mode=display">
1\cdot x_1+2\cdot x_2+3\cdot x_3+\cdots+n\cdot x_n=r</script><p>的非负整数解个数。</p>
<p>那么显然就是 $\frac{1}{(1-x)(1-x^2)\cdots(1-x)^n}$</p>
<h2 id="又一个拓展-OI中的应用"><a href="#又一个拓展-OI中的应用" class="headerlink" title="又一个拓展(OI中的应用)"></a>又一个拓展(OI中的应用)</h2><blockquote>
<p>给定 $n$ 和 $c_i(1\leq c_i\leq \rm m)$，求 $0\leq x_i\leq c_i$ 时，$\sum x_i=s$ 的解的数量。</p>
<p>对于前 $30\%$ 的数据，有 $n\leq 16,0\leq m,s\leq 10^9$  。</p>
<p>对于前 $70\%$ 的数据，有 $n\leq 35，0\leq m,s\leq 10^9$ 。</p>
<p>对于另外 $30\%$ 的数据，有 $1\leq n\leq 5\cdot 10^5,0\leq m,s\leq 100$。</p>
</blockquote>
<p>发现大概 $30\%$ 的可以直接大力容斥，最后 $30\%$ 的可以生成函数，中间 $40\%$ 的就需要神秘的 $\rm Meet~in~Middle$ 了。想了想大概就是分成两部分，枚举第二部分的时候顺便乘法原理一下第一部分的结果就完了。</p>
<h1 id="线性循环数列"><a href="#线性循环数列" class="headerlink" title="线性循环数列"></a>线性循环数列</h1><h2 id="斐波那契数列通项"><a href="#斐波那契数列通项" class="headerlink" title="斐波那契数列通项"></a>斐波那契数列通项</h2><p>考虑斐波那契数列 $\{a_n\}$ 的母函数可以这么得到：</p>
<script type="math/tex; mode=display">
f(x)=a_0+a_1x+\cdots+a_nx^n+\cdots\\
-xf(x)=-a_0x-a_1x^2-\cdots-a_nx^{n+1}\cdots\\
-x^2f(x)=-a_0x^2-a_1x^3-\cdots-a_nx^{n+2}\cdots\\</script><p>考虑 ① + ② + ③ 得到：</p>
<script type="math/tex; mode=display">
(1-x-x^2)f(x)=a_0+(a_1-a_0)x+(a_2-a_1-a_0)x^2\cdots</script><p>可知</p>
<script type="math/tex; mode=display">
f(x)=\frac{1}{1-x-x^2}</script><p>那么考虑如何展开这个东西。令 $r_1,r_2$ 为方程 $1-x-x^2$ 的两个根。那么有</p>
<script type="math/tex; mode=display">
\frac{1}{1-x-x^2}=\frac{1}{r_2-r_1}\left(\frac{1}{x-r_1}-\frac{1}{x-r_2}\right)</script><p>变一下形：</p>
<script type="math/tex; mode=display">
\frac{1}{1-x-x^2}=\frac{1}{r_2-r_1}\left(\frac{1}{r_2\left(1-\frac{1}{r_2}x\right)}-\frac{1}{r_1\left(1-\frac{1}{r_1}x\right)}\right)</script><p>然后有一步很神仙的转化。由</p>
<script type="math/tex; mode=display">
\frac{1}{1-\frac{1}{r_1}x}=\sum\left(\frac{1}{r_1}\right)^ix^i\\
\frac{1}{1-\frac{1}{r_2}x}=\sum\left(\frac{1}{r_2}\right)^ix^i</script><p>得到</p>
<script type="math/tex; mode=display">
\frac{1}{1-x-x^2}=\sum\left[\frac{1}{r_2-r_1}\left(\frac{1}{r_2^{i+1}}-\frac{1}{r_1^{i+1}}\right)\right]x^i</script><p>可知</p>
<script type="math/tex; mode=display">
a_n=\frac{1}{\left(r_1r_2\right)^n}\cdot\frac{r_2^{n+1}-r_1^{n+1}}{r_1-r_2}</script><p>继而可以得到</p>
<script type="math/tex; mode=display">
a_n=\frac{1}{\sqrt 5}\left[\left(\frac{1+\sqrt 5}{2}\right)^{n+1}-\left(\frac{1-\sqrt 5}{2}\right)^{n+1}\right]</script><h2 id="一般线性循环数列"><a href="#一般线性循环数列" class="headerlink" title="一般线性循环数列"></a>一般线性循环数列</h2><p>由上例可知，对于一个给定的 $k$ 阶线性循环数列，求母函数只需要构造出除了前 $k$ 项之外系数都为 $0$ 的幂级数即可。</p>
<p>比如给定数列 $\{a_n\}$ 满足：</p>
<script type="math/tex; mode=display">
a_0=0,a_1=1,a_2=-1\\
a_n=-a_{n-1}+16a_{n-2}-20a_{n-3}\quad(n=3,4,5\cdots)\\</script><p>那么考虑构造如下四个：</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)&=a_0+a_1x+\cdots+a_nx^n+\cdots\\
xf(x)&=a_0x+a_1x^2+\cdots + a_nx^{n+1}\cdots\\
-16x^2f(x)&=-16a_0x^2-16a_1x^3-\cdots-16a_nx^{n+2}\cdots\\
20x^3f(x)&=-20a_0x^3+20a_1x^4+\cdots+20a_nx^{n+3}\cdots\\
\end{aligned}</script><p>还是 ① + ② + ③ + ④：</p>
<script type="math/tex; mode=display">
(1+x-16x^2+20x^3)f(x)=x\\
f(x)=\frac{x}{1+x-16x^2+20x^3}</script><p>就完了。</p>
<p>嗯，剩下的内容就留给下一篇了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>组合计数/二项式定理</tag>
        <tag>组合计数/生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>【练习记录】平日里口胡的题目系列1</title>
    <url>/2020/02/09/%E5%B9%B3%E6%97%A5%E9%87%8C%E5%8F%A3%E8%83%A1%E7%9A%84%E9%A2%98%E7%9B%AE%E7%B3%BB%E5%88%971/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是有些题实在不想写，就把这些题给嘴了。</p>
<p>由于同一篇文章太长会造成很差的观感。所以就分成很多 $parts$ 了。</p>
<p>对于个人认为比较妙的题，会打上 <code>*</code> 的图标。</p>
<a id="more"></a>
<h1 id="MdOI2020"><a href="#MdOI2020" class="headerlink" title="MdOI2020"></a>MdOI2020</h1><p>当成月赛打了。T1写了个诡异的算法结果因为特判时没输出换行拿了64，然后就没有打的兴趣了（</p>
<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>考虑对于一种拆分是最优的。即 $(a,b,c)=d$，$d$ 为所求，那么发现会有 $d\cdot (\frac{a}{d}+\frac{b}{d}+\frac{c}{d})=n$。发现当 $\frac{a}{d},\frac{b}{d},\frac{c}{d}$ 三者不同时，一定可以转化成其中一个数 $=d$ 的构造方式。</p>
<p>所以考虑质因数分解之后枚举 $\frac{n}{d}$。发现当 $\frac{n}{d}\leq 5$ 的时候，当前枚举的 $d$ 不可以让 $\frac{a}{d},\frac{b}{d},\frac{c}{d}$ 三者不同。所以判掉这些数据，剩下的取 $\rm max$ 即可。</p>
<p>发现现在要求的，就是从 $n$ 的所有分解里面，挑出一个最接近 $6$ 且 $\geq 6$ 的构造 $\frac{n}{d}$ 的方案。发现最多需要三个素因子才可以超过 $6\to (2,2,2)$，最少的话一个就足够了。所以考虑 $\log ^3n$ 三重循环枚举所有的质因子即可。</p>
<p>质因数分解完全可以 $\rm pollard-rho$。最后复杂度 $O(T\max(\log^3 n,n^\frac{1}{4}))$</p>
<p>(这个题写的长是因为直接把自己写的题解给粘过来了)</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>考虑一个性质，排好序后，最后不变的一定是一个连续区间。所以考虑枚举这个连续区间，尺取或者二分出右端点，检验一下就可以了。复杂度 $O(n)$。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>考虑一个性质。发现其实左上角的数定住之后，之后的数都确定了。所以可以随便用点差分 $trick$ 实现 $n^2$ .</p>
<h2 id="D"><a href="#D" class="headerlink" title="D*"></a>D*</h2><p>比较有趣的题。根据第二个子任务的提示可以发现，对于每个询问可以把当前点旋到根，然后求的就是一个区间内点的 $lca$ 的深度。发现这个东西有结合律，比较容易用线段树维护。</p>
<p>然而每次换根复杂度显然不对。考虑进一步分析性质，当询问点 $q$ 不在原树上的 $lca$ 的子树内时，换根不会影响距离，所以直接统计即可；当询问点 $q$ 不在 $lca$ 的子树内时，考虑换根之后的 $lca’$ 一定也是原树里 $p$ 的某个祖先。通过画图可以知道，只需要倍增找出 $p$ 的第一个包含 $[l,r]$ 内点的祖先即可。求交集可以用主席树来维护。复杂度 $(n\log^2n+q\log^2n)$。</p>
<h2 id="E"><a href="#E" class="headerlink" title="E*"></a>E*</h2><p>发现可以转化成枚举一个点 $x$ ，从 $x$ 的子树内外各选一对点使得 xor 值最大，发现直接拿Trie维护一个回滚莫队状物即可。复杂度 $n\sqrt n\log V$ 。</p>
<p>似乎可以用什么值域分块的黑科技优化一下。emmm但我还不会。</p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>是个推式子题，暂时不是很想推。</p>
<h1 id="EA的练习赛"><a href="#EA的练习赛" class="headerlink" title="EA的练习赛"></a>EA的练习赛</h1><p>发现自己被叫去验题结果啥都不会十分丢人.jpg</p>
<h2 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h2><p>发现如果第一个字符和后面的任意一个字符相同，那么就一定不合法；反之一定合法。所以答案是 $26\times 25^{n-1}$ 。</p>
<h2 id="B-1"><a href="#B-1" class="headerlink" title="B*"></a>B*</h2><p>根据期望的线性性，发现可以将每个点的答案转化一下：$E=\sum_{i=1}^{n-1}P(x\geq i)$ 。</p>
<p>考虑每个点什么时候被删除。发现只跟离他最近的前后两个比他大的数有关，每当有一个与 $x$ 相邻时 $x$ 就会挂。所以用容斥原理算一下，$P(x\geq i)=1-P(pre\sim x)-P(x\sim~nxt)+P(pre\sim nxt)$ 。发现这东西显然有组合意义，所以算一波组合数即可。复杂度 $O(n^2)$ 。</p>
<h2 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h2><p>有意思的题。发现切割方式严格要求从左到右，那么对于两根弦，如果以 $u_j\geq u_i,v_j\leq v_i$ 的方式相交，那么就可以把 $j$ 这条弦给删掉。所以删掉之后重新排序，然后按弦 $dp$。$f_i$ 表示处理完前 $i$ 根弦的 $\min$ 。那么转移就枚举一下把哪个 $j\sim i$ 的连续区间给删掉。</p>
<p>那么转移大概是 $f_i=\min_{0\leq j&lt;i}(f_j+A_{u_{j+1}-1}\times B_{v_i+1})$ 。其中 $A,B$ 分别是 $a_i,b_i$ 的前后缀最小值。</p>
<p>发现稍微变一下形，就是 $f_j=-A_{u_{j+1}-1}\times B_{v_i+1}+f_i$。发现斜率 $B$ 单调，$x$ 坐标 $A$ 单调递减。所以就是在维护一个下凸壳，直接最裸的斜率优化就好了。</p>
<h2 id="D-1"><a href="#D-1" class="headerlink" title="D**"></a>D**</h2><p>很有意思的组合题。发现对于每个点，如果在访问他之前访问了比他深度更小的叶子节点，他就不会被访问。所以考虑对于一个点 $x$ 的每个祖先 $anc_x$ ，设 $anc_x$ 有 $n’$ 个儿子，其中有 $m’$ 个子树内叶节点的最小深度小于 $x$ 的深度，那么这一层不会进入死亡分叉的方案数就是 $\binom{n’}{m’+1}\cdot (n’-m’-1)!\cdot (m’)!$ ，计数思路大概就是选出 $m’+1$ 个位置来，每次选都把这 $m’+1$ 位置中的第一个位置留给当前的 $x$ 所在子树放，剩下就是排列数。</p>
<p>然后考虑进入 $x$ 的概率就是很神奇的 $\prod \frac{1}{m_{anc_i}’+1}$。考虑这个东西怎么快速算。发现对于同一棵子树，$lca$ 上方的信息都是一样的，改变的只有子树内部的方案。那么考虑对于每个儿子，直接按照「子树内叶子的最小深度」排序，就可以顺序处理出结果。</p>
<p>类似于用栈来维护 $k$ 级祖先的过程，发现只需要一个可撤销的树状数组即可。复杂度 $n\log n$。</p>
<h2 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h2><p>似乎是一道神秘的插值题。鸽了鸽了。</p>
<h1 id="LG二月月赛-·-加油武汉"><a href="#LG二月月赛-·-加油武汉" class="headerlink" title="LG二月月赛 · 加油武汉"></a>LG二月月赛 · 加油武汉</h1><p>没参加的一场月赛，似乎被爆破了.jpg</p>
<h2 id="A-2"><a href="#A-2" class="headerlink" title="A**"></a>A**</h2><p>这题本来想枚举最后选的哪个数来做，但是发现根本不科学，自闭了半天。就是考虑钦定了一个数，如果不是最后一个取他，那么前 $k$ 个一定都放比他小的数，同时可以在他的位置和 $k$ 个之间也放一些比他小的数，但是这些方案对于不同的前 $k$ 个元素的最大值，方案是不同的，所以复杂度很假也很麻烦。</p>
<p>发现似乎直接枚举前 $k$ 个元素的最大值比较容易做。分成两类来讨论，一类情况是取到了某个 $x$，另一类情况是不得不取最后一个，发现当且仅当集合里的最大值在前 $k$ 个才会发生。</p>
<p>1、第一种情况。对于每个最大值 $x$，取到他的概率是 $\frac{\binom{x-1}{k-1}}{\binom{n}{k}}$，在取到最大值为 $x$ 的情况下，期望就再乘上一个 $\frac{\mathrm{S-S_{p_x}}}{n-p_x}$。其中 $\rm S$ 表示集合元素的总和，$\rm S_x$ 表前 $x$ 小的元素的和，$p_x$ 表示 $x$ 是第几小的。不难发现这样是对的。</p>
<p>2、第二种情况。不难发现概率是 $\frac{\binom{n-1}{k-1}}{\binom{n}{k}}=\frac{k}{n}$ 。那么期望的话，发现这种情况下最后一个数是谁情况相同。所以乘上一个 $\frac{\mathrm{S}-x_{\max}}{n-1}$ 就完了。</p>
<p>嗯。这个故事告诉我们有时候期望题并不可以直接大力去组合所有情况来算，还是需要一定技巧的。</p>
<p>啊…不会转换组合对象…我太弱了…</p>
<h2 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h2><p>由于是完全图，那么每个点贡献的异色三角形个数就是 $(n-1-b)\cdot b$ 。</p>
<p>所以最后算一下补，答案就是 $\binom{n}{3}-\frac{1}{2}\sum_{i=1}^n(n-1-b_i)\cdot b_i$ 。做完才发现是一道做烂了的题.jpg</p>
<h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><p>sb费用流。发现最大流的情况下，不会出现一个点覆盖了另一个强连通分量中的某个点。所以可以直接流。用一些贪心的 $trick$ 就可以边数消掉一个 $n$ 了 。</p>
<h2 id="D-2"><a href="#D-2" class="headerlink" title="D*"></a>D*</h2><p>很有意思一道题。首先发现原来 $min_25$ 筛并不可以过得去。之后发现 </p>
<script type="math/tex; mode=display">
\begin{aligned}
\sigma_0(n)&=\prod(e_i+1)\\
\sigma_0(n^k)&= \prod(k\times e_i+1)
\end{aligned}</script><p>于是可以发现，大概对于每个 $n$，他的 $\sigma_0$ 都是一个关于 $k$ 的 $\omega(n)$ 次多项式。于是就可以筛出多项式来，前缀和一下。然后就做完了。复杂度大概 $O(\max(\omega\cdot n, \omega\cdot q))$ 。</p>
<p>可能筛多项式需要一些诡秘的 $trick$ 吧。不过大概还是通过记录最小质因子来转移。</p>
<p>由于以前没见过这种题，于是写了个代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    poly[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])&#123;</span><br><span class="line">            frm[i] = <span class="number">1</span> ;</span><br><span class="line">            chk[i] = <span class="number">1</span> ;</span><br><span class="line">            mind[i] = i ;</span><br><span class="line">            mindc[i] = <span class="number">1</span> ;</span><br><span class="line">            pr[++ cnt] = i ;</span><br><span class="line">            poly[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            poly[i][<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m, j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            m = <span class="number">1l</span>l * pr[j] * i ; </span><br><span class="line">            <span class="keyword">if</span> (m &gt; n) <span class="keyword">break</span> ; chk[m] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                mind[m] = pr[j] ;</span><br><span class="line">                mindc[m] = <span class="number">1</span>, frm[m] = i ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mindc[m] = mindc[i] + <span class="number">1</span> ;</span><br><span class="line">                mind[m] = mind[i] ; frm[m] = frm[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">8</span> ; ++ k)</span><br><span class="line">                poly[m][k] = poly[frm[m]][k] ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">8</span> ; k &gt;= <span class="number">1</span> ; -- k)</span><br><span class="line">                (poly[m][k] += <span class="number">1l</span>l * mindc[m] * poly[m][k - <span class="number">1</span>] % P) %= P ;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= <span class="number">8</span> ; ++ j)</span><br><span class="line">            poly[i][j] -= (poly[i][j] += poly[i - <span class="number">1</span>][j]) &gt;= P ? P : <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h2><p>有很长的题面以及红色的难度标签。于是决定跳过。</p>
<h2 id="F-1"><a href="#F-1" class="headerlink" title="F"></a>F</h2><p>辣鸡二分答案题。难点在于知道要去二分答案。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>技巧/倍增</tag>
        <tag>数学/素数/素数筛法</tag>
        <tag>数学/数论</tag>
        <tag>数学/概率,期望</tag>
        <tag>数据结构/数据结构方法/莫队</tag>
        <tag>多项式的应用</tag>
        <tag>有趣的二分答案</tag>
        <tag>动态规划/斜率优化</tag>
        <tag>数据结构/可持久化/可持久化线段树</tag>
        <tag>组合计数/有技巧的计数</tag>
        <tag>有技巧的差分</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活碎片4】生化危机Resident Evil</title>
    <url>/2020/02/08/Life4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里可是《生化危机》系列的死忠！</p>
<p>其实这里放的是高一下学期某次语文课演讲的演讲稿了啦。</p>
<a id="more"></a>
<div class="pdf" target="./Lecture.pdf" height=""></div>
<p>才发现原来强制用WPS进行ppt转word，动画效果是莫得的，所以有些图片只能拼一起了，sad。</p>
<p>如果pdf加载不出来，推荐 <code>firefox</code> 浏览器或者等上那么一二三四…五六十分钟（huaji</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>「生活碎片」系列目录</title>
    <url>/2020/02/07/%E7%94%9F%E6%B4%BB%E7%A2%8E%E7%89%87%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>出这个系列，原因是想瞎写点东西记录生活。有别于「随想」系列，这些文章的感情不是那么浓厚，大概是记录比较正常的生活点滴。</p>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">篇目</th>
<th style="text-align:center">链接（点击即可）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">「生活碎片0」CSP2019游记</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2019/12/20/CSP-S2019%E6%B8%B8%E8%AE%B0/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">「生活碎片1」一个小开始</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/15/Life1/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">「生活碎片2」原来我还什么都不懂</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/23/Life2/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">「生活碎片3」Life is strange</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2020/01/24/Life3/">$Link$</a></td>
</tr>
<tr>
<td style="text-align:center">「生活碎片4」生化危机Resident Evil</td>
<td style="text-align:center"><a href="https://www.orchidany.cn/2020/02/08/Life4/#more">$Link$</a></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】杜教筛</title>
    <url>/2020/01/24/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一种比较快的筛法？</p>
<p>用于积性函数求和。比如给定了一个函数 $\boldsymbol{\rm f} $ ，考虑构造出这样的一个 $\boldsymbol{\rm g}$ ，使得在如此转化之后：</p>
<script type="math/tex; mode=display">
\mathbf{S}(n)=\sum_{i=1}^{n} \mathbf{f}(i)\\
\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)=\sum_{i=1}^{n} \sum_{x y=i} \mathbf{f}(x) \mathbf{g}(y)=\sum_{y=1}^{n} \mathbf{g}(y) \sum_{x y \leq n} \mathbf{f}(x)=\sum_{y=1}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)</script><p>得出来的：</p>
<script type="math/tex; mode=display">
\mathbf{g}(1) \mathbf{S}(n)=\sum_{i=1}^{n}(\mathbf{f} * \mathbf{g})(i)-\sum_{y=2}^{n} \mathbf{g}(y) \mathbf{S}\left(\left\lfloor\frac{n}{y}\right\rfloor\right)</script><p>如果其中 $\bf f*g$ 比较容易计算，就可以达到快速计算 $\mathbf{S}$ 的目的了。</p>
<a id="more"></a>
<p>似乎很简单？因为这种题的难点在于构造，构造完了就可以分块做了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	ll s = sum(<span class="number">1</span>, n, f * g) ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>) </span><br><span class="line">    r = n / (n / l), s -= solve(n / l) * sum(<span class="number">1</span>, l, g) ;</span><br><span class="line"> 	<span class="keyword">return</span> (s /= g(<span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这么做的复杂度不对。考虑这样一个引理：</p>
<script type="math/tex; mode=display">
\forall x,y,z\in\mathbb{Z},\quad \left\lfloor\frac{\left\lfloor\frac{z}{x}\right\rfloor}{y}\right\rfloor=\left\lfloor\frac{z}{x y}\right\rfloor</script><p>证明大概是把 $z$ 设成带余除法的标准形式，然后搞一下就可以了。此处略去。</p>
<p>于是发现，其实每次要计算的 $n’$ ，都是某个 $\lfloor \frac{n}{x}\rfloor$ ，因为假设这次是 $\lfloor \frac{n}{x}\rfloor$ ，下次是 $\lfloor \frac{\lfloor \frac{n}{x}\rfloor}{y}\rfloor=\lfloor \frac{n}{x\cdot y}\rfloor$ 。所以 $\sqrt n$ 为上界，可以直接通过 $\lfloor \frac{n}{x}\rfloor $ 记忆化所有的 $x$ 。</p>
<p>同时，发现对于 $x$ 的调用，都只会是 </p>
<script type="math/tex; mode=display">
1,2,3\dots \sqrt n,\lfloor{\frac{n}{1}}\rfloor,\lfloor{\frac{n}{2}}\rfloor,\lfloor{\frac{n}{3}}\rfloor\dots\lfloor{\frac{n}{\sqrt n}}\rfloor</script><p>这些数，且每次计算 $\mathbf{S}$ 的复杂度都是 $\sqrt n$ 。所以最终复杂度是：</p>
<script type="math/tex; mode=display">
O\left(\sum_{i=1}^{\sqrt{n}} \sqrt{i}+\sum_{i=1}^{\sqrt{n}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(\sum_{i=1}^{\sqrt{n}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(\int_{1}^{\sqrt{n}} \sqrt{\frac{n}{x}} \mathrm{d} x\right)=O\left(n^{\frac{3}{4}}\right)</script><p>其实就是两步近似。</p>
<p>然而可以做到更优，即发现对于一些很小的 $n’$ ，完全可以直接预处理出来。所以假设对于前 $p(0&lt;p&lt;1)$ 的 $\mathbf S$ 直接预处理，那么复杂度会变成：</p>
<script type="math/tex; mode=display">
O\left(n^{p}+\sum_{i=1}^{n^{1-p}} \sqrt{\left\lfloor\frac{n}{i}\right\rfloor}\right)=O\left(n^{p}+\int_{1}^{n^{1-p}} \sqrt{\frac{n}{x}} \mathrm{d} x\right)=O\left(n^{p}+n^{1-\frac{1}{2} p}\right)</script><p>发现此时取 $p=\frac{2}{3}$ 为最优，所以复杂度 $O(n^{\frac{2}{3}})$。</p>
<p>草，据说这东西是 xudyh 在考场上构造出来的，这也太神了吧…</p>
<h1 id="1-例题"><a href="#1-例题" class="headerlink" title="$1$ 例题"></a>$1$ 例题</h1><h2 id="LG4213-【模板】杜教筛（Sum）"><a href="#LG4213-【模板】杜教筛（Sum）" class="headerlink" title="LG4213 【模板】杜教筛（Sum）"></a>LG4213 【模板】杜教筛（Sum）</h2><blockquote>
<p>求</p>
<script type="math/tex; mode=display">
\begin{aligned}
&a n s_{1}=\sum_{i=1}^{n} \varphi(i)\\
&a n s_{2}=\sum_{i=1}^{n} \mu(i)
\end{aligned}</script><p>$1\leq n\leq 2\times 10^9$</p>
</blockquote>
<p>考虑杜教筛。</p>
<p>考虑如何构造 $\varphi$ 的 $g$ 。发现有 $\sum_{d|n}\varphi(d)=n$，即 $\varphi <em> \mathbf{1}=\bf Id$，那么 $\bf f</em>g$ 就是 $\frac{n\cdot (n+1)}{2}$。</p>
<p>考虑如何构造 $\mu$ 的 $g$ 。发现有 $\sum_{d|n}\mu(d)=[n=1]$，即 $\mu <em> \bf 1 = ϵ$，那么 $\bf f</em>g$ 就是 $[n=1]$。</p>
<p>然后就没有然后了。去年 $6$ 月我写的是不带记忆化的，慢的很。今天重写加了记忆化，复杂度看起来还可以？但是不知道为啥被 <code>min_25</code> 吊着锤。(其实也就快一点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXS 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 5200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> T, N, S ; </span><br><span class="line"><span class="keyword">bool</span> chk[MAXN] ; </span><br><span class="line">LL phi[MAXN], Mu[MAXN] ; </span><br><span class="line">LL Smu[MAXS], Sphi[MAXS] ;</span><br><span class="line"><span class="keyword">int</span> pr[MAXN], t, i, j, x ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">	Mu[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; MAXN ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!chk[i]) </span><br><span class="line">      pr[++ t] = i, Mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= t &amp;&amp; pr[j] * i &lt; MAXN ; ++ j)&#123;</span><br><span class="line">			chk[i * pr[j]] = <span class="number">1</span> ; </span><br><span class="line">			<span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123; </span><br><span class="line">        phi[i * pr[j]] = phi[i] * pr[j] ; </span><br><span class="line">        <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">      	Mu[i * pr[j]] = - Mu[i],</span><br><span class="line">        phi[i * pr[j]] = phi[i] * phi[pr[j]] ;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; MAXN ; ++ i) Mu[i] = Mu[i - <span class="number">1</span>] + Mu[i], phi[i] = phi[i - <span class="number">1</span>] + phi[i] ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_Mu</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &lt; MAXN) <span class="keyword">return</span> Mu[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= S &amp;&amp; Smu[p]) <span class="keyword">return</span> Smu[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &gt; S &amp;&amp; Smu[N / p]) <span class="keyword">return</span> Smu[N / p] ;</span><br><span class="line"></span><br><span class="line">    LL ret = <span class="number">1L</span>L ; rr <span class="keyword">int</span> l, r ;</span><br><span class="line">	<span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt;= p ; l = r + <span class="number">1</span>) </span><br><span class="line">        r = (p / (p / l)), ret -= (r - l + <span class="number">1</span>) * get_Mu(p / l) ; </span><br><span class="line">    <span class="keyword">return</span> (p &gt; S ? (Smu[N / p] = ret) : (Smu[p] = ret)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p &lt; MAXN) <span class="keyword">return</span> phi[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &lt;= S &amp;&amp; Sphi[p]) <span class="keyword">return</span> Sphi[p] ; </span><br><span class="line">    <span class="keyword">if</span> (p &gt; S &amp;&amp; Sphi[N / p]) <span class="keyword">return</span> Sphi[N / p] ;</span><br><span class="line"></span><br><span class="line">    LL ret = <span class="number">1l</span>l * (<span class="number">1</span> + p) * p / <span class="number">2L</span>L ; rr <span class="keyword">int</span> l, r ;</span><br><span class="line">	<span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt;= p ; l = r + <span class="number">1</span>) </span><br><span class="line">        r = (p / (p / l)), ret -= (r - l + <span class="number">1</span>) * get_phi(p / l) ; </span><br><span class="line">    <span class="keyword">return</span> (p &gt; S ? (Sphi[N / p] = ret) : (Sphi[p] = ret)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T, init() ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N, S = <span class="built_in">sqrt</span>(N) ;</span><br><span class="line">        <span class="built_in">memset</span>(Smu, <span class="number">0</span>, <span class="keyword">sizeof</span>(Smu)) ;</span><br><span class="line">        <span class="built_in">memset</span>(Sphi, <span class="number">0</span>, <span class="keyword">sizeof</span>(Sphi)) ; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; get_phi(N) &lt;&lt; <span class="string">" "</span> &lt;&lt; get_Mu(N) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-高级应用"><a href="#3-高级应用" class="headerlink" title="$3$ 高级应用"></a>$3$ 高级应用</h1><p> 高级应用：我不是很会的应用（</p>
<blockquote>
<p>求</p>
<script type="math/tex; mode=display">
\left(\sum_{i=1}^{n} \sum_{j=1}^{n} i \cdot j \cdot \operatorname{gcd}(i, j)\right) \bmod p</script><p>$p\in \mathbb{P},1\leq n\leq 10^{10}$ .</p>
</blockquote>
<p>首先是朴素反演：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^{n} \sum_{j=1}^{n} i\cdot j\cdot \operatorname{gcd}(i, j)\\
=&\sum_{i=1}^n\sum_{j=1}^ni\cdot j\cdot\sum_{d|i\operatorname{and}d|j} \varphi(d)\\
=&\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}i\cdot j\\
=&\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \left(\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\right)^2\\
\end{aligned}</script><p>然后发现前面都是完全积性，后面那个平方里面还带着求和不是很好搞…</p>
<p>这个地方有个很牛的引理：</p>
<script type="math/tex; mode=display">
\left(\sum_{i=1}^xi\right)^2=\sum_{i=1}^{x}i^3</script><p>这东西大概是能归纳出来的。似乎还没有什么比较有趣的证明<del>约等于只能选择背过</del></p>
<p>然后就是</p>
<script type="math/tex; mode=display">
\sum_{d=1}^n\varphi(d)\cdot d^2\cdot \sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}p^3</script><p><del>发现都比较容易算，并且都积性，于是就可以直接杜教筛了。</del></p>
<p>上句话在扯 $p$。后面那一坨根本没法筛。于是考虑整除分块套一个杜教筛。这样复杂度还是 $n^{\frac{2}{3}}$ ！！这点很重要！！因为本质上我的整除分块还是在枚举某些 $\lfloor\frac{\lfloor\frac{n}{l}\rfloor}{x}\rfloor$。于是该记下来的不多不少，还是记下来了，复杂度不变。</p>
<p>代码实现有点细节，还需要多学习多积累。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNN 10000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; pq ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXNN], chk[MAXN] ;</span><br><span class="line">LL Inv6, Inv4, cnt, p[MAXNN] ;</span><br><span class="line">LL P ; LL N, Sp[MAXN], phi[MAXNN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL l, LL r)</span></span>&#123;</span><br><span class="line">    l -- ; l %= P, r %= P ;</span><br><span class="line">    LL r1 = r * (r + <span class="number">1</span>) % P * (<span class="number">2</span> * r + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">    LL r2 = l * (l + <span class="number">1</span>) % P * (<span class="number">2</span> * l + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">    <span class="keyword">return</span> ((r1 - r2) % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calcc</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ans ; x %= P ;</span><br><span class="line">    ans = x * x % P ;</span><br><span class="line">    (ans *= Inv4) %= P ;</span><br><span class="line">    (ans *= (x + <span class="number">1</span>) % P * (x + <span class="number">1</span>) % P) %= P ;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; MAXNN)</span><br><span class="line">        <span class="keyword">return</span> phi[x] ;</span><br><span class="line">    LL y = N / x ;</span><br><span class="line">    <span class="keyword">if</span> (chk[y]) <span class="keyword">return</span> Sp[y] ;</span><br><span class="line">    chk[y] = <span class="number">1</span> ; LL &amp;ans = Sp[y] ;</span><br><span class="line">    ans = calcc(x) ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">2</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = x / (x / l),</span><br><span class="line">        (ans -= calc(l, r) * solve(x / l) % P) %= P ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) ans += P ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">return</span> Sp[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">work</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = x / (x / l) ;</span><br><span class="line">        (res += (solve(r) - solve(l - <span class="number">1</span>)) * calcc(x / l) % P) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (res % P + P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; N ; phi[<span class="number">1</span>] = vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    Inv4 = expow(<span class="number">4</span>, P - <span class="number">2</span>), Inv6 = expow(<span class="number">6</span>, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt; MAXNN ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            p[++ cnt] = i, phi[i] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] * i &gt;= MAXNN) <span class="keyword">break</span> ;</span><br><span class="line">            vis[p[j] * i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * p[j]] = phi[i] * p[j] % P ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i * p[j]] = phi[i] * phi[p[j]] % P ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXNN ; ++ i) </span><br><span class="line">      (phi[i] = <span class="number">1l</span>l * i * i % P * phi[i] + phi[i - <span class="number">1</span>]) %= P ;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; phi[8000000] &lt;&lt; endl ; </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, work(N)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>杜教筛</category>
      </categories>
      <tags>
        <tag>数学/积性函数求和/杜教筛</tag>
        <tag>数学/积性函数/欧拉反演</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】loj#2353 [NOI2007]货币兑换</title>
    <url>/2020/01/24/%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>某CDQ好题.</p>
<p><del>没人看出上面这句话是有俩含义吗</del></p>
<a id="more"></a>
<p>小Y最近在一家金券交易所工作。该金券交易所只发行交易两种金券：$A$ 纪念券（以下简称 $A$ 券）和 $B$ 纪念券（以下简称 $B$ 券）。每个持有金券的顾客都有一个自己的帐户。金券的数目可以是一个实数。</p>
<p>每天随着市场的起伏波动，两种金券都有自己当时的价值，即每一单位金券当天可以兑换的人民币数目。我们记录第 $K$ 天中 $A$ 券和 $B$ 券的价值分别为 $A_K$ 和 $B_K$ （元/单位金券）。</p>
<p>为了方便顾客，金券交易所提供了一种非常方便的交易方式：比例交易法。</p>
<p>比例交易法分为两个方面：</p>
<p>a) 卖出金券：顾客提供一个 $[0，100]$ 内的实数 $\rm OP$ 作为卖出比例，其意义为：将 $\rm OP\%$ 的 $A$ 券和 $\rm OP\%$ 的 $B$ 券以当时的价值兑换为人民币；</p>
<p>b) 买入金券：顾客支付 $\rm IP$ 元人民币，交易所将会兑换给用户总价值为 $\rm IP$ 的金券，并且，满足提供给顾客的 $A$ 券和 $B$ 券的比例在第 $K$ 天恰好为 $\rm Rate_K$ ；</p>
<p>小 Y 是一个很有经济头脑的员工，通过较长时间的运作和行情测算，他已经知道了未来 $\rm N$ 天内的 $A$ 券和 $B$ 券的价值以及 $\rm Rate$。他还希望能够计算出来，如果开始时拥有 $\rm S$ 元钱，那么 $\rm N$ 天后最多能够获得多少元钱。</p>
<p>其中 $\rm N\leq 10^5$.</p>
<p>首先想到 $dp$ 。这个地方设计的 $dp$ 个人感觉还是比较 $\rm tricky$ 的。发现本质上最大化 $A$ 券或者 $B$ 券的数量和最大化手里拿到的rmb都是某些最优决策，所以不能一起维护。</p>
<p>发现通过券来维护rmb比较方便，于是考虑设 $f_i$ 表示在第 $i$ 天把rmb都花完能得到多少 $A$ 券。初值显然是</p>
<script type="math/tex; mode=display">
m=f_1\cdot A_1+\frac{f_1\cdot B_1}{\rm Rate_1}\\
f_1=\frac{m\cdot\mathrm{Rate_1}}{A_1\cdot \mathrm{Rate_1}+B_1}</script><p>那么考虑如何以此计算rmb。发现第 $i$ 天可能会保有 $1\sim i-1$ 天时的金券。于是令 $g_i$ 表示前 $i$ 天的最大获利，发现可以这么转移：</p>
<script type="math/tex; mode=display">
g_i=\max_{1\leq j<i}(g_{i-1},f_j\cdot (A_i+\frac{B_i}{\rm Rate_j}))</script><p>转移的正确性在于，卖出的 $A$ 券和 $B$ 券的百分比必须一致，所以不会出现分多次卖的情况。于是喜提一个 $n^2$ 算法。</p>
<p>考虑优化。发现如果对于一个 $i$ 其转移点为 $j$，那么会有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g_i&=f_j\cdot A_i+f_j\cdot \frac{B_i}{\rm Rate_j}\\
\frac{f_j}{\mathrm{Rate_j}}&=-\frac{A_i}{B_i}\cdot f_j+\frac{g_i}{B_i}
\end{aligned}</script><p>发现可以令 $y_i=\frac{f_i}{\mathrm{Rate_i}},x_i=f_i$ 。那么这就是一个斜率优化的标准形式。</p>
<p>但问题在于，$f_j$ 很悲惨的由于每天的兑换量有不同，它并不单增，并且斜率也不单增，所以不能用删除末尾几个（即单调队列）来维护凸壳，必须要用某些神秘 $\rm splay$ 技巧来加速这个过程。</p>
<p>然而还有另一种 $\rm CDQ$ 写法。大概就是考虑为了保证横坐标是单调的，所以要排序，但是排序之后转移就会失秩，而这个过程显然可以 $\rm CDQ$ 来优化，于是就没了。</p>
<p>值得注意的是，朴素的 $\rm CDQ$ 由于不需要严格按秩，即二进制拆分顺序不限，所以可以瞎分治。但是维护 $dp$ 的时候由于转移顺序必须按秩，所以有严格的分治顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cash</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, k ;</span><br><span class="line">    <span class="keyword">double</span> A, B, R ; <span class="keyword">int</span> ID ;</span><br><span class="line">&#125;T[MAXN], Div[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N ; <span class="keyword">double</span> M ; <span class="keyword">double</span> dp[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">    <span class="keyword">double</span> Ans, t ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Ans = M, dp[<span class="number">1</span>] = M * T[<span class="number">1</span>].R / (T[<span class="number">1</span>].A * T[<span class="number">1</span>].R + T[<span class="number">1</span>].B) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">                Ans = max(Ans, dp[j] * T[i].A + dp[j] / T[j].R * T[i].B) ;</span><br><span class="line">            dp[i] = Ans * T[i].R / (T[i].A * T[i].R + T[i].B) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, Ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> CDQ&#123;</span><br><span class="line">    <span class="keyword">int</span> stk[MAXN] ; <span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e9</span>, eps = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> Cash &amp; A, <span class="keyword">const</span> Cash &amp; B)</span></span>&#123; <span class="keyword">return</span> A.k &lt; B.k ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">getr</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(T[d].x - T[b].x) &lt;= eps) <span class="keyword">return</span> INF ;</span><br><span class="line">        <span class="keyword">return</span> (T[d].y - T[b]. y) / (T[d].x - T[b].x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Mid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = L, r = Mid + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= Mid &amp;&amp; (r &gt; R || T[l].x &lt; T[r].x))</span><br><span class="line">        Div[i] = T[l ++]; <span class="keyword">else</span> Div[i] = T[r ++] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) T[i] = Div[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dp_CDQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)&#123;</span><br><span class="line">            dp[L] = max(dp[L], dp[L - <span class="number">1</span>]) ;<span class="comment">//?</span></span><br><span class="line">            T[L].y = dp[L] / (T[L].A * T[L].R + T[L].B), T[L].x = T[L].y * T[L].R ;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">//y : f[j] / Rate[j], x : f[j]。此处应该以f[j]单增来排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l = L - <span class="number">1</span>, r = Mid ; <span class="keyword">int</span> top = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (T[i].ID &lt;= Mid) Div[++ l] = T[i] ; <span class="keyword">else</span> Div[++ r] = T[i] ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) T[i] = Div[i] ; dp_CDQ(L, Mid) ; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = L ; i &lt;= Mid ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; getr(stk[top], stk[top - <span class="number">1</span>]) &lt; getr(stk[top], i)) -- top ;</span><br><span class="line">            stk[++ top] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> i = Mid + <span class="number">1</span> ; i &lt;= R ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; getr(stk[top], stk[top - <span class="number">1</span>]) &lt;= T[i].k) -- top ;</span><br><span class="line">            dp[T[i].ID] = max(dp[T[i].ID], T[stk[top]].x * T[i].A + T[stk[top]].y * T[i].B) ;</span><br><span class="line">        &#125;</span><br><span class="line">        dp_CDQ(Mid + <span class="number">1</span>, R), Merge_sort(L, R, Mid) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = M ;</span><br><span class="line">          sort(T + <span class="number">1</span>, T + N + <span class="number">1</span>, Compare) ;</span><br><span class="line">          dp_CDQ(<span class="number">1</span>, N) ; <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, dp[N]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//     freopen("1492.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//     freopen("1492.out", "w", stdout) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;T[i].A, &amp;T[i].B, &amp;T[i].R),</span><br><span class="line">      T[i].k = -T[i].A / T[i].B, T[i].ID = i ;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">5000</span>) DP :: Solve1() ;</span><br><span class="line">      <span class="keyword">else</span> CDQ :: Solve2() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
        <tag>动态规划/斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】CDQ分治</title>
    <url>/2020/01/24/CDQ%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是对操作分治的算法，算是我最早学过的离线分治算法了？</p>
<p>大题思想就是考虑对操作分治，每次统计左边一半的修改对右边询问的影响，类似于二进制拆分，使得每个询问的答案统计可以分成不同的几块。</p>
<p>那么复杂度就是 $T(n)=2T(\frac{n}{2})+O(n\log^kn)$ ，解得 $T(n)=O(n\log ^{k+1}n)$ 。 </p>
<a id="more"></a>
<h1 id="loj-112-模板-三维偏序"><a href="#loj-112-模板-三维偏序" class="headerlink" title="loj#112 [模板]三维偏序"></a>loj#112 [模板]三维偏序</h1><blockquote>
<p>有 $n$ 个元素，第 $i$ 个元素有 $a_i$、$b_i$、$c_i$三个属性。</p>
<p>设 $f_i$ 表示满足 $a_j\leq a_i$ 且 $b_j\leq b_i$ 且 $c_j\leq c_i$ 的 $j$ 的数量。</p>
<p>对于 $\forall i \in [0,n)$ ，求 $f_j=i$ 的 $j$ 的数量。</p>
</blockquote>
<p>这不是传统意义上的 $\rm CDQ$ 。考虑 $\rm CDQ$ 在维护本质上是在维护一系列权值，通过分治统计前面对后面的贡献，类似于通过分治对全局的询问做时间上的二进制拆分。所以其实具有类似拆分性质的统计都可以这么实现。</p>
<p>回到这题，发现本质上三维数点也可以直接通过 $\rm CDQ$ 解决。考虑在分治完后，需要统计本层左区间对右区间的贡献。这时直接bit+扫描线即可，即按照一维排序，另一维用bit维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, K, bit[MAXN], res[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodes</span>&#123;</span> <span class="keyword">int</span> x, y, z, ans ; &#125;base[MAXN], t[MAXN] ;</span><br><span class="line">il <span class="keyword">bool</span> <span class="keyword">operator</span> == (nodes a, nodes b)&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.x == b.x) &amp; (a.y == b.y) &amp; (a.z == b.z) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span>, fg = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) fg = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">	<span class="keyword">return</span> res * fg ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp1</span><span class="params">(nodes a, nodes b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x == b.x ? (a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y) : a.x &lt; b.x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp2</span><span class="params">(nodes a, nodes b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.y == b.y ? a.z &lt; b.z : a.y &lt; b.y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; p &lt;= K ; p += low(p)) bit[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( ; p ; p -= low(p)) ret += bit[p] ; </span><br><span class="line">	<span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span> ; </span><br><span class="line">	<span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l, r ; </span><br><span class="line">	cdq(L, Mid), cdq(Mid + <span class="number">1</span>, R) ;  </span><br><span class="line">	sort(base + L, base + Mid + <span class="number">1</span>, comp2), l = L ;</span><br><span class="line">	sort(base + Mid + <span class="number">1</span>, base + R + <span class="number">1</span>, comp2), r = Mid + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= Mid &amp;&amp; base[l].y &lt;= base[r].y) </span><br><span class="line">			upd(base[l].z, <span class="number">1</span>), ++ l ; </span><br><span class="line">		base[r].ans += qry(base[r].z), ++ r ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt; l ; ++ i) upd(base[i].z, <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; <span class="keyword">int</span> i, j, o ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		base[i].x = qr(), base[i].y = qr(), base[i].z = qr() ; </span><br><span class="line">	sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp1) ; cdq(<span class="number">1</span>, N) ;</span><br><span class="line">	sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, comp1) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>, j = o = <span class="number">0</span> ; i &lt;= N ; j = o = <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span> (base[i] == base[i - <span class="number">1</span>]) ++ i, ++ j ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = i - j - <span class="number">1</span> ; k &lt; i ; ++ k) o = max(o, base[k].ans) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = i - j - <span class="number">1</span> ; k &lt; i ; ++ k) base[k].ans = o ; <span class="keyword">if</span> (!j) ++ i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) res[base[i].ans] ++ ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i]) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Violet-天使玩偶-SYJ摆棋子"><a href="#Violet-天使玩偶-SYJ摆棋子" class="headerlink" title="[Violet] 天使玩偶/SYJ摆棋子"></a>[Violet] 天使玩偶/SYJ摆棋子</h1><blockquote>
<p>给定一张 $n\times m$ 的网格。</p>
<p>有两个操作，插入一个新的点或者询问离某个点欧几里得距离最近的点。</p>
<p>$n,m\leq 3\times10^5$ </p>
</blockquote>
<p>发现欧几里得距离即：</p>
<script type="math/tex; mode=display">
|x_i-x_j|+|y_i-y_j|</script><p>通过分类讨论可以得到有这么四类情况：</p>
<script type="math/tex; mode=display">
x_i-x_j+y_i-y_j\\
x_i-x_j-y_i+y_j\\
-x_i+x_j+y_i-y_j\\
-x_i+x_j-y_i+y_j\\</script><p>发现，其中第二种情况就是第一种按照 $x$ 轴对称了一下的结果，后两种类似。于是可以通过坐标变换都转化到第一种问题。</p>
<p>对于第一个问题，发现询问可以分段处理，于是想到 $\rm CDQ$ 。考虑如何处理离自己最近的点：</p>
<script type="math/tex; mode=display">
x_i-x_j+y_i-y_j=(x_i+y_i)-(x_j+y_j)</script><p>这样转化出来的两部分即具有差分性质（即可以拆），并且保证了只与时间轴有关（不再和网格图有关）。所以可以把 $x_i+y_i$ 插入进去，这样就可以用四遍 $\rm CDQ$ 做完这题了。</p>
<p>感觉还是很神仙的吧…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 600010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 192608170</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, bit[MAXM], ans[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrys</span>&#123;</span> <span class="keyword">int</span> mk, id, x, y ; &#125;t[MAXN], q[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ch_top 24000001</span></span><br><span class="line"><span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &lt; <span class="number">48</span>) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &gt;= <span class="number">48</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">7</span>] ; <span class="keyword">static</span> <span class="keyword">int</span> top ;</span><br><span class="line">    <span class="keyword">while</span> (st[++ top] = <span class="number">48</span> + x % <span class="number">10</span>, x /= <span class="number">10</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (*++ now_w = st[top], -- top) ; *++ now_w = <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; p &lt;= K &amp;&amp; bit[p] ; p += low(p)) bit[p] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> ( ; p &lt;= K ; p += low(p)) bit[p] = max(bit[p], v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( ; p ; p -= low(p)) ret = max(ret, bit[p]) ; </span><br><span class="line">	<span class="keyword">return</span> ret ? ret : -Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdq</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == R) <span class="keyword">return</span> ; </span><br><span class="line">	rg <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, l, r, o = L ; </span><br><span class="line">	cdq(L, Mid), cdq(Mid + <span class="number">1</span>, R), l = L, r = Mid + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt;= Mid &amp;&amp; base[l].x &lt;= base[r].x)&#123;</span><br><span class="line">			<span class="keyword">if</span> (base[l].mk &lt; <span class="number">2</span>) </span><br><span class="line">				upd(base[l].y, base[l].x + base[l].y) ; </span><br><span class="line">			t[o ++] = base[l ++] ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (base[r].mk &gt; <span class="number">1</span>) </span><br><span class="line">			ans[base[r].id] = min(ans[base[r].id], </span><br><span class="line">							  base[r].x + base[r].y - qry(base[r].y)) ; </span><br><span class="line">		t[o ++] = base[r ++] ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (rg <span class="keyword">int</span> i = L ; i &lt; l ; ++ i) </span><br><span class="line">    <span class="keyword">if</span> (base[i].mk &lt; <span class="number">2</span>) del(base[i].y) ;</span><br><span class="line">	<span class="keyword">while</span> (l &lt;= Mid) t[o ++] = base[l ++] ; </span><br><span class="line">  <span class="keyword">for</span> (rg <span class="keyword">int</span> i = L ; i &lt;= R ; ++ i) base[i] = t[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;ox, <span class="keyword">const</span> <span class="keyword">int</span> &amp;oy)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N + M ; ++ i)&#123;</span><br><span class="line">		base[i] = q[i] ; </span><br><span class="line">		base[i].x = ox ? q[i].x : K - q[i].x, </span><br><span class="line">		base[i].y = oy ? q[i].y : K - q[i].y ;</span><br><span class="line">	&#125;</span><br><span class="line">	cdq(<span class="number">1</span>, N + M) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("data1.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//	freopen("data1.out", "w", stdout) ;</span></span><br><span class="line">	fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">	N = read(), M = read() ; <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="built_in">memset</span>(ans, <span class="number">63</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		q[i].mk = <span class="number">1</span>, q[i].id = i, q[i].x = read() + <span class="number">1</span>, </span><br><span class="line">		q[i].y = read() + <span class="number">1</span>, K = max(K, max(q[i].x, q[i].y) + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) </span><br><span class="line">		q[i].mk = read(), q[i].id = i, q[i].x = read() + <span class="number">1</span>, </span><br><span class="line">		q[i].y = read() + <span class="number">1</span>, K = max(K, max(q[i].x, q[i].y) + <span class="number">1</span>) ;</span><br><span class="line">	solve(<span class="number">1</span>, <span class="number">0</span>), solve(<span class="number">0</span>, <span class="number">1</span>), solve(<span class="number">1</span>, <span class="number">1</span>), solve(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) <span class="keyword">if</span> (q[i].mk &gt; <span class="number">1</span>) write(ans[i]) ;</span><br><span class="line">	fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不知道啥时候才能真正地灵活运用…</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>CDQ分治</category>
      </categories>
      <tags>
        <tag>离线算法/CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活碎片3】· Life is strange</title>
    <url>/2020/01/24/Life3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Life is strange, no matter who u are.</p>
</blockquote>
<a id="more"></a>
<p>初逢「奇异人生」这款游戏，还是从C菌那里了解的。但是这次不同以往，发现这东西在Mac上完全带的起来，于是就决定自己在steam上买来玩儿。虽然没有汉化，但是基本上还是很流畅的（除了有时候由于不知道在说哪国英语而疯狂卡关）。最后从C菌那里也成功地看到了第二个结局。</p>
<p>至于「奇异人生二」，则完全是在看C菌的实况。从19年 $4$ 月的第三章等到 $8$ 月，接着等到 $12$ 月，这部被先入为主的粉丝批评「没有第一部好」的杰作，终于迎来了它的 $\rm Ending$。结局共 $4$ 个，都体现了很高的「讲故事」水平，个人来讲这可能是我能想到最好的结局。</p>
<p>会有三吗？可能会有吧。对我来说，这是个有温度的公司，制作的有温度的游戏。每一帧画面、每一首 $\rm bgm$ 都是在不紧不慢地叙事，交织成一条缓缓流淌的河，流过主人公的奇异人生，流向远方。</p>
<p>那其中或许昭示着，每一种不同的生命状态都有其存在的意义和价值。换句话说，不论你活成什么样，都值得继续活下去。因为人生的意义，就在于活着。</p>
<!--more-->
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>其实 「奇异人生1」的剧情已经在 「随想9」里面说了很多啦。大概就是讲的两个妹子之间无可撼动的友谊遇上了滥用会导致天灾的超能力，最后（我选择）把 $\rm Acadia~ Bay$ 整个牺牲了换妹子的故事。</p>
<p>其实 $1$ 里面的剧情也好、世界也好，都仅仅是局限在 $\rm Acadia~ Bay$ 的一角而已，比起「二」中的「竖跨美国」来讲十分的狭窄。所以如果说「二」的主题是「成长」与「勇气」，那么「一」的主题可能会是「成长」与 「赋予意义」。</p>
<p>$\rm Max$ 生活的城市其实并不很好，学校里的环境也不完美。然而从 $\rm Max$ 掌握了超能力开始，她似乎可以拯救周围的一切了——救下要自杀的同学、解决了人际关系的漏洞、数次救回了在死亡边缘疯狂试探的 $\rm Cloye$ 。但是无论怎么改，到最后都无法创造一个完美的结局——可以说，到最后，让 $\rm Cloye$ 活着才是她最希望且唯一希望的事。</p>
<p>但其实，似乎制作者钦定的结局是牺牲 $\rm Cloye$ 而不是 $\rm Acadia~Bay$。这或许就更好地揭示了「赋予意义」这层含义：生活其实本身就是那样地充满 “$\rm Obstacles$” ，也没有什么可以拯救一切的超能力（因为 $\rm Max$ 的超能力滥用会导致日食、双月、飓风等非自然现象），所以大家都只是平凡活着的平凡人，做着自己喜欢的平凡的事，人生是否「奇异」不在于自己获得了什么天助的能力，在于给自己的平凡生活赋予了什么不凡的意义。「碌碌无为」的牢笼需要自己走出，拥有再强的超能力也只是加速了自己原地打转的速度而已。所以，可能学会「赋予意义」才是让每天都可以「翩翩起舞」的最佳方案。</p>
<p>所以最后 $\rm Cloye$ 被剧情杀了。可能这也是在告诉 $\rm Max$ 和我们，一切美好的东西都会逝去，如何对接下来的生活更好地赋予意义，才是真正需要思考的问题。</p>
<p>「一」中最受好评的，可能是其最后两章的叙事手法，简直是神来之笔。一遍遍回溯、一遍遍寻找，交叠的空间与时间，$\rm Max$ 拯救 $\rm Cloye$ 的过程，让人十分动容。</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>「奇异人生二」跟「一」不同。主角兄弟俩一开始过着平稳安逸的生活，被突如其来的冲突打乱、被视为通缉犯，决定南下去墨西哥开启新生活，并在途中经历了一系列波折。这其中没有「一」中奇诡的剧情，但是横跨了比「一」更大的时空。</p>
<p>其实呢，「二」遭人诟病，是因为剧情比起「一」来水了很多。「二」中的作画和配乐依旧优秀、细节处理依然到位，但是剧情很薄。比起「一」中 $\rm Max$ 和 $\rm Cloye$ 无比真挚的友谊，「二」中没有激烈的情感喷薄，只是在淡淡地叙事罢了。</p>
<p>但是，「二」的剧情似乎被最后的结局给救了回来。最后一共有四个结局：</p>
<ul>
<li>1：弟弟用超能力炸毁了边境大门，和哥哥一起去了墨西哥。这个结局需要之前的剧情交互中对弟弟管教不严格、让弟弟肆意妄为且最后玩家选择「冲」才可以达成。最后他们在墨西哥开了间修车厂，过上了黑帮的生活。个人感觉不是一个很好的结局，因为本身他俩都是受害者，经历劫难之后似乎根本没有走出阴影，也就是「成长」的味道比较浅。</li>
<li>2：哥哥选择投降，但是弟弟不投降，执意冲过边境线但导致哥哥被流弹击杀。这个结局需要之前的剧情交互中对弟弟管教不严格、让弟弟肆意妄为且最后玩家选择「不冲」才可以达成。最后弟弟一个人在墨西哥开启了新的「秧歌star」生活…我觉得应该是最烂的结局了233</li>
<li>3：哥哥选择投降，弟弟也选择投降。这需要选择「不冲」并且弟弟被玩家教育的很懂事才可以。最后当然是哥哥被关了 $20+$ 年，弟弟由于是未成年人并且自首啥事没有，出来已经是中年人了。也不是很好吧233</li>
<li>4：哥哥选择冲，弟弟选择帮他炸开边境但是自己留了下来、接受制裁。这是我认为最好的结局。哥哥路上经历的一切有了报偿，弟弟也不再一味索求，选择主动奉献。最后的结局很美。哥哥在墨西哥给弟弟写信，弟弟在美国的外公外婆家里读信。两人都成长了、收获了自己应有的生活。</li>
</ul>
<p>「二」中的剧情，是慢慢地讲述着的。无论是他们重逢了他们的母亲，还是路上遇到一切的艰难险阻，都如同一条均匀地洒满金箔的河流，慢慢地流淌，慢慢地把闪光点展露出来。</p>
<p>这是 $\rm B$ 站里面四个结局的 $\rm Link$：<a href="https://www.bilibili.com/video/av78032043?from=search&amp;seid=1274319984559483706" target="_blank" rel="noopener">戳我</a></p>
<h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>「二」中也或多或少直径了第一部，于是会根据玩家第一部选择的是牺牲 $\rm Cloye$ 还是 $\rm Acadia~Bay$ 流了不同的彩蛋。</p>
<p>最后留个 $\rm Link$ 吧：<a href="https://www.bilibili.com/video/av78454677?from=search&amp;seid=2854200599543211488" target="_blank" rel="noopener">戳我</a> </p>
<p>你问我为什么不像以前一样写很长的篇末总结？</p>
<p>对于这种十分美好的东西，「让它淡淡的来，让他好好的去」才是最恰当的方案吧？</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>【探究】用LCT维护MST</title>
    <url>/2020/01/24/LCT3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是整理了一下 $\rm LCT$ 维护 $\rm min/max~spanning~tree$ 。</p>
<p>说起来其实很简单，只要维护一条路径中最长的那条边，然后替换即可。</p>
<p>似乎很简单？就是很简单。</p>
<a id="more"></a>
<h1 id="LG3366-【模板】最小生成树"><a href="#LG3366-【模板】最小生成树" class="headerlink" title="LG3366 【模板】最小生成树"></a>LG3366 【模板】最小生成树</h1><p>就是贴个代码?</p>
<p>值得注意的是，需要把每一条边加入点，删除的话就只需要把与这条边相连的点之间的边断掉。</p>
<p>似乎没啥难的？LCT虽然说很长，但是似乎写起来很轻松诶。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) e[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) e[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl(k) e[k].vl</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">600010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vl ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">int</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[N] ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> val[M] ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lc(fa(x)) == x) || (rc(fa(x)) == x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span>, swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    val[x] = x ;</span><br><span class="line">    <span class="keyword">if</span> (vl(val[x]) &lt; vl(val[lc(x)])) val[x] = val[lc(x)] ;</span><br><span class="line">    <span class="keyword">if</span> (vl(val[x]) &lt; vl(val[rc(x)])) val[x] = val[rc(x)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (notroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    fa( t[x].son[w ^ <span class="number">1</span>] ) = f1 ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">    update(f1) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y ;</span><br><span class="line">    stk[++ tp] = y = x ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(y))</span><br><span class="line">        y = fa(y), stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (notroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((rc(f1) == x) == (rc(f2) == f1))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y, update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span>(lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    make_root(u), access(v), splay(v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    make_root(u), fa(u) = v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    split(u, v) ;</span><br><span class="line">    fa(u) = lc(v) = <span class="number">0</span> ;</span><br><span class="line">    update(v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//access(to(x)) ; </span></span><br><span class="line">	splay(x) ;</span><br><span class="line">    lc(x) = rc(x) = fa(lc(x)) = fa(rc(x)) = <span class="number">0</span> ;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(fr(i)),</span><br><span class="line">        qr(to(i)), qr(vl(i)) ;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; vl(i) &lt;&lt; endl ;</span></span><br><span class="line">        fr(i) += m, to(i) += m ;</span><br><span class="line">        make_root(to(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (find_root(fr(i)) != to(i))</span><br><span class="line">            ans += vl(i), link(fr(i), i), link(to(i), i) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vl(i) &lt; vl(val[fr(i)]))&#123;</span><br><span class="line">			ans += vl(i) - vl(val[fr(i)]) ;</span><br><span class="line">        	cut(val[fr(i)]), link(fr(i), i), link(to(i), i) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WC2006-水管局长"><a href="#WC2006-水管局长" class="headerlink" title="[WC2006]水管局长"></a>[WC2006]水管局长</h1><blockquote>
<p>要求动态维护一张图。</p>
<p>只有删边操作、动态询问 $x$ 到 $y$ 间所有路径上最大边权的最小值。</p>
</blockquote>
<p>那显然是在最小生成树上跑。</p>
<p>既有加边也有删边的MST是没法做的。因为删边的时候可能有一堆候选集合，这是无法简单维护的。但是只有加边或者只有删边的MST很简单。由于只有删边，所以倒着做一遍就完了。</p>
<p>hiahiahia，快来欣赏一下我特别棒的码风：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> o, u, v ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(fr(i)) ;</span><br><span class="line">        qr(to(i)) ;</span><br><span class="line">        qr(vl(i)) ;</span><br><span class="line">        fr(i) += (m + q) ;</span><br><span class="line">        to(i) += (m + q) ;</span><br><span class="line">        <span class="keyword">if</span> (fr(i) &gt; to(i))</span><br><span class="line">            swap(fr(i), to(i)) ;</span><br><span class="line">        Id[mk_p(fr(i), to(i))] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span> ; i &lt;= m + q ; ++ i)&#123;</span><br><span class="line">        qr(vl(i)) ;</span><br><span class="line">        qr(fr(i)) ;</span><br><span class="line">        qr(to(i)) ;</span><br><span class="line">        fr(i) += (m + q) ;</span><br><span class="line">        to(i) += (m + q) ;</span><br><span class="line">        <span class="keyword">int</span> u = fr(i) ;</span><br><span class="line">        <span class="keyword">int</span> v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (vl(i) &lt;= <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v)</span><br><span class="line">            swap(u, v),</span><br><span class="line">            swap(fr(i), to(i)) ;</span><br><span class="line">        o = Id[mk_p(u, v)] ;</span><br><span class="line">        vis[o] = <span class="number">1</span>, mem[i] = o ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; 2333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        u = fr(i) ;</span><br><span class="line">        v = to(i) ;</span><br><span class="line">        make_root(v) ;</span><br><span class="line">        <span class="keyword">if</span> (find_root(u) != v)&#123;</span><br><span class="line">            link(u, i) ;</span><br><span class="line">            link(v, i) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vl(i) &lt; vl(val[u]))&#123;</span><br><span class="line">            dcut(val[u]) ;</span><br><span class="line">            link(u, i) ; link(v, i) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + q ; i &gt; m ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = fr(i) ;</span><br><span class="line">        <span class="keyword">int</span> v = to(i) ;</span><br><span class="line">        <span class="keyword">int</span> j = mem[i] ;</span><br><span class="line">        <span class="keyword">if</span> (vl(i) == <span class="number">1</span>)&#123;</span><br><span class="line">            merge(u, v) ;</span><br><span class="line">            ans[i - m] = vl(val[v]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            u = fr(j) ;</span><br><span class="line">            v = to(j) ;</span><br><span class="line">            make_root(v) ;</span><br><span class="line">            ans[i - m] = <span class="number">-1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (find_root(u) != v)&#123;</span><br><span class="line">                link(u, j) ;</span><br><span class="line">                link(v, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vl(j) &lt; vl(val[fr(j)]))&#123;</span><br><span class="line">                dcut(val[u]) ;</span><br><span class="line">                link(u, j) ; link(v, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~ans[i]) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NOI2014-魔法森林"><a href="#NOI2014-魔法森林" class="headerlink" title="[NOI2014]魔法森林"></a>[NOI2014]魔法森林</h1><blockquote>
<p>给出一个 $n$ 个点，$m$ 条边的无向图，每条边都有权值 $a_i,b_i$ 。</p>
<p>求一条从点 $1$ 到点 $n$ 的路径，使得这条路径上边的 $a_i,b_i$ 最大值之和最小。</p>
<p>$2 \leq n \leq 5 \times 10^4, 0 \leq m \leq 1 \times 10^5$。</p>
</blockquote>
<p>发现可以先把边权按照第一维排个序，然后做普通的lct维护MST就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ans = MAX ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(fr(i)), qr(to(i)), qr(va(i)), qr(vb(i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) fr(i) += m, to(i) += m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m + <span class="number">1</span> ; ++ i) f[i] = i ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        rg <span class="keyword">int</span> f1, f2 ;</span><br><span class="line">        rg <span class="keyword">int</span> u = fr(i), v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; val[i] &lt;&lt; endl ;</span></span><br><span class="line">        merge(v, u) ;</span><br><span class="line">        f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            link(u, i), link(v, i) ;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &lt; sz[f2])</span><br><span class="line">                f[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            <span class="keyword">else</span> f[f2] = f1, sz[f1] += sz[f2] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vb(i) &lt; vb(val[u]))</span><br><span class="line">            cut(val[u]), link(u, i), link(v, i) ;</span><br><span class="line">        <span class="keyword">if</span> (find(m + <span class="number">1</span>) == find(m + n))</span><br><span class="line">            merge(m + <span class="number">1</span>, n + m),</span><br><span class="line">            ans = Min(ans, va(i) + vb(val[n + m]) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans == MAX ? <span class="number">-1</span> : ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我在水博客。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>数据结构/LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】LCT简单题选做</title>
    <url>/2020/01/24/LCT2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是重学了一遍 $\rm LCT$。然后整理一下之前做过的题？大多数都比较套路。</p>
<a id="more"></a>
<h1 id="SDOI2008-洞穴勘测"><a href="#SDOI2008-洞穴勘测" class="headerlink" title="[SDOI2008]洞穴勘测"></a>[SDOI2008]洞穴勘测</h1><blockquote>
<p>动态维护图的连通性。</p>
<p>保证任意时刻图的边数不超过 $n-1$ 条。</p>
</blockquote>
<p>发现是个sb线段树分治，然后随便写个lct就过了（</p>
<h1 id="COCI-2009-OTOCI-极地旅行社"><a href="#COCI-2009-OTOCI-极地旅行社" class="headerlink" title="[COCI 2009] OTOCI / 极地旅行社"></a>[COCI 2009] OTOCI / 极地旅行社</h1><blockquote>
<p>给出一张空图</p>
<ul>
<li><p><code>bridge u v</code>：询问结点 u与结点 $v$ 是否连通。如果是则输出 <code>no</code>；否则输出 <code>yes</code>，并且在结点 $u$ 和结点 $v$ 之间连一条无向边。</p>
</li>
<li><p><code>penguins u x</code>：将结点 $u$ 对应的权值$ w_u$ 修改为 $x$。</p>
</li>
<li><p><code>excursion u v</code>：如果结点 $u$ 和结点 $v$ 不连通，则输出 <code>impossible</code>。否则输出结点 $u$ 到结点 $v$ 的路径上的点对应的权值的和。</p>
</li>
</ul>
<p>保证两点存在至多一条路径。</p>
</blockquote>
<p>发现是个弱智题，随便维护一下就可以。</p>
<h1 id="BJOI2014-大融合"><a href="#BJOI2014-大融合" class="headerlink" title="[BJOI2014]大融合"></a>[BJOI2014]大融合</h1><blockquote>
<p>给出一张空图</p>
<ul>
<li><code>A x y</code> ：若 $x$ 和 $y$不连通则连边.</li>
<li><code>Q x y</code> ：询问 $a$ 和 $b$ 在边 $(x,y)$ 两端的 $(a,b)$ 点对数。 </li>
</ul>
</blockquote>
<p>考虑实儿子和虚儿子数量分别维护。发现只有 <code>access</code> 和 <code>link</code> 需要修改。于是魔改一下就做完了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) </span><br><span class="line">		splay(x), npn[x] += size[rc] - size[qwq], rc = qwq, push_up(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Access(x), splay(x), reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    Rooten(x), Access(y), splay(y) ;</span><br><span class="line">    T[x].F = y, npn[y] += size[x], push_up(y) ;</span><br><span class="line">&#125;<span class="comment">//npn维护虚儿子</span></span><br></pre></td></tr></table></figure>
<p>注意一个问题，就是查询的时候需要这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(M --)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, O, &amp;A, &amp;B) ; <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'A'</span>) Link(A, B) ;</span><br><span class="line">    <span class="keyword">else</span> Rooten(A), Access(B), splay(B), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1L</span>L * size[A] * (size[B] - size[A])) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(M --)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, O, &amp;A, &amp;B) ; <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'A'</span>) Link(A, B) ;</span><br><span class="line">    <span class="keyword">else</span> Rooten(A), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1L</span>L * size[B] * (size[A] - size[B])) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概可以理解成朝向的问题，就是B的size方向没更新，所以要改一下朝向。也就是i本来LCT是没有根的，make_root实际上是一个无根树转有根树的过程，但是转完之后除了和u一个splay里的点，剩下的点都不知道换根了。</p>
<p>嗯，我觉得这么编十分有道理。</p>
<h1 id="国家集训队-Tree-II"><a href="#国家集训队-Tree-II" class="headerlink" title="[国家集训队]Tree II"></a>[国家集训队]Tree II</h1><blockquote>
<p>一棵 $n$ 个点的树，每个点的初始权值为 $1$。</p>
<p>对于这棵树有 $q$ 个操作，每个操作为以下四种操作之一：</p>
<ul>
<li><code>+ u v c</code>：将 $u$ 到 $v$ 的路径上的点的权值都加上自然数 $c$ ；</li>
<li><code>- u1 v1 u2 v2</code>：将树中原有的边 $(u_1,v_1)$ 删除，加入一条新边 $(u_2,v_2)$，保证操作完之后仍然是一棵树 ；</li>
<li><code>* u v c</code>：将 $u$ 到 $v$ 的路径上的点的权值都乘上自然数 $c$ ；</li>
<li><code>/ u v</code>：询问 $u$ 到 $v$ 的路径上的点的权值和，将答案对 $51061$ 取模。</li>
</ul>
</blockquote>
<p>发现就是很板的 $\rm LCT$ ？splay维护一下加法和乘法 <code>tag</code> 就好了。</p>
<p>主要是记录一下代码…</p>
<p>好久之前做的题了，当时给函数瞎起了一个 <code>split</code> 的名字，并且码风奇差，感觉自己很弟弟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> O[<span class="number">3</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">	<span class="keyword">bool</span> R ; <span class="keyword">long</span> <span class="keyword">long</span> tagv, tags ; </span><br><span class="line">	<span class="keyword">int</span> F, Son[<span class="number">2</span>], sz ; <span class="keyword">long</span> <span class="keyword">long</span> s, v  ;</span><br><span class="line">&#125;T[MAXN] ; <span class="keyword">int</span> stk[MAXN], base[MAXN], N, M, A, B, C, i ;</span><br><span class="line">                                                       </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;     </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;   </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;                        </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>;   </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) splay(x), rc = qwq, update(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123; (T[x].s += y * size) %= Mod, (T[x].v += y) %= Mod, (T[x].tags += y) %= Mod ; &#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; T[x].s = (T[lc].s + T[rc].s + T[x].v) % Mod ; T[x].sz = T[lc].sz + T[rc].sz + <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123; (T[x].s *= y) %= Mod, (T[x].v *= y) %= Mod, (T[x].tagv *= y) %= Mod ; (T[x].tags *= y) %= Mod ; &#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">    T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x, T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> qwq = x, t = <span class="number">1</span> ; stk[<span class="number">1</span>] = x ;</span><br><span class="line">	<span class="keyword">while</span>(check(qwq)) stk[++ t] = (qwq = T[qwq].F) ;</span><br><span class="line">	<span class="keyword">while</span>(t) push_down(stk[t --]) ;</span><br><span class="line">	<span class="keyword">while</span>(check(x))&#123;</span><br><span class="line">		<span class="keyword">register</span> <span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line">		<span class="keyword">if</span> (check(fa)) rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> res = <span class="number">0</span>, k = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) k = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ;  T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; split(x, y) ; T[x].F = T[y].Son[<span class="number">0</span>] = <span class="number">0</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (T[x].tagv != <span class="number">1</span>) Mul(lc, T[x].tagv), Mul(rc, T[x].tagv), T[x].tagv = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (T[x].tags)	    Add(lc, T[x].tags), Add(rc, T[x].tags), T[x].tags = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (T[x].R) 	&#123; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	rep(i, <span class="number">1</span>, N) T[i].v = T[i].tagv = T[i].sz = <span class="number">1</span> ;</span><br><span class="line">	rep(i ,<span class="number">1</span>, N - <span class="number">1</span>) A = qr(), B = qr(), Link(A, B) ;</span><br><span class="line">	rep(i, <span class="number">1</span>, M)&#123;</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;O) ;</span><br><span class="line">		<span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'+'</span>) A = qr(), B = qr(), C = qr(), split(A, B), Add(B, C) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'*'</span>) A = qr(), B = qr(), C = qr(), split(A, B), Mul(B, C) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'/'</span>) A = qr(), B = qr(), split(A, B), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, T[B].s) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (O[<span class="number">0</span>] == <span class="string">'-'</span>) A = qr(), B = qr(), Cut(A, B), A = qr(), B = qr(), Link(A, B) ;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构/LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Cf938G Shortest Path Queries</title>
    <url>/2020/01/24/Cf938G/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给出一个连通带权无向图,边有边权,要求支持 $q$ 个操作:</p>
<p><code>1 x y d</code> 在原图中加入一条 $x$ 到 $y$ 权值为 $b$ 的边。</p>
<p><code>2 x y</code> 把图中 $x$ 到 $y$ 的边删掉。</p>
<p><code>3 x y</code> 表示询问 $x$ 到 $y$ 的异或最短路。</p>
<p>保证任意操作后原图连通无重边自环且操作均合法。</p>
<p>$1\leq n,m,q\leq 200000$</p>
<a id="more"></a>
<p>这题和 [HAOI2017] 的那个不是很相同。那题比较弱智，每次询问的只是包括 $1$ 的圈，但是这题需要维护连通性，并且没有初始边。所以就需要维护一个可撤销的 $dsu$ 来配合操作。</p>
<p>嗯，又写了一遍发现这个可撤销并查集的实现可能需要再领悟一下。</p>
<p>感觉代码实现方面还有很多需要熟悉的啊…尤其是线性基维护生成树、直接用 <code>query(x) &amp; query(y)</code> 就可以直接求出询问，感觉很神奇。慢慢学、慢慢来吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">30</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">800010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, l, r, val ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qss</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">&#125;qs[N] ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> tot, cntq ;</span><br><span class="line"><span class="keyword">int</span> fa[N], sz[N] ;</span><br><span class="line"><span class="built_in">map</span> &lt;pint, <span class="keyword">int</span>&gt; sch ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; S[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxj</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> base[<span class="number">50</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = B ; ~k ; -- k)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; k &amp; x)&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[k]) x ^= base[k] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> base[k] = x, <span class="keyword">void</span>() ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~i ; -- i)</span><br><span class="line">            ret = min(ret, ret ^ base[i]) ;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;F ;</span><br><span class="line"><span class="comment">//using namespace xxj ;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, edge val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &gt; ur) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b(val), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, val) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, val) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dofa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doxor</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        ret ^= f[x], x = fa[x] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, xxj now)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;edge&gt; O ; <span class="comment">//O.clear() ;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; <span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> w = S[rt][i].val ;</span><br><span class="line">        <span class="keyword">int</span> f1 = dofa(u), f2 = dofa(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; w &lt;&lt; endl ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; " " &lt;&lt; sz[f1] &lt;&lt; " " &lt;&lt; sz[f2] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &gt; sz[f2])</span><br><span class="line">                swap(f1, f2), swap(u, v) ;</span><br><span class="line">            O.p_b((edge)&#123;f1, f2, sz[f2]&#125;) ;</span><br><span class="line">            fa[f1] = f2, sz[f2] += sz[f1],</span><br><span class="line">            f[f1] = doxor(u) ^ doxor(v) ^ w ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now.Insert(doxor(u) ^ doxor(v) ^ w) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        ans[l] = now.Query(doxor(qs[l].u) ^ doxor(qs[l].v)) ;</span><br><span class="line">    <span class="keyword">else</span> solve(rt &lt;&lt; <span class="number">1</span>, l, mid, now),</span><br><span class="line">         solve(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, now) ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; f[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = O.size() - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        fa[O[i].u] = O[i].u, sz[O[i].v] = O[i].l, f[O[i].u] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, mk ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fa[i] = i, sz[i] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(u), qr(v), qr(w) ;</span><br><span class="line">        e[++ tot] = (edge)&#123;u, v, <span class="number">1</span>, <span class="number">-1</span>, w&#125; ;</span><br><span class="line">        sch[mkp(u, v)] = tot ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        qr(mk), qr(u), qr(v) ;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) swap(u, v) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            qr(w), ++ tot,</span><br><span class="line">            sch[mkp(u, v)] = tot,</span><br><span class="line">            e[tot] = (edge)&#123;u, v, cntq + <span class="number">1</span>, <span class="number">-1</span>, w&#125; ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            e[sch[mkp(u,v)]].r = cntq ;</span><br><span class="line">        <span class="keyword">else</span> qs[++ cntq] = (qss)&#123;u, v&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (e[i].r &lt; <span class="number">0</span>) e[i].r = cntq ;</span><br><span class="line">   <span class="comment">// for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; e[i].l &lt;&lt; " " &lt;&lt; e[i].r &lt;&lt; " " &lt;&lt; e[i].u &lt;&lt; " " &lt;&lt; e[i].v &lt;&lt; " " &lt;&lt; e[i].val &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, cntq, e[i].l, e[i].r, e[i]) ;</span><br><span class="line">    solve(<span class="number">1</span>, <span class="number">1</span>, cntq, F) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>离线算法/线段树分治</tag>
        <tag>线性代数/线性空间/线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】loj#2312 [HAOI2017]八纵八横</title>
    <url>/2020/01/24/HAOI2017%E5%85%AB%E7%BA%B5%E5%85%AB%E6%A8%AA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实不是什么难题，只是因为「写起来很麻烦」+「单独拿出来方便记忆」所以单独开一篇。</p>
<a id="more"></a>
<p>Anihc 国有 $n$ 个城市，这 $n$ 个城市从 $1$ 编号，$1$ 号城市为首都。城市间初始时有 $m$ 条高速公路，每条高速公路都有一个非负整数的经济影响因子，每条高速公路的两端都是城市（可能两端是同一个城市)，保证任意两个城市都可以通过高速公路互达。</p>
<p>Anihc 国正在筹划「八纵八横」的高铁建设计划，计划要修建一些高速铁路，每条高速铁路两端也都是城市（可能两端是同一个城市)，也都有一个非负整数的经济影响因子。国家还计划在「八纵八横」计划建成之后，将「一带一路」扩展为「一带一路一环」，增加「内陆城市经济环」即选择一条从首都出发沿若一系列高铁与高速公路走的路径，每条高铁或高速公路可以经过多次，每座城市也可以经过多次，最后路径又在首都结束。令「内陆城市经济环」的 $\rm GDP$ 为依次将这条路径上所经过的高铁或高速公路的经济影响因子异或起来（一条路经过多次则会被计算多次）。</p>
<p>现在 Anihc 在会议上讨论「八纵八横」的建设计划方案，他们会不断地修改计划方案，希望你能实时反馈对于当前的「八纵八横」的建设计划的方案「内陆城市经济环」的最大是多少。</p>
<p>初始时，八纵八横计划中不包含任何—条高铁，有以下三种操作：</p>
<p><code>Add x y z</code>  在计划中给在城市 $x$ 和城市 $y$ 之间建设一条高铁，其经济影响因子为 $z$，如果这是第 $k$ 个 <code>Add</code> 操作，则将这条高铁命名为 $k$ 号高铁。</p>
<p><code>Cancel k</code>  将计划中的 $k$ 号高铁取消掉，保证此时 $k$ 号高铁一定存在。</p>
<p><code>Change k z</code>  表示将第 $k$ 号高铁的经济影响因子更改为 $z$，保证此时 $k$ 号高铁一定存在.</p>
<h2 id="rm-Sol"><a href="#rm-Sol" class="headerlink" title="$\rm Sol$"></a>$\rm Sol$</h2><p>不得不说这题有点恶心…因为他需要 <code>bitset</code>，于是各种操作就很不优美。</p>
<p>大概就是考虑用线段树分治去维护边的存在性。那么接下来就是一开始随便 $dfs$ 出一个生成树来，然后每次询问时，发现对于每个合法的方案都是从 $1$ 开始的一个环。 那么考虑最后一定是一些环套起来，所以可以直接在线性基里面查询。</p>
<p>做这题时发现，这么做的正确性在于，可以随便生成一棵树。同时生成出来的环也具有「生成子集」的性质，也就是说可以据此生成所有 <strong>剩下未被统计的环</strong>。要证明其实也不难。</p>
<p>所以可能这种「线性基+生成树+环生成子集」的结合是“完洽”的，即彼此有着共同的性质，这种搭配似乎不是很常见？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p_b push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">char</span> s[L] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; val ;</span><br><span class="line">&#125;E[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, l, r ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; val ;</span><br><span class="line">&#125;e[M] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;L&gt; f[N] ;</span><br><span class="line"><span class="built_in">bitset</span> &lt;L&gt; ans[N] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; S[N * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt, tot, k ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> xxj&#123;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;L&gt; base[L] ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(<span class="built_in">bitset</span>&lt;L&gt; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (x[i])&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[i][i]) x ^= base[i] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> base[i] = x, i ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;L&gt; Query()&#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;L&gt; res ; res.reset() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">            <span class="keyword">if</span> (res[i] ^ base[i][i]) res ^= base[i] ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> xxj ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_put</span><span class="params">(<span class="built_in">bitset</span> &lt;L&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (!x[i])</span><br><span class="line">            &#123;<span class="keyword">if</span> (flag) <span class="built_in">putchar</span>(<span class="string">'0'</span>) ;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'1'</span>), flag = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitset</span>&lt;L&gt; get_bit()&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s + <span class="number">1</span>) ;</span><br><span class="line">    <span class="built_in">bitset</span> &lt;L&gt; ret ; ret.reset() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= len ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) ret.<span class="built_in">set</span>(len - i) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="built_in">bitset</span>&lt;L&gt; w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, edge val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= l &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b(val), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, val) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, val) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; O ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> d = Insert(S[rt][i].val ^ f[u] ^ f[v]) ;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) O.p_b(d) ; <span class="comment">//,cout &lt;&lt;d&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) ans[l] = Query() ;</span><br><span class="line">    <span class="keyword">else</span> solve(rt &lt;&lt; <span class="number">1</span>, l, mid),</span><br><span class="line">         solve(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; O.size() ; ++ i) base[O[i]].reset() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[to(k)])</span><br><span class="line">            Insert(f[u] ^ f[to(k)] ^ val(k)) ;</span><br><span class="line">        <span class="keyword">else</span> f[to(k)] = f[u] ^ val(k), dfs(to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(u), qr(v), add(u, v, get_bit()) ;</span><br><span class="line">    dfs(<span class="number">1</span>) ;</span><br><span class="line">	<span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; f[i].count() &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;<span class="comment">// cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'A'</span>)</span><br><span class="line">            ++ tot, qr(e[tot].u), qr(e[tot].v),</span><br><span class="line">            e[tot].val = get_bit(), e[tot].l = i, e[tot].r = q ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">2</span>] == <span class="string">'a'</span>)</span><br><span class="line">            qr(u),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, q, e[u].l, i - <span class="number">1</span>, e[u]), e[u].l = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">else</span> qr(u), update(<span class="number">1</span>, <span class="number">0</span>, q, e[u].l, i - <span class="number">1</span>, e[u]),</span><br><span class="line">             e[u].l = i, e[u].val = get_bit(), e[u].r = q ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	for (int i = 1 ; i &lt;= tot ; ++ i) </span></span><br><span class="line"><span class="comment">//		cout &lt;&lt; e[i].l &lt;&lt; " " &lt;&lt; e[i].u &lt;&lt; " " &lt;&lt; e[i].v &lt;&lt; " " &lt;&lt; e[i].val.count() &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; 2333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (~e[i].l) update(<span class="number">1</span>, <span class="number">0</span>, q, e[i].l, q, e[i]) ;</span><br><span class="line">    solve(<span class="number">1</span>, <span class="number">0</span>, q) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= q ; ++ i) out_put(ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>离线算法/线段树分治</tag>
        <tag>线性代数/线性空间/线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】线段树分治</title>
    <url>/2020/01/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线段树分治用于离线处理一些带有时间属性的操作。最常见的是对于给定的每个操作都只在某个时间区间内存在效力，换言之即每个操作都需要可撤销。</p>
<p>嗯，废话说完了。做法大概就是拿线段树 $+$ <code>vector</code> 维护一下操作区间的所有操作，然后直接在询问里按时间跑分治，顺便在线段树内维护合法修改即可。</p>
<a id="more"></a>
<h1 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h1><p>以下是 $bzoj4025$ :</p>
<blockquote>
<p>神犇有一个 $n$ 个节点的图。</p>
<p>因为神犇是神犇，所以在 $\rm T$ 时间内一些边会出现后消失。神犇要求出每一时间段内这个图是否是二分图。这么简单的问题神犇当然会做了，于是他想考考你。</p>
<p>$1\leq n,m,\rm T\leq 10^6$。</p>
</blockquote>
<p>大概就是通过线段树+vector维护每个区间加了哪些边，然后通过可撤销的并查集来维护当前图内是否有奇环。判断过程大概就是如果可以有边加进去就加边，否则判断两者到根的实际距离是否奇偶性相同，如果相同那么添上这条边一定会使得出现一个奇环。</p>
<p>然后这题由于有奇环可以把答案记为 $0$，那么就可以不再递归下去。也算是一个剪枝？</p>
<p>哦对，由于要支持撤销，所以就换成了按 $\rm size$ 合并的并查集。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> T = <span class="number">400010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, ans[T] ;</span><br><span class="line"><span class="keyword">int</span> dis[N], fa[N], sz[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span> <span class="keyword">int</span> u, v ; &#125; ;</span><br><span class="line"><span class="built_in">vector</span> &lt;edges&gt; S[N * <span class="number">3</span>], O ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        x = fa[x] ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (x != fa[x])</span><br><span class="line">        ret ^= dis[x], x = fa[x] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> fr, <span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> S[rt].p_b((edges)&#123;fr, to&#125;), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, fr, to) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, fr, to) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ; <span class="built_in">vector</span>&lt;edges&gt;O ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S[rt].size() ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = S[rt][i].u ;</span><br><span class="line">        <span class="keyword">int</span> v = S[rt][i].v ;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &gt; sz[f2])</span><br><span class="line">                swap(f1, f2), swap(u, v) ;</span><br><span class="line">            O.p_b((edges)&#123;f1, f2&#125;) ;</span><br><span class="line">            fa[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            dis[f1] = dis[u] ^ dis[v] ^ <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dist(u) == dist(v)) &#123; ret = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">if</span> (l == r) ans[l] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> do_do(rt &lt;&lt; <span class="number">1</span>, l, mid), do_do(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = O.size() - <span class="number">1</span> ; ~i ; -- i)</span><br><span class="line">        sz[O[i].v] -= sz[O[i].u], dis[O[i].u] = <span class="number">0</span>, fa[O[i].u] = O[i].u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, l, r ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; l &gt;&gt; r ;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) update(<span class="number">1</span>, <span class="number">1</span>, k, l + <span class="number">1</span>, r, u, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        fa[i] = i, sz[i] = <span class="number">1</span> ; do_do(<span class="number">1</span>, <span class="number">1</span>, k) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        ans[i] ? <span class="built_in">puts</span>(<span class="string">"Yes"</span>) : <span class="built_in">puts</span>(<span class="string">"No"</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，然后就没了…</p>
<h1 id="一些拓展"><a href="#一些拓展" class="headerlink" title="一些拓展"></a>一些拓展</h1><h2 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h2><blockquote>
<p>求不包含元素 $1\sim n$ 的 $01$ 背包。</p>
<p>$1\leq n,m\leq 2000$</p>
</blockquote>
<p>直接线段树分治做，第 $i$ 个物品的存在时间是 $1\sim i-1$ 和 $i+1 \sim n$ .</p>
<p>但有个问题就在于每次计算的复杂度都是 $nw$ 的。所以最后复杂度就是 $nw\log n$ 。</p>
<h2 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h2><blockquote>
<p>给定一张图，对所有的 $i,j,k$ 求 $i$ 到 $j$ 不经过 $k$ 的⽅案数。</p>
</blockquote>
<p>发现朴素地做是 $n^4$ 的。可以通过和上面那题差不多的方法，用线段树分治优化到 $n^3\log n$ 。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实我关于离线三姐妹的学习顺序是CDQ-&gt;整体二分-&gt;线段树分治。最后学线段树分治是因为第一次看这个算法感觉很懵…尤其是所有题解都在繁复叨叨那几句话QAQ</p>
<p>总之，句号也是一个新的开始，不是吗？</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线段树分治</category>
      </categories>
      <tags>
        <tag>离线算法/线段树分治</tag>
        <tag>图论/二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】线性基</title>
    <url>/2020/01/24/%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>真正线性基的定义需要扯到线代那一部分。因为心情不好，所以鸽了。</p>
<p>此处主要讨论的线性基定义在异或运算上。即考虑给出一系列整数，称其中某个可以通过异或运算表出全部元素的子集为一组<strong>生成子集</strong>，称一组彼此都不能被表出元素为<strong>线性无关集</strong>。那么<strong>线性基</strong>就是一组<strong>线性无关生成子集</strong>。</p>
<p>如果把每个数看成一个 $01$ 向量。可以如是做的原因是位运算时位位独立，就如同系数矩阵在做初等变换时行、列分别独立一样。所以这个线性空间内基的个数就是这个 $01$ 矩阵的秩。换句话说，求这个的过程完全可以通过高斯消元来实现。</p>
<a id="more"></a> 
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="（1）插入"><a href="#（1）插入" class="headerlink" title="（1）插入"></a>（1）插入</h2><p>普通的插入顺便消了消元：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ;</span><br><span class="line">                ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概消成的就是一个倒三角矩阵。显然最后 $x_i$ 有值的位数就是这个矩阵的秩。</p>
<p>虽然这样插入没错，但有一种更精妙的插入方式。这样插入之后可以保证线性基内至多存在 $1$ 个 $b_i$ 位为 $1$ 的数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ; ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                	<span class="keyword">if</span> (x[j] &amp;&amp; (y &gt;&gt; j &amp; <span class="number">1</span>)) x[i] ^= x[j] ; </span><br><span class="line">               	<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">               		<span class="keyword">if</span> (x[j] &gt;&gt; i &amp; <span class="number">1</span>) x[j] ^= x[i] ; </span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样消出来的就可以保证是一个部分对角的矩阵，比上三角矩阵有着更优秀的性质。</p>
<h2 id="（2）询问"><a href="#（2）询问" class="headerlink" title="（2）询问"></a>（2）询问</h2><p>询问操作常(我)见(会)的，首先是求最大值/最小值，这东西显然贪心一遍即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">    ans = max/min(ans, ans ^ x[i]) ;</span><br></pre></td></tr></table></figure>
<p>这种感觉。从大到小枚举不是因为贪心顺序，是因为这样可以保证消元消出来没有后效性。</p>
<p>然后是询问第 $k$ 小/大。这东西的话，考虑对于这个线性空间，一共可以张成 $2^n$ 个值。特判掉 $0$ 之后，发现对 $k$ 二进制拆分实际上就是在对角矩阵里面选数。所以如果一开始选择消成对角矩阵，那么就可以直接做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">63</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> haha ; LL z ;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt ; LL ans ;</span><br><span class="line">LL base[N], x[M + <span class="number">1</span>], rst[M + <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ins</span><span class="params">(LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; ~i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!x[i]) &#123;</span><br><span class="line">                x[i] = y ; ret = <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                	<span class="keyword">if</span> (x[j] &amp;&amp; (y &gt;&gt; j &amp; <span class="number">1</span>)) x[i] ^= x[j] ; </span><br><span class="line">               	<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">               		<span class="keyword">if</span> (x[j] &gt;&gt; i &amp; <span class="number">1</span>) x[j] ^= x[i] ; </span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                y ^= x[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL k)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!haha) -- k ;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">if</span> (k &gt;= (<span class="number">1l</span>l &lt;&lt; cnt)) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; cnt ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (k &amp; (<span class="number">1l</span>l &lt;&lt; i)) res ^= rst[i] ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; haha = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; base[i], haha &amp;= ins(base[i]) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; <span class="comment">//cout &lt;&lt; haha &lt;&lt; endl ;</span></span><br><span class="line">    cnt = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (x[i]) rst[cnt ++] = x[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;z), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(z)) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目是 <code>loj#114 k大异或和</code> 。</p>
<h2 id="（3）删除"><a href="#（3）删除" class="headerlink" title="（3）删除"></a>（3）删除</h2><p>这部分我很迷啊…</p>
<p>首先如果可以离线就可以线段树分治，剩下的先鸽着。</p>
<p>大概就是考虑如果删除了一个不在线性基内的数，那就无所谓了。如果在其中，那么</p>
<h1 id="经典应用"><a href="#经典应用" class="headerlink" title="经典应用"></a>经典应用</h1><blockquote>
<p>[WC2011]最大XOR和路径</p>
<p>考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 $\operatorname{XOR}$ 和最大。</p>
<p>$1\leq n,m\leq 10^6$</p>
</blockquote>
<p>一道很经典的题。大概是维护异或生成树。</p>
<p>考虑这题先随便生成一条 $1\sim n$ 的路径，这样就是钦定了一颗生成树，那么剩下的会是一些圈。考虑从这条路径走出去，走完剩下的圈再走回来是一个来回，中间的桥边（装作）会被经过两次，所以不需要考虑。</p>
<p>所以 <code>dfs</code> 一遍就行。遇到环就丢到线性基里面，否则记录一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~ i ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l &lt;&lt; i &amp; x)&#123;</span><br><span class="line">            <span class="keyword">if</span> (base[i]) x ^= base[i] ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> base[i] = x, <span class="keyword">void</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(LL basic)</span></span>&#123;</span><br><span class="line">    LL ret = basic ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B ; ~i ; -- i)</span><br><span class="line">        ret = max(ret, ret ^ base[i]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, LL w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, val(cnt) = w ;</span><br><span class="line">    next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, LL res)</span></span>&#123;</span><br><span class="line">    f[u] = res, vis[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (!vis[to(k)]) </span><br><span class="line">          dfs(to(k), res ^ val(k)) ;</span><br><span class="line">        <span class="keyword">else</span> Ins(res ^ val(k) ^ f[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> u, v ; LL w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w, add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Query(f[n])) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线性基</category>
      </categories>
      <tags>
        <tag>线性代数/线性空间/线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】Kruskal重构树</title>
    <url>/2020/01/24/%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是模拟 <code>Kruskal</code> 加边的过程，重构成一棵树。</p>
<p>过程大概是把原图中所有的点作为重构树的叶子，边按一定的秩排序，合并两个集合时把连接两个集合的边权作为公共父亲的点权。</p>
<p>这样的建树有一定性质。比如基于最小生成树的重构，两个点的 $lca$ 点权一定是「两点之间所有路径上最大值的最小值」。</p>
<a id="more"></a>
<h1 id="NOI2018-归程"><a href="#NOI2018-归程" class="headerlink" title="[NOI2018] 归程"></a>[NOI2018] 归程</h1><blockquote>
<p>给定一张图，每条路有一个长度一个海拔。</p>
<p>每次询问，询问从点 $x$ 出发，第一段只走海拔 $&gt;h$ 的边，走到某个点，然后无限制地走第二段到达 $1$ 号点，第二段路程的最小长度。</p>
<p>强制在线。</p>
</blockquote>
<p>发现Kruskal重构树具有堆性质，于是如果基于最大生成树重构，那么对于一个点能够经过大于 $v$ 的边到达的点应该在某个子树内。所以可以按照这个方式倍增。之前预处理一下子树内到 $1$ 的 $\rm mindist$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cost(k) E[k].cost</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, c ;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, cost ;</span><br><span class="line">    <span class="keyword">int</span> fr, to, next ;</span><br><span class="line">&#125;E[M &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, n ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp; neww) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; neww.dis ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> ff[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> lastans ;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q, s ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> dis[N], vis[N] ;</span><br><span class="line">priority_queue&lt;Node&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].fr = u ;</span><br><span class="line">    E[cnt].val = w, E[cnt].cost = c ;</span><br><span class="line">    E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">127</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    Q.push((Node)&#123;<span class="number">0</span>, <span class="number">1</span>&#125;), dis[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">        Node qwq = Q.top() ; Q.pop() ;</span><br><span class="line">        <span class="keyword">int</span> x1 = qwq.n, x2 = qwq.dis ;</span><br><span class="line">        <span class="keyword">if</span>(vis[x1]) <span class="keyword">continue</span> ; vis[x1] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = head[x1]; k ; k = next(k))&#123;</span><br><span class="line">            dis[to(k)] = min(dis[E[k].to], x2 + cost(k)) ;</span><br><span class="line">               Q.push((Node)&#123;dis[to(k)], to(k)&#125;) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(edges u, edges v)</span></span>&#123; <span class="keyword">return</span> u.w &gt; v.w ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ff[x] ? x : ff[x] = find(ff[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ffff)</span></span>&#123;</span><br><span class="line">    fa[x][<span class="number">0</span>] = ffff ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">19</span> ; ++ j)</span><br><span class="line">        fa[x][j] = fa[fa[x][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        dfs(to(k), x), dis[x] = min(dis[x], dis[to(k)]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("return.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("return.out", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> tot ;</span><br><span class="line">        <span class="keyword">int</span> u, v, w, c, k, l, now, ok ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].c &gt;&gt; e[i].w,</span><br><span class="line">             add(e[i].u, e[i].v, e[i].w, e[i].c), add(e[i].v, e[i].u, e[i].w, e[i].c) ;</span><br><span class="line">        dijkstra() ;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q &gt;&gt; k &gt;&gt; s ; tot = n ; ok = <span class="number">0</span> ;</span><br><span class="line">        sort(e + <span class="number">1</span>, e + m + <span class="number">1</span>, comp) ; <span class="comment">//cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">        fill(head, head + <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">0</span>), cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * n + <span class="number">1</span> ; ++ i) ff[i] = i ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> f1 = find(e[i].u) ;</span><br><span class="line">            <span class="keyword">int</span> f2 = find(e[i].v) ;</span><br><span class="line">            <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">                ++ ok ;</span><br><span class="line">                now = ++ tot ;</span><br><span class="line">                base[now] = e[i].w ;</span><br><span class="line">                ff[f1] = now, ff[f2] = now ;</span><br><span class="line">                add(now, f1, <span class="number">0</span>, <span class="number">0</span>), add(now, f2, <span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ok == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(now, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">            u = qr(), l = qr() ; <span class="keyword">int</span> x = u ;</span><br><span class="line">            l = (l + <span class="number">1l</span>l * k * lastans) % (s + <span class="number">1</span>) ;</span><br><span class="line">            x = (x + <span class="number">1l</span>l * k * lastans - <span class="number">1</span>) % n + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">                <span class="keyword">if</span> (fa[x][j] &amp;&amp; base[fa[x][j]] &gt; l) x = fa[x][j] ;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lastans = dis[x]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)) ;</span><br><span class="line">        <span class="built_in">memset</span>(base, <span class="number">0</span>, <span class="keyword">sizeof</span>(base)) ;</span><br><span class="line">        fill(vis + <span class="number">1</span>, vis + tot + <span class="number">1</span>, <span class="number">0</span>), cnt = <span class="number">0</span> ;</span><br><span class="line">        fill(head + <span class="number">1</span>, head + tot + <span class="number">1</span>, <span class="number">0</span>), lastans = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="神秘的题目"><a href="#神秘的题目" class="headerlink" title="神秘的题目"></a>神秘的题目</h1><blockquote>
<p>给出一棵 $n$ 个点的树，树边上有边权。 </p>
<p>定义一个点的权值为其到其他所有节点的路径上最小边权之和，求权值最大的点。 </p>
</blockquote>
<p>建一棵基于最大生成树的重构树，然后发现每条边作为 $(u,v)$ 最小边权当且仅当 $u,v$ 在重构树上的 $lca$ 是这条边。</p>
<p>所以可以直接离线统计每条边的贡献，<code>dfs</code> 时将左右子树中的叶子结点个数加权互加一下就完了。可以直接在 <code>dfn</code> 上维护一个差分，这样就是排序外线性了。 </p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Kruskal重构树</category>
      </categories>
      <tags>
        <tag>技巧/倍增</tag>
        <tag>图论/Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】bzoj#3545 Peaks</title>
    <url>/2020/01/24/Peaks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有 $n$ 座山峰，每座山峰有他的高度 $h_i$。</p>
<p>有山峰之间有双向道路相连，共 $m$ 条路径，每条路径有一个困难值。</p>
<p>现在有 $q$ 组询问，询问从点 $v$ 开始只经过困难值小于等于 $x$ 的路径所能到达的山峰中第 $k$ 高的山峰，如果无解输出 $-1$。</p>
<a id="more"></a>
<p>发现可以倍增，因为 $\leq x$ 的权在重构树上是一个子树。</p>
<p>倍增完了就可以直接套主席树了。主席树可以比较简单的按照叶子的标号建，每个边结点维护一个 $\rm leftrange$ 和 $\rm rightrange$ 即可。</p>
<p>等会儿，我就整理这么点儿东西为啥要新开这一篇blog啊？太浪费资源了吧QAQ。</p>
<p><del>那看上去就只能用代码来占空间了</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">500010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> V = <span class="number">5000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">    <span class="keyword">int</span> next, val ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> dad[N] ;</span><br><span class="line"><span class="keyword">int</span> wth[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> rg[N][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">20</span>] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[V], res, sz ;</span><br><span class="line"><span class="keyword">int</span> rt[V], lc[V], rc[V] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ sz ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> now ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    lc[now] = build(l, mid) ;</span><br><span class="line">    rc[now] = build(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    <span class="keyword">return</span> now ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ sz ;</span><br><span class="line">    lc[now] = lc[last] ;</span><br><span class="line">    rc[now] = rc[last] ;</span><br><span class="line">    sum[now] = sum[last] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> now ;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= mid)</span><br><span class="line">        lc[now] = update(lc[last], l, mid, v) ;</span><br><span class="line">    <span class="keyword">else</span> rc[now] = update(rc[last], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">    <span class="keyword">return</span> now ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rtl, <span class="keyword">int</span> rtr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> delta = sum[rc[rtr]] - sum[rc[rtl]] ;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; delta)</span><br><span class="line">        <span class="keyword">return</span> query(lc[rtl], lc[rtr], l, mid, v - delta) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rc[rtl], rc[rtr], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    val(cnt) = w, fr(cnt) = u ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == dad[x] ? x : dad[x] = find(dad[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge A, Edge B)</span></span>&#123; <span class="keyword">return</span> A.val &lt; B.val ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">    rg[u][<span class="number">0</span>] = res ;</span><br><span class="line">    <span class="keyword">if</span> (!head[u])</span><br><span class="line">        rg[u][<span class="number">0</span>] = ++ res,</span><br><span class="line">        rt[res] = update(rt[res - <span class="number">1</span>], <span class="number">1</span>, len, base[u]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k)) dfs(to(k)) ;</span><br><span class="line">    rg[u][<span class="number">1</span>] = res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, now, k, tot, op ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    len = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + len + <span class="number">1</span>, base[i]) - t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w), add(v, u, w) ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + cnt + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * n ; ++ i) dad[i] = i ;</span><br><span class="line">    fill(head + <span class="number">1</span>, head + n + <span class="number">1</span>, <span class="number">0</span>), op = cnt, tot = n, cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= op ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(fr(i)) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = find(to(i)) ;</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            now = ++ tot ;</span><br><span class="line">            wth[now] = val(i) ;</span><br><span class="line">            dad[f1] = dad[f2] = now ;</span><br><span class="line">            fa[f1][<span class="number">0</span>] = fa[f2][<span class="number">0</span>] = now ;</span><br><span class="line">            add(now, f1, <span class="number">0</span>),add(now, f2, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; tot &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= tot ; ++ i) cout &lt;&lt; fa[i][0] &lt;&lt; endl ;</span></span><br><span class="line">    rt[<span class="number">0</span>] = build(<span class="number">1</span>, len) ; dfs(now) ; <span class="comment">//cout &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;w, &amp;k) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (fa[u][j] &amp;&amp; wth[fa[u][j]] &lt;= w) u = fa[u][j] ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (rg[u][<span class="number">1</span>] - rg[u][<span class="number">0</span>] &lt; k) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; rg[u][0] &lt;&lt; " " &lt;&lt; rg[u][1] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[query(rt[rg[u][<span class="number">0</span>]], rt[rg[u][<span class="number">1</span>]], <span class="number">1</span>, len, k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>技巧/倍增</tag>
        <tag>图论/Kruskal重构树</tag>
      </tags>
  </entry>
  <entry>
    <title>【探究】欧拉反演</title>
    <url>/2020/01/24/%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是对于 $\varphi$ 函数性质的一点应用？比起 $\mu$ 其实不是那么的复杂，实用性也不是很高。</p>
<p>考虑 $\varphi$ 的这么一个性质：</p>
<script type="math/tex; mode=display">
\sum _{d|n}\varphi(d)=n</script><p>这大概就是这篇文章的主角。</p>
<a id="more"></a>
<hr>
<p>这东西大概可以用莫比乌斯反演定理来证？</p>
<p>令 $f(x)=\varphi(x)$，$g(x)=\boldsymbol{\rm Id}(x)$ ，则根据狄利克雷卷积的某些常识有</p>
<script type="math/tex; mode=display">
\sum_{d|n}g(d)\mu(\frac{n}{d})=f(n)\\</script><p>反演一下</p>
<script type="math/tex; mode=display">
g(n)=\sum_{d|n}f(d)</script><p>即</p>
<script type="math/tex; mode=display">
\sum_{d|n}\varphi(d)=\boldsymbol{\rm Id}(n)=n</script><p>当然也可以通过浅显的数论知识来证明：</p>
<p>设 $f(n)=\sum_{d|n}\varphi(d)$ ，则容易证明 $f$ 也是积性函数。（易证=懒得证XD）</p>
<p>考虑 $n$ 的标准分解式：</p>
<script type="math/tex; mode=display">
n=\sum p_i^{e_i}</script><p>并且考虑当 $p\in\mathbb{P}$ 时 </p>
<script type="math/tex; mode=display">
\varphi(p^k)=p^k-p^{k-1}=p(p^{k-1}-p^{k-2})</script><p>证明很简单，在不越界的情况下， $p^k$ 由于只有 $p$ 一个质因子，所以与 $p\times1,p\times2\cdots p\times p^{k-1}$ 都不互质，所以是 $p^k-p^{k-1}$ 。</p>
<p>那么有</p>
<script type="math/tex; mode=display">
f\left(p_{i}^{e_{i}}\right)=1+p-1+p(p-1)+p^{2}(p-1) \ldots+p^{e_{i}-1}(p-1)</script><p>通过几何级数的求和公式可以得到：</p>
<script type="math/tex; mode=display">
f(p_i^{e_i})=p_i^{e_i}</script><p>根据积性可以得到</p>
<script type="math/tex; mode=display">
f(n)=n</script><p>是不是比上一个证明清真了很多！</p>
<p>以下默认 $[i,j]$ 表示 $i,j$ 的 $\rm lcm$ 。 </p>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><blockquote>
<p>求 </p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m(i,j)</script><p>$1\leq n,m\leq 10^6,q\leq 10^5$</p>
</blockquote>
<p>随便做啦</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum _{i=1}^n\sum_{j=1}^m(i,j)
\\=&\sum _{i=1}^n\sum_{j=1}^m\sum_{d|n}\varphi(d)
\\=&\sum _{d=1}^n\varphi(d)\cdot \lfloor\frac{n}{d} \rfloor \cdot \lfloor\frac{m}{d} \rfloor
\end{aligned}</script><hr>
<p>接下来是一道翻车题：</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><blockquote>
<p>[国家集训队]Crash的数字表格 </p>
<p>求</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m[i,j]</script><p>$1\leq n,m\leq 10^7$。</p>
</blockquote>
<p>根据以往套路变形</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum _{i=1}^n\sum_{j=1}^m[i,j]
\\=&\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{(i,j)}
\\=&\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{\sum\limits_{d|i~\mathrm{and}~d|j}\varphi(d)}
\\=&\sum _{d=1}^n\frac{1}{\varphi(d)}\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor} j
\end{aligned}</script><p>看上去很真？但是并不对。原因是 <strong>和的倒数不等于倒数的和</strong>，也就是中间 $\sum \varphi(d)$ 不能直接提出来。</p>
<p>所以遇到这种情况就只能用莫比乌斯反演。考虑如此：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum _{i=1}^n\sum_{j=1}^m[i,j]
\\&=\sum _{d=1}^n\sum _{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{d}[(i,j)=d]
\\&=\sum _{d=1}^n\sum _{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor}i\cdot j\cdot d\cdot \sum_{p|i~\mathrm{and}~p|j}\mu(p) 
\\&=\sum _{d=1}^n d\sum_{p=1}^{\lfloor\frac{n}{d} \rfloor}\mu(p) \cdot p^2\sum_{i=1}^{\lfloor\frac{n}{pd} \rfloor}i\sum_{j=1}^{\lfloor\frac{m}{pd} \rfloor} j
\end{aligned}</script><p>然后这东西就可以两个数论分块套一起来解决，复杂度 $O(\sqrt n)\cdot O(\sqrt n)=O(n)$。</p>
<p>然而似乎有一只 $\sqrt{n}$ 的做法？有空再学吧233</p>
<p>代码似乎有不少细节？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, pr[N], o ;</span><br><span class="line">LL F[N], mu[N], ans ;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">do_do</span><span class="params">(LL u, LL v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (u * (u + <span class="number">1</span>) / <span class="number">2</span> % P) * (v * (v + <span class="number">1</span>) / <span class="number">2</span> % P) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    LL ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) swap(x, y) ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= x ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; endl ;</span></span><br><span class="line">        r = min(x / (x / l), y / (y / l)) ;</span><br><span class="line">        <span class="comment">// if (y == 1) cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        (ret += ((F[r] - F[l - <span class="number">1</span>]) % P + P) % P * do_do(x / l, y / l) % P) %= P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span> ; <span class="keyword">if</span> (n &gt; m) swap(n, m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++ o] = i, mu[i] = <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= o ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pr[j] * i &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">            vis[pr[j] * i] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[i * pr[j]] = <span class="number">0</span> ; <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[pr[j] * i] = -mu[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        F[i] = ((F[i - <span class="number">1</span>] + <span class="number">1l</span>l * i * i * mu[i] % P) % P + P) % P ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        r = min(n / (n / l), m / (m / l)) ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">        (ans += (<span class="number">1l</span>l * (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span> % P) * (solve(n / l, m / l) % P) % P) %= P ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ((ans % P + P) % P) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><blockquote>
<p>LG4917天守阁的地板/LG5221Product</p>
<p>简化题意：</p>
<p>求</p>
<script type="math/tex; mode=display">
\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{\operatorname{lcm}(i, j)}{\operatorname{gcd}(i, j)}</script><p>$1\leq n\leq 10^6$</p>
</blockquote>
<p>大概就是转化</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{\operatorname{lcm}(i, j)}{\operatorname{gcd}(i, j)}\\
=&\prod_{i=1}^{n} \prod_{j=1}^{n} \frac{i\times j}{\operatorname{gcd}^2(i, j)}\\
\end{aligned}</script><p>然后观察到 $\prod$ 对于除法有结合律，即可以分别算分母和分子。同时指数上的 $2$ 也可以最后再算。</p>
<p>于是考虑下半部分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{i=1}^{n} \prod_{j=1}^{n} \operatorname{gcd}(i, j)\\
=&\prod_{d=1}^n\prod_{i=1}^{n} \prod_{j=1}^{n} d\cdot [\operatorname{gcd}(i, j)=d]\\
=&\prod_{d=1}^nd^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} [\operatorname{gcd}(i, j)=1]}\\
\end{aligned}</script><p>其中第二步到第三步的原因是根据结合律 $\prod$ 要升级为乘方（就像 $\sum$ 会升级为 $\times $ 一样</p>
<p>发现似乎后面那个是老朋友了，所以可以直接反演成 $\mu$ 形式或者 $\varphi$ 形式。</p>
<p>其中 $\varphi$ 形式的证明大概是考虑每个数的数的贡献，同时由于是有序数对所以是 $\times 2-1$ 。</p>
<p>嗯，然后就会反演成这个样子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\prod_{d=1}^nd^{\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{n}{d}\rfloor} [\operatorname{gcd}(i, j)=1]}\\
=&\prod_{d=1}^n{d^{-1+2\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\varphi(i)}}
\end{aligned}</script><p>发现后面的可以数论分块于是这就可以 $\sqrt n$ 做了。</p>
<p>对于分子，发现就是：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^n\prod_{j=1}^n i\cdot j=\prod_{i=1}^n(i^n\cdot n!)=(n!)^n\cdot (n!)^n=(n!)^{2n}</script><p>然后就没有然后了233。</p>
<p>不过 <code>LG5221</code> 卡了空间，于是最后是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000001</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">104857601</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> n, pr[<span class="number">80001</span>], cnt ;</span><br><span class="line"><span class="keyword">int</span> ans1, ans2, phi[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1l</span>l * res * a % P ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % P ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> fac = <span class="number">1</span> ;</span><br><span class="line">    pr[<span class="number">0</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>, ans2 = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++ cnt] = i, phi[i] = i - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j] ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * pr[j]] = phi[i] * (pr[j] - <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = n / (n / l) ;</span><br><span class="line">        pr[++ cnt] = fac ; <span class="comment">//cout &lt;&lt; l - 1 &lt;&lt; " " ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            fac = <span class="number">1l</span>l * fac * i % P ;</span><br><span class="line">        pr[++ cnt] = fac ; <span class="comment">//cout &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; pr[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        phi[i] = phi[i - <span class="number">1</span>] + phi[i] ;</span><br><span class="line">        <span class="keyword">if</span> (phi[i] &gt; P - <span class="number">1</span>) phi[i] -= P - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    ans1 = expow(pr[cnt], <span class="number">2</span> * n + <span class="number">2</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = n / (n / l) ; <span class="keyword">int</span> t = ++ cnt ; ++ cnt ;</span><br><span class="line">        ans2 = <span class="number">1l</span>l * ans2 * expow(<span class="number">1l</span>l * pr[cnt] * expow(pr[t], P - <span class="number">2</span>) % P, phi[n / l]) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="number">1l</span>l * expow(ans2, P - <span class="number">5</span>) * ans1 % P) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>数学/积性函数/欧拉反演</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】$\mu$ 函数的性质</title>
    <url>/2020/01/24/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>众所周知 $\mu$ 函数具有如下性质：</p>
<script type="math/tex; mode=display">
\sum_{d|n} \mu(d)=[n=1]</script><p>大部分有关于 $\gcd$ 、带有艾佛森括号的反演题目都可以用这个性质解决。</p>
<a id="more"></a>
<p>证明方式有很多，此处采用狄利克雷卷积的方式来比较简洁地证明。</p>
<p>根据 $\mu$ 的定义，$\mu*\boldsymbol{1}=\boldsymbol{I}$，那么有 </p>
<script type="math/tex; mode=display">
\sum _{d|n}\mu(d)=\mu * \boldsymbol{1}=\boldsymbol{I}=[n=1]</script><p>当然，其实还有更优美的证法。思考 $\mu$ 的本质，当 $n$ 含有平方因子的时候，$\mu(n)=0$；否则 $\mu(n)=(-1)^k$，其中 $k$ 是 $n$ 的本质不同质因子个数。</p>
<p>接下来考虑一步转化。设 $n=\sum p_i^{e_i},n’=\sum{p_i}$ 。那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}&\sum_{d|n}\mu(d)\\ = &\sum_{d|n'}\mu(d)\\= &\sum_{i=0}^k \binom{k}{i}(-1)^i\\= & ~(1+(-1))^k\\= & ~[k=0]\end{aligned}</script><p>所以到最后 $[k=0]$ 就意味着 $[n=1]$ 。$\mathcal{Q.E.D.}$</p>
<p>默认 $(a,b)$ 代表 $a$ 与 $b$ 的最大公约数，$|$ 表示整除。</p>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><blockquote>
<p>求</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=1]</script><p>$1\leq n\leq m\leq 10^6,q\leq 50000$</p>
</blockquote>
<p>其实就是代换：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=1]&=\sum _{i=1}^n\sum_{j=1}^m\sum_{d|(i,j)}\mu(d)
\\&=\sum _{i=1}^n\sum_{j=1}^m\sum_{d|i~\text{and}~d|j}\mu(d)
\\&=\sum _{d=1}^n\mu(d) \sum_{i=1}^n[d|i]\sum_{j=1}^m[d|j]
\\&=\sum _{d=1}^n\mu(d)\cdot \lfloor\frac{n}{d}\rfloor \cdot \lfloor\frac{m}{d}\rfloor
\end{aligned}</script><p>然后就可以 $O(n)+O(q\sqrt n)$ 来做了。</p>
<p>但其实本质上，$n$ 可以出到 $10^9$ ？但是总感觉杜教筛套上一层数论分块复杂度就不是很对了。此处可能还需要思考思考。</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><blockquote>
<p>[POI2007]ZAP-Queries/LG4450双亲数</p>
<p>求</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=k]</script><p>$1\leq n\leq m\leq 10^6,q\leq 50000$</p>
</blockquote>
<p>其实本质上是一样的。</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=k]&=\sum _{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d|(i,j)}\mu(d)
\\&=\sum _{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d|i~\text{and}~d|j}\mu(d)
\\&=\sum _{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d) \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}[d|i]\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[d|j]
\\&=\sum _{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\cdot \lfloor\frac{n}{dk}\rfloor \cdot \lfloor\frac{m}{dk}\rfloor
\end{aligned}</script><h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><blockquote>
<p>$\forall p\in\mathbb{P}$，求</p>
<script type="math/tex; mode=display">
\sum _{i=1}^n\sum_{j=1}^m[(i,j)=p]</script><p>$1\leq n\leq m\leq 10^7,q\leq 10000$</p>
</blockquote>
<p>发现到最后变成了这样：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^{cntp}\sum _{d=1}^{\lfloor\frac{n}{p_k}\rfloor}\mu(d)\cdot \lfloor\frac{n}{p_kd}\rfloor \cdot \lfloor\frac{m}{p_kd}\rfloor</script><p>考虑继续换元，令 $q=p_kd$，枚举 $q$:</p>
<script type="math/tex; mode=display">
\sum_{q=1}^{n}\lfloor\frac{n}{q}\rfloor \cdot \lfloor\frac{m}{q}\rfloor\cdot \left(\sum _{k=1}^{cntp}[p_k~|~q]\cdot \mu(\frac{q}{p_k})\right)</script><p>然后发现前半部分可以数论分块，后半部分可以直接在筛素数的时候 $dp$ 出来即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; Pr[i] * j &lt;= MAXN - <span class="number">15</span> ; ++ j)</span><br><span class="line">		f[j * Pr[i]] += Mu[j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= MAXN - <span class="number">15</span> ; ++ i) S[i] = S[i - <span class="number">1</span>] + f[i] ;</span><br></pre></td></tr></table></figure>
<h1 id="4"><a href="#4" class="headerlink" title="$4$"></a>$4$</h1><blockquote>
<p>题目来自神仙李思杰的 $blog$：</p>
<p>求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n} \sum_{j=1}^{m} i\cdot j\cdot [(i, j)=k] \quad(n<m)</script><p>$1\leq n,m\leq 10^6$</p>
</blockquote>
<p>发现可以这么做：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{n} \sum_{j=1}^{m} i \cdot j\cdot[(i, j)=k] 
&=k^2\cdot \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{k}\rfloor} i \cdot j\cdot[(i, j)=1] \\
&=k^2\cdot \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{k}\rfloor} i \cdot j\cdot\sum_{d|i~\mathrm{and}~d|j} \mu(d)\\
&=k^2\cdot \sum_{d=1}^n\mu(d)\cdot d^2\cdot \sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor} i\cdot \sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor} j\\
\end{aligned}</script><p>发现后面是个简单的二阶求和形式，故至此已经可以分快了。</p>
<h1 id="5"><a href="#5" class="headerlink" title="$5$"></a>$5$</h1><blockquote>
<p>[SDOI2015]约数个数和</p>
<p>求 </p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i\times j)</script><p>$1\leq n,m\leq 10^6,1\leq q\leq 10^5$</p>
</blockquote>
<p>首先考虑一步<del>几乎想不出来的</del>转化：</p>
<script type="math/tex; mode=display">
\sigma_0(i \cdot j)=\sum_{x | i} \sum_{y | j}[(x, y)=1]</script><p>可以类似线性筛那样感性理解。</p>
<p>然后就可以直接做了：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i\times j)\\
=&\sum_{i=1}^n\sum_{j=1}^m\sum_{x | i} \sum_{y | j}[(x, y)=1]\\
=&\sum_{i=1}^n\sum_{j=1}^m\sum_{x | i} \sum_{y | j}\sum_{d|x\operatorname{and} d|y} \mu(d)\\
=&\sum_{x = 1}^n \sum_{y = 1}^m\lfloor\frac{n}{x}\rfloor\cdot \lfloor\frac{m}{y}\rfloor\cdot \sum_{d|x\operatorname{and} d|y} \mu(d)\\
=&\sum_{d = 1}^n \mu(d) \sum_{x = 1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y = 1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor\cdot \lfloor\frac{m}{dy}\rfloor\\
\end{aligned}</script><p>发现后面这东西可以很简单地</p>
<p>预处理，所以复杂度 $O(q\cdot\sqrt n)$</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>数学/积性函数/莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】回滚莫队</title>
    <url>/2020/01/23/%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概是一种离线算法，用于巧妙维护没有删除操作的离线序列问题。一般情况下都可以转化成普通的莫队带一个 ds 的 $\log$ 做法，可以比较简单地去维护某些不能差分的操作（即 <code>del</code> 比较难以实现，比如 $\max$）。</p>
<a id="more"></a>
<p>考虑不同于普通莫队的另一种做法。</p>
<p>首先还是将所有询问排序。考虑一种根号分治的做法：</p>
<ul>
<li><p>对于两个端点在同一个块内的直接跑暴力，总复杂度是 $O(qB)$；</p>
</li>
<li><p>两个端点不在一个块内的，考虑把两个指针都指针移到下一个块的开头，途中对每个点只撤销贡献而不删除贡献，之后 $r$ 单调向右移，$l$ 向左移，添加过程中计算贡献——其中控制 $r$ 单增的原因是 $r$ 的移动步长是 $O(n)$ 的，但每次 $l$ 的移动步长是 $O(B)$ 的。</p>
</li>
</ul>
<p>这样的话，复杂度就是 $O(qB+\frac{n^2}{B})$ 。简单地均值一下发现还是 $O(n\sqrt q)$ 的。</p>
<p>那看上去除了复杂度分析很莫队，本质上就是个根号分治啊。</p>
<h1 id="AT1219-歴史の研究"><a href="#AT1219-歴史の研究" class="headerlink" title="AT1219 歴史の研究"></a>AT1219 歴史の研究</h1><blockquote>
<p>给定一堆事件：</p>
<ol>
<li>选择日记中连续的一些天作为分析的时间段</li>
<li>事件种类 $t$ 的重要度为 $t$  $\times$ (这段时间内种类为 $t$ 的事件数)。</li>
<li>计算出所有事件种类的重要度，输出其中的最大值 现在你被要求制作一个帮助教授分析的程序，每次给出分析的区间，你需要输出重要度的最大值.</li>
</ol>
</blockquote>
<p>发现插入很简单，但是由于求的是 $\max$，所以朴素地删除会让答案难以统计。于是考虑直接上回滚莫队。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line">LL res ;</span><br><span class="line"><span class="keyword">int</span> g[N] ;</span><br><span class="line">LL ans[M] ;</span><br><span class="line"><span class="keyword">int</span> buc[M] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"><span class="keyword">int</span> n, w, m, b, bnum ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs p1,qs p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blg[p1.l] ^ blg[p2.l] )</span><br><span class="line">        <span class="keyword">return</span> blg[p1.l] &lt; blg[p2.l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p1.r &lt; p2.r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; buc[base[p]] -- ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, LL &amp; ret)</span></span>&#123;</span><br><span class="line">    buc[base[p]] ++ ;</span><br><span class="line">    ret = max(ret, <span class="number">1l</span>l * buc[base[p]] * g[p]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bucc[N] ;</span><br><span class="line"><span class="function">LL <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    LL ret ; ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) bucc[base[i]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        ret = max(ret, <span class="number">1l</span>l * bucc[base[i]] * g[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) bucc[base[i]] -- ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> l, r, lb ;</span><br><span class="line">    b = <span class="built_in">sqrt</span>(<span class="number">1.0</span> * n) ; bnum = n / b + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;g[i]), t[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bnum ; ++ i)</span><br><span class="line">        L[i] = (i - <span class="number">1</span>) * b + <span class="number">1</span>, R[i] = i * b ;</span><br><span class="line">    R[bnum] = min(R[bnum], n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bnum ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L[i] ; j &lt;= R[i] ; ++ j)</span><br><span class="line">            blg[j] = i ; sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    w = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + w + <span class="number">1</span>, g[i]) - t ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; base[i] &lt;&lt; '\n' ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp), l = <span class="number">1</span>, r = <span class="number">0</span>, lb = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; blg[i] &lt;&lt; " " ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])&#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; q[i].l &lt;&lt; " " &lt;&lt; q[i].r &lt;&lt; endl ;</span></span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] ^ lb)&#123;</span><br><span class="line">            <span class="keyword">while</span> (r &gt; R[blg[q[i].l]]) del(r --) ;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; R[blg[q[i].l]] + <span class="number">1</span>) del(l ++) ;</span><br><span class="line">            res = <span class="number">0</span> ; lb = blg[q[i].l] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ul = l ; LL anss = res ;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) add(++ r, res) ;</span><br><span class="line">        anss = res ; <span class="keyword">while</span> (ul &gt; q[i].l) add(-- ul, anss) ;</span><br><span class="line">        <span class="keyword">while</span> (ul &lt; l) del(ul ++) ; ans[q[i].id] = anss ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LG-5906-回滚莫队"><a href="#LG-5906-回滚莫队" class="headerlink" title="LG 5906 回滚莫队"></a>LG 5906 回滚莫队</h1><blockquote>
<p>给定一个序列，多次询问一段区间 $[l,r]$，求区间中<strong>相同的数的最远间隔距离</strong>。</p>
<p>序列中两个元素的<strong>间隔距离</strong>指的是<strong>两个元素下标差的绝对值</strong>。</p>
<p>$1\leq n,m\leq 2\cdot 10^5$</p>
</blockquote>
<p>本质上第一次见这题是某次校内胡策 <a href="https://www.luogu.com.cn/problem/U96381" target="_blank" rel="noopener">戳我</a>。之后发现原来是 <code>codechef</code> 上的题，然后就自己出了数据放到了谷上……然而数据十分的水……虽然我觉得我是精心构造了…233</p>
<p>然后这题其实是道好题…原因就是上一道题是不完全版的回滚莫队：上一道题的左端点 <code>add</code> 和右端 <code>add</code> 可以一样，因为第二层信息 <code>buc</code> 可以差分，即如果现减成 $-1$ 后来是可以加回来的；但是这道题的话，如果记录上一个和下一个相同的数字的位置会有很麻烦的边界，大部分做法都是赋值为 $0$ 或 $n$ ，但这样就会丢失信息，也就是左端点的 <code>add</code> 和右端点的 <code>add</code> 要分开处理。</p>
<p>所以如果铁憨憨地拿头写就会由很多边界，所以比较好的处理方式：</p>
<h2 id="询问分块处理"><a href="#询问分块处理" class="headerlink" title="询问分块处理"></a>询问分块处理</h2><p>大概就是每个块清零一次，直接让两个指针回归。这样做不容易错，但复杂度是满的 $\frac{n^2}{\sqrt m}$ （因为每个块都是 $\Theta(n)$ 的清零）。所以大概可以改下块大小来微调？但其实这题我出的所有 $n,m$ 差不超过 $5$ …233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, x, y ;</span><br><span class="line"><span class="keyword">int</span> val[N], base[N] ;</span><br><span class="line"><span class="keyword">int</span> pre[N], tmp[N], suf[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> qs &amp;a, <span class="keyword">const</span> qs &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i) tmp[base[i]] = n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        tmp[base[i]] = Min(tmp[base[i]], i), ret = Max(ret, i - tmp[base[i]]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123;</span><br><span class="line">    suf[base[p]] = Max(suf[base[p]], p) ;</span><br><span class="line">    pre[base[p]] = Min(pre[base[p]], p) ;</span><br><span class="line">    res = Max(res, suf[base[p]] - pre[base[p]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> bnum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = s, L = Min(n, bnum * b) ;</span><br><span class="line">    <span class="keyword">int</span> l = L + <span class="number">1</span>, r = L ; res = <span class="number">0</span> ;</span><br><span class="line">    fill(pre + <span class="number">1</span>, pre + len + <span class="number">1</span>, n) ;</span><br><span class="line">    fill(suf + <span class="number">1</span>, suf + len + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span>( ; blg[q[i].l] == bnum ; ++ i )&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])&#123;</span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> anss = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j) tmp[base[j]] = n ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j)&#123;</span><br><span class="line">            tmp[base[j]] = Min(tmp[base[j]], j) ;</span><br><span class="line">            anss = max(anss, Max(j - tmp[base[j]], suf[base[j]] - j)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q[i].id] = max(anss, res) ;<span class="comment">// cout &lt;&lt; i &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = qr(), val[i] = base[i] ;</span><br><span class="line">    sort(val + <span class="number">1</span>, val + n + <span class="number">1</span>) ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; b = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line">    len = unique(val + <span class="number">1</span>, val + n + <span class="number">1</span>) - val - <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(val + <span class="number">1</span>, val + len + <span class="number">1</span>, base[i]) - val ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        q[i].l = qr(), q[i].r = qr(), q[i].id = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) blg[i] = (i - <span class="number">1</span>) / b + <span class="number">1</span> ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ; <span class="keyword">int</span> L = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= blg[n] ; ++ i) &#123;</span><br><span class="line">        L = solve(L, i) ; <span class="keyword">if</span> (L &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把所有函数展开"><a href="#把所有函数展开" class="headerlink" title="把所有函数展开"></a>把所有函数展开</h2><p>没写过，因为个人认为会搞乱码风。</p>
<hr>
<h2 id="瞎写"><a href="#瞎写" class="headerlink" title="瞎写"></a>瞎写</h2><p>于是个人最初的写法是这样的，十分吊诡：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400100</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400100</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> len ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> buf[N] ;</span><br><span class="line"><span class="keyword">int</span> tmp[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[M] ;</span><br><span class="line"><span class="keyword">int</span> tbuc[N] ; </span><br><span class="line"><span class="keyword">int</span> bucp[N] ;</span><br><span class="line"><span class="keyword">int</span> bucs[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">int</span> l, r ;</span><br><span class="line">&#125;q[M] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs a, qs b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (blg[a.l] ^ blg[b.l])	</span><br><span class="line">	    <span class="keyword">return</span> blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">	<span class="keyword">return</span> a.r &lt; b.r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!buf[base[i]]) buf[base[i]] = i ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ret = max(ret, i - buf[base[i]]) ;</span><br><span class="line">            buf[base[i]] = min(i, buf[base[i]]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (buf[base[i]]) buf[base[i]] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    bucp[base[x]] = N ;</span><br><span class="line">    bucs[base[x]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;val)</span></span>&#123;</span><br><span class="line">    bucs[base[x]] = max(x, bucs[base[x]]) ;</span><br><span class="line">    bucp[base[x]] = min(x, bucp[base[x]]) ;</span><br><span class="line">    val = max(val, bucs[base[x]] - bucp[base[x]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, k = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), tmp[i] = base[i] ;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) ; </span><br><span class="line">    len = unique(tmp + <span class="number">1</span>, tmp + n + <span class="number">1</span>) - tmp - <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(tmp + <span class="number">1</span>, tmp + len + <span class="number">1</span>, base[i]) - tmp ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m ; b = n / <span class="built_in">sqrt</span>(m) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) blg[i] = i / b ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[i].l, &amp;q[i].r), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) bucs[i] = <span class="number">0</span>, bucp[i] = N ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (blg[q[i].l] == blg[q[i].r])</span><br><span class="line">            ans[q[i].id] = brute_force(q[i].l, q[i].r) ;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (blg[q[i].l] &gt; k)&#123;</span><br><span class="line">				<span class="keyword">while</span> (blg[r] &lt;= blg[q[i].l]) del(r ++)  ;</span><br><span class="line">                <span class="keyword">while</span> (blg[r] &gt; blg[q[i].l]) del(r --) ;</span><br><span class="line">                <span class="keyword">while</span> (blg[l] &lt;= blg[q[i].l]) del(l ++) ;</span><br><span class="line">                add(++ r, res) ; res = <span class="number">0</span> ; k = blg[q[i].l] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t, fl = l, ress = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[i].r) add(++ r, res) ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j) tbuc[base[j]] = N ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = q[i].l ; j &lt;= l ; ++ j)&#123;</span><br><span class="line">                t = base[j] ;</span><br><span class="line">                tbuc[t] = min(j, tbuc[t]) ;</span><br><span class="line">                ress = max(ress, max(j - tbuc[t], bucs[t] - j)) ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[q[i].id] = max(ress, res) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>边界很烦人…很烦人…当然个人实力菜占主要原因…</p>
<p>不过最后好歹也算是调出来了，QAQ</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/莫队</tag>
        <tag>技巧/根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】树上莫队</title>
    <url>/2020/01/23/%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯…好…序列数据结构就是用来上树的嘛/kk</p>
<p>发现首先树上分块很好处理，比较麻烦的一点在于，如何从 $(ou,ov)$ 这条路径移动到 $(nu,nv)$。</p>
<p>发现莫队的精髓在于排完序之后左右端点的移动是独立的，所以考虑如何转化成 $(ou,nu)$ 和 $(ov,nv)$。</p>
<a id="more"></a>
<h1 id="1-瞎构造"><a href="#1-瞎构造" class="headerlink" title="$1$ 瞎构造"></a>$1$ 瞎构造</h1><p><del>蜜汁more.jpg</del></p>
<p>有一个很常见的定理，就是「树上两条路径如果有交点，那么一定是在其中一条路径两端点的 $lca$   」。</p>
<p>证明暂时不知道（但是我有在思考）什么比较优美的证明。但遇到这种情况总是可以分类讨论的…略了略了</p>
<p>于是为了不处理本来就有交点的情况，莫队上树选择维护 $p(u,v)=(u,v)\setminus\{lca(u,v)\}$ 。发现这东西有很好的性质，即 </p>
<script type="math/tex; mode=display">
p(u,v)~\mathrm{xor}~ p(x,y)=p(x, u) \text { xor } p(v, y)</script><p>其中 $~\mathrm{xor}~$ 定义在集合上。</p>
<p>证明大概是考虑令 $r(x)$ 表示 $x$ 到根节点的路径的点集。那么就可以这么化式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(u,v)~\mathrm{xor}~ p(x,y)&=p(x, u) \text { xor } p(v, y)\\
(r(u) ~\mathrm{xor}~ r(v))~\mathrm{xor}~(r(x) ~\mathrm{xor}~ r(y))&=(r(u) ~\mathrm{xor}~ r(x))~\mathrm{xor}~(r(v) ~\mathrm{xor}~ r(y))\\

\end{aligned}</script><p>然后接下来懒得写了，发现就是个交换律+结合律的套路。</p>
<p>于是考虑每次把 $p(ou,nu)$ 和 $p(ov, nv)$ 内的点全部取反，单独处理一下 $lca$ 就好了。</p>
<h1 id="2-如何分块"><a href="#2-如何分块" class="headerlink" title="$2$ 如何分块"></a>$2$ 如何分块</h1><p>发现就是 <code>loj#2151王室联邦</code> 这题的分块方式。似乎这东西证明的话可以直接归纳出来？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = tp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u]; k; k = next(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to(k), u);</span><br><span class="line">        <span class="keyword">if</span> (tp - base &gt;= S) &#123;</span><br><span class="line">            cap[++Id] = u;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; base) </span><br><span class="line">              blg[s[tp--]] = Id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[++tp] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S;</span><br><span class="line">    <span class="keyword">int</span> i, u, v;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; ++i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (tp) blg[s[tp--]] = Id;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">cout</span> &lt;&lt; blg[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Id; ++i) <span class="built_in">cout</span> &lt;&lt; cap[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-例题"><a href="#3-例题" class="headerlink" title="$3$ 例题"></a>$3$ 例题</h1><h2 id="1-SP10707-Count-On-a-Tree-2"><a href="#1-SP10707-Count-On-a-Tree-2" class="headerlink" title="$1$ SP10707 Count On a Tree 2"></a>$1$ SP10707 Count On a Tree 2</h2><blockquote>
<p>给定一个 $n$ 个节点的树，每个节点表示一个整数。</p>
<p>$q$ 组询问，询问 $u$ 到 $v$ 的路径上有多少个不同的整数。</p>
</blockquote>
<p>套路题？不禁思考我都做了些什么浪费时间的题啊…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qss</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id ;</span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">&#125;qs[M] ;</span><br><span class="line"><span class="keyword">int</span> res ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N] ;</span><br><span class="line"><span class="keyword">int</span> son[N] ;</span><br><span class="line"><span class="keyword">int</span> blg[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum ;</span><br><span class="line"><span class="keyword">int</span> n, q, len ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> top[N], sz[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N] ;</span><br><span class="line"><span class="keyword">int</span> base[N], t[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; u &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">int</span> old = tp ; sz[u] = <span class="number">1</span> ;</span><br><span class="line">    fa[u] = f, dep[u] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != f)&#123;</span><br><span class="line">            dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">            <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">			<span class="keyword">if</span> (tp - old &gt;= b)&#123;</span><br><span class="line">         	   ++ bnum ;</span><br><span class="line">         	   <span class="keyword">while</span> (tp &gt; old)</span><br><span class="line">				   blg[stk[tp --]] = bnum ;</span><br><span class="line">        	&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ tp] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], u, tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != f &amp;&amp; to(k) != son[u]) dfs(to(k), u, to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qss a, qss b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.u] == blg[b.u] ? blg[a.v] &lt; blg[b.v] : blg[a.u] &lt; blg[b.u] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            swap(u, v) ; u = fa[top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[x])</span><br><span class="line">        res += !buc[base[x]] ++ ;</span><br><span class="line">    <span class="keyword">else</span> res -= !-- buc[base[x]] ;</span><br><span class="line">    vis[x] ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movemove</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">while</span> (dep[u] &gt; dep[v]) rev(u), u = fa[u] ;</span><br><span class="line">    <span class="keyword">while</span> (u != v) rev(u), rev(v), u = fa[u], v = fa[v] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q ; </span><br><span class="line">	<span class="keyword">int</span> u, v, f ; b = <span class="built_in">sqrt</span>(n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>) ;</span><br><span class="line">    len = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        base[i] = lower_bound(t + <span class="number">1</span>, t + n + <span class="number">1</span>, base[i]) - t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; bnum ++ ;</span><br><span class="line">	<span class="keyword">while</span> (tp) blg[stk[tp --]] = bnum ; </span><br><span class="line">	<span class="comment">//for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; top[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;qs[i].u, &amp;qs[i].v), qs[i].id = i ;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; lca(5, 8) &lt;&lt; " " &lt;&lt; lca(2, 7) &lt;&lt; " " &lt;&lt; lca(3, 7) &lt;&lt; endl ; </span></span><br><span class="line">    sort(qs + <span class="number">1</span>, qs + q + <span class="number">1</span>, comp) ; u = v = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        movemove(u, qs[i].u) ; u = qs[i].u ;</span><br><span class="line">        movemove(v, qs[i].v) ; v = qs[i].v ;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">        f = lca(u, v) ; rev(f) ;</span><br><span class="line">        ans[qs[i].id] = res ; rev(f) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>btw，感觉自己码风好多了？</p>
<h2 id="2-uoj-53-WC2013-糖果公园"><a href="#2-uoj-53-WC2013-糖果公园" class="headerlink" title="$2$ uoj#53 [WC2013]糖果公园"></a>$2$ uoj#53 [WC2013]糖果公园</h2><blockquote>
<p>给出一棵 $n$ 个点的树，每个节点有一个颜色。</p>
<p>每次或者询问你一条路径求 $\sum_{c}val_c\sum_{i=1}^{cnt_c}w_i$，或者更改一个点的颜色。</p>
<p>其中 $val$ 表示该颜色的价值, $cnt$ 表示其出现的次数, $w_i$ 表示第 $i$ 次出现的价值。</p>
<p>可以离线。</p>
</blockquote>
<p>发现就是树上莫队套了一个带修？</p>
<p>写起来没什么感觉…就是很长…很长…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Q = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uv</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, c ;</span><br><span class="line">&#125;us[Q] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">int</span> t, id ;</span><br><span class="line">&#125;qy[Q] ;</span><br><span class="line">LL res ;</span><br><span class="line">LL ans[Q] ;</span><br><span class="line"><span class="keyword">int</span> n, m, q ;</span><br><span class="line"><span class="keyword">int</span> cntu, cntq ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> sz[N], son[N] ;</span><br><span class="line"><span class="keyword">int</span> buc[N], vis[N] ;</span><br><span class="line"><span class="keyword">int</span> b, bnum, blg[N] ;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], top[N] ;</span><br><span class="line"><span class="keyword">int</span> val[M], wth[M], clr[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">    sz[u] = <span class="number">1</span>, fa[u] = f ; <span class="keyword">int</span> t = tp ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), u) ; sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">        <span class="keyword">if</span> (tp - t &gt;= b)&#123;</span><br><span class="line">            ++ bnum ;</span><br><span class="line">            <span class="keyword">while</span> (tp &gt; t)</span><br><span class="line">                blg[stk[tp --]] = bnum ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++ tp] = u ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], u, tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != f) dfs(to(k), u, to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]])</span><br><span class="line">            u ^= v ^= u ^= v ; u = fa[top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qs a, qs c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.u] == blg[c.u]) ?</span><br><span class="line">           ((blg[a.v] == blg[c.v]) ? a.t &lt; c.t : blg[a.v] &lt; blg[c.v]) : (blg[a.u] &lt; blg[c.u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x])</span><br><span class="line">        res -= <span class="number">1l</span>l * wth[buc[clr[x]] --] * val[clr[x]] ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        res += <span class="number">1l</span>l * wth[++ buc[clr[x]]] * val[clr[x]] ;</span><br><span class="line">    vis[x] ^= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movemove</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y) ;</span><br><span class="line">    <span class="keyword">while</span> (dep[x] &gt; dep[y]) rev(x), x = fa[x] ;</span><br><span class="line">    <span class="keyword">while</span> (x != y) rev(x), rev(y), x = fa[x], y = fa[y] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("in.in", "r", stdin) ;</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> u, v, f, l, r, mk, t ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;wth[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;clr[i]) ;</span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; E[i].to &lt;&lt; endl ;</span></span><br><span class="line">    b = <span class="built_in">pow</span>(<span class="number">1.0</span> * n, <span class="number">0.6667</span>) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; ++ bnum ;</span><br><span class="line">    <span class="keyword">while</span> (tp) blg[stk[tp --]] = bnum ;dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) ;</span><br><span class="line">    u = <span class="number">1</span>, v = <span class="number">1</span>, t = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//  for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; top[i] &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; lca(1, 3) &lt;&lt; " " &lt;&lt; lca(2,4) &lt;&lt; " " &lt;&lt; lca(1, 4) &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//  for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; fa[i] &lt;&lt; " "  ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;mk, &amp;l, &amp;r) ;</span><br><span class="line">        <span class="keyword">if</span> (mk)</span><br><span class="line">            qy[++ cntq].u = l, qy[cntq].v = r,</span><br><span class="line">            qy[cntq].t = cntu, qy[cntq].id = cntq ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            us[++ cntu].p = l, us[cntu].c = r ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(qy + <span class="number">1</span>, qy + cntq + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)&#123;</span><br><span class="line">        movemove(u, qy[i].u) ;</span><br><span class="line">        movemove(v, qy[i].v) ;</span><br><span class="line">        u = qy[i].u, v = qy[i].v ;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; qy[i].t)&#123;</span><br><span class="line">            ++ t ;</span><br><span class="line">            <span class="keyword">if</span> (vis[us[t].p])</span><br><span class="line">                rev(us[t].p),</span><br><span class="line">                swap(clr[us[t].p], us[t].c),</span><br><span class="line">                rev(us[t].p) ;</span><br><span class="line">            <span class="keyword">else</span> swap(clr[us[t].p], us[t].c) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; qy[i].t)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[us[t].p])</span><br><span class="line">                rev(us[t].p),</span><br><span class="line">                swap(clr[us[t].p], us[t].c),</span><br><span class="line">                rev(us[t].p) ;</span><br><span class="line">            <span class="keyword">else</span> swap(clr[us[t].p], us[t].c) ;</span><br><span class="line">            t -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        f = lca(u, v) ; rev(f) ;</span><br><span class="line">        ans[qy[i].id] = res ; rev(f) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cntq ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】简单莫队瞎吹</title>
    <url>/2020/01/23/%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E4%B8%8E%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>…感觉这东西似乎也没啥好说的啊</p>
<a id="more"></a>
<h1 id="1-理论瞎吹"><a href="#1-理论瞎吹" class="headerlink" title="$1$ 理论瞎吹"></a>$1$ 理论瞎吹</h1><p>大概就是个分块？但是是对询问分块的。莫队的精髓在于排序，排序时如果 <code>belong[l]</code> 相同复杂度就按照右端点排序，这样似乎是有保证的？</p>
<p>令 $m$ 为操作数，$B$ 为块大小。考虑对于一个块内的 $l$，其 $r$ 是单增的，于是考虑如下：</p>
<ul>
<li>左端点，在块内可能会一前一后这样设置，这样复杂度被卡到最满，为 $O(m\cdot B)$ ；</li>
<li>右端点，考虑各块内的询问显然都可以做到单块 $O(n)$，所以不需要考虑 $m$ 的贡献，即右端点移动的复杂度就是 $\frac{n}{B}\cdot n=\frac{n^2}{B}$。</li>
</ul>
<p>均值一下发现 $m\cdot B+\frac{n^2}{B}\geq 2\sqrt{n^2m}=O(n\sqrt m)$ ，此时有 $m\cdot B=\frac{n^2}{B}$，解得 $B=\frac{n}{\sqrt m}$ .</p>
<p>所以取块大小为 $\frac{n}{\sqrt m}$ 时达到理论最优，复杂度为 $O(n\sqrt m)$ 。</p>
<p>…当然这东西可能不准，毕竟常数稍微优一点可能就可以瞎分块了233</p>
<p>然后考虑如何带修改(当然只能离线做)。发现单纯地平移询问区间不对，于是考虑加一维时间轴，在平移完询问之后平移修改操作。排序时把「离当前询问最近的前一个修改操作是第几次修改」作为第三关键字，第二关键字换成「右端点所在块的编号」。</p>
<p>令 $c$ 为修改个数， $q$ 为询问个数，$B$ 依旧为块大小。那么考虑三维指针是怎么移动的：</p>
<ul>
<li>左端点和右端点依次还是 $qB+\frac{n^2}{B}$ ；</li>
<li>时间端点，考虑时间端点实际上每次至多移动 $c$，但是时间端点之外此时套了一层按 <code>belong[r]</code> 分的块，所以这一部分的复杂度为 $O(c\times\frac{n^2}{B^2})$ .</li>
</ul>
<p>于是总复杂度为 $O(\frac{n^2c}{B^2}+qB+\frac{n^2}{B})$。</p>
<p>这个东西他怎么求 $\min$ 呢…</p>
<p><del>嗯，你看这个式子这么可爱，求导总是可以求出来的吧，于是就不详细写了</del>~</p>
<p>直接上结论，$B=O(n^{\frac{2}{3}})$ 时最优，此时复杂度为 $O(n^{\frac{2}{3}}c+n^{\frac{2}{3}}q+n^\frac{4}{3})=O(n^{\frac{2}{3}}m)$。</p>
<p>发现这东西很好的一点就是，这么分块，复杂度不会受操作类型影响，因为 $q+c=m$ 是根据已知推出来，不是放缩放掉的。所以是个很满分的复杂度。</p>
<h1 id="2-水题瞎做"><a href="#2-水题瞎做" class="headerlink" title="$2$ 水题瞎做"></a>$2$ 水题瞎做</h1><h2 id="1-LG2709-小B的询问"><a href="#1-LG2709-小B的询问" class="headerlink" title="$1$ LG2709 小B的询问"></a>$1$ LG2709 小B的询问</h2><blockquote>
<p>给出长度为 $n$ 的序列，$q$ 组询问，每次询问区间 $[l,r]$ 内的 $\sum e_i^2$ 。其中 $e_i$ 表示数 $i$ 的出现次数。</p>
</blockquote>
<p>似乎是憨憨题？就是道普通的莫队。</p>
<p>不过学了一招，就是奇偶块的 $r$ 坐标反向排序。这样似乎理论应该带一个下界为 $\frac{1}{2}$ 的常数。但实际应用可能并不明显。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(querys a, querys b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> blg[a.l] == blg[b.l] ? ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r) : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; ans -= (<span class="number">2l</span>l * buc[base[p]] - <span class="number">1l</span>l), buc[base[p]] -- ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; ans += (<span class="number">2l</span>l * buc[base[p]] + <span class="number">1l</span>l), buc[base[p]] ++ ; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-LG1494-小Z的袜子"><a href="#2-LG1494-小Z的袜子" class="headerlink" title="$2$ LG1494 小Z的袜子"></a>$2$ LG1494 小Z的袜子</h2><blockquote>
<p>给出一个长为 $n$ 的序列，每次询问 $[l,r]$ 内，随机取两个数取到相同的数的概率。</p>
</blockquote>
<p>大概也是个憨憨题…发现最后结果就是 $\frac{\mathrm{cnt(same\_pair)}}{\binom{r-l+1}{2}}$。</p>
<h2 id="3-LG3709-大爷的字符串题"><a href="#3-LG3709-大爷的字符串题" class="headerlink" title="$3$ LG3709 大爷的字符串题"></a>$3$ LG3709 大爷的字符串题</h2><p>这题nmd是道语文题…</p>
<blockquote>
<p>原题面：</p>
<p>给你一个字符串 $a$，每次询问一段区间的贡献</p>
<p>贡献定义：</p>
<p>每次从这个区间中拿出一个字符 $x$，然后把 $x$ 从这个区间中删除，你要维护一个集合 $\rm S$：如果 $\rm S$ 为空，你 $rp$ 减 $1$ ; 如果 $\rm S$ 中有一个元素不小于 $x$，则你 $rp$  减 $1$，清空 $\rm S$；之后将 $x$ 插入 $\rm S$ 。</p>
<p>由于你是大爷，平时做过的题考试都会考到，所以每次询问你搞完这段区间的字符之后最多还有多少 $rp$ ？$rp$ 初始为 $0$，询问之间不互相影响。</p>
</blockquote>
<p>发现大概是在说，每次给定一个区间，要从中取出最少数量的严格上升子序列使得覆盖所有的数。发现其实就是「区间内出现次数最多的数」出现的次数。</p>
<p>这东西也比较容易维护，再拿另一个 $bucbuc$ 来维护 $buc$ 就解决了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123; </span><br><span class="line">	rg <span class="keyword">int</span> t = ++ buc[base[p]] ; </span><br><span class="line">	bucbuc[t] ++, bucbuc[t - <span class="number">1</span>] --, ans += (t &gt; ans) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p)</span></span>&#123; </span><br><span class="line">	rg <span class="keyword">int</span> t = -- buc[base[p]] ;</span><br><span class="line">	bucbuc[t] ++, bucbuc[t + <span class="number">1</span>] --, ans -= !bucbuc[ans] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是离散化之后的，复杂度就是比较稳的 $m \sqrt n$ 了。</p>
<p>但是还有一个不费脑子的方法，就是第一个 $buc$ 直接用 <code>std:: unordered_map</code> 来实现。但这东西首先复杂度是个谜，你说他是 $O(1)$ 的，但是确实很慢；你说他是 $\log$ 的，但毕竟只是个 $Hash$ 表，实在没理由是 $\log$ 的。</p>
<p>嗯，具体实现可能是什么 「亚 $\log$」 的Hash表吧。</p>
<h2 id="4-LG1903-国家集训队-数颜色"><a href="#4-LG1903-国家集训队-数颜色" class="headerlink" title="$4$  LG1903 [国家集训队]数颜色"></a>$4$  LG1903 [国家集训队]数颜色</h2><blockquote>
<p>询问区间内不同的数的个数+带修。</p>
</blockquote>
<p>这有啥好说的啊？</p>
<p>不过有一点需要注意：由于时间轴左右横跳要消除贡献，所以需要记录一下每个位置修改之前的值。这个地方直接 <code>std:swap</code> 做就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(querys a, querys b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> blg[a.l] == blg[b.l] ? </span><br><span class="line">		  (blg[a.r] == blg[b.r] ? a.t &lt; b.t : blg[a.r] &lt; blg[b.r]) : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; <span class="keyword">if</span> (!-- buc[base[p]]) -- ans ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; <span class="keyword">if</span> (!buc[base[p]] ++) ++ ans ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> l, r, v, p, i, j ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">if</span> (In[<span class="number">1</span>] == <span class="string">'Q'</span>)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r), q[++ cntq].t = cntm, </span><br><span class="line">			q[cntq].l = l, q[cntq].r = r, q[cntq].id = cntq ;  </span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;v), m[++ cntm].p = p, m[cntm].c = v ;</span><br><span class="line">	&#125;</span><br><span class="line">	B = <span class="built_in">pow</span>((<span class="keyword">double</span>)N, <span class="number">0.677</span>), </span><br><span class="line">	Bnum = <span class="built_in">ceil</span>((<span class="keyword">double</span>)N / (<span class="keyword">double</span>)B) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Bnum ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = B * i + <span class="number">1</span> ; j &lt;= B * (i + <span class="number">1</span>) ; ++ j) blg[j] = i + <span class="number">1</span> ;</span><br><span class="line">	l = <span class="number">1</span>, r = <span class="number">0</span>, ans = <span class="number">0</span>, T = <span class="number">0</span> ;</span><br><span class="line">	sort(q + <span class="number">1</span>, q + cntq + <span class="number">1</span>, comp) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ;</span><br><span class="line">		<span class="keyword">while</span> (l &gt; q[i].l) add(-- l) ;		</span><br><span class="line">		<span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">		<span class="keyword">while</span> (r &lt; q[i].r) add(++ r) ; </span><br><span class="line">		<span class="keyword">while</span> (q[i].t &gt; T)&#123;</span><br><span class="line">			++ T ;</span><br><span class="line">			<span class="keyword">if</span> (m[T].p &lt;= q[i].r &amp;&amp; m[T].p &gt;= q[i].l)&#123;</span><br><span class="line">				<span class="keyword">if</span> (!-- buc[base[m[T].p]]) -- ans ; </span><br><span class="line">				<span class="keyword">if</span> (!buc[m[T].c] ++) ++ ans ; </span><br><span class="line">			&#125;</span><br><span class="line">			swap(m[T].c, base[m[T].p]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (q[i].t &lt; T)&#123;</span><br><span class="line">			<span class="keyword">if</span> (m[T].p &lt;= q[i].r &amp;&amp; m[T].p &gt;= q[i].l)&#123;</span><br><span class="line">				<span class="keyword">if</span> (!-- buc[base[m[T].p]]) -- ans ; </span><br><span class="line">				<span class="keyword">if</span> (!buc[m[T].c] ++) ++ ans ; </span><br><span class="line">			&#125;	</span><br><span class="line">			swap(m[T].c, base[m[T].p]) ;</span><br><span class="line">			-- T ;</span><br><span class="line">		&#125;</span><br><span class="line">		res[q[i].id] = ans ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cntq ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[i]) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎选的都是很水的…剩下的题需要脑子，我莫得脑子，所以就先这样吧。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记&amp;题解】线段树优化建图</title>
    <url>/2020/01/23/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是把边数从 $n^2$ 优化到 $n\log n$ 的一个操作？还是挺简单的吧。</p>
<a id="more"></a>
<h1 id="0-瞎扯"><a href="#0-瞎扯" class="headerlink" title="$0$ 瞎扯"></a>$0$ 瞎扯</h1><p>考虑三个场景：从 $[l_1,r_1]$ 连向 $x$, 从 $x$ 连向 $[l_2,r_2]$，从 $[l_1,r_1]$ 连向 $[l_2,r_2]$ 。</p>
<p>发现可以用两棵线段树来模拟这个东西，一棵线段树从 $rt$ 向 $lc,rc$ 连边，一棵从 $lc,rc$ 向 $rt$ 连边。只要把叶子节点设置为 $1\sim n$ ，这样最终点数就是 $O(n\log n)$ 的。稳得很。</p>
<p>然后就没有然后了。</p>
<h1 id="1-CF786B-Legacy"><a href="#1-CF786B-Legacy" class="headerlink" title="$1$ CF786B Legacy"></a>$1$ CF786B Legacy</h1><blockquote>
<p>给定一张 $n$ 个点的图，有 $m$ 个下列操作：</p>
<ul>
<li><p>1.进行单点与单点连有向边 </p>
</li>
<li><p>2.进行单点与区间连有向边 </p>
</li>
<li><p>3.进行区间与单点连有向边。</p>
</li>
</ul>
<p>求最短路。</p>
</blockquote>
<p>发现就是个板子？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">2000010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inf = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[NN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">LL dis[NN] ;</span><br><span class="line"><span class="keyword">int</span> n, m, s ;</span><br><span class="line"><span class="keyword">bool</span> vis[NN] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="keyword">int</span> Id, head[NN], cnt ;</span><br><span class="line"><span class="keyword">int</span> rt1, rt2, lc[NN], rc[NN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, val(cnt) = val,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> rt = l, <span class="keyword">void</span>() ;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid, p) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r, p) ;</span><br><span class="line">    <span class="keyword">if</span> (!p) add(rt, lc[rt], <span class="number">0</span>), add(rt, rc[rt], <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">else</span> add(lc[rt], rt, <span class="number">0</span>), add(rc[rt], rt, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> w, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        p ? add(rt, u, w) : add(u, rt, w) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, u, ul, ur, w, p) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, u, ul, ur, w, p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    Id = n, <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; s ;</span><br><span class="line">    build(rt1, <span class="number">1</span>, n, <span class="number">0</span>) ;</span><br><span class="line">    build(rt2, <span class="number">1</span>, n, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">int</span> mk, u, v, w, l, r ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;l, &amp;r, &amp;w),</span><br><span class="line">            update(rt1, <span class="number">1</span>, n, u, l, r, w, mk - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;u, &amp;l, &amp;r, &amp;w),</span><br><span class="line">            update(rt2, <span class="number">1</span>, n, u, l, r, w, mk - <span class="number">2</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i) cout &lt;&lt; E[i].to &lt;&lt; " " &lt;&lt; E[i].val &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    fill(dis, dis + Id + <span class="number">1</span>, Inf) ;</span><br><span class="line">    q.push(s), dis[s] = <span class="number">0</span>, vis[s] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line">        vis[n] = <span class="number">0</span>, q.pop() ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[to(k)] &gt; dis[n] + val(k))&#123;</span><br><span class="line">                dis[to(k)] = dis[n] + val(k) ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)])</span><br><span class="line">                    vis[to(k)] = <span class="number">1</span>, q.push(to(k)) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>, dis[i] == Inf ? <span class="number">-1</span> : dis[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-LG3588-POI2015-PUS"><a href="#2-LG3588-POI2015-PUS" class="headerlink" title="$2$ LG3588 [POI2015]PUS"></a>$2$ LG3588 [POI2015]PUS</h1><blockquote>
<p>给定一个长度为 $n$ 的正整数序列 $a$ ,每个数都在 $1$ 到 $10^9$ 范围内,告诉你其中 $s$ 个数.</p>
<p>给出 $m$ 条信息,每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数,表示 $a_l..a_{l+1}…a_{r-1}..a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大 (严格大于，即没有等号)</p>
<p>构造一组合法解或者输出 $-1$ </p>
</blockquote>
<p>似乎就是一个差分约束？发现每次需要从每个 $k_{i,j}$ 连向剩下的子区间。如果用线段树优化建图，这样就是 $\sum k_i^2\log k_i$ 的边数，炸的很惨。</p>
<p>这个地方有个很妙的 $\rm Idea$ ，即对每个操作建立一个新点 $p_i$，让每个 $k_{i,j}$ 连向 $p_i$，再让 $p_i$ 连向每个分割开的子区间。这样就成功地只需要 $\sum O(k_i\log k_i)$ 的空间，很稳。</p>
<p><del>话说这还是自己第一次真正去写差分约束</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v ;</span><br><span class="line">    val(cnt) = val, deg[v] ++ ;</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> rt = l, <span class="keyword">void</span>() ;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r) ;</span><br><span class="line">    add(lc[rt], rt, <span class="number">0</span>), add(rc[rt], rt, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> u, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur) <span class="keyword">return</span> add(rt, u, w) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, u, ul, ur, w) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, u, ul, ur, w) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, l, r, k ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; m ;</span><br><span class="line">    Id = n ; build(root, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= s ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), base[u] = dis[u] = v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k) ;</span><br><span class="line">        Id ++, last = l - <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= k ; ++ j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v) ; add(Id, v, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (last + <span class="number">1</span> &lt; v)</span><br><span class="line">				update(root, <span class="number">1</span>, n, Id, last + <span class="number">1</span>, v - <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">            last = v ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (last &lt; r)</span><br><span class="line">            update(root, <span class="number">1</span>, n, Id, last + <span class="number">1</span>, r, <span class="number">0</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Id ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dis[i]) dis[i] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!deg[i]) q.push(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        u = q.front() ; q.pop() ; vis[u] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">            dis[to(k)] = max(dis[to(k)], dis[u] + val(k)) ;</span><br><span class="line">            <span class="keyword">if</span> (base[to(k)] &amp;&amp; dis[to(k)] &gt; base[to(k)])</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>), <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (! -- deg[to(k)]) q.push(to(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Id ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i] || dis[i] &gt; Inf) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"TAK"</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, dis[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-SNOI2017-炸弹"><a href="#3-SNOI2017-炸弹" class="headerlink" title="$3$ [SNOI2017]炸弹"></a>$3$ [SNOI2017]炸弹</h1><blockquote>
<p>在一条直线上有 $n$ 个炸弹，每个炸弹的坐标是 $x_i$，爆炸半径是 $r_i$。</p>
<p>当一个炸弹爆炸时，如果另一个炸弹所在位置 $x_j$ 满足： $|x_j-x_i| \le r_i$ ，那么，该炸弹也会被引爆。计算先把第 $i$ 个炸弹引爆，将引爆多少个炸弹。</p>
<p>答案对 $10^9+7$ 取模。保证 $x_i$ 随着 $i$ 单增。</p>
</blockquote>
<p>发现可以先二分出每个点要连的左右端点。然后考虑缩点。由于是 $\rm DAG$ 就可以直接求出每个点能到达的点的编号的 $\min,\max$ ，这东西可以一遍 $\rm topsort$ 求出来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">8000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> val(k) E[k].val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> deg[N] ;</span><br><span class="line"><span class="keyword">bool</span> vis[N] ;</span><br><span class="line"><span class="keyword">int</span> s[N], tp ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">LL x[N], r[N] ;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N] ;</span><br><span class="line"><span class="keyword">int</span> SCC, blg[N] ;</span><br><span class="line"><span class="keyword">int</span> n, Id, root ;</span><br><span class="line"><span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> val[N * <span class="number">3</span>][<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N] ;</span><br><span class="line"><span class="keyword">int</span> lc[N * <span class="number">3</span>], rc[N * <span class="number">3</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, fr(cnt) = u,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        rt = l ;</span><br><span class="line">        val[l][<span class="number">0</span>] = l ;</span><br><span class="line">        val[l][<span class="number">1</span>] = l ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    rt = ++ Id ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(lc[rt], l, mid) ;</span><br><span class="line">    build(rc[rt], mid + <span class="number">1</span>, r) ;</span><br><span class="line">    add(rt, lc[rt]) ; add(rt, rc[rt]) ;</span><br><span class="line">    val[rt][<span class="number">0</span>] = val[lc[rt]][<span class="number">0</span>] ;</span><br><span class="line">    val[rt][<span class="number">1</span>] = val[rc[rt]][<span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul ,<span class="keyword">int</span> ur, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> f == rt ? <span class="keyword">void</span>() : add(f, rt) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(lc[rt], l, mid, ul, ur, f) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rc[rt], mid + <span class="number">1</span>, r, ul, ur, f) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    s[++ tp] = x, vis[x] = <span class="number">1</span> ;</span><br><span class="line">    dfn[x] = low[x] = ++ tot ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[to(k)])</span><br><span class="line">            tarjan(to(k)),</span><br><span class="line">            low[x] = min(low[x], low[to(k)]) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[to(k)])</span><br><span class="line">            low[x] = min(low[x], dfn[to(k)]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> now ;</span><br><span class="line">        L[++ SCC] = n + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">while</span> (tp)&#123;</span><br><span class="line">            now = s[tp --] ;</span><br><span class="line">            L[SCC] = min(L[SCC], val[now][<span class="number">0</span>]) ;</span><br><span class="line">            R[SCC] = max(R[SCC], val[now][<span class="number">1</span>]) ;</span><br><span class="line">            vis[now] = <span class="number">0</span>, blg[now] = SCC ;</span><br><span class="line">            <span class="keyword">if</span> (now == x) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> lq, rq ; LL xx, oo ;</span><br><span class="line">    Id = n, build(root, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; fr(i) &lt;&lt; " " &lt;&lt; to(i) &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x[i], &amp;r[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        xx = x[i], oo = r[i] ;</span><br><span class="line">        lq = lower_bound(x + <span class="number">1</span>, x + n + <span class="number">1</span>, xx - oo) - x ;</span><br><span class="line">        rq = upper_bound(x + <span class="number">1</span>, x + n + <span class="number">1</span>, xx + oo) - x ;</span><br><span class="line">        rq -- ; <span class="keyword">if</span> (lq &lt;= rq) update(root, <span class="number">1</span>, n, lq, rq, i) ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; lq &lt;&lt; " " &lt;&lt; rq &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    puts("") ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; root &lt;&lt; endl ;</span></span><br><span class="line">    tarjan(root) ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; cnt &lt;&lt; " " &lt;&lt; SCC &lt;&lt; endl ;</span></span><br><span class="line">    tot = cnt, cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; blg[i] &lt;&lt; " " ;</span></span><br><span class="line"><span class="comment">//    puts("") ;</span></span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (blg[fr(i)] != blg[to(i)])</span><br><span class="line">            add(blg[to(i)], blg[fr(i)]), deg[blg[fr(i)]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= SCC ; ++ i) <span class="keyword">if</span> (!deg[i]) q.push(i) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        oo = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[oo] ; k ; k = next(k))&#123;</span><br><span class="line">            L[to(k)] = min(L[to(k)], L[oo]) ;</span><br><span class="line">            R[to(k)] = max(R[to(k)], R[oo]) ;</span><br><span class="line">            <span class="keyword">if</span> (!-- deg[to(k)]) q.push(to(k)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        (ans += <span class="number">1l</span>l * i * (R[blg[i]] - L[blg[i]] + <span class="number">1</span>) % P) %= P ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; L[blg[i]] &lt;&lt; " " &lt;&lt; R[blg[i]] &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>图论/普通建图技巧</tag>
        <tag>图论/线段树优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记&amp;题解】线段树合并瞎吹</title>
    <url>/2020/01/23/SegmentTreemerge1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大概就是合并俩线段树？重复的点一块儿用，否则直接拉过来指针。大多数都是动态开点写法（比较优美）。</p>
<p>以合并值域线段树为例说明。其复杂度是均摊的，即考虑每一次合并操作的复杂度实际上是两颗线段树重叠的点的数量。因为最后一共有 $n\log |V|$ 个点，所以复杂度是 $O(n\log |V|)$，其中 $V$ 是每个被合并元素的值域。</p>
<p>值得注意的是有些题同样需要维护合并之前的信息，那么合并的时候就需要新建节点当根。但根据主席树那套理论，本质上空间复杂度只会多个 $\log$ ?（存疑</p>
<a id="more"></a>
<h1 id="1-USACO17JAN-Promotion-Counting"><a href="#1-USACO17JAN-Promotion-Counting" class="headerlink" title="$1$ [USACO17JAN]Promotion Counting"></a>$1$ [USACO17JAN]Promotion Counting</h1><blockquote>
<p>给定一棵树，对于所有的 $i\in[1,n]∩\mathbb{Z}$ ，求以 $i$ 为根的子树内有多少权值 $&gt;i$ 的点。 </p>
</blockquote>
<p>大概是比较裸的线段树合并了？</p>
<p>考虑如果按照正常地线段树合并方式，从底向上合并，那么离散化后对于每个点只需要查询线段树内 $base_i\sim n$ 的数字个数和。于是就完了。</p>
<p>有两个点需要注意：</p>
<ul>
<li>1、线段树合并不同于普通的值域线段树建立，每次 <code>update</code> 可能会存在走重复节点的情况（否则复杂度就不对了）。所以需要特判 <code>if (!Rt) Rt = ++ Id ;</code> 。</li>
<li>2、本题由于保证了 $base_i$ 互异，所以离散化可以用一种比较有趣的方式进行：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base[a] &lt; base[b] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = i ;</span><br><span class="line">sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>, comp), base[t[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f), add(f, i), base[t[i]] = i ;</span><br></pre></td></tr></table></figure>
<p>其实也是很简单的吧？类似的 $trick$ 以前用过好多次了？</p>
<p>然后以下是总代码。大概就背一背 <code>merge</code> 就好了（</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[N] ; <span class="keyword">int</span> head[N], cnt ;</span><br><span class="line"><span class="keyword">int</span> lc[N * <span class="number">15</span>], rc[N * <span class="number">15</span>] ;</span><br><span class="line"><span class="keyword">int</span> rt[N * <span class="number">15</span>], val[N * <span class="number">15</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, m, ans[N], base[N], t[N], Id ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> base[a] &lt; base[b] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;Rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Rt) Rt = ++ Id ; val[Rt] ++ ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= mid) update(lc[Rt], l, mid, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rc[Rt], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++ Id ;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="number">1l</span>l * x * y)) <span class="keyword">return</span> x + y ;</span><br><span class="line">    val[now] = val[x] + val[y] ;</span><br><span class="line">    lc[now] = merge(lc[x], lc[y]),</span><br><span class="line">    rc[now] = merge(rc[x], rc[y]) ;</span><br><span class="line">    <span class="keyword">return</span> now ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> val[root] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res += query(lc[root], l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res += query(rc[root], mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        dfs(to(k)), rt[u] = merge(rt[u], rt[to(k)]) ;</span><br><span class="line">    ans[u] = query(rt[u], <span class="number">1</span>, n, base[u] + <span class="number">1</span>, n), update(rt[u], <span class="number">1</span>, n, base[u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; <span class="keyword">int</span> f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = i ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>, comp), base[t[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f), add(f, i), base[t[i]] = i ;</span><br><span class="line">    dfs(<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-POI2011-ROT-Tree-Rotations"><a href="#2-POI2011-ROT-Tree-Rotations" class="headerlink" title="$2$ [POI2011]ROT-Tree Rotations"></a>$2$ [POI2011]ROT-Tree Rotations</h1><blockquote>
<p>给出一棵 $n(1≤n≤200000)$ 个叶子的二叉树，可以交换每个点的左右子树，要求前序遍历叶子的逆序对最少。</p>
</blockquote>
<p>很妙的一道线段树合并题。</p>
<p>首先，考虑由于只能交换左右子树，所以对于一个点，后代的子树怎么变对其答案没有影响。发现用线段树合并来维护特别合适：对于每个点是否交换左右子树，分别算出新增的逆序对个数然后取 $\min$，该过程可以在 <code>merge</code> 中直接进行——维护值域的 $\rm exist_sum$ 之后，每次只需要用乘法原理求一下即可。</p>
<p>然后就是这题读入很诡…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200011</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400011</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">6000011</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt ;</span><br><span class="line"><span class="keyword">int</span> lc[NN], rc[NN], rt[NN] ;</span><br><span class="line">LL ans, val[NN], ans1, ans2 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ch_top = <span class="number">5e7</span> + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">char</span> ch[ch_top], *now_r = ch - <span class="number">1</span>, *now_w = ch - <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &lt; <span class="number">48</span>) ;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x = *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">while</span> (*++now_r &gt;= <span class="number">48</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + *now_r - <span class="number">48</span> ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">write</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>] ; <span class="keyword">static</span> <span class="keyword">int</span> top ;</span><br><span class="line">    <span class="keyword">while</span> (st[++ top] = <span class="number">48</span> + x % <span class="number">10</span>, x /= <span class="number">10</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (*++ now_w = st[top], -- top) ; *++ now_w = <span class="string">' '</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;Rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Rt)</span><br><span class="line">        Rt = ++ cnt ;</span><br><span class="line">    val[Rt] ++ ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= mid) update(lc[Rt], l, mid, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rc[Rt], mid + <span class="number">1</span>, r, v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x + y ;</span><br><span class="line">    val[x] += val[y] ;</span><br><span class="line">    ans1 += val[lc[x]] * val[rc[y]] ;</span><br><span class="line">    ans2 += val[rc[x]] * val[lc[y]] ;</span><br><span class="line">    lc[x] = merge(lc[x], lc[y]) ;</span><br><span class="line">    rc[x] = merge(rc[x], rc[y]) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y, ls, rs ;</span><br><span class="line">    y = read() ;</span><br><span class="line">    <span class="keyword">if</span> (!y)&#123;</span><br><span class="line">        ls = rs = <span class="number">0</span> ;</span><br><span class="line">        dfs(ls), dfs(rs) ; ans1 = ans2 = <span class="number">0</span> ;</span><br><span class="line">        x = merge(ls, rs) ; ans += min(ans1, ans2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> update(x, <span class="number">1</span>, n, y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">    n = read() ; <span class="keyword">int</span> u = <span class="number">0</span> ; dfs(u) ; write(ans) ;</span><br><span class="line">    fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-Vani有约会-雨天的尾巴"><a href="#3-Vani有约会-雨天的尾巴" class="headerlink" title="$3$ [Vani有约会]雨天的尾巴"></a>$3$ [Vani有约会]雨天的尾巴</h1><blockquote>
<p>给出一棵 $n$ 个结点的树。共 $m$ 次操作，每次给出树上的一条路径，给路径上所有点添加一个权值为 $w$ 的元素。最后输出每个点出现次数最多的元素的权值。</p>
</blockquote>
<p>考虑暴力去剖，发现这么做是 $\frac{n^2\log^2 n}{\omega}$的，即暴力合并 bitset.</p>
<p>但是发现可以离线，于是考虑直接用剖去维护树上差分。那么考虑，对于最终的 $m$ 组询问，可以处理为 $n\log n$ 段 $dfn$ 上的序列差分。</p>
<p>于是对这些差分再用权值线段树从头开始扫一遍就完了。最终复杂度 $O(n\log n)\times O(\log n)=O(n\log^2n)$ 。</p>
<p>但其实发现，树上差分然后拆区间这个过程完全可以用dfs+线段树合并来替代，于是复杂度降为 $n\log n$ 。</p>
<p>…但其实第二个做法其中拆询问的那个 $\log$ 跟本跑不满，再加上线段树合并的复杂度，均摊出来是在是有点 $gg$，于是似乎链剖踩爆了线段树合并的亚子QAQs。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">    fa[u] = f, sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs(son[u], u, tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != f) dfs(to(k), u, to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) swap(u, v) ;</span><br><span class="line">        u = fa[top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &gt; dep[v] ? v : u ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _up(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[lc[u]] &gt; s[rc[u]])</span><br><span class="line">        s[u] = s[lc[u]], val[u] = val[lc[u]] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s[lc[u]] &lt; s[rc[u]])</span><br><span class="line">        s[u] = s[rc[u]], val[u] = val[rc[u]] ;</span><br><span class="line">    <span class="keyword">else</span> s[u] = s[lc[u]], val[u] = min(val[lc[u]], val[rc[u]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;u, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) u = ++ cnt ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        s[u] += v ;</span><br><span class="line">        val[u] = s[u] ? r : <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(lc[u], l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rc[u], mid + <span class="number">1</span>, r, p, v) ; _up(u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> s[x] += s[y], val[x] = l, x ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    lc[x] = merge(lc[x], lc[y], l, mid) ;</span><br><span class="line">    rc[x] = merge(rc[x], rc[y], mid + <span class="number">1</span>, r) ;</span><br><span class="line">    _up(x) ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != f)</span><br><span class="line">            do_do(to(k), x),</span><br><span class="line">            rt[x] = merge(rt[x], rt[to(k)], <span class="number">1</span>, S) ;</span><br><span class="line">    ans[x] = val[rt[x]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">int</span> u, v, z, f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        qr(u), qr(v),</span><br><span class="line">        qr(z), f = lca(u, v) ;</span><br><span class="line">        update(rt[u], <span class="number">1</span>, S, z, <span class="number">1</span>) ;</span><br><span class="line">        update(rt[v], <span class="number">1</span>, S, z, <span class="number">1</span>) ;</span><br><span class="line">        update(rt[f], <span class="number">1</span>, S, z, <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (fa[f]) update(rt[fa[f]], <span class="number">1</span>, S, z, <span class="number">-1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    do_do(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-HNOI2012-永无乡"><a href="#4-HNOI2012-永无乡" class="headerlink" title="$4 $ [HNOI2012] 永无乡"></a>$4 $ [HNOI2012] 永无乡</h1><blockquote>
<p>你需要维护若干连通快，有两个操作：</p>
<ul>
<li>合并 $x,y$ 所在的连通块。</li>
<li>询问 $x$ 所在连通块中权值从小到大排第 $k$ 的结点编号。</li>
</ul>
<p>$1\leq n,q\leq 3\cdot 10^5$</p>
</blockquote>
<p>fa♂现线段树合并之后直接在线段树上二分就做完了，$n\log n$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= q ; ++ i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, I + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (I[<span class="number">1</span>] == <span class="string">'B'</span>)&#123;</span><br><span class="line">        u = qr(), v = qr() ;</span><br><span class="line">        <span class="keyword">int</span> f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="keyword">if</span> (f1 != f2) fa[f2] = f1, rt[f1] = merge(rt[f1], rt[f2]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        u = qr(), k = qr(), u = find(u) ;</span><br><span class="line">        <span class="keyword">if</span> (s[rt[u]] &lt; k) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(rt[u], <span class="number">1</span>, n, k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线段树合并</category>
      </categories>
      <tags>
        <tag>数据结构/数据结构方法/线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活碎片2】· 原来我还什么都不懂</title>
    <url>/2020/01/23/Life2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在看「爱情公寓5」，感触很多。</p>
<a id="more"></a>
<p>还记得自己是小学4年级第一次听同学说过这个剧，当时还觉得名字很俗气。之后就开始慢慢地追啊追，从当时正在热播的第三季追到第二季、第一季，而后又等到第四季，等到现在的第五季。</p>
<p>然而，每次看「爱情公寓」之前，都是很纠结很纠结的。纠结在，剧里描绘的那个世界那么美好简单，每次看完我都会感到无奈好几天、难以释怀好几天——这样的生活恐怕不属于我吧。</p>
<p>如果说我心中有两个地方最脆弱，那就是对往事的追思让我感到无奈与感动、对可望而不可即的生活的期盼让我感到渺小与希望。</p>
<p>所以，本质上，「爱情公寓5」这部剧，就是一个「移情」的途径。它既承载了我对以前追剧时简单生活的追思与怀念，又承载了「最好的朋友就在身边、最爱的人就在对面」的渴望与无奈，所以我才会很难以释怀。</p>
<p>然而这其实只是个小问题，但以前我似乎从来没去想过为什么我会那么彷徨无奈。</p>
<p>或许是从停课开始的，或许是从联赛开始的，或许会更早些——我会时常感到：“啊，原来我还什么都不懂，原来这个世界对我来说还是陌生的”。</p>
<p>啊，原来我还什么都不懂。</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>初中时，跟最要好的伙伴有一天突然聊到了心理。她说：“或许大家应该都去看看那些心理学的书，里面的东西或许挺值得学习的”。</p>
<p>我记得当时我十分不屑地说：“那上面那些东西，对自己而言都没啥价值吧？学了之后去别人或许挺有用，这点心理暗示对自己根本不起作用。”</p>
<p>她本就是个比较文静沉默的人，所以并没有继续跟我争论。</p>
<p>记得自己小时候很爱看心理学的书。可能缘于刚接触大自然，对什么事情都有一种新鲜的控制欲，自然什么「微表情窥探一个人的内心」、「浅谈心理学」之类的科普书籍比较受我喜爱。</p>
<p>但直到最近我才发现，原来这是一门需要经验和丰富学识的学科，并不是草草的阅读就能拯救来的。</p>
<p>接着我发现，原来似乎每一行要干好，都不容易。自己以前建立起的莫名其妙的自负，从那开始便渐渐开始烟消云散了。</p>
<p>原来我还什么都不懂。</p>
<p>记得曾经在初中，寄宿制。最好的两个朋友每天都要去给父母打一次电话。我很不理解，因为自己两周也未必会打一次电话。于是就带着有点轻蔑的口吻问他们：“每天打一次电话是不是有点太不独立了？老哥们，我们都初中了诶，也不用像小学一样成天跟家长沟通吧。要独立，独立！”</p>
<p>之后，他们也没说什么，只是简单地搪塞了过去。当时自己还觉得我很厉害，有点瞧不起这种每天都依赖父母的人。</p>
<p>直到高一的暑假，外出培训时，和别的人又发生了类似的争吵——我才发现，可能我随手毁坏的、侮辱的，是别人的人生信条。不同的人有不同的人生信条，就如同不同的夜挂着不同的星。我说那夜没有星，只是因为我觉得每天的星都不同而没去看，经验之谈罢了。</p>
<p>原来我还什么都不懂。</p>
<h2 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h2><p>看完了《爱情公寓5》。其实本来我一周前就看完了前 $34$ 集，一直舍不得看最后两集，骗自己说『没事，不看完的话，就永远也不会结束，对吧？』。</p>
<p>这种家庭式喜剧永远是我的伤痛。我有着健全美满的家庭，不错的同学朋友，优秀的老师。但我就是不满足。似乎我的快乐根本无法寄托在这种人与人之间的情感共鸣上。但是每当看完一季《爱情公寓》也好、《生活大爆炸》也罢、等待下一季的时候，我都会时不时地在想：为什么我就不能进入那个世界呢？周围的生活庸俗且颓废，高中之后唯一的寄托可能就是OI，但是OI这条路，我已经等够了啊。一天又一天告诉自己等待只是因为自己太弱，但是原谅我，我不知道该怎么改变这个现状啊？</p>
<p>于是自己就一直想要去逃避，逃避这一切。</p>
<p>但看《爱情公寓》的片花时，我发现，撕开那璀璨的剧情，原来每个演员都是十分努力的在演戏，一条不行换下一条，比起我这个整日只会空想的死肥宅高到不知道什么地方去了。所以我就在想啊，他们其实就是在无比地热爱着自己的生活吧？而我呢？似乎上了高中之后，就再也没有热爱过生活。</p>
<p>我到底怎么了呢？</p>
<p>但其实，我可能还没有必要去纠结这些东西。《爱情公寓》在落幕之前，揭示了主旨，就是『革命乐观主义精神』。宣传片的歌词里也说『_人生下一关 / 等着我们去开启 / 成长需要告别过去自己_』。所以，这可能就是我需要的吧。</p>
<p>热爱自己的生活，就是这样。无论自己空想出来的世界有多美，书里、剧里勾勒的世界有多妙，这一幕结束之后，我还是要去走自己的人生。逃避是没有用的，正面A上去才是唯一的救赎之道。</p>
<h2 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h2><p>这一篇算什么？鸡汤？</p>
<p>差不多吧。但我觉得比起鸡汤来，这东西显得浑浊的多。</p>
<p>我身处无尽深渊的最底部。周身弥漫的是紫黑色的雾气。我的双眼瞎了、两耳聋了、嘴也张不开了。但我能感受到自己身上在绽放着生命的力量，催我爬出去。</p>
<p>嗯，很赞同的一个观点：</p>
<blockquote>
<p>很多人想知道，生命的意义到底是什么？我们每天行色匆匆、得过且过。我们到底为什么而活？</p>
<p>其实，『活着』的意义，就是『活着』本身。</p>
</blockquote>
<p>总之呢，原来我还什么都不懂。这个世界，我还要一点一点慢慢地探索；这条路，我还要慢慢的走。</p>
<h2 id="4"><a href="#4" class="headerlink" title="$4$"></a>$4$</h2><p>最后挂几张爱情公寓的图，毕竟也是陪了我五六年的剧了。纪念一下吧！</p>
<p>再见啦，我的青春。再见啦，爱情公寓！</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/08/1RP91A.jpg" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/08/1RPPXt.jpg" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/08/1RPppd.jpg" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/08/1RCzfH.jpg" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/08/1RCxte.jpg" alt=""><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/02/08/1RPFnP.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】AC自动机泛做</title>
    <url>/2020/01/17/AC%E8%87%AA%E5%8A%A8%E6%9C%BA2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>几道AC自动机简单题qwq</p>
<p>以上是原标题。现在整理一遍发现除了第一道题都不太会了，所以题都挺好的QAQ</p>
<p><del>所以是不是间接证明了「好题」=「由于自己太菜而想不出来的题」啊，听上去好悲伤</del></p>
<a id="more"></a>
<h1 id="1-TJOI2013-单词"><a href="#1-TJOI2013-单词" class="headerlink" title="$1$ [TJOI2013]单词"></a>$1$ [TJOI2013]单词</h1><blockquote>
<p>小张最近在忙毕设，所以一直在读论文。</p>
<p>一篇论文是由许多单词组成。但小张发现一个单词会在论文中出现很多次，他想知道每个单词分别在论文中出现了多少次。</p>
</blockquote>
<p>发现怎么做都可以啦。当时自己似乎是记录了一下关键点(endpos)和每个点的经过次数，然后反向topsort就dp完了。</p>
<p>多攒攒经验，万一哪天就可以一眼秒了呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> rt = <span class="number">0</span>, c ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; s[k] ; ++ k)&#123;</span><br><span class="line">        c = s[k] - <span class="string">'a'</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!Trie[rt][c]) </span><br><span class="line">          Trie[rt][c] = ++ tot ; </span><br><span class="line">        rt = Trie[rt][c], ++ res[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[ID] = rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) </span><br><span class="line">      <span class="keyword">if</span>(Trie[<span class="number">0</span>][i]) q.push(Trie[<span class="number">0</span>][i]) ; </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front() ; T[++ n] = now ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!v(now)) </span><br><span class="line">              Trie[now][i] = Trie[fail[now]][i] ;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">              fail[v(now)] = Trie[fail[now]][i], q.push(v(now)) ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (i = n ; i &gt;= <span class="number">0</span> ; -- i) res[fail[T[i]]] += res[T[i]] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-USACO15FEB-Censoring-Gold"><a href="#2-USACO15FEB-Censoring-Gold" class="headerlink" title="$2$ [USACO15FEB]Censoring(Gold)"></a>$2$ [USACO15FEB]Censoring(Gold)</h1><blockquote>
<p>给出一个长串和一堆小串。每次从长串中找出最靠右的小串，删掉之后拼起来，继续删。求删到最后的串。</p>
<p>$\rm |S|\leq 10^6$</p>
</blockquote>
<p>第一眼不会做，我是弟弟QAQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *In)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rt = <span class="number">0</span>, L = <span class="built_in">strlen</span>(In) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> now = In[i] - <span class="string">'a'</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!Trie[rt][now]) </span><br><span class="line">		    Trie[rt][now] = ++ cnt ;</span><br><span class="line">		rt = Trie[rt][now] ;<span class="comment">// 1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	Id[rt] = L ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rt = <span class="number">0</span> ;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Ls ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> now = S[i] - <span class="string">'a'</span> ;</span><br><span class="line">		rt = Trie[rt][now], R[i] = rt, stk[++ top] = i ;</span><br><span class="line">		<span class="keyword">if</span> (Id[rt]) top -= Id[rt], rt = top ? R[stk[top]] : <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现似乎正解出奇的简洁…</p>
<p>然后发现原来「删除一个串再拼起来」这东西就直接顺着扫一遍弹栈就完了…</p>
<p>这题似乎挺考察基本功的吧…像我这种基本功不行的老年选手又被无情吊锤了QAQ</p>
<h1 id="3-NOI2011-阿狸的打字机"><a href="#3-NOI2011-阿狸的打字机" class="headerlink" title="$3$ [NOI2011]阿狸的打字机"></a>$3$ [NOI2011]阿狸的打字机</h1><blockquote>
<p>有一个打字机，支持三种操作：</p>
<ul>
<li>字符串末尾加一个小写字母</li>
<li>字符串末尾删一个字符</li>
<li>输出这个字符串</li>
</ul>
<p>经过不超过 $n$ 次操作后有 $m$ 组询问：$(x,y)$，表示询问第 $x$ 次输出第字符串在第 $y$ 次输出第字符串里出现几次</p>
<p>$1\leq n,m \leq 10^5$</p>
</blockquote>
<p>本来没做过这道题，但是一篇文章写两道题总觉得有点不爽，于是决定加一道。</p>
<p>于是就发现自己进了个天坑……本来觉得这题应该挺简单的说（通过题目名称猜的（（（</p>
<p>根据 ACAM 的性质，发现所有包含某个串 $\rm S$ 的集合 $O$ 就是 $\rm endpos(S)$ 在 $fail$ 树上的子树。所以每次可以看做查询 $\rm endpos(S_\mathit{x})$ 的 $fail$ 树子树中有多少个单词也在 $\rm S_\it{y}$ 里面。发现「也在 $\rm S_\it{y}$ 里面」这东西可以通过「$\rm endpos(S\mathit{_y})$ 在 Trie 上到根的路径」来表示，于是就直接拿个树状数组维护 $dfs$ 序就可以了。</p>
<p>然后以下是写这个题踩的坑：</p>
<ul>
<li>AC自动机由于求 fail 的时候要路径压缩，所以如果压完直接去 dfs 这个 Trie 的话会错，所以要事先复制一份（因为显然不路径压缩复杂度不对）。</li>
<li>不要忘了AC自动机有 0 号节点，所以 dfn 可能会比编号大 1，加上即可。</li>
<li>这题读入十分鬼畜，导致不能一个一个插入。发现删除就是跳 father ，加入就是走 root，所以也是考察了AC自动机的状态简并性吧。</li>
</ul>
<p>唉，我太菜了。中间由于思考不足导致走了一堆弯路。且一开始由于 TLE 还觉得是线段树太慢了又写了个 BIT…233</p>
<p>不管不管，这么难写的东西一定要代码全篇贴qwq！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Sigma = <span class="number">26</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1000010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to ;</span><br><span class="line">    <span class="keyword">int</span> next ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line"><span class="keyword">int</span> m ;</span><br><span class="line"><span class="keyword">int</span> Id ;</span><br><span class="line"><span class="keyword">int</span> cnt ;</span><br><span class="line"><span class="keyword">char</span> S[N] ;</span><br><span class="line"><span class="keyword">char</span> T[N] ;</span><br><span class="line"><span class="keyword">int</span> ans[N] ;</span><br><span class="line"><span class="keyword">int</span> sz[SZ] ;</span><br><span class="line"><span class="keyword">int</span> _bit[N] ;</span><br><span class="line"><span class="keyword">int</span> dfn[SZ] ;</span><br><span class="line"><span class="keyword">int</span> dep[SZ] ;</span><br><span class="line"><span class="keyword">int</span> head[SZ] ;</span><br><span class="line"><span class="keyword">int</span> t[N * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">int</span> tag[N * <span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">bool</span> vis[SZ] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;pint&gt; qs[N] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> L, rt ;</span><br><span class="line">    <span class="keyword">int</span> fa[SZ] ;</span><br><span class="line">    <span class="keyword">int</span> id[SZ] ;</span><br><span class="line">    <span class="keyword">int</span> sz, tot ;</span><br><span class="line">    <span class="keyword">int</span> _ed[SZ] ;</span><br><span class="line">    <span class="keyword">int</span> _ED[SZ] ;</span><br><span class="line">    <span class="keyword">int</span> fail[SZ] ;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="keyword">int</span> tr[SZ][Sigma] ;</span><br><span class="line">    <span class="keyword">int</span> trans[SZ][Sigma] ;</span><br><span class="line">    <span class="comment">/*void Insert(char *S, int len)&#123;</span></span><br><span class="line"><span class="comment">        L = len, rt = 0, ++ tot ;</span></span><br><span class="line"><span class="comment">        //cout &lt;&lt; " ** " &lt;&lt; len &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= L ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">            //cout &lt;&lt; S[i] ;</span></span><br><span class="line"><span class="comment">            int o = S[i] - 'a' ;</span></span><br><span class="line"><span class="comment">            if (!trans[rt][o])</span></span><br><span class="line"><span class="comment">                trans[rt][o] = ++ sz ;</span></span><br><span class="line"><span class="comment">            rt = trans[rt][o] ;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        _ed[rt] = tot ; _ED[tot] = rt ; //puts("") ;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Workfail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trans[<span class="number">0</span>][i]) q.push(trans[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= sz ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; Sigma ; ++ j)</span><br><span class="line">                tr[i][j] = trans[i][j] ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!tr[x][i]) tr[x][i] = tr[fail[x]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[tr[x][i]] = tr[fail[x]][i], q.push(tr[x][i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v,</span><br><span class="line">    next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">    dfn[x] = ++ Id ; sz[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        dep[to(k)] = dep[x] + <span class="number">1</span> ;</span><br><span class="line">        dfs(to(k)), sz[x] += sz[to(k)] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void down(int x, int l, int r)&#123;</span></span><br><span class="line"><span class="comment">    if (tag[x])&#123;</span></span><br><span class="line"><span class="comment">        int lc = x &lt;&lt; 1 ;</span></span><br><span class="line"><span class="comment">        int rc = x &lt;&lt; 1 | 1 ;</span></span><br><span class="line"><span class="comment">        int mid = (l + r) &gt;&gt; 1 ;</span></span><br><span class="line"><span class="comment">        tag[lc] += tag[x] ;</span></span><br><span class="line"><span class="comment">        tag[rc] += tag[x] ;</span></span><br><span class="line"><span class="comment">        t[rc] += tag[x] * (r - mid) ;</span></span><br><span class="line"><span class="comment">        t[lc] += tag[x] * (mid - l + 1) ;</span></span><br><span class="line"><span class="comment">        tag[x] = 0 ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void update(int rt, int l, int r, int ul, int ur, int v)&#123;</span></span><br><span class="line"><span class="comment">    if (ul &lt;= l &amp;&amp; r &lt;= ur)&#123;</span></span><br><span class="line"><span class="comment">        t[rt] += v * (r - l + 1) ;</span></span><br><span class="line"><span class="comment">        tag[rt] += v ; return void() ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1 ; down(rt, l, r) ;</span></span><br><span class="line"><span class="comment">    if (ul &lt;= mid) update(rt &lt;&lt; 1, l, mid, ul, ur, v) ;</span></span><br><span class="line"><span class="comment">    if (mid &lt; ur) update(rt &lt;&lt; 1 | 1, mid + 1, r, ul, ur, v) ;</span></span><br><span class="line"><span class="comment">    t[rt] = t[rt &lt;&lt; 1] + t[rt &lt;&lt; 1 | 1] ;</span></span><br><span class="line"><span class="comment">&#125;*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">void update(int rt, int l, int r, int p, int v)&#123;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1 ;</span></span><br><span class="line"><span class="comment">    if (l == r)</span></span><br><span class="line"><span class="comment">        return t[rt] += v, void() ;</span></span><br><span class="line"><span class="comment">    if (p &lt;= mid)</span></span><br><span class="line"><span class="comment">        update(rt &lt;&lt; 1, l, mid, p, v) ;</span></span><br><span class="line"><span class="comment">    else update(rt &lt;&lt; 1 | 1, mid + 1, r, p, v) ;</span></span><br><span class="line"><span class="comment">    t[rt] = t[rt &lt;&lt; 1] + t[rt &lt;&lt; 1 | 1] ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int query(int rt, int l, int r, int ql, int qr)&#123;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1, ret = 0 ;</span></span><br><span class="line"><span class="comment">    if (ql &lt;= l &amp;&amp; r &lt;= qr) return t[rt] ;</span></span><br><span class="line"><span class="comment">    if (ql &lt;= mid) ret += query(rt &lt;&lt; 1, l, mid, ql, qr) ;</span></span><br><span class="line"><span class="comment">    if (qr &gt; mid) ret += query(rt &lt;&lt; 1 | 1, mid + 1, r, ql, qr) ;</span></span><br><span class="line"><span class="comment">    return ret ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdf</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= A.sz ; p += low(p)) _bit[p] += v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p))</span><br><span class="line">        res += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">return</span> ; vis[x] = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; t[1] &lt;&lt; endl ;</span></span><br><span class="line">    mdf(dfn[x], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (A._ed[x])&#123;</span><br><span class="line">        <span class="keyword">int</span> n, k = A._ed[x] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : qs[k])&#123;</span><br><span class="line">            n = A._ED[i.first] ;</span><br><span class="line">            ans[i.second] = ask(dfn[n] + sz[n] - <span class="number">1</span>) ;</span><br><span class="line">            ans[i.second] -= ask(dfn[n] - <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Sigma ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (A.trans[x][i]) do_do(A.trans[x][i]) ;</span><br><span class="line">    mdf(dfn[x], <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y, rt ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>) ;</span><br><span class="line">    y = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ; A.sz = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= y ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">        if (S[i] == 'B') x -- ;</span></span><br><span class="line"><span class="comment">        else if (S[i] == 'P') A.Insert(T, x) ;</span></span><br><span class="line"><span class="comment">        else T[++ x] = S[i] ;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    rt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= y ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="string">'B'</span>) rt = A.fa[rt] ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'P'</span>)</span><br><span class="line">            A._ed[rt] = ++ A.tot, A._ED[A.tot] = rt ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> o = S[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!A.trans[rt][o]) A.trans[rt][o] = ++ A.sz ;</span><br><span class="line">            A.fa[A.trans[rt][o]] = rt, rt = A.trans[rt][o] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; A.sz &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= A.sz ; ++ i, puts(""))</span></span><br><span class="line"><span class="comment">        for (int j = 0 ; j &lt;= 2 ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; A.trans[i][j] &lt;&lt; " " ;*/</span></span><br><span class="line">    A.Workfail() ;</span><br><span class="line"><span class="comment">/*    for (int i = 1 ; i &lt;= A.sz ; ++ i, puts(""))</span></span><br><span class="line"><span class="comment">        for (int j = 0 ; j &lt;= 2 ; ++ j)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; A.trans[i][j] &lt;&lt; " " ;*/</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; A.tot &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= A.sz ; ++ i)</span><br><span class="line">        add(A.fail[i], i) ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    dfs(<span class="number">0</span>) ; <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">    <span class="comment">//for (int i = 0 ; i &lt;= 3 ; ++ i) cout &lt;&lt; dep[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; A.fail[9] &lt;&lt; endl ;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= A.tot ; ++ i) cout &lt;&lt; A._ED[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="comment">//for (int i = 1 ; i &lt;= A.sz ; ++ i) cout &lt;&lt; A.fail[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= A.sz ; ++ i) cout &lt;&lt; sz[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= m ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">        scanf("%d%d", &amp;x, &amp;y) ;</span></span><br><span class="line"><span class="comment">        x = A._ed[x], y = A._ed[y] ;</span></span><br><span class="line"><span class="comment">        //cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">        if (dfn[y] &gt;= dfn[x] &amp;&amp; dfn[y] &lt;= dfn[x] + sz[x] - 1)</span></span><br><span class="line"><span class="comment">            printf("%d\n", dep[y] - dep[x] + 1) ; else puts("0") ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y),</span><br><span class="line">        qs[y].push_back(make_pair(x, i)) ;</span><br><span class="line">    do_do(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划/自动机上DP</tag>
        <tag>树上技巧/dfs序+树状数组</tag>
        <tag>字符串/AC自动机</tag>
        <tag>数据结构/树状数组</tag>
        <tag>字符串/失配树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记/题解】AC自动机瞎吹</title>
    <url>/2020/01/17/AC%E8%87%AA%E5%8A%A8%E6%9C%BA1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AC自动机算是自动机系列比较早期引入OI的算法，全称为「$\rm Aho-Corasick ~Automaton$」。</p>
<p>然而其实这款自动机是以两个科学家的名字命名的。（这「款」？</p>
<p>并且上面这一条信息还是我从有道词典里查出来的，百度根本百度不到好吗 QAQ</p>
<p>不过话说这东西也是好久之前学的，于是这篇 blog 实际上是在炒冷饭。</p>
<a id="more"></a>
<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="$1$ 原理"></a>$1$ 原理</h1><p>原理还是很简单的，就是把 KMP 的一半放到了 Trie 上。那找 fail 就肯定要 bfs 了对吧。根据 Trie 的性质，一开始肯定是要把根节点所有非空孩子当作起始状态。大概是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123; </span><br><span class="line">    	<span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]) ; </span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.front() ; q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!tr[now][i]) tr[now][i] = tr[fail[now]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[tr[now][i]] = tr[fail[now]][i], q.push(tr[now][i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑求 $fail$ 的时候，如果没有当前的孩子，执行一个路径压缩。否则直接转移就可以了。</p>
<p>关于 $fail$ 的意义，一个点的 $fail$ 指向是其他模式串和他的最长的公共后缀，并且和这个最长公共后缀必然从根开始，不同于 KMP 的 border 。</p>
<p>大概AC自动机就这点知识吧？</p>
<h1 id="2-水题杀手"><a href="#2-水题杀手" class="headerlink" title="$2$ 水题杀手"></a>$2$ 水题杀手</h1><p>嗯，这个标题很炫酷。</p>
<h2 id="1-LG3808-【模板】AC自动机（简单版）"><a href="#1-LG3808-【模板】AC自动机（简单版）" class="headerlink" title="1 LG3808 【模板】AC自动机（简单版）"></a>1 LG3808 【模板】AC自动机（简单版）</h2><blockquote>
<p>给定 $n$ 个模式串和 $1$ 个文本串，求有多少个模式串在文本串里出现过。</p>
</blockquote>
<p>建 Trie 时记录一下每个串的 $endpos$ 就完了。</p>
<h2 id="2-LG3796-【模板】AC自动机（加强版）"><a href="#2-LG3796-【模板】AC自动机（加强版）" class="headerlink" title="2 LG3796 【模板】AC自动机（加强版）"></a>2 LG3796 【模板】AC自动机（加强版）</h2><blockquote>
<p>有 $\rm N$ 个由小写字母组成的模式串以及一个文本串 $\rm T$。</p>
<p>每个模式串可能会在文本串中出现多次。你需要找出<strong>哪些</strong>模式串在文本串 $\rm T$ 中出现的次数最多。</p>
</blockquote>
<p>嗯，这个其实是个弱化版本。考虑记录最暴力的解法大概就是每匹配到一个点，就不断向上跳 $fail$ 去找有哪些点打上了 $endpos$ 标记，每次匹配的时候不断向上跳，遇到 $endpos$ 就 $ ++$，最后再扫一遍。</p>
<p>当然其实这个地方存在一个剪枝。完全可以记录离现在这个点最近的一个有 $endpos$ 的 $fail$。推的方式跟推 $fail$ 大同小异。</p>
<p>大概可以把 $fail$ 理解为一阶失配指针，$last$ 为二阶的，所以理所应当在一阶上面跑。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) </span><br><span class="line">      <span class="keyword">if</span>(Trie[<span class="number">0</span>][i]) q.push(Trie[<span class="number">0</span>][i]) ; <span class="comment">//1 </span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!v(now)) Trie[now][i] = Trie[fail[now]][i] ;</span><br><span class="line">            <span class="keyword">else</span> fail[v(now)] = Trie[fail[now]][i], q.push(v(now)), </span><br><span class="line">            last[v(now)] = Send[fail[v(now)]] ? fail[v(now)] : last[fail[v(now)]] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-LG5357-【模板】AC自动机（二次加强版）"><a href="#3-LG5357-【模板】AC自动机（二次加强版）" class="headerlink" title="3 LG5357 【模板】AC自动机（二次加强版）"></a>3 LG5357 【模板】AC自动机（二次加强版）</h2><blockquote>
<p>有 $\rm N$ 个由小写字母组成的模式串以及一个文本串 $\rm T$。</p>
<p>每个模式串可能会在文本串中出现多次。你需要找出<strong>哪些</strong>模式串在文本串 $\rm T$ 中出现的次数最多。</p>
</blockquote>
<p>en，好久之前rqy就有讲过这个问题。其实上面那题无论剪不剪枝，最坏复杂度都是 $O(n^2)$ 的，只要这么构造就可以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">aa</span><br><span class="line">aaa</span><br><span class="line">aaaa</span><br><span class="line">........(省略)</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure>
<p>于是考虑这东西似乎正着算不好算，于是考虑倒着计算贡献。发现原来是个 $dp$ 的过程。</p>
<p>大概就是，在AC自动机的fail树上，自己的孩子一定和自己有着相同后缀。所以只需要按照fail边建树，然后算一遍子树大小。之前需要记录对应位置，最后输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXD 60010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXP 201000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2000200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N ; <span class="keyword">char</span> In[MAXP], S[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Hash&#123;</span><br><span class="line">    <span class="keyword">int</span> f[MAXN] ;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull ;</span><br><span class="line">    <span class="built_in">map</span> &lt;ull, <span class="keyword">int</span>&gt; htble ;</span><br><span class="line">    <span class="keyword">const</span> ull base = <span class="number">137</span> ;</span><br><span class="line">    <span class="function">ull <span class="title">get_h</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">strlen</span>(s) ;</span><br><span class="line">        ull ret = (s[<span class="number">0</span>] ^ <span class="number">32768</span>) + <span class="number">3</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)</span><br><span class="line">            ret = ret * base + (ull)s[i] ;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Hash ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, next ;</span><br><span class="line">    &#125;E[MAXP &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> cnt1, head[MAXP] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        E[++ cnt1].to = v, E[cnt1].next = head[u], head[u] = cnt1 ;</span><br><span class="line">        E[++ cnt1].to = u, E[cnt1].next = head[v], head[v] = cnt1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Graph ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt, e[MAXP], last[MAXP], ans ;</span><br><span class="line">    <span class="keyword">int</span> tr[MAXP][<span class="number">27</span>], res[MAXP], Id[MAXP], fail[MAXP] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e)) ;</span><br><span class="line">        <span class="built_in">memset</span>(Id, <span class="number">0</span>, <span class="keyword">sizeof</span>(Id)) ;</span><br><span class="line">        <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(fail)) ;</span><br><span class="line">        <span class="built_in">memset</span>(last, <span class="number">0</span>, <span class="keyword">sizeof</span>(last)) ;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span>(tr)), cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, l = <span class="built_in">strlen</span>(p) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = p[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!tr[rt][now]) </span><br><span class="line">              tr[rt][now] = ++ cnt ;</span><br><span class="line">            rt = tr[rt][now] ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ e[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">idins</span><span class="params">(<span class="keyword">char</span> *p, <span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, l = <span class="built_in">strlen</span>(p) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = p[i] - <span class="string">'a'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!tr[rt][now]) </span><br><span class="line">              tr[rt][now] = ++ cnt ;</span><br><span class="line">            rt = tr[rt][now] ;</span><br><span class="line">        &#125;</span><br><span class="line">        e[rt] = ID, Id[ID] = rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz[MAXN] ;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) </span><br><span class="line">          <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.push(tr[<span class="number">0</span>][i]) ; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">define</span> qwq tr[now][i]</span></span><br><span class="line">            <span class="keyword">int</span> now = q.front() ; q.pop() ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; q.size() &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!qwq) qwq = tr[fail[now]][i] ;</span><br><span class="line">                <span class="keyword">else</span> fail[qwq] = tr[fail[now]][i], q.push(qwq) ;</span><br><span class="line">                <span class="keyword">if</span> (e[fail[qwq]]) last[qwq] = fail[qwq] ;</span><br><span class="line">                <span class="keyword">else</span> last[qwq] = last[fail[qwq]] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">work1</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, ret = <span class="number">0</span>, i, l = <span class="built_in">strlen</span>(p), q ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; l ; ++ i)&#123;</span><br><span class="line">            rt = tr[rt][p[i] - <span class="string">'a'</span>], q = rt ;</span><br><span class="line">            <span class="keyword">while</span> (q &amp;&amp; (~e[q])) </span><br><span class="line">              ret += e[q], e[q] = <span class="number">-1</span>, q = fail[q] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work2</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, ret = <span class="number">0</span>, i, l = <span class="built_in">strlen</span>(p), q ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; l ; ++ i)&#123;</span><br><span class="line">            rt = tr[rt][p[i] - <span class="string">'a'</span>], q = rt ;</span><br><span class="line">            <span class="keyword">while</span> (q) &#123; <span class="keyword">if</span> (e[q]) res[e[q]] ++ ; q = last[q] ; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work3</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>, i, l = <span class="built_in">strlen</span>(p) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; l ; ++ i)</span><br><span class="line">            rt = tr[rt][p[i] - <span class="string">'a'</span>], sz[rt] ++ ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) add(i, fail[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (to(k) == v) <span class="keyword">continue</span> ;</span><br><span class="line">            dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> AC ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, ans ; <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) f[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In) ;</span><br><span class="line">        ull p = get_h(In) ;</span><br><span class="line">        <span class="keyword">if</span> (!htble.count(p))</span><br><span class="line">            idins(In, i), htble[p] = i ;</span><br><span class="line">        <span class="keyword">else</span> f[i] = htble[p] ;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs() ; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S) ; work3(S) ; dfs(<span class="number">0</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sz[Id[f[i]]]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唉，学了好几遍才真正学明白 $fail$ 指针是个什么东西，wtcl</p>
<p>btw，感觉AC自动机如果真要起名的话，叫后缀自动机也可以啊（</p>
<h1 id="4-例题"><a href="#4-例题" class="headerlink" title="$4$ 例题"></a>$4$ 例题</h1><h2 id="rm-POI2000-病毒"><a href="#rm-POI2000-病毒" class="headerlink" title="[$\rm POI2000$] 病毒"></a>[$\rm POI2000$] 病毒</h2><blockquote>
<p>给定一堆 $01$ 串，判断是否有一个无限长的 $01$ 串使得不包含任何一个给出 $01$ 串作为其子串。</p>
</blockquote>
<p> 考虑怎样才能算是无限长的安全代码。</p>
<p>先给出结论：对每个存在病毒代码的状态打上标记。那么如果<strong>完整</strong>的trie图里面存在一个不带标记的圈，就会有无限长的安全代码。此处完整指的是，对于给定一棵trie树，补全他的所有叶子。</p>
<p>可知这是显然的，因为本质上只需要考虑到深度=最长的病毒串长度这一步就ok了，剩下都可以循环生成。</p>
<p>注意到本质上 trie 不用显式地建出来，于是最后 $dfs$ 的时候统计一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fail[MAXS], vis[MAXS], sz ;</span><br><span class="line">    <span class="keyword">int</span> _ed[MAXS], trans[MAXS][<span class="number">2</span>], ans[MAXS] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span> ; N = <span class="built_in">strlen</span>(t + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            t[i] -= <span class="string">'0'</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!trans[rt][t[i]])</span><br><span class="line">                trans[rt][t[i]] = ++ sz ;</span><br><span class="line">            rt = trans[rt][t[i]] ;</span><br><span class="line">        &#125;</span><br><span class="line">        _ed[rt] ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, n ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (trans[<span class="number">0</span>][i]) q.push(trans[<span class="number">0</span>][i]) ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            n = q.front() ; q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">1</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trans[n][i])</span><br><span class="line">                    trans[n][i] = trans[fail[n]][i] ;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fail[trans[n][i]] = trans[fail[n]][i],</span><br><span class="line">                    _ed[trans[n][i]] |= _ed[fail[trans[n][i]]], q.push(trans[n][i]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[x])</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"TAK"</span>), <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (_ed[x] || vis[x]) <span class="keyword">return</span> ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">        vis[x] = ans[x] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">1</span> ; ++ i)</span><br><span class="line">            <span class="comment">//if (trans[x][i]) dfs(trans[x][i]) ;</span></span><br><span class="line">            dfs(trans[x][i]) ;</span><br><span class="line">        ans[x] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>), A.Ins(s) ;</span><br><span class="line">    A.build() ; A.dfs(<span class="number">0</span>) ; <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NIE"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到代码中 $dfs$ 里面注释的一行，显然是错的，可以被：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>这组数据直接给卡掉。但是数据太水就给过掉了…</p>
<p>…说实在的我本来想尝试去证明为什么那样错的写是对的，尝试努力去编出一个合理解释，到最后才发现是自己原来的 $code$ 错了QAQ</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>动态规划/自动机上DP</tag>
        <tag>字符串/AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】整体二分泛做</title>
    <url>/2020/01/17/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>说是泛做其实就是多做了三道题？</p>
<p>博文内容的水分日渐增多.jpeg</p>
<a id="more"></a>
<h1 id="1-LG1527-国家集训队-矩阵乘法"><a href="#1-LG1527-国家集训队-矩阵乘法" class="headerlink" title="$1$ LG1527 [国家集训队]矩阵乘法"></a>$1$ LG1527 [国家集训队]矩阵乘法</h1><blockquote>
<p>给你一个 $N\times N$ 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 $K$ 小数。</p>
</blockquote>
<p>把BIT换成二维的就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, l, r, z ;</span><br><span class="line">&#125;q[MAXM], lq[MAXM], rq[MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> ans[MAXQ], _bit[MAXN][MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = p ; i &lt;= N ; i += low(i))</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> j = q ; j &lt;= N ; j += low(j))</span><br><span class="line">            _bit[i][j] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = p ; i ; i -= low(i))</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> j = q ; j ; j -= low(j))</span><br><span class="line">            ret += _bit[i][j] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vl ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    rg <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].z &lt;= vmid)</span><br><span class="line">                upd(q[i].x, q[i].y, <span class="number">1</span>), lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> res = ask(q[i].l, q[i].r) ;</span><br><span class="line">            res -= ask(q[i].x - <span class="number">1</span>, q[i].r) ;</span><br><span class="line">            res -= ask(q[i].l, q[i].y - <span class="number">1</span>) ;</span><br><span class="line">            res += ask(q[i].x - <span class="number">1</span>, q[i].y - <span class="number">1</span>) ;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op &amp;&amp; q[i].z &lt;= vmid)</span><br><span class="line">            upd(q[i].x, q[i].y, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">int</span> n, x, y, l, r, k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            q[++ cnt].op = <span class="number">0</span>, q[cnt].x = i,</span><br><span class="line">            q[cnt].y = j, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[cnt].z) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        ++ cnt, <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;q[cnt].x, &amp;q[cnt].y) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;q[cnt].l, &amp;q[cnt].r, &amp;q[cnt].z), q[cnt].op = i ;</span><br><span class="line">    &#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; q[i].x &lt;&lt; " " &lt;&lt; q[i].y &lt;&lt; " " &lt;&lt; q[i].l &lt;&lt; " " &lt;&lt; q[i].r &lt;&lt; " " &lt;&lt; q[i].z &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; cnt &lt;&lt; endl ;</span></span><br><span class="line">    solve(<span class="number">0</span>, Inf, <span class="number">1</span>, cnt) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-LG4175-CTSC2008-网络管理"><a href="#2-LG4175-CTSC2008-网络管理" class="headerlink" title="$2$ LG4175 [CTSC2008]网络管理"></a>$2$ LG4175 [CTSC2008]网络管理</h1><blockquote>
<p>给定一棵树，每次或者修改一个点的点权，或者查询两点之间的第 $k$ 大点权。</p>
</blockquote>
<p>这东西是真的丧心病狂嗷233</p>
<p>发现写个树剖就变成傻题了。最终 $\log ^3$ 能过 $10^5$ 可能是医学奇迹叭。</p>
<p>贴个代码记录一下此时美好心情（毕竟写的很长.jpg</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">100000001</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> o[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, z ;</span><br><span class="line">&#125;q[MAXN], lq[MAXN], rq[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], ans[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Mary&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> to, next ;</span><br><span class="line">    &#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line">    <span class="keyword">int</span> Id[MAXN], dfn[MAXN], top[MAXN], tot ;</span><br><span class="line">    <span class="keyword">int</span> dep[MAXN], sz[MAXN], faa[MAXN], son[MAXN] ;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line">    <span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v)</span></span>&#123;</span><br><span class="line">        to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">        to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">        faa[u] = fa ;</span><br><span class="line">        sz[u] = <span class="number">1</span>, dep[u] = dep[fa] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">            <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">            dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">            <span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[to(k)]) son[u] = to(k) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> _top)</span></span>&#123;</span><br><span class="line">        top[u] = _top, dfn[u] = ++ tot ;</span><br><span class="line">        <span class="keyword">if</span> (son[u]) dfs(son[u], u, _top) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, to(k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> uv)</span></span>&#123;</span><br><span class="line">        rg <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> s[rt] += uv, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, p, uv) ;</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, uv) ;</span><br><span class="line">        s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">        rg <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; rg <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[u]] &lt; dep[top[v]]) swap(u, v) ;</span><br><span class="line">            ret += query(<span class="number">1</span>, <span class="number">1</span>, N, dfn[top[u]], dfn[u]), u = faa[top[u]] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[u] &gt; dfn[v]) swap(u, v) ;</span><br><span class="line">        ret += query(<span class="number">1</span>, <span class="number">1</span>, N, dfn[u], dfn[v]) ; <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Mary ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vr ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    rg <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &gt; vmid)</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, N, dfn[q[i].x], <span class="number">1</span>), rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &gt; vmid)</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, N, dfn[q[i].x], <span class="number">-1</span>), rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rg <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">            res = Query(q[i].x, q[i].y) ;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">-1</span> &amp;&amp; q[i].y &gt; vmid)</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, N, dfn[q[i].x], <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">-2</span> &amp;&amp; q[i].y &gt; vmid)</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, N, dfn[q[i].x], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, k, u, v ;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v, Mary :: add(u, v) ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    Mary :: dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    Mary :: dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), cnt = <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        q[++ cnt].y = base[i],</span><br><span class="line">        q[cnt].x = i, q[cnt].op = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">        <span class="keyword">if</span> (k)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r,</span><br><span class="line">            q[++ cnt].op = i, o[i] = <span class="number">1</span>,</span><br><span class="line">            q[cnt].x = l, q[cnt].y = r, q[cnt].z = k ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r ;</span><br><span class="line">            q[++ cnt].y = base[l],</span><br><span class="line">            q[cnt].x = l, q[cnt].op = <span class="number">-2</span> ;</span><br><span class="line">            q[++ cnt].y = (base[l] = r),</span><br><span class="line">            q[cnt].x = l, q[cnt].op = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    solve(<span class="number">0</span>, Inf, <span class="number">1</span>, cnt) ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!o[i]) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!ans[i])</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid request!"</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 23333 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-POI2011-Meteors"><a href="#3-POI2011-Meteors" class="headerlink" title="$3$ [POI2011] Meteors"></a>$3$ [POI2011] Meteors</h1><blockquote>
<p>给定一个环，每个节点有一个所属国家，$k$ 次事件，每次对 $[l,r]$ 区间上的每个点点权加上一个值，求每个国家最早多少次操作之后所有点的点权和能达到一个值。</p>
</blockquote>
<p>据蒋神说有 $1\log$ 的写法，然而并不想去学，等抽个空补上吧（</p>
<p>还是整体二分，二分时间。怎么说呢，这道题比之前做的题要灵活一点。考虑二分时间本质上就是在二分操作，所以只需要执行 $[vl,vmid]$ 内的操作就可以了。发现这样需要分治的是国家，查询的话拿一个vector+BIT差分维护一下即可。</p>
<p>感觉…就是还欠火候。明明每一部分都了解得一清二楚，明明每一部分都知道该怎么写，但是却串接不起来…wtcl</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">191981000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; _be[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">met</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, v, id ;</span><br><span class="line">&#125;q[N] ; <span class="keyword">int</span> t[N], lt[N], rt[N] ;</span><br><span class="line"><span class="keyword">int</span> n, m, k, s[N], b[N], _bit[N &lt;&lt; <span class="number">1</span>], ans[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= <span class="number">2</span> * m ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ; <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; _be[p].size() ; ++ i)&#123;</span><br><span class="line">        ret += ask(_be[p][i]) + ask(_be[p][i] + m) ;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= s[p]) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            ans[t[i]] = vl ; <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vr + vl) &gt;&gt; <span class="number">1</span>, fl = <span class="number">0</span>, fr = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vl ; i &lt;= vmid ; ++ i)</span><br><span class="line">        upd(q[i].l, q[i].v), upd(q[i].r + <span class="number">1</span>, -q[i].v) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = query(t[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= s[t[i]]) lt[++ fl] = t[i] ;</span><br><span class="line">        <span class="keyword">else</span> s[t[i]] -= res, rt[++ fr] = t[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vl ; i &lt;= vmid ; ++ i)</span><br><span class="line">        upd(q[i].l, -q[i].v), upd(q[i].r + <span class="number">1</span>, q[i].v) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= fl ; ++ i) t[i + l - <span class="number">1</span>] = lt[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= fr ; ++ i) t[i + l + fl - <span class="number">1</span>] = rt[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + fl - <span class="number">1</span>) ; solve(vmid + <span class="number">1</span>, vr, l + fl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;b[i]), _be[b[i]].pb(i) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) t[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;s[i]) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= k ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].v),</span><br><span class="line">        q[i].r += (q[i].l &gt; q[i].r) ? m : <span class="number">0</span>, q[i].id = i ;</span><br><span class="line">    q[++ k].l = <span class="number">1</span>, q[k].r = <span class="number">2</span> * m, q[k].id = k, q[k].v = Inf ;</span><br><span class="line">    solve(<span class="number">1</span>, k, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == k) <span class="built_in">puts</span>(<span class="string">"NIE"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>离线算法/整体二分</tag>
        <tag>数据结构/线段树</tag>
        <tag>数据结构/数据结构方法/轻重链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】整体二分</title>
    <url>/2020/01/16/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哇，一直想学整体二分诶，终于学会了233</p>
<p>十分感谢李煜东的蓝书！感觉从网上找讲解，一直看不明白呢…</p>
<a id="more"></a> 
<p>整体二分，其实本质上跟线段树上二分、splay上二分很相似。是对值域的整体分治。</p>
<p>首先考虑一个简单的问题，如何求解整个序列的第 $k$ 大。有这么一种二分的方法。最开始取一个 $L=1$，一个 $R=\rm MAX$。如果当前 $L\sim mid$ 的数字个数不足 $k$ 个，那么令 $k$ 减去这些数量，并将 $mid+1$ 作为新的 $L$ 继续二分。可以证明这样做也是 $\log$ 的。</p>
<p>为什么要说这种方法？本质上，求出整个序列的第 $k$ 大二分方法有很多，比如你可以直接二分答案。但实际上，只有上述二分方式具有较强的<strong>可分治性</strong>，每次可以直接舍弃掉 $[L,mid]$ 的全部内容，每次问题规模都小一半；但显然直接去二分第 $k$ 大不具备这个性质。</p>
<p>所以从这个例子中，或许可以得出一些启发性的分治方式。</p>
<h1 id="rm-Part1-简述整体二分"><a href="#rm-Part1-简述整体二分" class="headerlink" title="$\rm Part1$ 简述整体二分"></a>$\rm Part1$ 简述整体二分</h1><p>考虑现在给定一个序列有 $n$ 个数，$m$ 组询问。每次询问一个区间的第 $k$ 小的数。 可以离线</p>
<p>考虑首先离散化，并且把序列中一开始给出的数当作插入操作。然后：</p>
<ul>
<li>1、每次二分，在把答案分治掉的同时，需要对整个序列的元素也分治。所以需要对整个序列进行重排，很简单地 $double-l$ 扫一遍再合并就可以了。</li>
<li>2、考虑采用上方说的方法去处理插入和询问。对于一个插入操作，如果插入的数值 $&lt;$ 当前二分的值域的 $mid$，那么就直接插入BIT并且放到前一半，否则放到后一半不管；对于一个询问，可以用树状数组求出现在区间 $[ql,  qr]$ 内有多少被插入过的数——根据上文讨论得到的解法，考虑如果 $qk$ 比当前值大，说明之前还有比当前值域的 $mid$ 大的数没有被插入，所以把当前的询问减去当前的 $res$ 后放到后一半；否则什么都不处理，放到前一半。</li>
<li>3、考虑这么做的正确性。发现插入操作一定在询问操作之前，所以不需要担心询问扑空；同时发现对于一个单独的询问，实际上就是进行了上文中类似全局二分的操作。</li>
<li>4、每次用完BIT要清零。</li>
<li>5、s发现每次值域规模、元素规模均减半。于是最后复杂度就是 $O(m\log^2 n)$。而如果一开始不离散化，复杂度就会变成 $O(m\log \mathrm{SIZE}\log n)$ 。值得注意的是，不离散化也根本不需要担心空间会挂，因为在分治整个值域的时候，把值域作为分治轴可以使得只用下标就可以计算出贡献。</li>
</ul>
<p>然后以下是 <code>LG3834【模板】可持久化线段树1 (主席树)</code>，裸的区间 $k$ 小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 400010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, z ;</span><br><span class="line">&#125;q[MAXN], lq[MAXN], rq[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> ans[MAXN], _bit[MAXN], t[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= N ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vl ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &lt;= vmid)</span><br><span class="line">                upd(q[i].x, <span class="number">1</span>), lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> res = ask(q[i].y) - ask(q[i].x - <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; " " &lt;&lt; bl &lt;&lt; " " &lt;&lt; br &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op &amp;&amp; q[i].y &lt;= vmid) upd(q[i].x, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">int</span> n, val, l, r, k ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), t[i] = base[i] ;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + N + <span class="number">1</span>) ;</span><br><span class="line">    n = unique(t + <span class="number">1</span>, t + N + <span class="number">1</span>) - t - <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// for (int i = 1 ; i &lt;= n ; ++ i) cout &lt;&lt; t[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        val = lower_bound(t + <span class="number">1</span>, t + n + <span class="number">1</span>, base[i]) - t ;</span><br><span class="line">        ++ cnt, q[cnt].op = <span class="number">0</span>, q[cnt].x = i, q[cnt].y = val ;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; q[cnt].y &lt;&lt; endl ; </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k), ++ cnt ;</span><br><span class="line">        q[cnt].op = i, q[cnt].x = l, q[cnt].y = r, q[cnt].z = k ;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">0</span>, N * <span class="number">2</span>, <span class="number">1</span>, cnt) ;</span><br><span class="line">    <span class="comment">// for (int i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; ans[i] &lt;&lt; endl ;  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t[ ans[i] ]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Part2-如何处理简单带修"><a href="#rm-Part2-如何处理简单带修" class="headerlink" title="$\rm Part2$ 如何处理简单带修"></a>$\rm Part2$ 如何处理简单带修</h1><p>发现其实每个带修操作都是单点覆盖的话，可以拆成一个插入一个删除，而删除操作是BIT可维护的。</p>
<p>以下是 <code>bzoj#1901 Dynamic Rankings</code> ，裸的区间 $k$ 小+单点替换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1000000009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> low(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y, z ;</span><br><span class="line">&#125;q[MAXN], lq[MAXN], rq[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], _bit[MAXN], ans[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; p &lt;= N ; p += low(p)) _bit[p] += x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; p ; p -= low(p)) ret += _bit[p] ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vr ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &lt;= vmid)</span><br><span class="line">                upd(q[i].x, <span class="number">1</span>), lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].y &lt;= vmid)</span><br><span class="line">                upd(q[i].x, <span class="number">-1</span>), lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> res ;</span><br><span class="line">            res = ask(q[i].y) - ask(q[i].x - <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) lq[++ bl] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, rq[++ br] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">-1</span> &amp;&amp; q[i].y &lt;= vmid) upd(q[i].x, <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">-2</span> &amp;&amp; q[i].y &lt;= vmid) upd(q[i].x, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, k ;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        q[++ cnt].y = base[i],</span><br><span class="line">        q[cnt].x = i, q[cnt].op = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; (c + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (c[<span class="number">1</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k, q[++ cnt].op = i,</span><br><span class="line">            q[cnt].x = l, q[cnt].y = r, q[cnt].z = k ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; k ;</span><br><span class="line">            q[++ cnt].y = base[l],</span><br><span class="line">            q[cnt].x = l, q[cnt].op = <span class="number">-2</span> ;</span><br><span class="line">            q[++ cnt].y = (base[l] = k),</span><br><span class="line">            q[cnt].x = l, q[cnt].op = <span class="number">-1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(-Inf, Inf, <span class="number">1</span>, cnt) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &gt;= <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Part3-一道拓展"><a href="#rm-Part3-一道拓展" class="headerlink" title="$\rm Part3$ 一道拓展"></a>$\rm Part3$ 一道拓展</h1><blockquote>
<p>你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$。<br>这些集合初始都是空集，有 $m$ 个操作：</p>
<p><code>1 l r c</code>：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中<br><code>2 l r c</code>： 表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。</p>
</blockquote>
<p>发现这东西本质上就是把单点插入变成了区间插入，所以拿线段树维护一下区间和即可。并且由于查询 $K$ 大，原来的二分方式需要对称一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, x, y ; LL z ;</span><br><span class="line">&#125;q[MAXN], lq[MAXN], rq[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], ans[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line">LL s[MAXN &lt;&lt; <span class="number">2</span>], cov[MAXN &lt;&lt; <span class="number">2</span>], tag[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line">il <span class="keyword">void</span> _up(<span class="keyword">int</span> rt)&#123; s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ; &#125;</span><br><span class="line">il <span class="keyword">void</span> _down(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (cov[rt])&#123;</span><br><span class="line">        tag[rt &lt;&lt; <span class="number">1</span>] = s[rt &lt;&lt; <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        cov[rt &lt;&lt; <span class="number">1</span>] = cov[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = <span class="number">1</span>, cov[rt] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tag[rt])&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        tag[rt &lt;&lt; <span class="number">1</span>] += tag[rt] ;</span><br><span class="line">        tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[rt] ;</span><br><span class="line">        s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += <span class="number">1l</span>l * (r - mid) * tag[rt] ;</span><br><span class="line">        s[rt &lt;&lt; <span class="number">1</span>] += <span class="number">1l</span>l * (mid - l + <span class="number">1</span>) * tag[rt] ;</span><br><span class="line">        tag[rt] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)</span><br><span class="line">        <span class="keyword">return</span> tag[rt] += v,</span><br><span class="line">               s[rt] += v * (r - l + <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, v) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, v) ;</span><br><span class="line">    _up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; LL res = <span class="number">0</span> ; _down(rt, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid) res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> vl, <span class="keyword">int</span> vr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (vl == vr)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i].op &gt; <span class="number">0</span>) ans[q[i].op] = vr ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    cov[<span class="number">1</span>] = <span class="number">1</span>, tag[<span class="number">1</span>] = s[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> vmid = (vl + vr) &gt;&gt; <span class="number">1</span>, bl = <span class="number">0</span>, br = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q[i].op)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].z &gt; vmid)</span><br><span class="line">                update(<span class="number">1</span>, <span class="number">1</span>, N, q[i].x, q[i].y, <span class="number">1</span>), rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            LL res ;</span><br><span class="line">            res = query(<span class="number">1</span>, <span class="number">1</span>, N, q[i].x, q[i].y) ;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= q[i].z) rq[++ br] = q[i] ;</span><br><span class="line">            <span class="keyword">else</span> q[i].z -= res, lq[++ bl] = q[i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= bl ; ++ i) q[l + i - <span class="number">1</span>] = lq[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= br ; ++ i) q[l + bl + i - <span class="number">1</span>] = rq[i] ;</span><br><span class="line">    solve(vl, vmid, l, l + bl - <span class="number">1</span>), solve(vmid + <span class="number">1</span>, vr, l + bl, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL op, l, r, k ;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q[i].op &gt;&gt; q[i].x &gt;&gt; q[i].y &gt;&gt; q[i].z ;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">1</span>) q[i].op = <span class="number">0</span> ; <span class="keyword">else</span> q[i].op = ++ cnt ;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(-N, N, <span class="number">1</span>, M) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>整体二分</category>
      </categories>
      <tags>
        <tag>数据结构/树状数组</tag>
        <tag>离线算法/整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】bzoj#4044 [CERC2014]Virus Synthesis</title>
    <url>/2020/01/16/CERC2014-Virus-synthesis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>初始有一个空串，利用下面的操作构造给定串 $\rm S$ 。</p>
<p>1、串开头或末尾加一个字符</p>
<p>2、串开头或末尾加一个该串的逆串</p>
<p>求最小化操作数， $\rm |S| \leq 10^5$。</p>
</blockquote>
<p>dp是不可能会的，这辈子都不会了QAQ</p>
<a id="more"></a>
<p>首先预处理处上一篇 $blog$ 里的 $fail$ 和 $fail’$。</p>
<p>然后开始<del>不会</del>dp。发现对于PAM里每个状态 $x$，都可以由 $fail’(x)$ 推出。原因是 $fail’(x)$ 作为半失配指针（名字自己起的233），正好满足复制一遍的需求。于是考虑转移：</p>
<script type="math/tex; mode=display">
f_u=\min(f_{pre_u}+1,f_{fail'(u)}+(\frac{len_u}{2} - len_{fail'(u)}+1))</script><p>前半部分由于我们可以把加一个字符放到前面去执行，所以可以 $+1$ 而不用 $+2$ 。 后半部分由于半失配指针的最优性可以直接转移。</p>
<p>这样就做完了，考虑最后一定是一个长回文串加上一堆下脚料（原因是题目要求不能多串一起生成，只能维护一个回文串，所以不能把两个回文串拼起来之类的）。所以维护答案也很好维护。</p>
<p>按秩转移的话，bfs一遍就完了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="keyword">int</span> N, C, ans, dp[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">300</span>], vis[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> rt0, rt1, sz, last, f[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> trans[MAXN][<span class="number">4</span>], fail[MAXN], len[MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sz = <span class="number">-1</span> ;</span><br><span class="line">        val[<span class="string">'A'</span>] = <span class="number">0</span>, val[<span class="string">'C'</span>] = <span class="number">1</span>,</span><br><span class="line">        val[<span class="string">'G'</span>] = <span class="number">2</span>, val[<span class="string">'T'</span>] = <span class="number">3</span> ;</span><br><span class="line">        rt0 = ++ sz, rt1 = ++ sz ;</span><br><span class="line">        len[rt0] = <span class="number">0</span>, len[rt1] = <span class="number">-1</span> ;</span><br><span class="line">        fail[last = rt0] = fail[rt1] = rt1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, q, np, nq ;</span><br><span class="line">        <span class="keyword">while</span> (S[pos] != S[pos - len[p] - <span class="number">1</span>]) p = fail[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!trans[p][x])&#123;</span><br><span class="line">            np = ++ sz, q = fail[p] ;</span><br><span class="line">            <span class="keyword">while</span> (S[pos] != S[pos - len[q] - <span class="number">1</span>]) q = fail[q] ;</span><br><span class="line">            len[np] = len[p] + <span class="number">2</span>, fail[np] = trans[q][x], trans[p][x] = np ;</span><br><span class="line">            nq = f[p] ; <span class="keyword">if</span> (len[np] &lt;= <span class="number">2</span>) f[np] = fail[np] ;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (S[pos] != S[pos - len[nq] - <span class="number">1</span>] || len[nq] + <span class="number">2</span> &gt; (len[np] &gt;&gt; <span class="number">1</span>))</span><br><span class="line">                nq = fail[nq] ; f[np] = trans[nq][x] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = trans[p][x] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>, ans = N, q.push(<span class="number">0</span>), vis[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front() ; q.pop() ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">3</span> ; ++ i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!trans[x][i]) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">int</span> y = trans[x][i] ; dp[y] = dp[x] + <span class="number">1</span> ;</span><br><span class="line">                dp[y] = min(dp[y], dp[f[y]] + len[y] / <span class="number">2</span> - len[f[y]] + <span class="number">1</span>) ;</span><br><span class="line">                ans = min(ans, dp[y] + N - len[y]) ; <span class="keyword">if</span> (!vis[y]) q.push(y), vis[y] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= sz ; ++ i) vis[i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;T ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; C ;</span><br><span class="line">    <span class="keyword">while</span> (C --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>),</span><br><span class="line">        N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), T.Init() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            T.Ins(T.val[(<span class="keyword">int</span>)S[i]], i) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= T.sz ; ++ i) dp[i] = T.len[i] ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; T.sz &lt;&lt; endl ;</span></span><br><span class="line">        T.bfs() ; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= T.sz ; ++ i) </span><br><span class="line">          <span class="built_in">memset</span>(T.trans[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(T.trans[i])) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dpdpdpdpdpdpdpdpdpdp不会不会不会不会好烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦烦啊QAQ</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>动态规划/自动机上DP</tag>
        <tag>字符串/PAM,回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】loj#2579[SHOI2011]双倍回文</title>
    <url>/2020/01/16/SHOI2011-%E5%8F%8C%E5%80%8D%E5%9B%9E%E6%96%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一道PAM思维题…</p>
<p>像我这种只会写板子、莫得脑子的选手注定要挨打啊/kk</p>
<p>题面简述：</p>
<blockquote>
<p>给定一个串 $\rm S$，求该串最长的「双倍回文子串」。「双倍回文」指的是这么一种子串：自身回文，且前半部分、后半部分均回文。</p>
<p>$\rm |S|\leq 10^6$</p>
</blockquote>
<a id="more"></a>
<p>考虑PAM。但发现似乎不是很好做，因为每次转移是像串的两端各加一个字符，有点gg。但是仔细思考就会发现，PAM的 $fail$ 实际指向的是最长的回文后缀，而我们的所求也是这么一个回文后缀的形式，只不过限制了长度。</p>
<p>所以考虑求PAM的时候顺便维护另一个 $fail’$，其意义是「不超过当前串长一半的回文后缀」。</p>
<p>思考原来PAM的构造方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _insert(PAM &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> pos, <span class="keyword">char</span> *s)&#123;</span><br><span class="line">	<span class="keyword">int</span> u = p.last ; </span><br><span class="line">	<span class="keyword">while</span> (s[pos - p.len[u] - <span class="number">1</span>] != s[pos]) u = p.fail[u] ; </span><br><span class="line">	<span class="keyword">if</span> (!p.trie[u][x])&#123;</span><br><span class="line">		<span class="keyword">int</span> fa = p.fail[u] ;</span><br><span class="line">		<span class="keyword">int</span> newn = ++ p.sz ; </span><br><span class="line">		p.len[newn] = p.len[u] + <span class="number">2</span> ; </span><br><span class="line">		<span class="keyword">while</span> (s[pos - p.len[fa] - <span class="number">1</span>] != s[pos]) fa = p.fail[fa] ; </span><br><span class="line">		p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn ;</span><br><span class="line">	&#125;</span><br><span class="line">	p.last = p.trie[u][x] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以类推出新的构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, q, np, nq ;</span><br><span class="line">        <span class="keyword">while</span> (S[pos] != S[pos - len[p] - <span class="number">1</span>]) p = fail[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!trans[p][x])&#123;</span><br><span class="line">            np = ++ sz, q = fail[p] ;</span><br><span class="line">            <span class="keyword">while</span> (S[pos] != S[pos - len[q] - <span class="number">1</span>]) q = fail[q] ;</span><br><span class="line">            len[np] = len[p] + <span class="number">2</span>, fail[np] = trans[q][x], trans[p][x] = np ;</span><br><span class="line">            nq = f[p] ; <span class="keyword">if</span> (len[np] &lt;= <span class="number">2</span>) f[np] = fail[np] ;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (S[pos] != S[pos - len[nq] - <span class="number">1</span>] || len[nq] + <span class="number">2</span> &gt; (len[np] &gt;&gt; <span class="number">1</span>))</span><br><span class="line">                nq = fail[nq] ; f[np] = trans[nq][x] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = trans[p][x] ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这东西唯一的不同就是多了一个找 $fail’$ 的过程。首先如果当前的 $\rm len\leq 2$ 那么就应该是 $fail$（毕竟都是1个字母）  ，否则就向上跳着找。</p>
<p>复杂度证明：因跳跳 $fail$ 的复杂度是对的所以跳 $fail’$ 也是对的（雾</p>
<p>值得注意的是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (S[pos] != S[pos - len[nq] - <span class="number">1</span>] || len[nq] + <span class="number">2</span> &gt; (len[np] &gt;&gt; <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>这一句里第二个判断很容易写错。因为实际上我们跳的 $fail$ 是未扩展之前的，这一点从 <code>S[pos] != S[pos - len[nq] - 1]</code> 这一句就可以明显地看出来。所以如果要比较的话，应该 $+2$ 之后再比较。</p>
<p>于是为了水字数贴个代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; (S + <span class="number">1</span>) ; P.Init() ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) P.Ins(S[i] - <span class="string">'a'</span> + <span class="number">1</span>, i) ;</span><br><span class="line"><span class="comment">//    for (i = 1 ; i &lt;= P.sz ; ++ i) cout &lt;&lt; P.len[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= P.sz ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (P.len[i] == (P.len[P.f[i]] &lt;&lt; <span class="number">1</span>) &amp;&amp; (P.len[i] % <span class="number">4</span> == <span class="number">0</span>))</span><br><span class="line">            ans = max(ans, P.len[i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实本质上也不算一道难题，对吧？</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>字符串/PAM,回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习/出题笔记】失配树瞎吹</title>
    <url>/2020/01/16/%E5%A4%B1%E9%85%8D%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原因是做 <code>[POI2005]SZA-Template</code> 这题时新学了fail树，觉得很神的亚子233.</p>
<p>其实本质上就是对于每个前缀 $i$ ，向 $\mathrm{fail}_i$ 连一条边，可以知道这样连出来的一定是一棵 $root$ 为 $0$ 的树。</p>
<a id="more"></a>
<h1 id="1-LG5829-【模板】失配树"><a href="#1-LG5829-【模板】失配树" class="headerlink" title="$1$ LG5829 【模板】失配树"></a>$1$ LG5829 【模板】失配树</h1><p>当当当当！是我出的题啦~</p>
<blockquote>
<p>给定一个字符串 $s$，定义它的 <strong>$k$ 前缀</strong> $pre_k$ 为字符串 $s_{1\dots k}$，<strong>$k$ 后缀</strong> $suf_k$ 为字符串 $s_{|s|-k+1\dots |s|}$，其中 $1 \le k \le |s|$。</p>
<p>定义 $\boldsymbol{Border}(s)$ 为<strong>对于 $i \in [1, |s|)$，满足 $pre_i = suf_i$</strong> 的字符串 $pre_i$ 的集合。$\boldsymbol{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\operatorname{border}$。</p>
<p>有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 <strong>$\boldsymbol{p}$ 前缀</strong> 和 <strong>$\boldsymbol{q}$ 前缀</strong> 的 <strong>最长公共 $\operatorname{border}$</strong>  的长度。</p>
</blockquote>
<p>发现其实，怎么说呢，从根到某个点的路上的所有点，一定都是它的 $border$。所以就变成了 $lca$ 傻题。然而因为 $border$ 定义的时候不包含整个串，于是再判一下一个是不是另一个 $border$ 即可。</p>
<p>咋说呢，「判断一个点在不在另一个点的子树中」，接到这个问题我居然愣了几秒才想起用 $dfs$ 序搞，wtcl。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> freopen(a, b, c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next(k) E[k].next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IPT &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1000000</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[L], *front=buf, *end=buf;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">GetChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == end) &#123;</span><br><span class="line">      end = buf + fread(front = buf, <span class="number">1</span>, L, <span class="built_in">stdin</span>);</span><br><span class="line">      <span class="keyword">if</span> (front == end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(front++);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qr</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> ch = IPT::GetChar(), lst = <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">while</span> ((ch &gt; <span class="string">'9'</span>) || (ch &lt; <span class="string">'0'</span>)) lst = ch, ch=IPT::GetChar();</span><br><span class="line">  <span class="keyword">while</span> ((ch &gt;= <span class="string">'0'</span>) &amp;&amp; (ch &lt;= <span class="string">'9'</span>)) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = IPT::GetChar();</span><br><span class="line">  <span class="keyword">if</span> (lst == <span class="string">'-'</span>) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPT &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">120</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qw</span><span class="params">(T x, <span class="keyword">const</span> <span class="keyword">char</span> aft, <span class="keyword">const</span> <span class="keyword">bool</span> pt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>);&#125;</span><br><span class="line">  <span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;OPT::buf[++top] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(x % <span class="number">10</span> + <span class="string">'0'</span>);&#125; <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> (top) <span class="built_in">putchar</span>(OPT::buf[top--]);</span><br><span class="line">  <span class="keyword">if</span> (pt) <span class="built_in">putchar</span>(aft);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadStr</span><span class="params">(<span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> beg = p;</span><br><span class="line">  <span class="keyword">do</span> *(++p) = IPT::GetChar(); <span class="keyword">while</span> ((*p &gt;= <span class="string">'a'</span>) &amp;&amp; (*p &lt;= <span class="string">'z'</span>));</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> p - beg - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">char</span> S[MAXN] ; <span class="keyword">int</span> fa[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], dfn[MAXN], son[MAXN], cnt, tot ;</span><br><span class="line"><span class="keyword">int</span> H, N, M, dep[MAXN], fail[MAXN], sz[MAXN], top[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dep[u] = dep[fa[u]] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        fa[to(k)] = u, dfs(to(k)), sz[u] += sz[to(k)] ;</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    top[u] = tp, dfn[u] = ++ tot ;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs2(son[u], tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != son[u]) dfs2(to(k), to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// qw(u, '\n', true), qw(v, '\n', true) ;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[u]] &gt;= dep[top[v]]) u = fa[top[u]] ;</span><br><span class="line">        <span class="keyword">else</span> v = fa[top[v]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span> ;</span><br><span class="line">    N = ReadStr(S), qr(M) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; S[j + <span class="number">1</span>] != S[i]) j = fail[j] ;</span><br><span class="line">        <span class="keyword">if</span> (S[j + <span class="number">1</span>] == S[i]) fail[i] = ++ j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) add(fail[i], i) ;</span><br><span class="line">    dfs(<span class="number">0</span>) ; dfs2(<span class="number">0</span>, <span class="number">0</span>) ; <span class="keyword">int</span> p, q ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        p = <span class="number">0</span>, q = <span class="number">0</span>, qr(p), qr(q) ;</span><br><span class="line">        <span class="keyword">int</span> ans = lca(p, q) ;</span><br><span class="line">        <span class="keyword">if</span> (dep[p] &gt; dep[q]) swap(p, q) ;</span><br><span class="line">        <span class="keyword">if</span> (dfn[q] &gt;= dfn[p] &amp;&amp; dfn[q] &lt;= dfn[p] + sz[p] - <span class="number">1</span>) ans = fa[ans] ;</span><br><span class="line">        qw(ans, <span class="string">'\n'</span>, <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>长长的 <code>Read</code> 是嫖的zay的233，放到这里算是纪念一下他帮我验题吧！</p>
<h1 id="2-NOI2014-动物园"><a href="#2-NOI2014-动物园" class="headerlink" title="$2$ [NOI2014] 动物园"></a>$2$ [NOI2014] 动物园</h1><blockquote>
<p>定义 $num[i]$ 为字符串 $S$ 的前缀 $S[1\sim i]$ 中不重叠的相同前后缀的个数。给定 $S$，求所有 $(num[i]+1)$ 的乘积。$L\leq 10^6$</p>
</blockquote>
<p>发现其实就是 $fail$ 树上，这个点到根的路径上所有 $\leq \frac{L_{now}}{2}$ 的点的编号和。</p>
<p>这东西，那不是随便做？你可以随便上莫队，但是显然过不去；你可以直接剖，可能也不太过得去…不过发现，既然维护一个点到根的信息，那可以直接用栈维护链+dfs=稳得很。所以一眼肯定是二分，不过需要带个 $\log$。</p>
<p>这个地方有一个很nb的trick，可以做到 $O(n)$。根据「二分有可能可以two-pointers」的经典理论，发现随着深度递增，栈内可行的点不降。于是用栈去更新子树信息即可。复杂度 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    (ans *= <span class="number">1l</span>l * (res + <span class="number">1</span>)) %= Mod ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x], r ; k ; k = next(k))&#123;</span><br><span class="line">        stk[++ tp] = to(k), r = res ;</span><br><span class="line">        <span class="keyword">while</span> (stk[res + <span class="number">1</span>] * <span class="number">2</span> &lt;= to(k)) ++ res ;</span><br><span class="line">        dfs(to(k)) ; stk[tp --] = <span class="number">0</span>, res = r ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span>(fail)) ;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; S[j + <span class="number">1</span>] != S[i]) j = fail[j] ;</span><br><span class="line">            <span class="keyword">if</span> (S[j + <span class="number">1</span>] == S[i]) fail[i] = ++ j ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) add(fail[i], i) ;</span><br><span class="line">        ans = <span class="number">1</span>, res = <span class="number">0</span>, dfs(<span class="number">0</span>) ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-POI2005-SZA-Template"><a href="#3-POI2005-SZA-Template" class="headerlink" title="$3$ [POI2005] SZA-Template"></a>$3$ [POI2005] SZA-Template</h1><blockquote>
<p>给定一个串，求一个最小的长度，使得该长度的前缀可以通过循环覆盖覆盖整个串。同一个位置的字符可以覆盖多次。比如 <code>ababa</code> 就可以被 <code>aba</code> 覆盖掉。</p>
<p>$L\leq 10^6$</p>
</blockquote>
<p>很神的一道题233</p>
<p>考虑先建出 $fail$ 树来，那么可能成为答案的一定是 $0\sim n$ 这一条链上的点，于是打标记。同时考虑，对于一个 $border$ ，只有两个 $border$ 结尾字符的距离 $\leq$ 该 $border$ 的长度才有可能被算入答案。</p>
<p>考虑怎么维护这个东西，发现对于一段前缀 $[1….i]$，他的所有终点都在他的子树中。于是只需要知道，子树中相邻的点，编号差的最大值，就可以判断是否合法。发现这东西可以直接求前驱和后继，据说有一种暴力可以拿平衡树去维护，然而不是很懂.jpg</p>
<p>考虑从上到下遍历这棵树，那么不断删除不在路径上的子树，更新答案即可。</p>
<p>思考了半天，一直觉得这个算法看不太透。但似乎稍微手玩/思考一下，也没啥大问题。。</p>
<hr>
<p>嗯，出去吃了个晚饭，编了个自认为很合理的解释：考虑对于一个前缀 $i$，在 $0\sim n$ 的路径上，会对它的判定造成影响的只会是那些包含他但不把他作为 $border$ 的更长的前缀。那么考虑，如果一个前缀不以 $i$ 为 $border$，那么也一定不以 $i+k~(k&gt;0)$ 做 $border$。所以对于一个 $i$ 而言，只需要考虑比他小的 $border$ 产生的贡献，这也正是从根到它的路径上，除去 $0\sim n$ 链之外的所有子树。于是删掉即可。复杂度 $O(\rm |S|)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line"><span class="keyword">char</span> In[MAXN] ; <span class="keyword">int</span> N, fail[MAXN], ans ;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN], nxt[MAXN], onw[MAXN], val = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//  cout &lt;&lt; x &lt;&lt; endl ;</span></span><br><span class="line">    pre[nxt[x]] = pre[x] ;</span><br><span class="line">    nxt[pre[x]] = nxt[x] ;</span><br><span class="line">    val = max(val, nxt[x] - pre[x]),</span><br><span class="line">    pre[x] = nxt[x] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k)) del(to(k)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= u) </span><br><span class="line">      <span class="keyword">return</span> ans = u, <span class="keyword">void</span>() ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">int</span> xyg ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k)) </span><br><span class="line">      <span class="keyword">if</span> (onw[to(k)]) xyg = to(k) ; <span class="keyword">else</span> del(to(k)) ;</span><br><span class="line">    dfs(xyg) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">    N = <span class="built_in">strlen</span>(In + <span class="number">1</span>), ans = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; In[j + <span class="number">1</span>] != In[i]) j = fail[j] ;</span><br><span class="line">        <span class="keyword">if</span> (In[j + <span class="number">1</span>] == In[i]) fail[i] = ++ j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) add(fail[i], i) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) pre[i] = i - <span class="number">1</span>, nxt[i] = i + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = N ; i ; i = fail[i]) onw[i] = <span class="number">1</span> ; </span><br><span class="line">    dfs(<span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>失配树</category>
      </categories>
      <tags>
        <tag>奇怪的技巧</tag>
        <tag>字符串/fail树</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】SAM瞎做 · 公共子串相关</title>
    <url>/2020/01/16/SAM3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了水blog，决定单拿出来再整理一篇233</p>
<p>严格来讲，这东西似乎应该算在广义SAM的范畴？</p>
<a id="more"></a>
<h1 id="1-SP1811-LCS"><a href="#1-SP1811-LCS" class="headerlink" title="$1$ SP1811 LCS"></a>$1$ SP1811 LCS</h1><blockquote>
<p>输入 $2$ 个长度不大于 $250000$ 的字符串，输出这 $2$ 个字符串的最长公共子串。</p>
</blockquote>
<p>考虑对连个串都建SAM，方法是插入一个串后随便插入一个 $\not\in \Sigma$ 的字符间隔开，这样，从本质上就把第二个串的后缀连成了一棵新子树接在虚根的下面。</p>
<p>还是原来的 $dp$ 原理。每次遇到一个在两个串中都出现过的串就把答案更新一下。</p>
<p>嗯，不得不说，SAM按照 $endpos$ 构建等价类这个想法实在太妙了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		dfs(to(k)), f[x][<span class="number">0</span>] += f[to(k)][<span class="number">0</span>], f[x][<span class="number">1</span>] += f[to(k)][<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">if</span> (f[x][<span class="number">0</span>] &amp;&amp; f[x][<span class="number">1</span>]) ans = max(ans, sam.len[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sam.Init() ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) &gt;&gt; (T + <span class="number">1</span>) ; </span><br><span class="line">	N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M = <span class="built_in">strlen</span>(T + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) sam.Ins(S[i] - <span class="string">'a'</span> + <span class="number">1</span>, <span class="number">0</span>) ; sam.Ins(<span class="number">27</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) sam.Ins(T[i] - <span class="string">'a'</span> + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= sam.sz ; ++ i) add(sam.fa[i], i) ; dfs(<span class="number">1</span>) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-HAOI2016-找相同字符"><a href="#2-HAOI2016-找相同字符" class="headerlink" title="$2$ [HAOI2016] 找相同字符"></a>$2$ [HAOI2016] 找相同字符</h1><blockquote>
<p>给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。</p>
</blockquote>
<p>我明白了，$15,16$ 年的时候正值SAM变的普及的阶段，所以这种没有新意的题才会有一堆人出。</p>
<p>首先就是乘法原理，然后考虑不同的子串数量可以直接 $parent$ 上父子差分，然后就没了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">		dfs(to(k)), f[x][<span class="number">0</span>] += f[to(k)][<span class="number">0</span>], f[x][<span class="number">1</span>] += f[to(k)][<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">1</span> &amp;&amp; f[x][<span class="number">0</span>] &amp;&amp; f[x][<span class="number">1</span>]) </span><br><span class="line">		ans += <span class="number">1l</span>l * f[x][<span class="number">0</span>] * f[x][<span class="number">1</span>] * (sam.len[x] - sam.len[sam.fa[x]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-多串的LCS"><a href="#3-多串的LCS" class="headerlink" title="$3$ 多串的LCS"></a>$3$ 多串的LCS</h1><p>此处的 “S” 指的是 “Substring” 的意思啦。</p>
<p>本质上是SPOJ的两道题，<code>SP10570 LONGCS</code> 和 <code>SP1812 LCS2</code> 。</p>
<blockquote>
<p>给定一些字符串，求出它们的最长公共子串</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> S[MAXN], T[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, L, res, ans[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> last, sz ;</span><br><span class="line">    <span class="keyword">int</span> fa[MAXN], f[MAXN], len[MAXN] ;</span><br><span class="line">    <span class="keyword">int</span> trans[MAXN][<span class="number">27</span>], buc[MAXN], base[MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        last = sz = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = ++ sz ;</span><br><span class="line">        last = np, len[np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][x])</span><br><span class="line">            trans[p][x] = np, p = fa[p] ;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = <span class="number">1</span>, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">int</span> q = trans[p][x] ;</span><br><span class="line">        <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> fa[np] = q, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">int</span> nq = ++ sz ;</span><br><span class="line">        fa[nq] = fa[q],</span><br><span class="line">        fa[q] = fa[np] = nq ;</span><br><span class="line">        len[nq] = len[p] + <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="keyword">sizeof</span>(trans[q])) ;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q)</span><br><span class="line">            trans[p][x] = nq, p = fa[p] ;</span><br><span class="line">    &#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">    void dfs(int x)&#123;</span></span><br><span class="line"><span class="comment">        if (vis[x]) return ; vis[x] = 1 ;</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= 26 ; ++ i) if (trans[x][i]) dfs(trans[x][i]) ;</span></span><br><span class="line"><span class="comment">        ans[fa[x]] = max(ans[fa[x]], min(ans[x], len[fa[x]])) ;</span></span><br><span class="line"><span class="comment">        f[x] = min(f[x], ans[x]), ans[x] = 0 ; </span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= sz ; ++ i) buc[len[i]] ++ ;</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= sz ; ++ i) buc[i] += buc[i - <span class="number">1</span>] ;</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = sz ; i &gt;= <span class="number">1</span> ; -- i) base[buc[len[i]] --] = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">1</span>, x, l = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">            x = s[i] - <span class="string">'a'</span> + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">while</span> (rt &amp;&amp; !trans[rt][x]) rt = fa[rt], l = len[rt] ;</span><br><span class="line">            <span class="keyword">if</span> (rt) ++ l, rt = trans[rt][x], ans[rt] = max(ans[rt], l) ;</span><br><span class="line">            <span class="keyword">else</span> rt = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sz ; i ; -- i)</span><br><span class="line">            rt = base[i], x = fa[rt], </span><br><span class="line">            ans[x] = max(ans[x], min(ans[rt], len[x])), </span><br><span class="line">            f[rt] = min(f[rt], ans[rt]), ans[rt] = <span class="number">0</span> ; </span><br><span class="line">        <span class="comment">// for (int i = 1 ; i &lt;= sz ; ++ i) cout &lt;&lt; ans[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line">        <span class="comment">// dfs(1) ;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;M ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>) ; <span class="keyword">int</span> i ;</span><br><span class="line">    N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        M.Insert(S[i] - <span class="string">'a'</span> + <span class="number">1</span>) ;</span><br><span class="line">    M.sort() ;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, T + <span class="number">1</span>))</span><br><span class="line">        L = <span class="built_in">strlen</span>(T + <span class="number">1</span>), M.work(T) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M.sz ; ++ i)</span><br><span class="line">        res = max(res, M.f[i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先拿第一个串朴素建 SAM。对于一个新的串，考虑将这个串放到 SAM 上运行，同时记录每个位置能够匹配到的最长长度。再用一个 $f$ 记录全局，而 $f$ 显然应该对每个串的 $rt$ 处的匹配取 $\min$。</p>
<p>嗯，注意由于 $parent$ 树的性质，父亲答案的一部分包含在儿子中，但也不会多于自身的长度。于是一开四$topsort$ 一遍就可以了。复杂度似乎是 $\sum\rm |S_i|$ ?</p>
<p>en，似乎这道题也是 <code>[POI2000]公共串</code> 的加强版。不过这种题目几倍经验也不奇怪吧？</p>
<h1 id="4-SDOI2008-Sandy的卡片"><a href="#4-SDOI2008-Sandy的卡片" class="headerlink" title="$4$ [SDOI2008] Sandy的卡片"></a>$4$ [SDOI2008] Sandy的卡片</h1><blockquote>
<p>Sandy和Sue的热衷于收集干脆面中的卡片。</p>
<p>每一张卡片都由一些数字进行标记，第 $i$ 张卡片的序列长度为 $M_i$，要想兑换人物模型，首先必须要集够 $N$ 张卡片，对于这 $N$ 张卡片，如果他们都有一个相同的子串长度为 $k$，则可以兑换一个等级为 $k$ 的人物模型。相同的定义为：两个子串长度相同且一个串的全部元素加上一个数就会变成另一个串。</p>
<p>现在又一堆卡片，请你帮助Sandy和Sue，看看他们最高能够得到哪个等级的人物模型。</p>
</blockquote>
<p>看到这题蒙了半天，甚至写了一发枚举「加上的数是多少」然后再去SAM，结果发现原来不同串之间可以用不同的数 ……我是弟弟。</p>
<p>于是最后被题解暴击：差分一下即可。我是dd。QAQ</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; N ; T -- ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) t[i] = S[i] - S[i - <span class="number">1</span>] ; M.Init() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) M.Insert(t[i]) ; M.sort() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ss[i][<span class="number">0</span>]) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= ss[i][<span class="number">0</span>] ; ++ j) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ss[i][j]);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> ; j &lt;= ss[i][<span class="number">0</span>] ; ++ j) t[j] = ss[i][j] - ss[i][j - <span class="number">1</span>] ;</span><br><span class="line"><span class="comment">//        for (j = 1 ; j &lt;= ss[i][0] ; ++ j) cout &lt;&lt; t[j] &lt;&lt; " " ; puts(" ") ;</span></span><br><span class="line">        t[<span class="number">1</span>] = -(i + <span class="number">1</span>) ; M.work(t, ss[i][<span class="number">0</span>]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M.sz ; ++ i) res = max(res, M.f[i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方我默认把第一个元素瞎给了个值。</p>
<p>哦，还有，可能好久没写差分了？一开始写差分我是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) S[i] = S[i] - S[i - <span class="number">1</span>] ;</span><br></pre></td></tr></table></figure>
<p>是弟中弟本弟没错了（cry</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/后缀自动机(SAM)</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】SAM瞎做 · 字典序相关</title>
    <url>/2020/01/16/SAM2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为了证明自己不是🕊并且自己经常写博客，打算把本来可以 $1p$ 讲完的分了 $4p$。这是第二 $p$，嘎嘎嘎。</p>
<a id="more"></a>
<h1 id="1-LG1368-工艺"><a href="#1-LG1368-工艺" class="headerlink" title="$1$ LG1368 工艺"></a>$1$ LG1368 工艺</h1><p>似乎std是什么最小表示法，看⑧透啊，$O(n)$ 的SAM它不香吗 ？</p>
<blockquote>
<p>把一个串循环排列，求最小的字典序排列。</p>
</blockquote>
<p>发现把串向SAM里面插两次，从始状态开始不断找最小的转移，走 $n$ 次就完了。</p>
<p>似乎只是用到了一丢丢SAM的性质啊QAQ</p>
<h1 id="2-SP7258-Lexicographical-Substring-Search"><a href="#2-SP7258-Lexicographical-Substring-Search" class="headerlink" title="$2$ [SP7258] Lexicographical Substring Search"></a>$2$ [SP7258] Lexicographical Substring Search</h1><p>题目名称…好长…</p>
<blockquote>
<p>给定一个字符串，求本质不同排名第k小的子串。</p>
</blockquote>
<p>考虑首先在SAM上算出现次数，然后从 $1$ 开始走，类似于二叉搜索木找 $k-$极值 的方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="keyword">return</span> ; vis[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (S.trans[u][i]) </span><br><span class="line">      dfs2(S.trans[u][i]), </span><br><span class="line">  		g[u] += g[S.trans[u][i]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go_Out</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= f[p]) </span><br><span class="line">    	<span class="keyword">return</span> ; </span><br><span class="line">  <span class="keyword">else</span> s -= f[p] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (!S.trans[p][i]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s &gt; g[S.trans[p][i]]) s -= g[S.trans[p][i]] ;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">"%c"</span>, i + <span class="string">'a'</span>), go_Out(S.trans[p][i], s) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) &gt;&gt; T ; </span><br><span class="line">	N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ; S.Init() ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) S.Ins(In[i] - <span class="string">'a'</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= S.sz ; ++ i) add(S.fa[i], i) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= S.sz ; ++ i) g[i] = f[i] = <span class="number">1</span> ; dfs2(<span class="number">1</span>) ;</span><br><span class="line">	dfs2(<span class="number">1</span>) ; <span class="keyword">while</span> (T --) K = qr(), go_Out(<span class="number">1</span>, K), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-TJOI2015-弦论"><a href="#3-TJOI2015-弦论" class="headerlink" title="$3$ [TJOI2015]弦论"></a>$3$ [TJOI2015]弦论</h1><blockquote>
<p>求：</p>
<p>1、本质不同的第 $k$ 小子串。</p>
<p>2、第 $k$ 小子串。</p>
</blockquote>
<p>发现第一问就是上面那一道，但是第二问里面，本质不同的串要算多次。</p>
<p>然而其实并没有什么变化，$dfs$ 一遍顺便算个出现次数就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k)) </span><br><span class="line">		dfs(to(k)), f[u] += f[to(k)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[u]) <span class="keyword">return</span> ; vis[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (S.trans[u][i]) </span><br><span class="line">			dfs2(S.trans[u][i]), g[u] += g[S.trans[u][i]] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go_Out</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s &lt;= f[p]) <span class="keyword">return</span> ; <span class="keyword">else</span> s -= f[p] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (!S.trans[p][i]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s &gt; g[S.trans[p][i]]) s -= g[S.trans[p][i]] ;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">"%c"</span>, i + <span class="string">'a'</span> - <span class="number">1</span>), go_Out(S.trans[p][i], s) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/后缀自动机(SAM)</tag>
      </tags>
  </entry>
  <entry>
    <title>【生活碎片1】· 开始啦</title>
    <url>/2020/01/15/Life1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小班终于来啦！孤独的机房终于要迎来一丝亮色了。</p>
<p>自己呢？也要准备好背起行囊，重新出发了吧！</p>
<p><del>流水账警告</del></p>
<a id="more"></a>
<h1 id="rm-Part1"><a href="#rm-Part1" class="headerlink" title="$\rm Part1$"></a>$\rm Part1$</h1><blockquote>
<p>「沉舟侧畔千帆过，病树前头万木春。」</p>
</blockquote>
<p>第一部分当然要谦虚一点，自己是沉舟病树啦。</p>
<p>然而其实谦不谦虚的，都是沉舟病树qaq</p>
<p>最近小班来了，金哥把四个提前学过的放到了我这屋。跟他们在一块显著感觉出自己有多么颓废，虽然不是很想承认，可能金哥的「错位打击」真的管用了吧？</p>
<p>然后就是想讲课？可能是因为孩儿们太可爱了，所以忍不住地就像去找他们玩…然而他们现在学的不多，所以可能不能讲太难的内容。想了一两天，决定给他们讲贪心啊、随机化啊、构造啊这种有意思的题目。</p>
<p>于是就开始学 $\TeX $ 咋用，其实挺好明白的，跟着网上找几个教程，下一堆乱七八糟的东西就好了。这里推荐清华搭的镜像站，速度很快，不愧是你清。</p>
<p>再之后就开始学 $beamer$，发现还是很简单的。然而由于自己没用过 <code>sublime 3</code> （目前只用来识别特殊字符+文本替换+文档暂存），所以就只能一行一行地手敲 $\TeX$，给爷整蒙了……</p>
<p>不过经历了一番苦难还是做好了的，最后就是 $42$ 页 PPT，觉得还可以？但不知道为啥，总觉得只有像 $\rm lxl$ 和我校化学奥赛教练那样一个课件做好几百页才算做PPT…于是只给自己打 $95$ 分（雾</p>
<p>然而，在给他们讲课的前一天下午，听他们聊起的内容，已经是 「$\rm SPFA$」、「Luogu上蓝色的贪心」这种东西，于是觉得他们很强，就临时又加了一点 $dp$ 的内容，加到了$84$ 页…and为了防止被喷菜，随便找了一道作为Cfdiv2F的dp。<del>才不会告诉你我自己看这个题都蒙了半天最后还翻的题解</del></p>
<p>结果……发现好像有什么不对……</p>
<p>大概就是本来觉得 $\rm 2h$ 结束的内容讲了 $\text{6+}~h$ 还没讲完…</p>
<p>不过最终感觉还可以？可能构造和dp是个亮点，前面讲贪心翻了一次车233，我还是太菜啊QAQ</p>
<p>发现了几个比较有天分的小朋友，希望他们将来会有所建树吧。</p>
<p>首先是人生经验：</p>
<div class="pdf" target="./瞎讲讲.pdf" height=""></div>
<p>其次是课件，自我感觉做的还不错：</p>
<div class="pdf" target="./技巧性问题选讲.pdf" height=""></div>
<p>（如果pdf加载不出来，推荐 <code>firefox</code> 浏览器或者等上那么一二三四…五六十分钟【huaji ）</p>
<p>最后把自己从MO那里嫖来的数竞教材交给了下一代…233</p>
<p>不过呢，感觉自己真是老了啊。衔接班的懵懂，高一的迷茫，高二的从容，一路走来，经历了很多，也明白了很多。</p>
<p>但是，比较伤感的一点是，无论我对这一级初三的小班有多么真挚的感情，我都不可能再陪他们去参加一年联赛了。也就说自己可能就只是他们OI生涯中，一个不起眼的过客…</p>
<p>想来有点伤感呢，但这世界本就是这样吧？</p>
<p>想起自己前几天看张庚新学长的 $blog$，里面大多都是「给小班讲STL」之类的，当时的小班（现在是我的2级学长）也很高兴地去催更。虽然东西明明那么简单，讲的明明也那么简陋，但我总能感觉出一种感情、一股力量，嵌在文字间、流淌在评论里。想到这里，感觉心脏似乎空了一块儿。</p>
<p>那力量，似乎就是从沉舟病树里面发出的，似乎在大声地喊「我还要活着」。</p>
<p>那感情，可能就是最质朴的感情吧？</p>
<h1 id="rm-Part2"><a href="#rm-Part2" class="headerlink" title="$\rm Part2$"></a>$\rm Part2$</h1><p>第二部分呢，打算自己当一回「千帆过」、「万木春」233。</p>
<p>实不相瞒，暗恋了一年多的妹子突然有了男票之后唯一的感觉就是空虚…一种「过去把自己分到她身上一部分，现在她走了，自己空了一大块」的认知，一种「为什么总感觉生活只是在不断兜着一个从“做梦”到“失败”再到“做梦”的圈子」的情感，两者叠加在一起，让我感到每天都十分的浑浑噩噩…</p>
<p>但仔细想了想，自己似乎做的事还有很多。比如可以学音乐啊、学英语、法语、俄语、日语啊之类的。但总觉得自己是三分钟热度。</p>
<p>虽然看不到什么东西，在偌大的世界也总感觉自己是孤单一人。但《飘》里面，斯嘉丽在最后说的话，似乎比较适合结尾：</p>
<blockquote>
<p> Tomorrow is another day !</p>
</blockquote>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】后缀自动机瞎学</title>
    <url>/2020/01/15/SAM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次学SAM还是一年前，当时只记得怎么看怎么不会orz</p>
<a id="more"></a>
<h1 id="1-基本内容"><a href="#1-基本内容" class="headerlink" title="$1$ 基本内容"></a>$1$ 基本内容</h1><p>…于是还是分条陈述</p>
<p>0、一个子串的 $endpos$ 集合指的是它在原串内出现的所有的右端点下标组成的集合。显然有这么一个性质，对于两个子串，它们的 $endpos$ 集合要么存在包含关系，要么没有交集。 </p>
<p>1、首先，SAM是个自动机。转移是字母，状态是 <strong>$endpos$ 集合相同的子串</strong>。有一个其实状态，一堆终止状态，每个终止状态是原串的一个后缀。</p>
<p>2、如果记每个状态里面最长的子串的长度为 $L_{\max}$，最短的子串长度为 $L_{\min}$ ，那么这个状态承载的子串长度覆盖 $[L_{\min},L_{\max}]$.</p>
<p>3、考虑后缀链接 $\rm link$ 。$\mathrm{link}(v)$ 指向的是 $L_{\max}(u)+1=L_{\min}(v)$ 且 $endpos(v)\subset endpos(u)$ 的这么一个节点 $u$ . 可以看出，其实 $u$ 里面的子串就是 $v$ 中的子串的某些更短的后缀。</p>
<p>4、发现后缀链接 $\rm link$ 联系起来的每个状态之间，长度单调且前驱唯一，再加上显然连通，所以 $\{\rm S,link\}$ 本质上是一棵树。</p>
<p>5、于是考虑怎么构造。大概就是增量构造法。</p>
<p>（1）每次加入一个新的状态 $np$ 时，考虑上一个转移到的状态 $p$ ，把 $L_{max}(np)$ 设置为 $L_{\max}(p) + 1$ （显然）。一直沿着后缀链接向上跳，并且把途中的转移都连向 $np$，因为原来不存在当前字母 $c_{now}$ 的转移，所以加入一个字母之后要一起改。</p>
<p>（2）考虑不断跳 $p$ ，直到跳到一个 $p$ 具有 $c_{now}$ 的转移，把这个转移到的状态称之为 $q$。那么此时 $endpos(q)$ 会多出一个元素，长度为 $L_{\max}+1$。此时由于 $L_{\max}(p)&lt;q$ 有两种情况需要考虑：</p>
<ul>
<li><ol>
<li>$L_{\max}(q)=L_{\max}(p)+1$，这时 $q$ 代表的所有串的 $endpos$ 不变。考虑 $np$ 具有至少一个不同于 $q$ 的状态，即 $[1…now]$ ，现在插入的最长前缀。所以此时令 $\mathrm{link}(np)=q$ 而不是合并。</li>
</ol>
</li>
<li><ol>
<li>$L_\max(q)&gt;L_\max(p)+1$，这时 $q$ 中的串，长度不超过 $L_\max(p)+1$ 的串会多一个 $endpos$，即 $now$；但是大于 $L_{\max}(p)+1$ 的串则不会。所以此时需要<strong>拆开状态</strong> 。考虑为了维护一个状态里面所有点的 $endpos$ 相同，需要新建一个状态 $nq$，代表原来串中所有长度不超过 $L_\max(p)+1$ 的串。发现这么拆分的话，有 </li>
</ol>
</li>
</ul>
<script type="math/tex; mode=display">
\mathrm{link}(q)=\mathrm{link}(np) = nq</script><ul>
<li>3、对于第二种情况，发现就类似抠掉一个点，换进去一颗子树。于是乎从 $p$ 开始又要不断向上跳，把所有 $trans=q$ 的点都改成 $nq$。</li>
</ul>
<p>哦，对，树 $\{\rm S,link\}$ 有个学名叫做 $parent$ 树来着。</p>
<p>然后就完了，就完了……</p>
<p>发现其实到最后SAM十分的短：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> last, sz ;</span><br><span class="line">	<span class="keyword">int</span> trans[MAXN][Sigma] ;</span><br><span class="line">	<span class="keyword">int</span> len[MAXN], fa[MAXN] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123; last = sz = <span class="number">1</span> ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> np = ++ sz ; </span><br><span class="line">		<span class="keyword">int</span> p = last, q, nq ;</span><br><span class="line">		last = np, f[np] = <span class="number">1</span> ;</span><br><span class="line">		len[np] = len[p] + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; !trans[p][x]) </span><br><span class="line">			trans[p][x] = np, p = fa[p] ; </span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">			<span class="keyword">return</span> fa[np] = <span class="number">1</span>, <span class="keyword">void</span>() ; </span><br><span class="line">		q = trans[p][x] ; </span><br><span class="line">		<span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> fa[np] = q, <span class="keyword">void</span>() ;</span><br><span class="line">		nq = ++ sz, </span><br><span class="line">		len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">		fa[nq] = fa[q], fa[q] = fa[np] = nq ; </span><br><span class="line">		<span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="keyword">sizeof</span>(trans[q])) ; </span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q) </span><br><span class="line">			trans[p][x] = nq, p = fa[p] ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;S;</span><br></pre></td></tr></table></figure>
<h1 id="2-例题"><a href="#2-例题" class="headerlink" title="$2$ 例题"></a>$2$ 例题</h1><p>然而有些例题就是很水。。。于是放到这里来了。。</p>
<h2 id="1-SDOI2016-生成魔咒"><a href="#1-SDOI2016-生成魔咒" class="headerlink" title="$1$ [SDOI2016]生成魔咒"></a>$1$ [SDOI2016]生成魔咒</h2><p>2016年SD居然考过这种有趣东西x</p>
<blockquote>
<p>询问每加入一个字符时，当前整个串的本质不同子串数量。</p>
</blockquote>
<hr>
<p>发现在SAM里面的 $\rm link$ 树上，本质不同的子串数的增量是 $L_{\max}(now)-L_{\max}(fa)$。</p>
<p>于是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">设fa为q原来的父亲。</span><br><span class="line">则原来的贡献是len(q) - len(fa) </span><br><span class="line">现在的贡献是</span><br><span class="line">len(nq) - len(fa) + len(q) - len(nq) + len(np) - len(nq) </span><br><span class="line">= len(q) - len(a) + len(np) - len(nq)</span><br><span class="line">相当于只增加了len(np) - len(nq)</span><br><span class="line">SAM题 = 推式子题.jpg</span><br></pre></td></tr></table></figure>
<p>然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> last, sz ; </span><br><span class="line">	<span class="keyword">int</span> len[MAXN], fa[MAXN] ;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; trans[MAXN] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123; last = sz = <span class="number">1</span> ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> np = ++ sz ;</span><br><span class="line">		<span class="keyword">int</span> p = last, q, copy ; </span><br><span class="line">		len[np] = len[p] + <span class="number">1</span>, last = np ;</span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; !trans[p].count(x)) </span><br><span class="line">			trans[p][x] = np, p = fa[p] ;</span><br><span class="line">		<span class="keyword">if</span> (!p) </span><br><span class="line">			<span class="keyword">return</span> fa[np] = <span class="number">1</span>, ans += <span class="number">1l</span>l * len[np], <span class="keyword">void</span>() ; </span><br><span class="line">		q = trans[p][x] ;</span><br><span class="line">		<span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) </span><br><span class="line">			<span class="keyword">return</span> fa[np] = q, ans += <span class="number">1l</span>l * (len[np] - len[q]), <span class="keyword">void</span>() ; </span><br><span class="line">		copy = ++ sz ;</span><br><span class="line">		fa[copy] = fa[q], </span><br><span class="line">		fa[q] = fa[np] = copy, </span><br><span class="line">		len[copy] = len[p] + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//		memcpy(trans[copy], trans[q], sizeof())</span></span><br><span class="line">		trans[copy] = trans[q] ; </span><br><span class="line">		<span class="keyword">while</span> (p &amp;&amp; trans[p][x] == q) trans[p][x] = copy, p = fa[p] ;</span><br><span class="line">		ans += <span class="number">1l</span>l * (- len[copy] + len[np]) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;S ;</span><br></pre></td></tr></table></figure>
<h2 id="2-LG3804【模板】SAM"><a href="#2-LG3804【模板】SAM" class="headerlink" title="$2$  LG3804【模板】SAM"></a>$2$  LG3804【模板】SAM</h2><blockquote>
<p>给定一个只包含小写字母的字符串 $\rm S$,</p>
<p>请你求出 $\rm S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。</p>
</blockquote>
<p>于是发现，这个出现次数的话，可以在 $parent$ 树上直接 $dp$ 一遍。对于每个准确插入的状态，初始设置成 $1$，然后 $dp$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k)) </span><br><span class="line">		dfs(to(k)), f[x] += f[to(k)] ;</span><br><span class="line">	<span class="keyword">if</span> (f[x] &gt; <span class="number">1</span>) ans = max(ans, f[x] * <span class="number">1l</span>l * S.len[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">	N = <span class="built_in">strlen</span>(In + <span class="number">1</span>), S.Init() ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) S.Insert(In[i] - <span class="string">'a'</span> + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= S.sz ; ++ i) add(S.fa[i], i) ; dfs(<span class="number">1</span>) ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-USACO06DEC-Milk-Patterns"><a href="#3-USACO06DEC-Milk-Patterns" class="headerlink" title="$3$ [USACO06DEC] Milk Patterns"></a>$3$ [USACO06DEC] Milk Patterns</h2><blockquote>
<p>找 $\rm S$ 中出现次数超过 $k$ 的最长的串的长度。</p>
</blockquote>
<p>还是 $dp$ 一遍，然后就没有然后了。</p>
<p><del>我在干什么？</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))</span><br><span class="line">		dfs(to(k)), f[u] += f[to(k)] ; </span><br><span class="line">	<span class="keyword">if</span> (f[u] &gt;= K) ans = max(S.len[u], ans) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>SAM</category>
      </categories>
      <tags>
        <tag>字符串/后缀自动机(SAM)</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】SPOJ数个数</title>
    <url>/2020/01/05/count-divisors/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题目名称是我瞎写的233</p>
<p>事实上是 $\rm SPOJ$ 的三<del>倍经验</del>道题，解决的是以下问题：</p>
<script type="math/tex; mode=display">
\sum _{i=1}^{n}\sigma_0(i^k)</script><p>其中 $n,k$ 给定，$n\leq 10^{10},\quad k\leq2^{64}$ </p>
<p><del>我也忘了是不是这个数据范围反正能过就对了</del></p>
<p>提交链接 ：</p>
<p>1 <a href="http://www.spoj.com/problems/DIVCNTK2/" target="_blank" rel="noopener">$k=2$  DIVCNTK2</a><br>2 <a href="http://www.spoj.com/problems/DIVCNTK3/" target="_blank" rel="noopener">$k=3$  DIVCNTK3</a><br>3 <a href="http://www.spoj.com/problems/DIVCNTK/" target="_blank" rel="noopener">$\mathrm{input} ~k$  DIVTNK(general)</a></p>
<a id="more"></a>
<h2 id="正经题解"><a href="#正经题解" class="headerlink" title="正经题解"></a>正经题解</h2><p>其实很水的，对吧？已知 $\forall p\in \mathbb{P,}~\sigma_0(p^k)=k+1$，所以有 $f(p)=k+1,f(p^j)=jk+1$ 于是这东西看起来可以效仿原来的思路直接设一个 $f(p)=1,f(p)=k$ 来做，然后就。。。就不对了！</p>
<p>然后我就很奇怪啊，为啥按照公式推，$g$ 应该没推错，但是结果不对？迷惑了大半个上午。</p>
<p>…到最后这个题纠结了半天，原因是我忘了 $f(p)=k$ 这东西 <strong>不是积性函数</strong> ，所以不能去推 $f(k)$，也就是说<strong>不能直接拆</strong>。</p>
<p>然后为了这个事儿还去 uoj 群丢了一上午人，Life so hard ….</p>
<p>所以怎么解决？考虑只维护一个 $f(p)=1$，然后计算的时候 $\times ~(k+1)$ 就完了。</p>
<p>最后还是 <a href="https://www.cnblogs.com/bestwyj" target="_blank" rel="noopener"><code>iostream</code></a> 神仙在Luogu的讨论区帮了我，十分感动555</p>
<p>总结：感觉自己是个弟弟qaq</p>
<p>然后以下是正确写法，只推一个 $h$ 就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL n, e ;</span><br><span class="line">LL val[N], h[N] ;</span><br><span class="line"><span class="keyword">int</span> s, tot, cnt ;</span><br><span class="line">LL id1[N], id2[N] ;</span><br><span class="line"><span class="keyword">int</span> T, chk[N], pr[N] ;</span><br><span class="line"><span class="keyword">const</span> LL Inv2 = <span class="number">500000004</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    LL id = p &lt;= s ? id1[p] : id2[n / p] ;</span><br><span class="line">    LL ans = h[id] * (e + <span class="number">1</span>) - q * (e + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p)</span><br><span class="line">            <span class="keyword">break</span> ; LL m = pr[k], t = pr[k] ; <span class="keyword">int</span> o ;</span><br><span class="line">        <span class="keyword">for</span> (o = <span class="number">1</span> ; m &lt;= p ; ++ o, m *= t)</span><br><span class="line">            ans += <span class="number">1u</span>ll * (o * e + <span class="number">1</span>) * (S(p / m, k) + (o &gt; <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    sieve(N - <span class="number">1</span>) ;</span><br><span class="line">    LL l, r, w, t ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n, e = <span class="number">3</span> ;</span><br><span class="line">        s = <span class="built_in">sqrt</span>(n) ; tot = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">            t = n / l ; r = n / t ;</span><br><span class="line">            val[++ tot] = t ; h[tot] = t - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (t &lt;= s) id1[t] = tot ; <span class="keyword">else</span> id2[l] = tot ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            LL nowp = <span class="number">1l</span>l * pr[i] * pr[i], w, id ;</span><br><span class="line">            <span class="keyword">if</span> (nowp &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; val[j] &gt;= nowp ; ++ j)&#123;</span><br><span class="line">                w = val[j] / pr[i] ;</span><br><span class="line">                id = (w &lt;= s) ? id1[w] : id2[n / w] ;</span><br><span class="line">                h[j] -= h[id] - (i - <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; S(n, <span class="number">0</span>) + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>上午在去 uoj 群里丢脸之前，找到欧神 <code>ouuuyuuu</code> （欧神：说了多少遍我不打算起这个ID！？）——我校现役MO最强战力，SD-01，CMO2019非集训队第一。找他是因为曾经给他看过杜教筛，他觉得简单，于是我就让他现场 $5min$ 学完了 $\rm Min25$ 筛（可能效果不是很好）然后问他为什么不对。</p>
<p>然后我俩：</p>
<blockquote>
<p>好迷啊（齐声）</p>
</blockquote>
<p>所以事实证明，弱菜弱到一定地步是可以带飞神仙的。qed。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>SPOJ</category>
      </categories>
      <tags>
        <tag>数学/积性函数求和/Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】#loj6053 简单的函数</title>
    <url>/2020/01/05/loj6053/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>给定函数 $f(x)$ 满足：</p>
<script type="math/tex; mode=display">
\begin{array}{l}{\text { 1. } f \left (1\right) =1} \\ {\text { 2. } f\left(p^{c}\right)=p \oplus c} \qquad \oplus\text{代表异或运算}\\ {\text { 3. } f\left(a b\right)=f\left(a\right) f\left(b\right) \qquad (a,b)=1}\end{array}</script><p>求 $\sum f(x)$, $n\leq 10^{10}$</p>
</blockquote>
<p>单独拿出一道题来整理一下，也算是理一下用 Min_25 解题的一点思路吧。</p>
<a id="more"></a>
<p>嗯，首先思考 Min_25 筛本质上需要做什么：</p>
<p>1、对于每个 $x = \lfloor \frac{n}{y}\rfloor$ ，这样不同的 $x$ 共有 $O(\sqrt n)$ 个，需要快速得到 </p>
<script type="math/tex; mode=display">
\sum_{i=1}^x \boldsymbol{F'}(i)</script><p>的值。</p>
<p>2、需要根据递推式求出 $g$ 来，同时由于空间不够，而我们其实只需要知道 $g(x,j)$ 在所有 $x = \lfloor \frac{n}{y}\rfloor$ 处的取值就好，所以考虑用两个 $\sqrt n$ 的标号来存。</p>
<p>3、在 $\rm S$ 中，分工很明确，<code>for</code> 之前求的是所有质数处的 $f$ 和，然而由于直接算 $f$ 求出的是 $1\sim n$ 的质数处的 $f$ 和，我们需要的是 $j+ 1\sim n$ 的，所以把 $1\sim j$ 的减去；对于合数，我们枚举每个 $\geq j+1$ 的质数，然后 $\log$ 次向上计算：</p>
<script type="math/tex; mode=display">
\sum_{p_{k}^{e} \leq n, k>j} f\left(p_{k}^{e}\right)\left(\mathrm{S}\left(\frac{n}{p_{k}^{e}}, k\right)+[e>1]\right)</script><p>直观上可以感觉出有一个很大的上界 $n$，即 </p>
<script type="math/tex; mode=display">
\sum_{x=1}^{\lfloor\frac{n}{\ln n}\rfloor} \log_xn<n</script><p>。。。然而似乎并没有用，因为线性筛也是这个复杂度233</p>
<p>然后说题，考虑质数处的取值：</p>
<script type="math/tex; mode=display">
f(p)=p \operatorname{xor} 1=\left\{\begin{array}{ll}{p+1} & {p=2} \\ {p-1} & {p\not =2}\end{array}\right.</script><p>然后就可以维护一个 $n$ 一个 $1$，质数次幂就是 $f(p^c)=p\oplus c$ 易求，最后再加上 $2$ 处多减去的 $2$ 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL n ;</span><br><span class="line">LL val[N] ;</span><br><span class="line">LL g[N], h[N] ;</span><br><span class="line"><span class="keyword">int</span> s, tot, cnt ;</span><br><span class="line"><span class="keyword">int</span> chk[N], pr[N] ;</span><br><span class="line">LL id1[N], id2[N], sp[N] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inv2 = <span class="number">500000004</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i,</span><br><span class="line">            sp[cnt] = (sp[cnt - <span class="number">1</span>] + i) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; m) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    LL id = p &lt;= s ? id1[p] : id2[n / p] ;</span><br><span class="line">    LL ans = ((g[id] - h[id] - sp[q] + q) % P + P) % P ;</span><br><span class="line">    <span class="keyword">if</span> (!q) ans += <span class="number">2</span> ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p)</span><br><span class="line">            <span class="keyword">break</span> ; LL m = pr[k], t = pr[k] ; <span class="keyword">int</span> o ;</span><br><span class="line">        <span class="keyword">for</span> (o = <span class="number">1</span> ; m &lt;= p ; ++ o, m *= t)</span><br><span class="line">            ans = (ans + <span class="number">1l</span>l * (pr[k] ^ o) * (S(p / m, k) + (o &gt; <span class="number">1</span>)) % P) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ; s = <span class="built_in">sqrt</span>(n) ;</span><br><span class="line">    sieve(s) ; LL l, r, w, t ;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        t = n / l ; r = n / t ;</span><br><span class="line">        val[++ tot] = t ; h[tot] = ((t - <span class="number">1</span>) % P + P) % P  ;</span><br><span class="line">        g[tot] = ((t % P * (t % P + <span class="number">1</span>) % P * Inv2 % P - <span class="number">1</span>) % P + P) % P ;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= s) id1[t] = tot ; <span class="keyword">else</span> id2[l] = tot ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">        LL nowp = <span class="number">1l</span>l * pr[i] * pr[i], w, id ;</span><br><span class="line">        <span class="keyword">if</span> (nowp &gt; n) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; val[j] &gt;= nowp ; ++ j)&#123;</span><br><span class="line">            w = val[j] / pr[i] ;</span><br><span class="line">            id = (w &lt;= s) ? id1[w] : id2[n / w] ;</span><br><span class="line">            (h[j] -= h[id] - (i - <span class="number">1</span>)) %= P ;</span><br><span class="line">            (g[j] -= <span class="number">1l</span>l * pr[i] * (g[id] - sp[i - <span class="number">1</span>]) % P) %= P  ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= tot ; ++ i) cout &lt;&lt; h[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (S(n, <span class="number">0</span>) + <span class="number">1</span>) % P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一想到 zzq 出这个题的年纪我还在玩泥巴，就知道自己退役预定了。</p>
<p>是啊，本来就是强行续命，所以无论结果怎么样也只能欣然接受了吧。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>数学/积性函数求和/Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】Min_25筛</title>
    <url>/2020/01/04/min25%E7%AD%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>源自一个日本老哥神仙级别的构造，原链接在这里：<a href="https://min-25.hatenablog.com/entry/2018/11/11/172216" target="_blank" rel="noopener">$min\_25’s~blog$</a></p>
<p>啊，学了好久啊…总是学不会呢，再聪明一点吧。</p>
<a id="more"></a>
<p>然后 $min25$ 筛大概是对积性函数求和的一种方法。他求和的函数有以下特征：</p>
<p>1、$\boldsymbol{F}$ 是整值积性函数 </p>
<p>2、广义上讲，需要 ${i\in \mathbb{P}},\boldsymbol{F}(i),\boldsymbol{F}(i^k)$ 这俩东西可以很简单地计算</p>
<p>3、然而一般情况下，都是 $f$ 这东西在素数处可以化作一个低次多项式（即完全积性，否则不能提出来）。</p>
<p>嗯，第三条是大部分情况下都会把原函数拆分为 $\sum _{i\in\mathbb{P}} i^k$ 这种形式，因为这种形式的和比较好求。然而其实这么说来十分的naive，毕竟 $\varphi,\mu$ 也很好求。</p>
<p>大概思想就是神仙构造，比杜教筛神仙许多的构造。当然也有人管这个叫“扩展埃拉托色尼筛”…不过也确实很形象。</p>
<h1 id="1-构造一个-g-n-j"><a href="#1-构造一个-g-n-j" class="headerlink" title="$1$ 构造一个 $g(n,j)$"></a>$1$ 构造一个 $g(n,j)$</h1><p>本节先假设 $f$ 为 <strong>完全积性函数</strong>。</p>
<p>嗯，这东西是这么一种形式 ：</p>
<script type="math/tex; mode=display">
g(n,j)=\sum_{i=1}^{n}f(i)\cdot\max([i\in\mathbb{P}],[\mathrm{minf}(i)> prime_j])</script><p>其中 $[]$ 还是艾佛森括号，$prime_j$ 表示线性筛出来的质数集合中第 $j$ 大的元素，$\mathrm{minf}(i)$ 表示 $i$ 的最小素因子。</p>
<p>直观地来说，$g(n,j)$ 表示的就是 $n$ 以内的在埃筛算法进行第 $i$ 轮后尚未被筛去的数的 $f$ 的和。</p>
<p>然后思考怎么转移，假设枚举到了 $j$：</p>
<p>1、如果当前 $prime_j^2&gt;n$ ，那么对于当前的 $prime$ 不可能存在更多的 $\mathrm{minf}(i)&gt; prime_j$ 。所以此时 $g(n,j)=g(n,j-1)$<br>2、如果当前 $prime_j^2\leq n$，即 $\lfloor \frac{n}{prime_j}\rfloor \geq prime_j$ 那么考虑应该减去那些最小素因子为 $prime_j$ 的数的 $f$ 值。 然而这个值发现本质上可以通过 $g$ 数组本身来刻画。即：</p>
<script type="math/tex; mode=display">
g(n,j)=g(n,j-1) - f(prime_j)\cdot (g(\lfloor \frac{n}{prime_j}\rfloor,j-1)-g(prime_{j-1},j-1))</script><p>（1）首先，根据上文假设，$f$ 应该是一个完全积性函数，所以可以直接提出来。<br>（2）第二项的前一半是所有剔除掉 $prime_j$ 这一项之后，最小质因子 $&gt;prime_{j-1}$ 即 $\geq prime_j$ 的数字的和，因为这些数字没有比 $prime_j$ 更小的质因子，所以要减去；后面是要减去前一项里面顺带计算了的 $&lt;prime_j$ 的质数，因为显然 $1\sim prime_{j-1}$ 不可能存在以比 $prime_{j-1}$ 大的质数为最小质因子的数，所以累加的只有质数；而据定义这一部分需要倍计算进去，但是他们 $ \times ~prime_j$ 之后的数显然最小质因子不是 $prime_j$ 。</p>
<p>所以最终的递推式，为了简洁用 $p_j$ 替代 $prime_j$:</p>
<script type="math/tex; mode=display">
g_{(n,j)}=\begin{cases}g_{(n,j-1)} - f_{(p_j)}\cdot (g_{(\lfloor \frac{n}{p_j}\rfloor,j-1)}-g_{(p_{j-1},j-1)}) & \mathrm{if}~(p_j^2\leq n) \\\ g_{(n,j-1)} & \mathrm{otherwise}\end{cases}</script><p>…鬼知道我为了理解这部分<del>打了多久的摆</del>花了多少时间和精力233</p>
<p>不过观察整s个 $g$ 的递推，可以发现只跟 $f$ 在质数处的取值有关。所以如果对于一个积性函数 $\boldsymbol{F}$， 我们可以将其拆分成几个完全积性函数 $\boldsymbol{F’,F’’….}$ 在 $x\in \mathbb{P}$ 处的乘积或者是加和，就可以实现快速计算 $g$。</p>
<p>这也正是上文中对于 $\boldsymbol{F}$ 的限制。如果 $\boldsymbol{F}$ 是个简单的低次多项式，那么就可以按照幂次拆分成几项分别求和再相加；或者更广义一点， $\boldsymbol{F}$  可以拆分成许多在质数处以求得的函数，那么同样适用于 $min25$ 筛</p>
<h1 id="2-求和"><a href="#2-求和" class="headerlink" title="$2$ 求和"></a>$2$ 求和</h1><p>终于要求和啦！</p>
<p>首先令 $\mathrm{S}(n,j)=\sum_{i}^{n} f(i) [\mathrm{minf}(i)&gt;prime_j]$ ，那么最终结果就是 $\mathrm{S}(n,0)+f(1)$ 。最后的 $1$ 是因为 $1$ 没有质因子。</p>
<p>（ps : 然而似乎 $f(1)\equiv 1$？因为毕竟 $f(x)$ 是积性函数，那么就一定有 $f(x)\cdot f(1)=f(x)$……除了 $f(x)\equiv0$ 这种情况）</p>
<p>那么就可以知道 $\rm S$ 可以这么推：</p>
<script type="math/tex; mode=display">
\mathrm{S}(n,j)= g(n,|\{p \}|) - g(p_{j-1},j-1)+\sum_{p_{k}^{e} \leq n, k>j} f\left(p_{k}^{e}\right)\left(\mathrm{S}\left(\frac{n}{p_{k}^{e}}, k\right)+[e>1]\right)</script><p>前半部分是所有质数的贡献，同样由于不存在比最大的质数 $p_{\max}$ 更大的质因子，所以第一项就是统计了所有质数；后一项则是根据定义减掉了比 $j$ 小的质数的贡献。</p>
<p>后半部分计算合数。这个地方考虑枚举合数的最小质因子（此处显然 $&gt;prime_j$，即枚举 $k&gt;j$），然后利用积性函数的性质提取。值得注意的是最后有一个艾佛森括号，$[e&gt;1]$，其意义是前文提到过的“ $1$ 没有质因子”，而当 $e=1$ 时，$prime_k^1\in \{prime\}$ , 是质数, 在前半部分计算过了。</p>
<p>嗯，于是这东西就可以暴力 $dfs$ 了。稳得很。</p>
<h1 id="3-复杂度"><a href="#3-复杂度" class="headerlink" title="$3$ 复杂度"></a>$3$ 复杂度</h1><p>大家都说是 $\frac{n^{\frac{3}{4}}}{\ln n}$，然而神仙说其实应该是 $O(n^{1-\epsilon})$，是一种亚线性筛法，但感觉用在 $n\leq 1e10$ 还是可以 $1.5s$ 以内出结果的。</p>
<p>然后有个小细节，就是发现算 $g$ 这个东西的时候，空间开不下。然而其实发现 </p>
<script type="math/tex; mode=display">
\left\lfloor\frac{\left\lfloor\frac{n}{a}\right\rfloor}{b}\right\rfloor=\left\lfloor\frac{n}{a b}\right\rfloor</script><p>这东西说明了，$n$ 除以某个数得到的值其实是有限的。于是就可以直接当 $k&gt;\sqrt n$ 时，用第一张表存 $\lfloor \frac{n}{k}\rfloor$ ；当 $k\leq \sqrt n$ 时，用第二张表存 $k$。同时 $g$ 的第二维也可以直接滚掉。发现这样空间复杂度就做到了 $O(\sqrt n)$ 。</p>
<h1 id="4-例题"><a href="#4-例题" class="headerlink" title="$4$ 例题"></a>$4$ 例题</h1><h2 id="LG5325-【模板】Min-25筛"><a href="#LG5325-【模板】Min-25筛" class="headerlink" title="LG5325 【模板】Min_25筛"></a>LG5325 【模板】Min_25筛</h2><blockquote>
<p>给定积性函数 $f$，满足 $p\in \mathbb{P},f(p^k)=p^k(p^k-1)$ 。求和</p>
<p>$n\leq 10^{10}$。</p>
</blockquote>
<p>发现这就是比较套路的多项式拆成单项式，所以就直接拆成平方项和一次项做就好了。</p>
<p>然后递推 $g$ 之前要先把 $g(n,0)$ 算出来，这东西完全可以 $\sqrt n$ 根据定义直接算。</p>
<p>。。。还有，注意取模</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL g1[N], g2[N] ;</span><br><span class="line">LL n, s1[N], s2[N] ;</span><br><span class="line">LL dex[<span class="number">2</span>][N] ; <span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1000000007</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inv6 = <span class="number">166666668l</span>l ;</span><br><span class="line"><span class="keyword">const</span> LL Inv2 = <span class="number">500000004l</span>l ;</span><br><span class="line"><span class="keyword">int</span> s, pr[N], cnt, chk[N] ; LL Id[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_sieve</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= w ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i,</span><br><span class="line">            s1[cnt] = (s1[cnt - <span class="number">1</span>] + i) % P,</span><br><span class="line">            s2[cnt] = (s2[cnt - <span class="number">1</span>] + <span class="number">1l</span>l * i * i % P) % P ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; w) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc1</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    x %= P ; </span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) % P * Inv2 % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc2</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    x %= P ; </span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) % P * (<span class="number">2</span> * x + <span class="number">1</span>) % P * Inv6 % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    LL id = (p &lt;= s ? dex[<span class="number">0</span>][p] : dex[<span class="number">1</span>][n / p]) ;</span><br><span class="line">    LL ans = ((g2[id] - g1[id] - s2[q] + s1[q]) % P + P) % P ;</span><br><span class="line">  	<span class="comment">//上一句本质上就是 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p) <span class="keyword">break</span> ; LL o, t, pq ;</span><br><span class="line">        <span class="keyword">for</span> (o = <span class="number">1</span>, pq = pr[k] ; pq &lt;= p ; ++ o, pq = <span class="number">1l</span>l * pr[k] * pq)</span><br><span class="line">            t = pq % P,</span><br><span class="line">            ans = (ans + t * (t - <span class="number">1</span>) % P * (S(p / pq, k) % P + (o &gt; <span class="number">1</span>))) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n,</span><br><span class="line">    s = <span class="built_in">sqrt</span>(n) + <span class="number">1</span>,</span><br><span class="line">    pre_sieve(s) ; LL l, r, w ;</span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        r = n / (n / l),</span><br><span class="line">        Id[++ tot] = n / r ;</span><br><span class="line">        g1[tot] = (calc1(n / l) - <span class="number">1</span> + P) % P ;</span><br><span class="line">        g2[tot] = (calc2(n / l) - <span class="number">1</span> + P) % P ;</span><br><span class="line">        <span class="keyword">if</span> (n / l &gt; s)</span><br><span class="line">            dex[<span class="number">1</span>][l] = tot ;</span><br><span class="line">        <span class="keyword">else</span> dex[<span class="number">0</span>][n / l] = tot ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">        w = <span class="number">1l</span>l * pr[i] * pr[i] ; LL now ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; w &lt;= Id[j] ; ++ j)&#123;</span><br><span class="line">            now = Id[j] / pr[i] ;</span><br><span class="line">            now = (now &lt;= s) ? dex[<span class="number">0</span>][now] : dex[<span class="number">1</span>][n / now] ;</span><br><span class="line">            (g1[j] -= <span class="number">1l</span>l * pr[i] * (g1[now] - s1[i - <span class="number">1</span>] + P) % P) %= P ;</span><br><span class="line">            (g2[j] -= <span class="number">1l</span>l * pr[i] * pr[i] % P * (g2[now] - s2[i - <span class="number">1</span>] + P) % P) %= P ;</span><br><span class="line">            g1[j] += (g1[j] &lt; <span class="number">0</span>) ? P : <span class="number">0</span> ;</span><br><span class="line">            g2[j] += (g2[j] &lt; <span class="number">0</span>) ? P : <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*for (int i = 1 ; i &lt;= tot ; ++ i)</span></span><br><span class="line"><span class="comment">        printf("%lld %lld\n", g1[i], g2[i]) ; */</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; 233 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (S(n, <span class="number">0</span>) + <span class="number">1</span>) % P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LG4213-【模板】杜教筛"><a href="#LG4213-【模板】杜教筛" class="headerlink" title="LG4213 【模板】杜教筛"></a>LG4213 【模板】杜教筛</h2><blockquote>
<p>求 $\sum \varphi(i)$ 和 $\sum \mu(i)$ .</p>
<p>$n&lt; 2^{31}$</p>
</blockquote>
<p>发现 $p\in \mathbb{P}$ ，$\varphi(p)=p-1,\varphi(p^k)=p^{k-1}(p-1)$，可以快速求，于是可以用一个 $g$ 来推 $f(x)=x$ 的前缀质数和，一个 $g$ 来推 $1$ ；同样对于 $p\in \mathbb{P},\mu(p)=-1,\mu(p^{k})=0 $ 所以这东西也可以通过递推 $1$ 来实现。</p>
<p>代码方面，虽然比自己实现的杜教筛要快，但是比其他人的杜教筛要慢不少。。。awsl</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n ; LL sp[N] ;</span><br><span class="line">LL gmu[N], gphi[N] ;</span><br><span class="line">LL dex[<span class="number">2</span>][N] ; <span class="keyword">int</span> T, tot ;</span><br><span class="line"><span class="keyword">int</span> s, pr[N], cnt, chk[N] ; LL Id[N] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_sieve</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    chk[<span class="number">0</span>] = chk[<span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= w ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!chk[i])</span><br><span class="line">            pr[++ cnt] = i,</span><br><span class="line">            sp[cnt] = sp[cnt - <span class="number">1</span>] + i ;</span><br><span class="line">        <span class="keyword">for</span> (rg <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * pr[j] &gt; w) <span class="keyword">break</span> ;</span><br><span class="line">            chk[i * pr[j]] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j] == <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc1</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Sphi</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> id = (p &lt;= s ? dex[<span class="number">0</span>][p] : dex[<span class="number">1</span>][n / p]) ;</span><br><span class="line">    rg LL ans = (gphi[id] - gmu[id]) - (sp[q] - q) ; </span><br><span class="line">  	<span class="comment">//上一句本质上就是g(n,|\&#123;prime \&#125;|) - g(prime_&#123;j-1&#125;,j-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;<span class="comment">//之后就是枚举更大的素因子（枚举合数）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p) <span class="keyword">break</span> ; LL o, t, pq ;</span><br><span class="line">        <span class="keyword">for</span> (o = <span class="number">1</span>, pq = pr[k] ; pq &lt;= p ; ++ o, pq = <span class="number">1l</span>l * pr[k] * pq)</span><br><span class="line">            ans = (ans + (pq / pr[k]) * (pr[k] - <span class="number">1</span>) * (Sphi(p / pq, k) + (o &gt; <span class="number">1</span>))) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Smu</span><span class="params">(LL p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[q] &gt;= p) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> id = (p &lt;= s ? dex[<span class="number">0</span>][p] : dex[<span class="number">1</span>][n / p]) ;</span><br><span class="line">    LL ans = -gmu[id] + q ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = q + <span class="number">1</span> ; k &lt;= cnt ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1l</span>l * pr[k] * pr[k] &gt; p) <span class="keyword">break</span> ;</span><br><span class="line">        ans += -(Smu(p / pr[k], k)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    pre_sieve(N - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) ; tot = <span class="number">0</span> ;</span><br><span class="line">        rg LL l, r, w, t ; s = <span class="built_in">sqrt</span>(n) ;</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= n ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//先用整除分块预处理g(n,0)</span></span><br><span class="line">            t = n / l ;</span><br><span class="line">            r = n / t ;</span><br><span class="line">            Id[++ tot] = t ;<span class="comment">//(保存每一项，最多只有2*sqrt(n)个)</span></span><br><span class="line">            gmu[tot] = t - <span class="number">1</span> ;<span class="comment">//预处理1，即在j=0时，就是该函数在所有的素数的取值-1</span></span><br><span class="line">            gphi[tot] = calc1(t) - <span class="number">1</span> ;<span class="comment">//预处理n</span></span><br><span class="line">            <span class="keyword">if</span> (n / l &gt; s)</span><br><span class="line">                dex[<span class="number">1</span>][l] = tot ;</span><br><span class="line">            <span class="keyword">else</span> dex[<span class="number">0</span>][n / l] = tot ;<span class="comment">//空间节省</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)&#123;</span><br><span class="line">            w = <span class="number">1l</span>l * pr[i] * pr[i] ; LL now ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= tot &amp;&amp; Id[j] &gt;= w ; ++ j)&#123;</span><br><span class="line">                now = Id[j] / pr[i] ;</span><br><span class="line">                now = (now &lt;= s) ? dex[<span class="number">0</span>][now] : dex[<span class="number">1</span>][n / now] ;</span><br><span class="line">                gmu[j] -= gmu[now] - (i - <span class="number">1</span>), <span class="comment">//按照递推式求g1和g2</span></span><br><span class="line">              	gphi[j] -= <span class="number">1l</span>l * pr[i] * (gphi[now] - sp[i - <span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, Sphi(n, <span class="number">0</span>) + <span class="number">1</span>, Smu(n, <span class="number">0</span>) + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-一点后话"><a href="#5-一点后话" class="headerlink" title="$5$ 一点后话"></a>$5$ 一点后话</h1><p>在写题的过程中发现了另一种写法。大概就是原本 $\rm S$ 的定义是这样的：</p>
<script type="math/tex; mode=display">
\mathrm{S}(n,j)=\sum_{i}^{n} f(i) [\mathrm{minf}(i)>prime_j]</script><p>然后他们推导的是这样的：</p>
<script type="math/tex; mode=display">
\mathrm{S}(n,j)=\sum_{i}^{n} f(i) [\mathrm{minf}(i)\geq prime_j]</script><p>这样最后的答案就是 $\mathrm{S}(n,1)+1$ ，在写的时候也需要后移一位。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Min_25筛</category>
      </categories>
      <tags>
        <tag>技巧/分块</tag>
        <tag>数学/积性函数求和/Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】树的直径泛做</title>
    <url>/2019/12/31/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做了做和这一块儿有关的题。</p>
<p><del>说是泛做然而只做了三道题</del></p>
<a id="more"></a>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><p>嗯，首先就是考虑一点定义。</p>
<ul>
<li>树的直径：一棵树内最长的一条简单路径。</li>
</ul>
<p>然后关于直径有一些性质，大部分都可以拿反证法证出来：</p>
<ul>
<li><p>对树上随便一个点 $x$ 而言，与之相距最远的点一定是直径的某个端点。</p>
<ul>
<li>证明的话可以分类讨论:<ul>
<li><ol>
<li>对于直径上一点 $x$，离他最远点设为 $y$，不在直径上，那么直径完全可以从这个地方拐到 $y$ 从而变得更大，与直径的最优性矛盾。</li>
</ol>
</li>
<li><ol>
<li>对于非直径上一点 $x$，离他最远的点为 $y$，不在直径上。那么考虑设 $x$ 到直径上最近一点 $u$ 的距离为 $d_u$，直径远端的距离为 $d$，到 $y$ 的距离为 $d_y$。那么有 $d_y+d_u&gt;d$ 。于是考虑如果让直径从 $u$ 拐到 $y$ 的话显然会更优，与直径的最优性矛盾。 </li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>定义一棵树的 <strong>中心</strong> 为 $\max_{v\in T}{d_{u,v}}$ 最小的点 $u$，那么 $u$ 在直径上。</p>
<ul>
<li>证明的话考虑如果不在直径上，那么考虑到直径上最近的一点 $p$，发现 $p$ 对于直径的两个端点距离要小于 $p$ 。再结合上面证明过的，对于 $u$ 而言，$\max_{v\in T}{d_{u,v}}$ 一定会在直径上面取到，而 $u$ 的次远点到 $p$ 的距离一定小于 $p$ 到直径端点的距离，所以中心 $u$ 一定在直径上。</li>
</ul>
</li>
</ul>
<p>这两个结论有事还是很有用的2333</p>
<hr>
<p>以上是证明着玩的。接下来考虑直径的求法。</p>
<p>首先就是喜闻乐见的两遍 $dfs/bfs$ 求。大概就是考虑第一遍随便选一个点找一个与他相距最远的点 $u$， 那么 $u$ 一定会在直径上。之后再dfs求一遍最远点即可。由于固定了端点所以就直接脑残求就完了。</p>
<p>然而我是这么 $dfs$ 的。回想起来自己是个憨憨：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法是直接 $dp$ ，这个比较傻，维护最长链和次长链即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n), ans = max(ans, dp[n] + dp[to(k)] + val(k)) ;</span><br><span class="line">        dp[n] = max(dp[n], dp[to(k)] + val(k)) ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-例题"><a href="#2-例题" class="headerlink" title="2 例题"></a>2 例题</h1><h2 id="1-APIO2010-巡逻"><a href="#1-APIO2010-巡逻" class="headerlink" title="1 [APIO2010]巡逻"></a>1 [APIO2010]巡逻</h2><blockquote>
<p>给定一棵树。可以连 $K~(K\in\\{1,2\\})$ 条额外的边使得从 $1$ 号点出发，遍历所有路径一次，使走的走路程最短。</p>
<p>同时有以下约束：</p>
<ul>
<li>每条路必须经过<strong>至少</strong>一次，点可以经过多次。</li>
<li>最后要回到一号点。</li>
</ul>
</blockquote>
<p>发现 $K=1$ 时比较容易考虑，把直径两端连起来放到最后走，这样一定是最优的。于是此时答案为 $2(n-1) - (L-1)=2n-L+1$ 。</p>
<p>然后考虑 $K=2$ 。发现 $K=2$ 时和 $K=1$ 情况大致相似，第一条边连直径。然后考虑第二条边，发现第二条边可能存在连出的圈与第一个圈有相交一部分的情况。但解决方法也很简单，把直径上的边权设置为其相反数即可。</p>
<p>然后就是求两遍直径就完事了233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[to(k)] || to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        val(k) = <span class="number">-1</span>, val(k ^ <span class="number">1</span>) = <span class="number">-1</span>, do_do(to(k), n) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; ~k ; k = next(k))&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">			do_dp(to(k), u), </span><br><span class="line">			L2 = max(L2, d[to(k)] + val(k) + d[u]) ; </span><br><span class="line">			d[u] = max(d[u], d[to(k)] + val(k)) ; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, u, v, n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>) ; n = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n]) n = pre[n] ;</span><br><span class="line">    dfs(n, <span class="number">0</span>), L1 = d[n] + (<span class="keyword">bool</span>)(K == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        vis[n] = <span class="number">1</span>, n = pre[n] ;</span><br><span class="line">    vis[n] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; L1 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (K &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        do_do(n, <span class="number">0</span>) ;</span><br><span class="line">		<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)) ; </span><br><span class="line">		do_dp(<span class="number">3</span>, <span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; L1 &lt;&lt; " " &lt;&lt; L2 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> * N - L1 - L2 &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-NOIp2007-树网的核"><a href="#2-NOIp2007-树网的核" class="headerlink" title="2 [NOIp2007]树网的核"></a>2 [NOIp2007]树网的核</h2><blockquote>
<p>给定一棵树 $\rm T=(E,V)$，求一段长度不超过 $s$ 的路径 $p=(\rm e, v)$，最小化：</p>
<script type="math/tex; mode=display">
\max_{\begin{aligned}u,v & \in \rm T\\\ u\in V, &v\not \in V\end{aligned}} [\forall t \in \mathrm{path}(u,v), t\not \in \mathrm{v}]\times d_{u,v}</script><p>其中 $\mathrm{path}(u,v)$ 表示 $u,v$ 之间唯一路径上，除去 $u,v$ 的点集。$[~]$ 为艾佛森括号。</p>
<p>$1\leq n\leq 5,000$</p>
</blockquote>
<p>类比一开始对中心的位置的证明，可以发现这段路径一定在直径上（事实上可以把这段路径缩成一个点来考虑）。然后就考虑先把直径找出来，然后 $n^2$ 枚举路径端点 $(p,q)$ ，$O(n)$ 算一下最长距离，这样是 $O(n^3)$ 的。然而发现可以贪心，链长期望越长，式子的值期望越小。所以可以 $n^2$ 预处理出来直径上离每个点最远且距离 $\leq s$ 的端点，然后 $n^2$ 做即可。最终复杂度 $n^2$。</p>
<h2 id="3-SDOI2011-消防"><a href="#3-SDOI2011-消防" class="headerlink" title="3 [SDOI2011]消防"></a>3 [SDOI2011]消防</h2><blockquote>
<p>给定一棵树 $\rm T=(E,V)$，求一段长度不超过 $s$ 的路径 $p=(\rm e, v)$，最小化：</p>
<script type="math/tex; mode=display">
\max_{\begin{aligned}u,v & \in \rm T\\\ u\in V, &v\not \in V\end{aligned}} [\forall t \in \mathrm{path}(u,v), t\not \in \mathrm{v}]\times d_{u,v}</script><p>其中 $\mathrm{path}(u,v)$ 表示 $u,v$ 之间唯一路径上，除去 $u,v$ 的点集。$[~]$ 为艾佛森括号。</p>
<p>$1\leq n\leq 500,000$</p>
</blockquote>
<p>……所以其实就是上一道题的加强版。</p>
<p>考虑怎么优化一下 $n^2$ 的算法，发现两部分都需要优化。首先考虑 <code>n^2 预处理出来直径上离每个点最远且距离 ≤ s 端点</code> 这东西，发现完全可以二分，于是变成了 $\log$ ；然后发现后一部分，完全可以一遍 $dp$ 求出来 “离直径上每个点最远的点的距离”这个东西，然后就可以 $\rm rmq$ 解决。然后两部分就都变成了 $n\log n$ 。（当然你也可以认为 $rmq$ 是 $O(\rm C)$ 的）</p>
<p>但实际上可以继续优化。首先发现的是那个二分可以拿尺取法做掉。之后考虑拿出之前整过的结论操作一下。令 $d_u$ 表示直径上一点 $u$ 在不经过直径的情况下，到某个非直径上点的最远距离。设直径的点集为 $l$，起点为 $s$， 终点为 $t$。那么答案就是</p>
<script type="math/tex; mode=display">
\min_{i,j\in l} \\{ \quad \max (dist_{s,i},dist_{j,t},\max_{v\in \mathrm{path}(i,j)} \\{ d_v \\}) \quad \\}</script><p>但是其实里面的最后一项 $\max_{v\in \mathrm{path}(i,j)} \\{ d_v \\}$ 可以被换成 $\max_{v\in l} \\{ d_v \\}$。原因是考虑当前枚举的段外一点（此处默认是在靠 $s$ 近的一侧） $w$ 的 $d_w$ 肯定会小于等于 $dist(s,w)$，而由于 $i$ 在这一段外面，所以 $dist(s,w)&lt;dist(s,i)$ ，也就是说对答案没有贡献，可以直接忽略掉。</p>
<p>于是最后就可以 $O(n)$ 做了。</p>
<p>然后先上一下 $rmq$ 的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    d[n] = <span class="number">0</span>, pre[n] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(to(k), n) ;</span><br><span class="line">        <span class="keyword">if</span> (d[to(k)] + val(k) &gt; d[n])</span><br><span class="line">            d[n] = d[to(k)] + val(k), pre[n] = to(k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">        do_do(to(k), u) ;</span><br><span class="line">        <span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">        d[u] = max(d[to(k)] + val(k), d[u]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> d[l] ;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k) &lt;= r - l) k ++ ;</span><br><span class="line">    k -- ; <span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k)][k]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, n ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; S, cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w), add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), n = <span class="number">1</span>, res = Inf ; </span><br><span class="line">    <span class="keyword">while</span> (pre[n]) n = pre[n] ; dfs(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n]) vis[n] = <span class="number">1</span>, s[++ tot] = n, n = pre[n] ;</span><br><span class="line">    s[++ tot] = n, vis[n] = <span class="number">1</span> ; </span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) rev[s[i]] = i ; </span><br><span class="line">	  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)), do_do(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; tot ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[s[i]] ; ~j ; j = next(j))</span><br><span class="line">            <span class="keyword">if</span> (to(j) == s[i + <span class="number">1</span>]) base[i + <span class="number">1</span>] = val(j) + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) f[i][<span class="number">0</span>] = d[s[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j + (<span class="number">1</span> &lt;&lt; i) &lt;= tot + <span class="number">1</span> ; ++ j)</span><br><span class="line">            f[j][i] = max(f[j][i - <span class="number">1</span>], f[j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)][i - <span class="number">1</span>]) ;</span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) ans = max(ans, d[i]) ; </span><br><span class="line">	  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, l = <span class="number">1</span> ; r &lt;= tot ; ++ r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (base[r] - base[l] &gt; S) ++ l ; <span class="comment">//cout &lt;&lt; base[tot] &lt;&lt; " " ; </span></span><br><span class="line">        res = min(res, max(max(base[l], base[tot] - base[r]), query(l, r))) ;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是另一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a, <span class="keyword">const</span> <span class="keyword">int</span> &amp; b)</span></span>&#123; <span class="keyword">return</span> a &lt; b? a : b ; &#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a, <span class="keyword">const</span> <span class="keyword">int</span> &amp; b)</span></span>&#123; <span class="keyword">return</span> a &gt; b? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w, n ;</span><br><span class="line">    fread(ch, <span class="number">1</span>, ch_top, <span class="built_in">stdin</span>) ;</span><br><span class="line">    N = read(), S = read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        u = read(), v = read(), w = read(), add(u, v, w) ;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), n = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        n = pre[n] ; dfs(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (pre[n])</span><br><span class="line">        vis[n] = <span class="number">1</span>, s[++ tot] = n, n = pre[n] ;</span><br><span class="line">    s[++ tot] = n, vis[n] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d)), do_do(n, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; tot ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[s[i]] ; j ; j = next(j))</span><br><span class="line">            <span class="keyword">if</span> (to(j) == s[i + <span class="number">1</span>]) base[i + <span class="number">1</span>] = val(j) + base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i) ans = Max(ans, d[s[i]]) ; res = ans ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>, l = <span class="number">1</span> ; r &lt;= tot ; ++ r)&#123;</span><br><span class="line">        <span class="keyword">while</span> (base[r] - base[l] &gt; S) ++ l ;</span><br><span class="line">        res = Min(res, Max(Max(base[l], base[tot] - base[r]), ans)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    write(res) ; fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>程序猿的生命大多葬送给了调试。</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>动态规划/树形DP</tag>
        <tag>树上技巧/树的直径的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】灭绝树</title>
    <url>/2019/12/30/%E7%81%AD%E7%BB%9D%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来想学支配树，据说和灭绝树就是一个东西，就滚去学了灭绝树。</p>
<p>不过一说到灭绝树，脑海中就会勾勒出一副好久之前的场景，让人怀念……</p>
<a id="more"></a>
<h1 id="1-ZJOI2012-灾难"><a href="#1-ZJOI2012-灾难" class="headerlink" title="1 [ZJOI2012] 灾难"></a>1 [ZJOI2012] 灾难</h1><blockquote>
<p>给定一个 $\rm DAG$，定义灾难值：在一个节点被删去后以它为根从上到下逐步删去入度为 $0$ 的点，最终被删去的点的数量。求每个点的灾难值。</p>
<p>$n \leq 100,000$</p>
</blockquote>
<p>不说构造方面的东西了，直接考虑怎么做。直接建一棵树， $fa_x$ 记录的是这么一个点 $u$，表示如果 $u$ 挂了那么 $x$ 肯定会挂且 $dist(u,x)$ 最小。然后考虑这个东西实际上就是每个 $x$ 的入边的另一个端点在这棵树上的 $\rm LCA$ ，于是考虑边 <code>topsort</code> 边建树。然后子树大小 $-1$ 就是答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>], e[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], Head[MAXN], sz[MAXN], cnt1, cnt2 ;</span><br><span class="line"><span class="keyword">int</span> N, deg[MAXN], dep[MAXN], fa[MAXN], anc[MAXN][<span class="number">20</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    e[++ cnt1].to = v, e[cnt1].next = head[u], head[u] = cnt1 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt2].to = v, E[cnt2].next = Head[u], Head[u] = cnt2 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = Head[u] ; k ; k = E[k].next)</span><br><span class="line">        dfs(E[k].to), sz[u] += sz[E[k].to] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">int</span> dif = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; dif) u = anc[u][j] ;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (anc[u][j] != anc[v][j])</span><br><span class="line">            u = anc[u][j], v = anc[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios :: sync_with_stdio(<span class="literal">false</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>), <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, x, y ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; y ;</span><br><span class="line">        <span class="keyword">while</span> (y) add1(y, i), deg[i] ++, <span class="built_in">cin</span> &gt;&gt; y ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; deg[i] &lt;&lt; " " ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!deg[i]) fa[i] = <span class="number">0</span>, q.push(i) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        q.pop(), add2(fa[n], n) ;</span><br><span class="line">        anc[n][<span class="number">0</span>] = fa[n], dep[n] = dep[fa[n]] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">            anc[n][i] = anc[anc[n][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[n] ; i ; i = e[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[e[i].to] == <span class="number">-1</span>) fa[e[i].to] = n ;</span><br><span class="line">            <span class="keyword">else</span> fa[e[i].to] = lca(n, fa[e[i].to]) ;</span><br><span class="line">            <span class="keyword">if</span> (!(-- deg[e[i].to])) q.push(e[i].to) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; fa[i] &lt;&lt; " " ;</span></span><br><span class="line">    dfs(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (sz[i] - <span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是很简单的吧？</p>
<h1 id="2-CF757F-Team-Rocket-Rises-Again"><a href="#2-CF757F-Team-Rocket-Rises-Again" class="headerlink" title="2 CF757F Team Rocket Rises Again"></a>2 CF757F Team Rocket Rises Again</h1><p>一道例题？</p>
<blockquote>
<p>给定一个 $n$ 个点，$m$ 条边的带权无向图和起点 $\rm S$。选择一个点 $u$ $(u\not =\rm S)$，使在图中删掉点 $u$ 后，有尽可能多的点到 $\rm S$ 的最短距离改变。</p>
<p>$n\leq 200,000$</p>
</blockquote>
<p>在发现求完一遍最短路这个图变成 DAG之后，这道题就变成了一道傻题。</p>
<p>哦，忘了，有个坑点。他可能给的这个图一开始不连通，所以要判一下 <code>vis</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    E[m][++ cnt[m]].to = v, E[m][cnt[m]].val = w,</span><br><span class="line">    E[m][cnt[m]].next = head[m][u], head[m][u] = cnt[m] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">2</span>][u] ; k ; k = E[<span class="number">2</span>][k].next)</span><br><span class="line">        dfs(E[<span class="number">2</span>][k].to), sz[u] += sz[E[<span class="number">2</span>][k].to] ;</span><br><span class="line">    <span class="keyword">if</span> (vis[u] &amp;&amp; u &amp;&amp; u != S) ans = max(ans, sz[u]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    <span class="keyword">int</span> dif = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; dif) u = anc[u][j] ;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">18</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (anc[u][j] != anc[v][j])</span><br><span class="line">            u = anc[u][j], v = anc[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> anc[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S ; <span class="keyword">int</span> u, v, w ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w),</span><br><span class="line">        add(<span class="number">0</span>, u, v, w), add(<span class="number">0</span>, v, u, w) ;</span><br><span class="line">    q.push(S) ; vis[S] = <span class="number">1</span> ;</span><br><span class="line">    fill(dis + <span class="number">1</span>, dis + N + <span class="number">1</span>, Inf), dis[S] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ; q.pop() ; vis[n] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">0</span>][n] ; k ; k = E[<span class="number">0</span>][k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[E[<span class="number">0</span>][k].to] &gt; dis[n] + E[<span class="number">0</span>][k].val)&#123;</span><br><span class="line">                dis[E[<span class="number">0</span>][k].to] = dis[n] + E[<span class="number">0</span>][k].val ;</span><br><span class="line">                <span class="keyword">if</span> (!vis[E[<span class="number">0</span>][k].to])</span><br><span class="line">                    vis[E[<span class="number">0</span>][k].to] = <span class="number">1</span>, q.push(E[<span class="number">0</span>][k].to) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[<span class="number">0</span>][i] ; j ; j = E[<span class="number">0</span>][j].next)</span><br><span class="line">            <span class="keyword">if</span> (dis[i] + E[<span class="number">0</span>][j].val == dis[E[<span class="number">0</span>][j].to])</span><br><span class="line">                add(<span class="number">1</span>, i, E[<span class="number">0</span>][j].to, <span class="number">0</span>), deg[E[<span class="number">0</span>][j].to] ++ ;</span><br><span class="line">    fill(vis, vis + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) fa[i] = <span class="number">-1</span> ;</span><br><span class="line">    q.push(S), fa[S] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = q.front() ;</span><br><span class="line">        q.pop(), vis[n] = <span class="number">1</span>, add(<span class="number">2</span>, fa[n], n, <span class="number">0</span>) ;</span><br><span class="line">        anc[n][<span class="number">0</span>] = fa[n], dep[n] = dep[fa[n]] + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">18</span> ; ++ i)</span><br><span class="line">            anc[n][i] = anc[anc[n][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>][n] ; k ; k = E[<span class="number">1</span>][k].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> ww = E[<span class="number">1</span>][k].to ;</span><br><span class="line">            <span class="keyword">if</span> (!(~fa[ww])) fa[ww] = n ;</span><br><span class="line">            <span class="keyword">else</span> fa[ww] = lca(fa[ww], n) ;</span><br><span class="line">            <span class="keyword">if</span> (! -- deg[ww]) q.push(ww) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-吐槽"><a href="#3-吐槽" class="headerlink" title="3 吐槽"></a>3 吐槽</h1><p>这东西在 Luogu 上也能算紫色的？</p>
<h1 id="4-一点回忆"><a href="#4-一点回忆" class="headerlink" title="4 一点回忆"></a>4 一点回忆</h1><p>那是 18 年的 4 月。想来已经是前年了，有些伤感。</p>
<p>当时金牌教练让 rqy 给我们出题考试，题目如下：</p>
<div class="pdf" target="./P0.pdf" height=""></div>
<p>T1是个有点 tricky 的最小字典序最大独立集，T2就是个灭绝树的板子，T3是个 DLX 的板子。然而当时大家最高分只有 $60$ 分也是有点惨惨。</p>
<p>还记得当时大家几乎都在认真地做 T2，我在做 T1 的前 60 分。然而最后 T1 还是因为边表没开两倍而 RE 挂了 40，大家 T2 都是枚举每个点然后再去 topsort , 可惜当时我连 topsort 也不会。</p>
<p>然后大家考完之后，听完 rqy 讲题就开始研究 T2，发现原来就是“[ZJOI]灾难”那题。然后大家就都去做了那道题。</p>
<p>还记得wx在考场上已经想出了几近正解，当时自己只会膜。</p>
<p>到现在为止，“灾难”这题在Luogu的题解区，地一篇题解依旧是wx的，他的前三条评论依旧是我的。</p>
<p>感觉……有点伤感。不知道是不是机房太冷的缘故，感到大脑有些麻木。是啊，rqy不再是当年的rqy了，LCEZ55级机房也不是之前那个LCEZ55级机房了，也搬到了新校。总之，一切都变了。</p>
<p>倒不是说改变不好，只是那些夕阳下的场景总是让现如今孑然一身的我感到有些无所适从。</p>
<p>看来我就是那被遗忘在时光里的老人了吧。</p>
<p>要说启迪什么的，大概就是不要再等到失去之后发现自己当时有多么愚蠢。</p>
<p>以前总是不理解为什么 rqy 要为了没有人陪他学OI而哭，现在才发现，“哦，原来是这样子的感觉啊”。</p>
<p>『 初闻不解戏中意，如今已是戏中人。』</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>灭绝树</category>
      </categories>
      <tags>
        <tag>技巧/倍增</tag>
        <tag>图论/灭绝树</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Cf Round 250</title>
    <url>/2019/12/30/CFR250/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先呢，做这一场的原因是看了 vfk 的 blog（<a href="https://blog.csdn.net/VFleaKing/article/details/90521383" target="_blank" rel="noopener">戳我</a>）感觉很有趣，并且似乎以前的 CF 的 <code>div1</code> 难度比现在低一点，于是就打算做一下。</p>
<p>嗯，是一场 CNround，可能会更贴合国内的出题氛围？感觉质量还是很好的233.</p>
<p>题号是 $\rm CF437/438$。</p>
<p>向前辈们致敬！</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>给出一个四项选择题，三长选一短，三短选一长，否则选 $C$。</p>
<p>其中“短”和“长”限制了 2 倍关系。</p>
</blockquote>
<p>我不会告诉你这题我交了5遍:(</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; L[<span class="number">4</span>] ;</span><br><span class="line"><span class="keyword">char</span> I[<span class="number">4</span>][MAXN] ; <span class="keyword">int</span> ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (I[<span class="number">0</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">1</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">2</span>] + <span class="number">1</span>) &gt;&gt; (I[<span class="number">3</span>] + <span class="number">1</span>) ;</span><br><span class="line">    L[<span class="number">0</span>].sc = <span class="number">0</span>, L[<span class="number">1</span>].sc = <span class="number">1</span>, L[<span class="number">2</span>].sc = <span class="number">2</span>, L[<span class="number">3</span>].sc = <span class="number">3</span> ;</span><br><span class="line">    L[<span class="number">0</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">0</span>] + <span class="number">1</span>) - <span class="number">2</span>, L[<span class="number">1</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">1</span>] + <span class="number">1</span>) - <span class="number">2</span> ;</span><br><span class="line">    L[<span class="number">2</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">2</span>] + <span class="number">1</span>) - <span class="number">2</span>, L[<span class="number">3</span>].fr = <span class="built_in">strlen</span>(I[<span class="number">3</span>] + <span class="number">1</span>) - <span class="number">2</span> ; </span><br><span class="line">  sort(L, L + <span class="number">4</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (L[<span class="number">3</span>].fr &gt;= L[<span class="number">2</span>].fr * <span class="number">2</span>) ++ ans ;</span><br><span class="line">    <span class="keyword">if</span> (L[<span class="number">0</span>].fr * <span class="number">2</span> &lt;= L[<span class="number">1</span>].fr) ans += <span class="number">2</span> ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>, L[<span class="number">3</span>].sc + <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ans == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%c"</span>, L[<span class="number">0</span>].sc + <span class="string">'A'</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"C"</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>给你两个整数$n$, $m$，要求在 $1\sim m$ 中选任意个数 $x_i$，使得 $\sum lowbit(x_i)=n$ 。 </p>
</blockquote>
<p>一开始脑残写了一堆奇怪的东西？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, cnt, ans[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x &amp; (-x)) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        p[i] = make_pair(lowbit(i), i) ;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + M + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M ; i &gt;= <span class="number">1</span> ; -- i)</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= p[i].first)</span><br><span class="line">            N -= p[i].first, ans[++ cnt] = p[i].second ;</span><br><span class="line">    <span class="keyword">if</span> (N) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">    <span class="comment">/*while (N)&#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; N &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">        if (N == lowbit(N))</span></span><br><span class="line"><span class="comment">            ans[++ cnt] = N ;</span></span><br><span class="line"><span class="comment">        else ans[++ cnt] = lowbit(N) ;</span></span><br><span class="line"><span class="comment">        if (ans[cnt] &gt; M) return puts("-1") ;</span></span><br><span class="line"><span class="comment">        else N -= lowbit(N) ;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">while</span> (cnt) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[cnt --]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>$n$ 个带权点，$m$ 条无向边，删除一个点就要付出所有与之有相连且没有被删除的点的点权之和的代价。</p>
<p>求删除所有点的最小代价。</p>
<p>$n,m\leq 200,000$</p>
</blockquote>
<p>小清新题，可能需要想一会儿。由于发现最后每条边只会被删一次，且每条边显然都可以做到被小权值的点删掉，于是答案就是 $\sum _{k\in E} \min(val_{from(k)},val_{to(k)})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i, j, u, v ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v, ans += <span class="number">1l</span>l * min(base[u], base[v]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p>给定一张点权图，随机选两个点，求两点间所有简单路径中路径上最小点权的最大值的期望。</p>
<p>$n,m\leq 200,000$</p>
</blockquote>
<p><del>开始时一直读不懂题我好难啊</del></p>
<p>大概就是考虑一遍建生成树一边建生成树一边同记。首先考虑路径一定会在最大生成树上。然后发现由于是最小点权，所以要用小的那个点来统计答案。于是排好序后，对于加入一个点 $u$ 之前的那些点，点权都大于 $u$ 。所以此时 $u$ 可以作为只剩下权值比他大的点时的图中的答案点，统计一下即可。</p>
<p>嗯，是个 trick。记得当时做“货车运输”那题是为了应付作业直接 copy 的同学的代码，导致后来一直不是很熟悉……233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL ans ;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], fa[MAXN], sz[MAXN], Id[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    to(++ cnt) = v, next(cnt) = head[u], head[u] = cnt ;</span><br><span class="line">    to(++ cnt) = u, next(cnt) = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> base[a] &gt; base[b] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) sz[i] = <span class="number">1</span>, fa[i] = Id[i] = i ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    sort(Id + <span class="number">1</span>, Id + N + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        LL ctn = <span class="number">0</span> ; <span class="keyword">int</span> n = Id[i], f1, f2 ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[n] ; j ; j = next(j))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[to(j)]) <span class="keyword">continue</span> ;</span><br><span class="line">            f1 = find(n), f2 = find(to(j)) ;</span><br><span class="line">            <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">                ctn += <span class="number">1l</span>l * sz[f1] * sz[f2],</span><br><span class="line">                sz[f1] += sz[f2], fa[f2] = f1 ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1l</span>l * base[n] * ctn, vis[n] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, ans * <span class="number">2.0</span> / (<span class="number">1.0</span> * N * (N - <span class="number">1</span>))) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>给出 $n$ 个点，求这个多边形的三角剖分的方案数对 $1e9+7$ 取模。</p>
<p>$n\leq 200$</p>
</blockquote>
<p>恕我直言…我对三角剖分唯一知道的就是能叉出多边形面积来233</p>
<p>根据数据范围猜算法，发现应该是区间 $dp$ 的形式。$f_{l,r}$ 表示区间 $l,r$ 内的点的三角剖分方案数。那么转移就是考虑</p>
<script type="math/tex; mode=display">
f_{l,r}=\sum_{k=l}^{r} [\mathrm{convex}(l\to k\to r)]\cdot (f_{l,k}\times f_{k,r})</script><p>其中 $[]$ 还是艾佛森括号，$\rm convex$ 函数为一个 $0/1$ 函数，返回给定的三个点对于整个多边形是否是凸的。</p>
<p>然后为了快速判断这个东西，可以先把所有点按照一个方向排一圈，然后叉积求出是否在外侧。</p>
<p>以下是如何用叉积去判:</p>
<p>如果 $a\times b &lt; 0$ 说明 $a$ 在 $b$ 的逆时针方向， $=0$ 说明同向， $&gt;0$ 说明 $a$ 在 $b$ 的顺时针方向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N ;</span><br><span class="line"><span class="keyword">double</span> s ;</span><br><span class="line">LL f[MAXN][MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nodes</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    nodes <span class="keyword">friend</span> <span class="keyword">operator</span> - (<span class="keyword">const</span> nodes &amp;a, <span class="keyword">const</span> nodes &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> (nodes)&#123;a.x - b.x, a.y - b.y&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">friend</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> nodes &amp;a, <span class="keyword">const</span> nodes &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x * b.y - a.y * b.x ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;base[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;base[i].x, &amp;base[i].y) ;</span><br><span class="line">    s += base[N] * base[<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        s += base[i] * base[i + <span class="number">1</span>], f[i][i + <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) reverse(base + <span class="number">1</span>, base + N + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">2</span> ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">            <span class="keyword">for</span> (k = j ; k &lt;= i ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> ((base[i] - base[j]) * (base[k] - base[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                    (f[j][i] += f[j][k] * f[k][i]) %= Mod ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">1</span>][N] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><blockquote>
<p>给定数列，区间查询和，区间取模，单点修改。</p>
<p>$1\leq n,m\leq 100,000,\quad 0\leq a_i\leq 10^9$。</p>
</blockquote>
<p>大概就是发现取模的一个性质，就是取模成功之后数值至少减半。可以分类讨论 $p&gt;\frac{n}{2}$ 和 $p\leq \frac{n}{2}$ ，发现 $n$ 对  $p$ 取完膜之后肯定 $&lt;\frac{n}{2}$ 。</p>
<p>于是这东西就是 $\log$ 的。于是就可以直接 $m \log n + m\log a_i$ 做了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mk, n, m, base[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N &lt;&lt; <span class="number">1</span>] ; LL s[N &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] = s[rt] = base[l], <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid) ;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> v)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] = s[rt] = v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) _change(rt &lt;&lt; <span class="number">1</span>, l, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> _change(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, v) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> val[rt] %= mod, s[rt] %= mod, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid &amp;&amp; val[rt &lt;&lt; <span class="number">1</span>] &gt;= mod)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, mod) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid &amp;&amp; val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] &gt;= mod)</span><br><span class="line">        update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, mod) ;</span><br><span class="line">    s[rt] = s[rt &lt;&lt; <span class="number">1</span>] + s[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    val[rt] = Max(val[rt &lt;&lt; <span class="number">1</span>], val[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; LL res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ql &amp;&amp; r &lt;= qr) <span class="keyword">return</span> s[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid)</span><br><span class="line">        res += query(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr) ;</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid)</span><br><span class="line">        res += query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr) ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> l, r, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, n) ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, l, r)) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mk == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;v),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, l, r, v) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;r, &amp;v), _change(<span class="number">1</span>, <span class="number">1</span>, n, r, v) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h1><blockquote>
<p>求每个结点都有个权值只在 $c_1, c_2, …, c_n$中取的，总点权为 $s$ 的二叉树的个数。对于每个 $1 \leq s \leq m$ 计算答案。</p>
<p>$1\leq n,m \leq 10^5$ 。</p>
</blockquote>
<p>发现其实是一个卡特兰数的转移形式。令 $f_n$ 表示总点权为 $n$ 的二叉树个数，那么转移应该这么转移：</p>
<script type="math/tex; mode=display">
f_n=[n=0]+\sum_{p=1}^{m}[p\in c] \sum_{q=0}^{m-p}f_{q}f_{m-p-q}</script><p>发现后面是 $p + q + m-p-q=m$ ，正好是卷积的形式。</p>
<p>那如果设 $\\{ f_n\\}$ 的生成函数为 $\rm F$， $g_x=[x\in c]$，$\\{g_n\\}$ 的生成函数为 $\rm G$，则有：</p>
<script type="math/tex; mode=display">
\rm F = G\times F^2+1</script><p>那么解一下可以得到</p>
<script type="math/tex; mode=display">
\rm F=\frac{1±\sqrt{1-4G}}{2G}</script><p>发现改变一下形式之后：</p>
<script type="math/tex; mode=display">
\rm F=\frac{2}{1±\sqrt{1-4G}}</script><p>这东西，在取负号的时候，分母是不存在逆元的。所以分母取正号。</p>
<p>然后就多项式一顿套就完了233。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Gp = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, Gi, R[MAXN] ;</span><br><span class="line">LL G[MAXN], H[MAXN], F[MAXN], t[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= P ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % P, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> L, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr LL Gn, Gi = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        Gn = expow(Gp, (P - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; Gi = <span class="number">1</span>, j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k, Gi = Gi * Gn % P)&#123;</span><br><span class="line">                rr <span class="keyword">int</span> real = J[j + k], iroot = J[j + k + i] * Gi % P ;</span><br><span class="line">                J[j + k] = (real + iroot) % P, J[j + k + i] = (real - iroot + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> Inv = expow(L, P - <span class="number">2</span>) ;  reverse(J + <span class="number">1</span>, J + L) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Inv(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], P - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ; NTT(g, Len, <span class="number">1</span>), NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - t[i] * g[i] % P + P) % P * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">LL Ig[MAXN], pf[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _sqr(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)&#123; g[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _sqr(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) pf[i] = Ig[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) Ig[i] = <span class="number">0</span>, pf[i] = <span class="number">2</span> * g[i] % P ;</span><br><span class="line">    _Inv(pf, Ig, len) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) <span class="comment">/* */</span> t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; ( l - <span class="number">1</span> )) ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) g[i] = (g[i] + f[i]) % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; NTT(Ig, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * Ig[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, l = <span class="number">1</span> ;</span><br><span class="line">    Gi = expow(Gp, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K, ++ K, M = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;j), F[j] = <span class="number">1</span> ;</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; K ; ++ i)</span><br><span class="line">        F[i] = (<span class="number">-4l</span>l * F[i] % P + P) % P ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; K ; ++ i) cout &lt;&lt; F[i] &lt;&lt; " " ;</span></span><br><span class="line">    _sqr(F, G, K), (G[<span class="number">0</span>] += <span class="number">1</span>) %= P ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; K ; ++ i) cout &lt;&lt; G[i] &lt;&lt; " " ;</span></span><br><span class="line">    _Inv(G, H, K) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; K ; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, H[i] * <span class="number">2l</span>l % P) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/计数</tag>
        <tag>动态规划/普通DP</tag>
        <tag>贪心</tag>
        <tag>奇怪的技巧</tag>
        <tag>多项式的应用</tag>
        <tag>组合计数/生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】李超树</title>
    <url>/2019/12/28/%E6%9D%8E%E8%B6%85%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>李超树，一种奇怪的数据结构——然而其实是线段树，用于维护平面优势直线。</p>
<p>顺便学了学标记永久化。</p>
<a id="more"></a>
<p>虽然不知道是谁，但是先orz李超233</p>
<h1 id="1-标记永久化"><a href="#1-标记永久化" class="headerlink" title="$1$ 标记永久化"></a>$1$ 标记永久化</h1><p>似乎李超树不是很好 <code>push_down</code> 的样子，于是去网上学了一发。大概思想就是，线段树区间维护时信息不再打标记，而是选择把标记打在自己身上不再下传。查询的时候一路查下去，记录覆盖在这条路径上的信息，然后基于修改的信息对整个区间的信息合并一下即可。</p>
<p>然后是瞎写的伪代码？Sumblime 3 真好用，自创语法真有趣233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认区间修改 = 区间的每个单点更新信息 </span></span><br><span class="line">Class Segment_Tree&#123;</span><br><span class="line">	Inform * Tag, Val ;</span><br><span class="line">	<span class="keyword">int</span> : L, R, Mid, Lson, Rson ;</span><br><span class="line">	<span class="function">Function <span class="title">Clear</span><span class="params">()</span> </span>&#123;....&#125; ;</span><br><span class="line">&#125;<span class="comment">//其中 *Tag 是当前点维护信息时打的标记，*Val 是当前节点的信息。</span></span><br><span class="line"></span><br><span class="line">Function[Inform] Merge(Inform * n, Inform * m) &#123;....&#125; ;</span><br><span class="line">Function[<span class="keyword">void</span>] Update(Segment_Tree *T, <span class="keyword">int</span> root, <span class="keyword">int</span> qL, <span class="keyword">int</span> qR, Inform *S)&#123;</span><br><span class="line">	Do_Some_Work(T[root], qL, qR, S) ;</span><br><span class="line">	<span class="keyword">if</span> (T[root] -&gt; L &gt;= qL &amp;&amp; T[root] -&gt; R &lt;= qR)</span><br><span class="line">		<span class="keyword">return</span> T[root].Tag = Merge(S, T[root].tag), <span class="keyword">void</span>() ;  </span><br><span class="line">	<span class="keyword">if</span> (qL &lt;= T[root] -&gt; Mid) </span><br><span class="line">		Update(T, T[root].Lson, qL, qR, S) ;</span><br><span class="line">	<span class="keyword">if</span> (qR &gt; T[root] -&gt; Mid) </span><br><span class="line">		Update(T, T[root].Rson, qL, qR, S) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">void</span>() ; </span><br><span class="line">&#125;</span><br><span class="line">Function[Inform] Query(Segment_Tree *T, <span class="keyword">int</span> root, <span class="keyword">int</span> qL, <span class="keyword">int</span> qR, Inform *S)&#123;</span><br><span class="line"><span class="comment">//询问操作，最后一个参数代表一路询问下来的合并标记</span></span><br><span class="line">	Inform * res ; res = EMPTY ; </span><br><span class="line">	<span class="keyword">if</span> (T[root] -&gt; L &gt;= qL &amp;&amp; T[root] -&gt; R &lt;= qR) </span><br><span class="line">		<span class="keyword">return</span> res = Merge(T[root].Val, S) ; </span><br><span class="line">	<span class="keyword">if</span> (qL &lt;= T[root] -&gt; Mid) </span><br><span class="line">		res = Merge(res, Query(T, T[root].Lson, qL, qR, Merge(S, T[root].tag))) ;</span><br><span class="line">	<span class="keyword">if</span> (qR &gt; T[root] -&gt; Mid) </span><br><span class="line">		res = Merge(res, Query(T, T[root].Rson, qL, qR, Merge(S, T[root].tag))) ;</span><br><span class="line">	<span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-李超树"><a href="#2-李超树" class="headerlink" title="$2$ 李超树"></a>$2$ 李超树</h1><p>首先李超树的最简单操作就是：</p>
<ul>
<li>向平面内添加一条直线</li>
<li>查询覆盖在某个坐标上的直线中，纵坐标值最大/最小值</li>
<li>$n,m\leq 200,000$</li>
</ul>
<p>考虑如何维护这个东西，考虑维护每个点代表区间的<strong>优势直线</strong>，即在大多数区域内<strong>可能</strong>是最优解的那条线——或者，在代表区间的中点是最优解的直线。这么做采用了启发式的思想，保存了有限多的备选最优解。于是就可以保证最后询问的时候，采用标记永久化的思想，取所有覆盖在一个单点上的优势直线的最大值即可，复杂度 $\log n$ 。</p>
<p>那么考虑怎么维护优势区间。假设区间 $\rm [L,R]$ 的优势直线为 $l$ ，现在插入一条直线 $l’$，开始分类讨论：</p>
<ul>
<li>如果当前区间的左端和右端都满足 $l’$ 更优，那么直接拿 $l’$ 替代。</li>
<li><p>如果当前取件的左端和右端都满足 $l’$ 更劣，那么 $l’$ 爱滚哪去滚哪去。</p>
</li>
<li><p>$\mathrm {slope}(l’)&gt;\mathrm{slope}(l)$</p>
<ul>
<li><p>当 $l$ 在中点处的值比 $l’$ 劣时，那么左区间可能要算一波，右区间就一定会是 $l’$ 更优。这个时候为了保证 $l$ 作为潜在的优选方案不丢失，就把 $l’$ 保存在当前区间，把 $l$ 送到自己的左儿子区间。</p>
</li>
<li><p>$l’$ 更劣时，那么右区间可能算一波，当前区间的优势直线也不会变，所以只去改右区间即可。</p>
</li>
</ul>
</li>
<li><p>$\mathrm {slope}(l’)&lt;\mathrm{slope}(l)$</p>
<ul>
<li>同理可证，显然，证毕（</li>
</ul>
</li>
</ul>
<p>于是就上代码，模板题 <code>LG4254 JSOI2008 BlueMarry开公司</code>。注意本题给的直线需要平移一下再用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> b[N &lt;&lt; <span class="number">2</span>], k[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">char</span> s[N] ; <span class="keyword">int</span> m, n, v[N &lt;&lt; <span class="number">2</span>], x, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">double</span> <span class="title">val</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k[id] * (x - <span class="number">1</span>) + b[id] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">double</span> o, p, q, u, s, t ;</span><br><span class="line">    o = val(l, id), p = val(l, v[rt]) ;</span><br><span class="line">    q = val(r, id), u = val(r, v[rt]) ;</span><br><span class="line">    s = val(mid, id), t = val(mid, v[rt]) ;</span><br><span class="line">    <span class="keyword">if</span> (o &lt;= p &amp;&amp; q &lt;= u) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (o &gt; p &amp;&amp; q &gt; u) <span class="keyword">return</span> v[rt] = id, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (k[v[rt]] &gt; k[id20])</span><br><span class="line">        <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span>, l, mid, id) ;</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, v[rt]), v[rt] = id ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, id) ;</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span>, l, mid, v[rt]), v[rt] = id ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val(x, v[rt]) ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> max(val(x, v[rt]), query(rt &lt;&lt; <span class="number">1</span>, l, mid, x)) ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> max(val(x, v[rt]), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m, n = <span class="number">50001</span> ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'P'</span>)</span><br><span class="line">            ++ cnt,</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;b[cnt], &amp;k[cnt]),</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, cnt) ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)query(<span class="number">1</span>, <span class="number">1</span>, n, x) / <span class="number">100</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-一道例题"><a href="#3-一道例题" class="headerlink" title="$3$ 一道例题"></a>$3$ 一道例题</h1><p>例题就是 <code>HEOI2013 Segment</code> 。插入一条<strong>线段</strong>，维护每个横坐标的优势线段编号。</p>
<p>发现魔改一下就可以。然后一个坑点就是斜率为 $\inf$ 的线段要特殊处理一下，然而一开始自己直接把这种线段的 $\max val$ 当作 $\inf$ 算了也是很降智。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 19260817.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M1 39989</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M2 1000000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> b[N &lt;&lt; <span class="number">2</span>], k[N &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> L, m, mk, n, v[N &lt;&lt; <span class="number">2</span>], x, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">double</span> <span class="title">val</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * x * k[id] + b[id] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= ul &amp;&amp; r &lt;= ur)&#123;</span><br><span class="line">        <span class="keyword">double</span> o, p, q, u, s, t ;</span><br><span class="line">        o = val(l, id), p = val(l, v[rt]) ;</span><br><span class="line">        q = val(r, id), u = val(r, v[rt]) ;</span><br><span class="line">        s = val(mid, id), t = val(mid, v[rt]) ;</span><br><span class="line">        <span class="keyword">if</span> (o &lt;= p &amp;&amp; q &lt;= u) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">if</span> (o &gt; p &amp;&amp; q &gt; u) <span class="keyword">return</span> v[rt] = id, <span class="keyword">void</span>() ;</span><br><span class="line">        <span class="keyword">if</span> (k[v[rt]] &gt; k[cnt])</span><br><span class="line">            <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, id) ;</span><br><span class="line">            <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, v[rt]), v[rt] = id ;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (s &lt; t) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, id) ;</span><br><span class="line">            <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, v[rt]), v[rt] = id ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul, ur, id) ;</span><br><span class="line">    <span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, id) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">int</span> id = query(rt &lt;&lt; <span class="number">1</span>, l, mid, x) ;</span><br><span class="line">        <span class="keyword">if</span> (val(x, id) &gt; val(x, v[rt])) <span class="keyword">return</span> id ; <span class="keyword">else</span> <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> id = query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">        <span class="keyword">if</span> (val(x, id) &gt; val(x, v[rt])) <span class="keyword">return</span> id ; <span class="keyword">else</span> <span class="keyword">return</span> v[rt] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x + L - <span class="number">1</span>) % M1 + <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> (x + L - <span class="number">1</span>) % M2 + <span class="number">1</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, e, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m, n = <span class="number">50001</span> ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mk) ;</span><br><span class="line">        <span class="keyword">if</span> (mk)&#123;</span><br><span class="line">            ++ cnt ;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;e, &amp;c, &amp;d) ;</span><br><span class="line">            a = w(a), e = g(e), c = w(c), d = g(d) ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; a &lt;&lt; " " &lt;&lt; e &lt;&lt; " " &lt;&lt; c &lt;&lt; " " &lt;&lt; d &lt;&lt; endl ;</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt; c) swap(a, c), swap(d, e) ;</span><br><span class="line">            <span class="keyword">if</span> (c == a) k[cnt] = <span class="number">0</span>, b[cnt] = max(d, e) ;</span><br><span class="line">            <span class="keyword">else</span> k[cnt] = (<span class="keyword">double</span>)(d - e) / (<span class="keyword">double</span>)(c - a),</span><br><span class="line">                 b[cnt] = <span class="number">1.0</span> * d - <span class="number">1.0</span> * c * k[cnt] ;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; k[cnt] &lt;&lt; " " &lt;&lt; b[cnt] &lt;&lt; endl ;</span></span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, a, c, cnt) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), x = w(x),</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L = query(<span class="number">1</span>, <span class="number">1</span>, n, x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>李超树</category>
      </categories>
      <tags>
        <tag>数据结构/李超树</tag>
        <tag>数据结构/线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】对抗搜索与Alpha-Beta剪枝</title>
    <url>/2019/12/28/%E5%AF%B9%E6%8A%97%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学了一下比较简单的博弈模型的常规求解方式，发现就是爆搜。顺便学了有启发式思想的 Alpha-Beta 剪枝，现在觉得是玄学……可能还是记搜比较靠谱？</p>
<a id="more"></a>
<h1 id="1-对抗搜索"><a href="#1-对抗搜索" class="headerlink" title="1 对抗搜索"></a>1 对抗搜索</h1><p>……然而其实就是搜索。每次大概就是记录一下双方的决策结果和（哈希之后的）局面，然后改谁走谁走就完了。伪代码大概可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Function <span class="title">doMax</span><span class="params">(State S)</span></span>&#123;</span><br><span class="line">	Value res = -Inf ;</span><br><span class="line">	State Moveable_Set = calc(S) ;   </span><br><span class="line">	<span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">		Value now = evaluate(doMin(S)) ;</span><br><span class="line">		<span class="keyword">if</span> [now &gt; res] res = now ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Function <span class="title">doMin</span><span class="params">(State S)</span></span>&#123;</span><br><span class="line">	Value res = Inf ;</span><br><span class="line">	State Moveable_Set = calc(S) ;   </span><br><span class="line">	<span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">		Value now = evaluate(doMax(S)) ;</span><br><span class="line">		<span class="keyword">if</span> [now &lt; res] res = now ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> res ;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概就是交替迭代的思想。</p>
<p>考虑一棵博弈树，节点承载的信息是局面 。那么对于一个零和博弈游戏，双方必然是让自己得益更多，于是考虑转化一下，令局面的分数为「先手的分数 - 后手的分数」，那么先手就是最大化局面分数，后手则是最小化。</p>
<p>于是定义轮到<strong>最大化局面分数一方</strong>走的局面节点叫做 $\boldsymbol{Max}$<strong>节点</strong>，轮到<strong>最小化局面分数一方</strong>走的局面节点叫做 $\boldsymbol{Min}$<strong>节点</strong> 。那么显然在博弈树上同类节点集合是一个独立集。这种博弈也叫做 <strong>零和博弈完全信息公平博弈</strong> ，双方的目的均是 <strong>最值化局面分数</strong>。</p>
<h1 id="2-Alpha-Beta-剪枝"><a href="#2-Alpha-Beta-剪枝" class="headerlink" title="2 Alpha-Beta 剪枝"></a>2 Alpha-Beta 剪枝</h1><p>然后这东西就是一个剪枝，给每个节点一个 $\alpha$ 下界和 $\beta$ 上界。类比状态转移，考虑相邻的状态，大致如下：</p>
<ul>
<li><p>假设当前节点为 $\boldsymbol{Max}$ 节点，那么如果存在一种决策使得该 $\boldsymbol{Max}$ 状态的分数 $&gt;$ <strong>上一层</strong>决策的分数<strong>上限</strong> $\beta’$，那么当前节点的父亲节点，$\boldsymbol{Min}$ 状态，就一定不会做出某些决策，使得局面变成当前的 $\boldsymbol Max$ 决策。</p>
</li>
<li><p>假设当前节点为 $\boldsymbol{Min}$ 节点，那么如果存在一种决策使得该 $\boldsymbol{Min}$ 状态的分数 $&lt;$ <strong>上一层</strong>决策的分数<strong>下限</strong> $\alpha’$，那么当前节点的父亲节点，$\boldsymbol{Max}$ 状态，就一定不会做出某些决策，使得局面变成当前的 $\boldsymbol Min$ 决策。</p>
</li>
<li><p>于是我们记录 $\alpha$ 值为每个 $\boldsymbol{Max}$ 状态的<strong>得分下界</strong>，$\beta$ 值为每个 $\boldsymbol{Min}$ 状态的得分下界。初始为 $\alpha=-\infty,\beta=+\infty$</p>
</li>
<li><p>考虑优化的意义。当前状态的分支可能有很多，但是如果在搜第一个分支的时候就发现已经有 $\alpha_n&gt;\beta_{fa_n}$ 了，那么 $fa_n$ 就一定不会走这个决策（毕竟最次也可以让对方得益），于是剩下的分支就不用再搜了。</p>
</li>
<li><p>显然，这种决策是启发性的。同时有以下特点：</p>
<ul>
<li><p>决策顺序影响时间效率。如果每次搜都在第一次跳出自然可以让时间上做到最优，但是如果每次都在最后一次跳出就是压根没剪。</p>
</li>
<li><p>不可以裸的记忆化。考虑每个节点如果要记忆化，记下来的应该是当前状态能扩展到的最优局面。但是 Alpha-Beta 剪枝的目的就是在未得到这个点的最优决策时，已经知道该不该继续走。</p>
</li>
</ul>
</li>
</ul>
<p>然后就是伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Function <span class="title">doMax</span><span class="params">(State S, Value alpha, Value beta)</span></span>&#123;</span><br><span class="line">	State Moveable_Set = calc(S) ;   </span><br><span class="line">	<span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">		Value now = evaluate(doMin(S)) ;</span><br><span class="line">		<span class="keyword">if</span> [now &gt; alpha] alpha = now ;</span><br><span class="line">		<span class="keyword">if</span> [alpha &gt;= beta] <span class="keyword">return</span> alpha ;  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> alpha ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Function <span class="title">doMin</span><span class="params">(State S, Value alpha, Value Beta)</span></span>&#123;</span><br><span class="line">	State Moveable_Set = calc(S) ;   </span><br><span class="line">	<span class="keyword">for</span> : s in Moveable_Set&#123;</span><br><span class="line">		Value now = evaluate(doMax(S)) ;</span><br><span class="line">		<span class="keyword">if</span> [now &lt; beta] beta = now ; </span><br><span class="line">		<span class="keyword">if</span> [alpha &gt;= beta] <span class="keyword">return</span> beta ;  </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> beta ;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样的话，我们顶多是能快速计算谁赢谁输而不是赢多少/输多少。于是考虑魔改一下：</p>
<p>版本一：某一方获利最多。参考题目：[九省联考]一双木棋，可以拿到 $70pts$</p>
<p>其实就是修改一下终态的返回值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet, <span class="keyword">int</span> sa, <span class="keyword">int</span> sb)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (dep &gt;= N * M) <span class="keyword">return</span> sa - sb ; <span class="keyword">int</span> val, b = dep &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    memset(R[b], 0, sizeof(R[b])) ;</span></span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = R[i] + <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; "A" &lt;&lt; " " &lt;&lt; dep &lt;&lt; ".." &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">                   <span class="keyword">if</span> (!base[i][j] &amp;&amp; base[i][j - <span class="number">1</span>] &amp;&amp; base[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">                       base[i][j] = <span class="number">1</span> ; R[i] = j ;</span><br><span class="line">                       val = battle(dep + <span class="number">1</span>, i, j, alp, bet, sa + A[i][j], sb) ;</span><br><span class="line">                       base[i][j] = <span class="number">0</span> ; alp = max(val, alp) ;</span><br><span class="line">                       R[i] = <span class="number">0</span> ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">return</span> alp ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = R[i] + <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line"><span class="comment">//                    cout &lt;&lt; "B" &lt;&lt; " " &lt;&lt; dep &lt;&lt; ".." &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">                   <span class="keyword">if</span> (!base[i][j] &amp;&amp; base[i][j - <span class="number">1</span>] &amp;&amp; base[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">                       base[i][j] = <span class="number">1</span> ; R[i] = j ;</span><br><span class="line">                       val = battle(dep + <span class="number">1</span>, i, j, alp, bet, sa, sb + B[i][j]) ;</span><br><span class="line">                       base[i][j] = <span class="number">0</span>, bet = min(val, bet) ;</span><br><span class="line">                       R[i] = <span class="number">0</span> ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> bet ;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">return</span> bet ;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本二：败方存活时间最长。参考题目：[CQOI2013]棋盘游戏，可以拿到 $40pts$</p>
<p>这种的话就直接返回 $-1^{\text{胜方}}\times \text{深度}$ 即可，最大化的就是败方存活的最大深度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> xa, <span class="keyword">int</span> ya, <span class="keyword">int</span> xb, <span class="keyword">int</span> yb, <span class="keyword">bool</span> w, <span class="keyword">int</span> step, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt; <span class="number">3</span> * N) <span class="keyword">return</span> _d_a_y ;</span><br><span class="line">    <span class="keyword">if</span> (xa == xb &amp;&amp; ya == yb) <span class="keyword">return</span> w ? -step : step ; <span class="keyword">int</span> val ;</span><br><span class="line">    <span class="keyword">if</span> (!w)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = xa + dx[i], ky = ya + dy[i] ;</span><br><span class="line">            <span class="keyword">if</span> (kx &lt;= N &amp;&amp; ky &lt;= N &amp;&amp; kx &gt;= <span class="number">1</span> &amp;&amp; ky &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                val = dfs(kx, ky, xb, yb, w ^ <span class="number">1</span>, step + <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                alp = max(alp, val) ; <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> alp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span> ; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = xb + dx[i], ky = yb + dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (kx &lt;= N &amp;&amp; ky &lt;= N &amp;&amp; kx &gt;= <span class="number">1</span> &amp;&amp; ky &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            val = dfs(xa, ya, kx, ky, w ^ <span class="number">1</span>, step + <span class="number">1</span>, alp, bet) ;</span><br><span class="line">            bet = min(val, bet) ; <span class="keyword">if</span> (bet &lt;= alp) <span class="keyword">return</span> bet ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bet ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-两道例题"><a href="#3-两道例题" class="headerlink" title="3 两道例题"></a>3 两道例题</h1><p>uva好啊。</p>
<h2 id="1-UVA10111-Find-the-Winning-Move"><a href="#1-UVA10111-Find-the-Winning-Move" class="headerlink" title="$(1$ UVA10111 Find the Winning Move"></a>$(1$ UVA10111 Find the Winning Move</h2><blockquote>
<p>两人下 $4\times 4$ 的井字棋，给出一个残局，问是否有先手必胜策略。</p>
<p>井字棋：必须要四子连珠才能赢。</p>
</blockquote>
<p>这东西只问赢没赢，于是就可以愉快地把局面分数赋为 $1/-1$。搜就完事了233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">        res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">            res += (<span class="keyword">bool</span>)(base[i][j] == x) ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">            res += (<span class="keyword">bool</span>)(base[j][i] == x) ;</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">        res += (<span class="keyword">bool</span>)(base[i][i] == x) ;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">        res += (<span class="keyword">bool</span>)(base[i][<span class="number">5</span> - i] == x) ;</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">1</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = (ans - step) &amp; <span class="number">1</span>, val ;</span><br><span class="line">    <span class="keyword">if</span> (!st)&#123;</span><br><span class="line">        <span class="keyword">if</span> (check(<span class="number">2</span>) || !step) <span class="keyword">return</span> -check(<span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!base[i][j])&#123;</span><br><span class="line">                    base[i][j] = <span class="number">1</span> ;</span><br><span class="line">                    val = battle(step - <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                    base[i][j] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">if</span> (val &gt; alp)&#123;</span><br><span class="line">                        alp = val ;</span><br><span class="line">                        <span class="keyword">if</span> (step == ans)</span><br><span class="line">                            resx = i - <span class="number">1</span>, resy = j - <span class="number">1</span> ;</span><br><span class="line">                        <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> alp ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> alp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (check(<span class="number">1</span>) || !step) <span class="keyword">return</span> check(<span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (!base[i][j])&#123;</span><br><span class="line">                    base[i][j] = <span class="number">2</span> ;</span><br><span class="line">                    val = battle(step - <span class="number">1</span>, alp, bet) ;</span><br><span class="line">                    base[i][j] = <span class="number">0</span>, bet = min(val, bet) ;</span><br><span class="line">                    <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">return</span> bet ;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> bet ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'$'</span>) <span class="keyword">return</span> <span class="number">0</span> ; ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, bc[i] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)&#123;</span><br><span class="line">                base[i][j] = bc[i][j] == <span class="string">'x'</span> ? <span class="number">1</span></span><br><span class="line">                          : (bc[i][j] == <span class="string">'.'</span> ? <span class="number">0</span> : <span class="number">2</span>) ;</span><br><span class="line">                ans += (!base[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= <span class="number">12</span>) &#123; <span class="built_in">puts</span>(<span class="string">"#####"</span>) ; <span class="keyword">continue</span> ;&#125;</span><br><span class="line">        ans = battle(ans, <span class="number">-1</span>, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"(%d,%d)\n"</span>, resx, resy) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"#####"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-UVA751-Triangle-War"><a href="#2-UVA751-Triangle-War" class="headerlink" title="$(2$ UVA751 Triangle War"></a>$(2$ UVA751 Triangle War</h2><blockquote>
<p>给出 $10$ 个点，共有 $18$ 条边，每次 $A,B$ 两个人轮流加入一条边。A先加。</p>
<p>如果形成一个三角形，则三角形归他所有，<strong>而且还必须再走一步</strong>。最后三角形多的人胜。</p>
<p>现在已经给出一部分已经完成的步数，由于两位玩家都是<strong>最聪明的</strong>，他们都会走<strong>为自己带来最大优势</strong>的步数。你需要判断谁会赢得游戏。</p>
</blockquote>
<p>一道憨憨题。发现可以直接状压且每个询问图不变，所以果断<del>打开题解找到思路差不多的把打的表copy过来</del>手推。然后其实就是一开始先把初始状态走完，然后因为一共九个三角形，所以如果一方比另一方多 $5$ 个游戏就结束了，于是发现可以把这个差值当做局面分数，搜就完事了。</p>
<p>还有一个烂大街的 $trick$，按秩转移每条边于是想到 $\rm lowbit$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> Q, T, M, A[N][N], st[<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> e[<span class="number">11</span>][<span class="number">11</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">17</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">16</span>&#125;, &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">17</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">16</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> t[<span class="number">9</span>] = &#123;<span class="number">7</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">448</span>, <span class="number">3584</span>, <span class="number">6160</span>, <span class="number">28672</span>, <span class="number">49280</span>, <span class="number">229376</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;p, <span class="keyword">const</span> <span class="keyword">int</span> &amp;q)</span></span>&#123;</span><br><span class="line">    rg <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rg <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">8</span> ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (((p &amp; t[i]) != t[i]) &amp;&amp; ((q &amp; t[i]) == t[i])) ++ ret ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">battle</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> s, <span class="keyword">int</span> alp, <span class="keyword">int</span> bet)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st[<span class="number">0</span>] &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (st[<span class="number">1</span>] &gt;= <span class="number">5</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> O = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>, ss ;</span><br><span class="line">    <span class="keyword">int</span> _rest = s ^ O, now, val ;</span><br><span class="line">    <span class="keyword">for</span> ( ; _rest ; _rest -= low(_rest))&#123;</span><br><span class="line">        now = calc(s, ss = s | low(_rest)) ;</span><br><span class="line">        <span class="keyword">if</span> (n)</span><br><span class="line">            st[n] += now,</span><br><span class="line">            val = battle(n ^ (((<span class="keyword">bool</span>)now) ^ <span class="number">1</span>), ss, alp, bet),</span><br><span class="line">            bet = min(bet, val), st[n] -= now ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            st[n] += now,</span><br><span class="line">            val = battle(n ^ (((<span class="keyword">bool</span>)now) ^ <span class="number">1</span>), ss, alp, bet),</span><br><span class="line">            alp = max(alp, val), st[n] -= now ;</span><br><span class="line">        <span class="keyword">if</span> (alp &gt;= bet) <span class="keyword">break</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n ? bet : alp ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T, Q = T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;M) ;</span><br><span class="line">        st[<span class="number">0</span>] = st[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> _state = <span class="number">0</span>, n = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x, y, z, i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), </span><br><span class="line">            z = calc(_state, _state | (<span class="number">1</span> &lt;&lt; e[x][y])) ;</span><br><span class="line">            _state |= (<span class="number">1</span> &lt;&lt; e[x][y]), st[n] += z, n ^= (((<span class="keyword">bool</span>)z) ^ <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; _state &lt;&lt; " " &lt;&lt; n &lt;&lt; endl ;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Game %d: "</span>, Q - T) ;</span><br><span class="line">        <span class="keyword">if</span> (battle(n, _state, <span class="number">-23333</span>, <span class="number">23333</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"A wins.\n"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"B wins.\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学这个就图一乐。想得高分请记搜/kel。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>搜索/剪枝</tag>
        <tag>博弈论/对抗搜索</tag>
        <tag>博弈论/Alpha-Beta剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】构造题选做 · 2</title>
    <url>/2019/12/24/%E6%9E%84%E9%80%A02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没啥特别原因，就是底下那篇文章题太多了就分流出一部分。</p>
<a id="more"></a>
<h3 id="1-UVa1697"><a href="#1-UVa1697" class="headerlink" title="$1$ UVa1697"></a>$1$ UVa1697</h3><blockquote>
<p>给定一排长度为 $4n$ 的格子，编号从 $-2n+1$ 到 $2n$ 每个编号为正的格子中有一个物品，其中每个编号为奇数的格子中有一个 $B$ 类物品，编号为偶数的格子中有一个 $A$ 类物品。</p>
<p>你只能进行一种操作：选择某两个相邻的都有物品的格子，移动到另外两个相邻的空格子中，同时不能改变两个格子的相对位置。</p>
<p>要求进行最少的操作使得所有物品以 <code>AAA…ABBB…B</code> ($n$ 个 $A$ 和 $n$ 个 $B$) 的形式排列在一起 输出一种可行方案 </p>
<p>$3\leq n \leq 100$</p>
</blockquote>
<p>人类智慧学不来了orz</p>
<p>考虑 $n=3,4,5,6,7$ 的时候都可以人类智慧。那么对于 $n &gt; 7$ 时考虑增量构造，即从 $n$ 构造到 $n+4$。</p>
<p>那么 $n=4$ 时可以这么构造：</p>
<blockquote>
<p><code>__babababa</code></p>
<p><code>abbabab__a</code></p>
<p><code>abba__bbaa</code></p>
<p><code>a__abbbbaa</code></p>
<p><code>aaaabbbb__</code></p>
</blockquote>
<p>然后考虑对于 $n+4$，记 $|BA|$  表示有一堆 <code>bababa</code> 这种东西。</p>
<p>那么考虑 $n+4$ 可以这么玩：</p>
<blockquote>
<p><code>__|BA|</code></p>
<p><code>ab|BA|b__a</code></p>
<p><code>abba__|BA|bbaa</code></p>
</blockquote>
<p>发现中间那一段和起始状态是一样的，就可以大力递归，回代的时候回代一下即可。</p>
<p>$n=3\sim 7$ 我选择直接从网上抄来别人的人类智慧，毕竟我莫得智慧.jpg</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" to "</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = R - L + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">3</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(<span class="number">2</span>, <span class="number">-1</span>), oo(<span class="number">5</span>, <span class="number">2</span>), oo(<span class="number">3</span>, <span class="number">-3</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">4</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">5</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, L + <span class="number">5</span>), oo(L - <span class="number">1</span>, L + <span class="number">2</span>), oo(L + <span class="number">6</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">5</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">7</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, L + <span class="number">7</span>),</span><br><span class="line">               oo(L + <span class="number">5</span>, L + <span class="number">2</span>), oo(L - <span class="number">1</span>, L + <span class="number">5</span>), oo(L + <span class="number">8</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">6</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">9</span>, L - <span class="number">2</span>), oo(L + <span class="number">6</span>, L + <span class="number">9</span>), oo(L + <span class="number">1</span>, L + <span class="number">6</span>),</span><br><span class="line">               oo(L + <span class="number">5</span>, L + <span class="number">1</span>), oo(L - <span class="number">1</span>, L + <span class="number">5</span>), oo(L + <span class="number">10</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">7</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> oo(L + <span class="number">7</span>, L - <span class="number">2</span>), oo(L + <span class="number">4</span>, L + <span class="number">7</span>), oo(L + <span class="number">11</span>, L + <span class="number">4</span>),</span><br><span class="line">               oo(L + <span class="number">2</span>, L + <span class="number">11</span>), oo(L + <span class="number">8</span>, L + <span class="number">2</span>), oo(L - <span class="number">1</span>, L + <span class="number">8</span>), oo(L + <span class="number">12</span>, L - <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">    oo(R - <span class="number">2</span>, L - <span class="number">2</span>), oo(L + <span class="number">2</span>, R - <span class="number">2</span>), work(L + <span class="number">4</span>, R - <span class="number">4</span>), oo(L - <span class="number">1</span>, R - <span class="number">5</span>), oo(R - <span class="number">1</span>, L - <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N) work(<span class="number">1</span>, N * <span class="number">2</span>), <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-BZOJ4148-Pillars"><a href="#2-BZOJ4148-Pillars" class="headerlink" title="$2$ BZOJ4148 Pillars"></a>$2$ BZOJ4148 Pillars</h3><blockquote>
<p>给定一个 $n\times m$ 的矩形，其中有 $f$ 个 $2\times 2$ 的障碍物，其中任意两个障碍物中心之间的欧几里得距离至少为 $6$，且每个障碍物的中心到边缘的距离至少为 $3$。</p>
<p>请找到一条从左下角 $(1,1)$ 出发经过所有没有障碍物的点各一次的且最后回到左下角的回路。</p>
<p>保证 $n,m$ 均为偶数，且 $1\leq n,m\leq 1000$ .</p>
</blockquote>
<p>就是考虑如果没有障碍的走法，由于 $n,m$ 都是偶数，所以可以从 $(1,1)$ 上到 $(1,n)$，然后从 $(1,n)$ 到 $(n,n)$ 再到 $(n,n-1)$ 再到 $(2,n-1)$ 这么蛇形走。</p>
<p>考虑有了障碍，因为每个障碍可以看做是独立的的，所以大概可以这么走：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="qwq.png" alt=""></p>
<p>其中紫色是障碍，黄色是原来的路线，红色是新的。由于 $6$ 的限制，所以可以这么绕。</p>
<p>所以是道细节题233</p>
<p>代码先鸽着，什么时候有心情再写。s</p>
<h3 id="3-【UR-6】-智商锁"><a href="#3-【UR-6】-智商锁" class="headerlink" title="$3$ 【UR #6】 智商锁"></a>$3$ 【UR #6】 智商锁</h3><blockquote>
<p>构造一个节点数不超过 $100$ 的无向图，使其生成树个数对 $998244353$ 取模的结果为 $k$ 。</p>
<p>$k\leq 10^9$</p>
</blockquote>
<p>看题，仔细一想，莫非是什么神秘的 $\boldsymbol{EGF}$ 大力乱搞（警觉）。</p>
<p>结果人傻了……以下是官方做法：</p>
<p>考虑如果两个图只有一个公共点，那么生成树个数为两个图相乘。那么随机 $1000$ 个随机无向图，两两拼凑出 $10^6$ 个无向图，然后对每一个在 <code>map</code> 里找 $k$ 的逆元即可。<del>如果没有就再随机一遍。</del></p>
<p>发现这样实际上几乎不可能没有解。。。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://img.uoj.ac/utility/bear-thinking.gif" alt="思考熊"></p>
<p>降智打击.jpg</p>
<h3 id="4-【UNR-1】Jakarta-Skyscrapers"><a href="#4-【UNR-1】Jakarta-Skyscrapers" class="headerlink" title="$4$  【UNR #1】Jakarta Skyscrapers"></a>$4$  【UNR #1】Jakarta Skyscrapers</h3><blockquote>
<p>有一个数集，最初其中只有 $a$ 和 $b$。</p>
<p>你可以进行最多 $400$ 次操作，每次选择集合中满足 $i&gt;j$ 的 $i$ 和 $j$，把 $i-j$ 加入集合中，使得最后 $c$ 在这个集合中。</p>
<p>$a,b,c\leq 10^{18}$</p>
</blockquote>
<p>考虑构造中间状态。发现可以用 $a-(a-b-c)$ 构造 $b+c$， 可以用 $a-(a-b-b)$ 构造倍增，于是考虑先辗转相除得到 $1$，然后倍增，然后就没了。注意，如果一开始 $(a,b) \not|~c$ 的话是无解的。那么考虑同除<br>$(a,b)$ 就可以快乐地更相减损得到 $1$ 了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>技巧/倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】构造题选做 · 1</title>
    <url>/2019/12/24/%E6%9E%84%E9%80%A01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从网课和 <code>uoj</code> 群里的课件扒出来的构造题，都挺(不)好(会)的(做)。</p>
<a id="more"></a>
<h3 id="1-神秘的题目"><a href="#1-神秘的题目" class="headerlink" title="1 神秘的题目"></a>1 神秘的题目</h3><p>设 $f_A$ 表示 $A$ 的本质不同子串个数<br>给出 $x, y$，要求构造出两个字符串 $A, B$<br>满足：<br>$f_A = x , f_B = y , f_{A+B} = x + y$</p>
<p>$x, y ≤ 5000$</p>
<hr>
<p>考虑 $x$ 个 $a$，$y$ 个 $a$ ，然后拼起来就好……</p>
<h3 id="2-CF743C"><a href="#2-CF743C" class="headerlink" title="2 CF743C"></a>2 CF743C</h3><p>给出 n，构造出 x, y, z，满足：</p>
<script type="math/tex; mode=display">
\frac{2}{n} = \frac{1}{x}+\frac{1}{y}+\frac{1}{z}\\\
x\not= y, x\not= z, y\not= z</script><p>无解输出 −1<br>$n ≤ 10^4$</p>
<hr>
<p>考虑通分（分时裂项），即</p>
<script type="math/tex; mode=display">
\frac{1}{n}-\frac{1}{n+1}=\frac{1}{n(n+1)}\\\
\frac{1}{n}=\frac{1}{n+1}+ \frac{1}{n(n+1)}\\\
\frac{2}{n}=\frac{1}{n} + \frac{1}{n+1}+ \frac{1}{n(n+1)}</script><p>然后就做完了。</p>
<p>注意1要特判。</p>
<h3 id="3-CF359B"><a href="#3-CF359B" class="headerlink" title="3 CF359B"></a>3 CF359B</h3><p>给出 $n, k , 2k ≤ n$，构造出 $2n$ 的一个排列，满足：</p>
<script type="math/tex; mode=display">
∑^n_{i=1} |a_{2i−1} − a_{2i}| − |∑^n_{i=1}(a_{2i−1} − a_{2i})| = 2k</script><p>$n ≤ 50000$</p>
<hr>
<p>寄几想了一种构造，就是$a_{i+1} = a_i+k,~i=2p,~p \in \mathbb{N+}$，然后随便两次交换两项就好了。然而并不对，因为这样构造出的结果并不合法；于是遂决定改成$a_{i+1} = a_i+2k,~i=2p,~p \in \mathbb{N+}$，但也不对，单次交换的步长太长了，是$4k$。于是我又想能否有什么诡异的交换方法可以补救回来$2k$……失败了qaq</p>
<p>然而其实很简单，我们只要把步长控制为$1$就一定能凑出来。所以一开始先令$a_i=a_{i+1}+1$这种感觉，然后交换$k$次即可。</p>
<h3 id="color-violet-4-rm-CF-it-512E"><a href="#color-violet-4-rm-CF-it-512E" class="headerlink" title="$\color{violet}{4~ \rm{CF}\it{512E}}$"></a>$\color{violet}{4~ \rm{CF}\it{512E}}$</h3><p>对于一个正 n 边形，可以用 n − 3 条边分成 n − 2 个三角形<br>给出两种划分，你需要进行若干次操作把第一种划分变成第二种划分<br>每次操作选择一个四边形删去它的对角线，连另外一条对角线<br>n ≤ 1000，操作次数不超过 20000</p>
<hr>
<p>开始掉线……</p>
<p>其实主要思想就是<del>酱油瓶</del>状态替换，把起始状态 $s$ 变成对角线都从 $1$ 出发的状态 $p$，再从 $p$ 出发变成终态 $t$。</p>
<p>具体操作好像是</p>
<p>别想了，掉线了怎么可能还会有？</p>
<h3 id="5-神秘的题目"><a href="#5-神秘的题目" class="headerlink" title="$5$ 神秘的题目"></a>$5$ 神秘的题目</h3><blockquote>
<p>给出一棵树，定义一个点的邻居集合为到它距离 $\leq 2$ 的所有点。</p>
<p>给出所有点的邻居集合，还原原树。</p>
<p>$n\leq 1,000$</p>
</blockquote>
<p>考虑一个结论，如果两个点的邻居集合交集大小为 $2$， 那么交集中的点一定有连边。（$\rm bitset$ 做到 $\frac{n^3}{w}$）</p>
<p>于是就可以先把 <strong>非叶子节点</strong> 两两之间的连边求出来</p>
<p>然后考虑如何求出叶子。发现叶子有个性质，就是叶子到某些非叶节点的距离一定 $=$ 与之相邻的非叶节点到某些非叶节点的距离 $+1$。所以就可以再把离每个非叶节点距离为 $1$ 的非叶节点求出来，称这个点集为<strong>旁边集合</strong>。那么如果叶子 $u$ 的邻居集合与非叶节点 $v$ 的旁边集合相同，那么 $u$ 就一定挂在 $v$ 上。</p>
<h3 id="6-AT3877"><a href="#6-AT3877" class="headerlink" title="$6$ AT3877"></a>$6$ AT3877</h3><blockquote>
<p>给定 $\rm X,Y$， 给出 $[d_{i,j}]$ 表示当 $\mathrm X=i,\mathrm Y=j$ 时，$\rm S$ 到 $\rm T$ 的最短路。</p>
<p>构造这张图，使之点数 $&lt;300$，无自环和重边，每条边的权值 $\leq 100$， 权值可以是数也可以是 $\rm X,Y$，并给出 $\rm S,T$ 。</p>
</blockquote>
<p>设 $g_{i,j}$ 表示从 $\rm S$ 到 $\rm T$ ，经过了包含 $i$ 条 $\rm X$ 边， $j$ 条 $\rm Y$ 边的路径，其它边的边权最小和。</p>
<p>那么发现这东西可以这么转移出 $[d_{i,j}]$来</p>
<script type="math/tex; mode=display">
d_{i,j}= \min_{p,q}{(p\cdot i+q\cdot j + g_{p,q})}</script><p>然后可以得到松弛条件</p>
<script type="math/tex; mode=display">
\forall p,q, \quad \exists~ d_{i,j}\leq p\cdot i+q\cdot j+g_{p,q}</script><p>移项可以得到</p>
<script type="math/tex; mode=display">
g_{p,q}=\max_{i,j}{(d_{i,j}-p\cdot i - q\cdot j)}</script><p>于是考虑求出 $g $ ，之后反推出 $[d_{i,j}]’$ 观察是否吻合。吻合则考虑根据经过的 $\rm X,Y$ 连边即可。</p>
<h3 id="7-ARC-095F"><a href="#7-ARC-095F" class="headerlink" title="$7$ ARC 095F"></a>$7$ ARC 095F</h3><blockquote>
<p>给定一棵树 $\rm T$, 要求构造一个排列 $p$ .</p>
<p>对于每一个 $p_i$ ，找到最大的 $j$ 使得 $p_j&lt;p_i$，然后在 $i,j$ 间连边。</p>
<p>问是否可以构造出与 $\rm T$ 同构的树。</p>
<p>如果可以，则给出字典序最小的排列。</p>
<p>$n\leq 100,000$ </p>
</blockquote>
<p>考虑如果给定一个排列，如何通过这种方式生成一棵树。那肯定是按照权值从小到大枚举每个权值所在的位置，每次在 $\max_right$ 和枚举的 $i$ 之间连边，并更新 $\max_right$。</p>
<p>可以发现，由于给定的是排列，局部最大值唯一，那么只会出现「非局部最大值向局部最大值连边」和「上一个版本的局部最大值和当前局部最大值连边」两种连边方式。所以不难看出最后的树的形态就是一个一阶毛毛虫——直径旁边挂着一堆点，每个点与直径的距离均为 $1$ 。所以是否合法求一下直径然后check即可。</p>
<p>考虑如何构造。发现只要求同构，那么肯定是从 $1$ 开始重新编号。对于每个直径上的 $x$，设<strong>与其相连且不在直径上</strong>的点的个数为 $\deg_x$，迄今为止一共有 $s$ 个点已经编完号了，那么只要让 $x=s+\deg_x+1$，剩下的点依次赋值为 $s+1,s+2,s+3\cdots s+\deg_x$ 就完了。可以知道这样一定是最优的方案。</p>
<p>从直径两端分别处理一下取个字典序最小即可。复杂度 $O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> faa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = u, s ;</span><br><span class="line">    fa[u] = faa, dep[u] = dep[faa] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != faa)&#123;</span><br><span class="line">            s = dfs(to(k), u) ;</span><br><span class="line">            <span class="keyword">if</span> (dep[ret] &lt; dep[s]) ret = s ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n ;</span><br><span class="line">    <span class="keyword">int</span> rt1, rt2, num, u, v ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), add(u, v) ;</span><br><span class="line">    rt1 = dfs(<span class="number">1</span>, <span class="number">0</span>) ; fa[rt1] = <span class="number">0</span> ;</span><br><span class="line">    dep[rt1] = <span class="number">0</span> ; rt2 = dfs(rt1, <span class="number">0</span>) ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; rt1 &lt;&lt; " " &lt;&lt; rt2 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> ( ; rt2 ; rt2 = fa[rt2])</span><br><span class="line">        vis[rt2] = <span class="number">1</span>, d[++ tot] = rt2 ;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; tot &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span> ; <span class="keyword">bool</span> ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[i] ; k ; k = next(k))</span><br><span class="line">            <span class="keyword">if</span> (vis[to(k)]) &#123; deg[to(k)] ++, ans = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ans) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= tot ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= deg[d[i]] ; ++ j)</span><br><span class="line">            p[num + j] = num + j + <span class="number">1</span> ;</span><br><span class="line">        p[num + deg[d[i]] + <span class="number">1</span>] = num + <span class="number">1</span> ; num += deg[d[i]] + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= deg[d[i]] ; ++ j)</span><br><span class="line">            q[num + j] = num + j + <span class="number">1</span> ;</span><br><span class="line">        q[num + deg[d[i]] + <span class="number">1</span>] = num + <span class="number">1</span> ; num += deg[d[i]] + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (p[i] != q[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] &lt; q[i])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[j]) ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[j]) ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; ++ j)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[j]) ; <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-小题整理"><a href="#8-小题整理" class="headerlink" title="$8$ 小题整理"></a>$8$ 小题整理</h3><p>8.1 覆盖</p>
<blockquote>
<p>平面上给定 $n$ 个点，每个点可以覆盖 $\frac{1}{4}$ 的平面，求最少需要多少个点才能覆盖所有点</p>
</blockquote>
<hr>
<p>orz我和ouuuyuuu一开始觉得题很傻，最多四个，结果发现原来最多两个就可以，然后发现我们很傻。。</p>
<p>找某一维坐标最大/最小的两个点，再判一下是不是只需要一个点就可以满足，就做完了。</p>
<p>8.2 CF477B</p>
<blockquote>
<p>有 $n$ 个集合，彼此交集为空。</p>
<p>每个集合有 $4$ 个元素，两两之间均有 $\gcd = k$</p>
<p>求 $4n$ 个数中最大值的最小值</p>
<p>$1\leq n\leq 10000$</p>
</blockquote>
<p>发现可以同除以 $k$ ，于是就变成两两互质了，于是 $4$ 个数中至多 $1$ 个偶数。</p>
<p>同时发现一个<del>鬼能发现的</del>性质，就是相邻两个奇数一定互质，那么就构造 </p>
<script type="math/tex; mode=display">
\mathrm{S}:\{6i-1,6i-3,6i-5,6i-4 \}</script><p>可知它们互质。然后就没了。</p>
<h3 id="9-CF-527D"><a href="#9-CF-527D" class="headerlink" title="$9$ CF 527D"></a>$9$ CF 527D</h3><blockquote>
<p>每个元素有一个 $a_i$ 一个 $b_i$ .</p>
<p>求一个最大的点集使得 $\forall p,q\in \mathrm{S},\quad |a_p-a_q|\geq b_p+b_q$</p>
<p>$n\leq 200,000$</p>
</blockquote>
<p>我丢，其实就是把每个元素看做 $(a_i-b_i,a_i+b_i)$ 这么一段区间，然后求的就是最长不相交的区间个数。</p>
<p>然后就没了……就没了……</p>
<h3 id="10-ARC-084D"><a href="#10-ARC-084D" class="headerlink" title="$10$ ARC 084D"></a>$10$ ARC 084D</h3><blockquote>
<p>求出 $K$ 的倍数中，各位数字的和最小的那个数字的数字和。</p>
<p>$K \leq 100,000$</p>
</blockquote>
<p>考虑从 $i$ 到 $i+1$ 连一条长度为 $1$ 的边，$i$ 到 $10\cdot i$ 连长度为 $0$ 的边。然后按照$\bmod k$ 的余数建边，最后就是  $1\to 0$ 的最短路。</p>
<h3 id="11-神秘的题目"><a href="#11-神秘的题目" class="headerlink" title="$11$ 神秘的题目"></a>$11$ 神秘的题目</h3><blockquote>
<p>给出一张 $n \cdot m$ 的网格图，曼哈顿距离为 $2$ 或 $3$ 的点之间连一条边，构造出一条哈密尔顿回路。</p>
<p>可能无解。哈密尔顿回路：经过每个点恰一次。</p>
</blockquote>
<p>发现可以走法可以是棋盘染色，即黑白相间染色，先走完黑色再走完白色。</p>
<p>发现只有 $n=2,m=2$ 时无解。当 $\min(n,m)=1$ 时，考虑 $(1,2),(1,3),(2,4),(2,5)$ 都必须连（保证有回路），剩下的瞎构造即可。</p>
<h3 id="12-CF-468A"><a href="#12-CF-468A" class="headerlink" title="$12$ CF 468A"></a>$12$ CF 468A</h3><blockquote>
<p>用 $1\sim n$ 的所有数凑出 $24$，输出方案。</p>
<p>每个数都要用，只能用 <code>+</code>、<code>-</code>、<code>×</code> 三种运算。 $n\leq 100,000$</p>
</blockquote>
<p>发现 $n\leq 3$ 显然不行。</p>
<p>然后 $n=4$ 的时候阶乘即可，$n=5$ 的时候发现可以 $5\times 3+4\times 2+1$ 这么算。</p>
<p>然后考虑 $n&gt;5$，那么 $n$ 一定可以由 $n-2$ 推过来，因为只要乘上 $n-(n-1)$ 即可。发现这样总是可以构造出来合法解。</p>
<h3 id="13-Loj-525"><a href="#13-Loj-525" class="headerlink" title="$13$ Loj #525"></a>$13$ Loj #525</h3><blockquote>
<p>给定一个正整数 $k$，你需要寻找一个系数均为 $0$ 到 $k−1$ 之间的非零多项式 $f(x)$，满足对于任意整数 $x$ 均有 $f(x)≡0~(\bmod k)$</p>
<p>要求 $\deg(f)\leq 60000$</p>
<p>$k\leq 30000$<br>首先发现只要对 $0\sim k-1$ 成立那么就满足条件。 <del>然后就变成傻题了，分治FFT！分治FFT！</del></p>
</blockquote>
<p>然而分治FFT会T。不妨令 $q\geq \varphi(k)$，则由于扩展欧拉定理有：</p>
<script type="math/tex; mode=display">
x^q\equiv x^{q\bmod \varphi(k)+\varphi(k)}(\mod k)</script><p>那么如果令 $v=q+\varphi(k)$，就会有</p>
<script type="math/tex; mode=display">
\begin{aligned}
x^v & \equiv x^{v\bmod \varphi(k)+\varphi(k)} (\bmod k) \\\ &\equiv x^{(q\bmod \varphi(k)+\varphi(k) \bmod \varphi(k))\bmod \varphi(k) +\varphi(k)} (\bmod k)\\\ & \equiv x^{q\bmod \varphi(k)+\varphi(k)}(\bmod k)\\\ & \equiv x^q(\bmod k)
\end{aligned}</script><p>然后就构造第 $\varphi(k)$ 项系数为 $k-1$，第 $2\cdot \varphi(k)$ 项系数为 $1$ 即可。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>构造</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>【练习记录】之前的杂题整理（To Be Continued....）</title>
    <url>/2019/12/22/%E6%9D%82%E9%A2%98%E6%B3%9B%E5%81%9A%C2%B7%E4%B9%8B%E5%89%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要是 <code>CSP-S 2019</code> 之前的杂题整理？</p>
<p>天知道我为了整理这些东西要花费怎样漫长的时间去 read back 我的提交记录……</p>
<a id="more"></a>
<hr>
<p>1、<a href="https://www.luogu.com.cn/problem/P1357" target="_blank" rel="noopener">LG5317 花园</a></p>
<p>发现一共只有两种方格，并且转移只跟 $\rm M$ 有关，于是考虑状压。考虑 $g(s, t)$ 表示从状态 $s$ 转移到 $t$ 的方案数。其中转移指的是向右扩展一格。</p>
<p>那么显然这东西可以 <code>dfs</code> 预处理出来。然后发现这东西类似于 <code>floyd</code> 的转移矩阵，然后就快速幂。考虑由于花圃是个环，那么合法的方案就是 $1…m$ 和 $n+1….n+m$ 要相同。所以就直接把开头结尾相同的累加一波。</p>
<p>2、<a href="https://www.luogu.com.cn/problem/P4318#submit" target="_blank" rel="noopener">LG4218 完全平方数</a></p>
<p>一道傻题，大概就是考察 $\mu$ 的性质。</p>
<ul>
<li><p>$\rm Algorithm~1$</p>
<ul>
<li>发现可以容斥，且 $\mu$ 函数的性质在于，$\mu (x) = (-1)^k$，当且仅当 $x$ 不含平方因子且 $x$ 的不同素因子个数为 $k$。所以就考虑先二分，二分完了求一下 </li>
<li><script type="math/tex; mode=display">
\sum _{i=1}^{\sqrt n} \mu(i)\lfloor \frac{n}{i^2}\rfloor</script><ul>
<li>就变成傻题了。复杂度 $T \cdot \sqrt n \log n$</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>顺便记录一个很绝的 <code>idea</code></p>
<ul>
<li><p>$\rm Algorithm~2$</p>
<ul>
<li><p>根据 $\mu$ 的性质，发现似乎只有 $\mu(x) = 0$ 时，$x$ 才会被讨厌。所以其实二分求的就是 </p>
<ul>
<li><script type="math/tex; mode=display">
\sum _{i=1}^{x}\mu^2(x)\leq K</script><p>然后我们发现这东西可以直接杜教筛。于是复杂度就变成了 $T\cdot n^{\frac{2}{3}} \log n$。然而实际记忆化了会更快。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><del>但显然杜教筛被暴力给爆锤了好吗</del></p>
<p>3、[]</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>泛做</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>思维题/容斥</tag>
        <tag>数学/线性代数/矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>【游记】CSP-S2019游记</title>
    <url>/2019/12/20/CSP-S2019%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想不到吧，还有这个时候写游记的。</p>
<p>在机房啥题都做不动了，难受。于是打算写篇游记？不过CSP已经过去几百年了啊，我这篇文章按道理应该已经属于“历史文献”而不是“游记”了吧233</p>
<p>这是一个什么故事呢？这只是一个普通人在挣扎的故事而已吧。</p>
<a id="more"></a>
<h1 id="rm-Day-quad"><a href="#rm-Day-quad" class="headerlink" title="$\rm Day\quad -???$"></a>$\rm Day\quad -???$</h1><p>LCEZ机房终于只剩8个人了。</p>
<p>分别是经常会灵光一现的wxl，稳得一批的yjk，经常被膜被AKIOI的wx，玩梗宅男ljp，爱占便宜的lwy，智商不低的qcr，首席颓蛋/电视导购lzr和我。</p>
<p>其实初三刚来实验班一开始是12个人，但是后来1个人去了友校，1个人选择在 <code>NOIP2018</code> 之前去学文化课，我们把她在团队里的名字改成了“等你回来”，但是最后也没等到；剩下两个人选择考完NOIP2018就退出，现在其中一个因为选了一科地理去了平行班，另一个选择留在文化课班专攻文化课。当然，那就是另一个故事了。</p>
<p>NOIP2018，我们之中有人考得很好，有人铩羽而归，而我属于后者。所以大家都在积极准备着，选择在国庆之后就停课。</p>
<p>国庆的时候，我和lzr，wx和qcr去了青岛参加正睿，自认为是停课效果排名比较靠前的一次外出培训了。我只记得前几天每天闲的时候会选择去打 _This is the police 2_，并且在走的前一天成功丢了身份证awa，lzr 则在狂颓上古卷轴Online，wx和qcr在另一个屋，所以我并不清楚。无论怎样，青岛的培训也是很值得回忆的吧。我到现在也可以回想起夜里无人的大街、昏黄的房间只有一件台灯、抑郁的我、经常去买的大桶雪碧和辣条<del>和我丢了的身份证</del>。</p>
<p>无论怎样，青岛的外卖没有济南的好吃，嘿嘿。</p>
<h1 id="rm-Day-quad-1"><a href="#rm-Day-quad-1" class="headerlink" title="$\rm Day\quad -??$"></a>$\rm Day\quad -??$</h1><p>我选择把每天上午安排给ZR的模拟赛，一般名次都不会很高，唉菜死了。</p>
<p>剩下人可能在做题，可能在颓。印象最深刻的就是我每五次去找yjk玩，有三次他都在刷知乎。。。</p>
<p>发现自己无论什么大型比赛之前都会发现自己原来有整理不完的博客，平时习惯太差带来的后果真可怕e</p>
<p>不过似乎是有我引起的一阵风，机房里大家都开始晚上喝_香飘飘_，甚至连铁公鸡yjk也拔毛了买过几次奶茶，于是走廊上就一股浓郁的奶茶味233</p>
<p>之前嘛，就做了做<code>dp</code>，学了学<code>odt</code>，第一次写莫队结果被逼着调了半天最后套了个线段树。剩下的或许就没有什么印象深刻的事情了。</p>
<p>哦，胜利一中的神仙们一直很在状态。我就很奇怪为什么会有人每天坚持打比赛还能坚持整完所有题目的……期间我整天听歌，还抽了一个晚上看了集《奇葩说》，感觉李诞认真起来实力也不弱蛤。</p>
<p>要来了吗？要来了吧。</p>
<h1 id="rm-Day-quad-3"><a href="#rm-Day-quad-3" class="headerlink" title="$\rm Day\quad-3$"></a>$\rm Day\quad-3$</h1><p>给最喜欢的语文老师写了封信，跟她说我觉得我可能在考完之后不会继续走下去了，这让我很难过，因为我割舍不下那些回忆，觉得她可能会理解我。她回信了。我很高兴她没有硬塞什么心灵鸡汤。于是每天晚上我都会拿出信来读一遍。</p>
<p>哦对，她以前是我的语文老师，文化课/奥赛分班之后她就只教隔壁了。</p>
<p>其实你说现在我有什么感受呢？我也不知道，就是蔡琴唱过的 _让它好好的来，让它好好的去_ 这种感觉吧。</p>
<h1 id="rm-Day-quad-0"><a href="#rm-Day-quad-0" class="headerlink" title="$\rm Day\quad 0$"></a>$\rm Day\quad 0$</h1><p>报到日，群体乘大巴。大巴上我教yjk打音游和拳皇，打deemo他菜的一批233</p>
<p>到了考点，日照什么职业技术大学。校园一般，宿舍还行，起码有插头和桌子。</p>
<p>去试了试饭菜，感觉还可以，挺丰富的。发现是兑换餐币，于是就换了三种面值的留下作纪念了。</p>
<p>晚上去试机，豪华六边形方桌，和机房里一样，感到很开心。键盘也很轻。听别人说键盘难用、座位之间间距太小，才知道原来不是每个考场都是豪华六边形方桌。有抽中大奖的喜悦233</p>
<p>试机回来就是瞎写了写板子，写了写博客。睡前听的是德彪西的《月光》。</p>
<p>考前和yjk估摸了一下，Day1要拿260左右才能稳，不知道明天会怎样。</p>
<p>哦，对，当时听的那一版《月光》，是我听完好多版之后最喜欢的一个版本。但之后我尝试找过，但无论怎么找都找不到了…</p>
<h1 id="rm-Day-quad-1"><a href="#rm-Day-quad-1" class="headerlink" title="$\rm Day\quad 1$"></a>$\rm Day\quad 1$</h1><p>考啦考啦。</p>
<p>开题发现有一些奇怪的说明，没管。</p>
<p>开 $\rm T1$，发现是个sb题，写了$\rm [5,10]min$ 左右切了，开考 $15\min$ 的时候拍上了。</p>
<p>开 $\rm T2$，发现 $50$ 在送，于是先写了 $50$ 。之后寻思着去做做 $\rm T3$，发现不太会。本着求稳，写了 $10pts$ 就回去写 $\rm T2$了。于是就开始演，演了半小时写出了一堆不知道啥东西，然后又演了半小时发现大样例爆栈了……</p>
<p>我不会告诉你我接下来浪费了快半小时去回忆<code>Dev</code>怎么开栈…… </p>
<p>最后还是失败了，但是发现其实大样例不需要 <code>dfs</code> ，于是写了个序列版本给演过去了。之后 $\rm T2$ 就拍上了。此时大概是 $10:15$ 。</p>
<p>觉得去刚 $\rm T3$ 应该不至于一分没有，结果就真的一分没有，伤心。</p>
<p>之后就自闭了。出了考场，我戴紧冲锋衣帽子冲到了一个僻静的小路里面，周围都是密密麻麻的树，开始思考人生。在家庭群里用微信发了句 “考挂了，没救了”，跟妹子说了声“要退役了”就找了个角落开始思考人生。思考完之后开始在校园里闲逛，不想回宿舍。我觉得一定会有 sb 学弟或者 sb 同级生在对 tnd 答案，结果最后手机没电了不得不回去。</p>
<p>回去之后要了份脆皮鸡饭叫上 yjk 出去逛，发现原来大家都是 210 左右，心态得到了放松。结果不知道为啥，后半程跟 yjk 越走越自闭。我们俩大概是这么聊天的：</p>
<blockquote>
<p>我：你最后考到多少名还学？</p>
<p>yjk：20~30吧。</p>
<p>我：嗯我也是。那 70 以后呢（因为他去年这个名次）？</p>
<p>yjk：不学了吧。。</p>
<p>我：嗯我也是。</p>
<p>yjk：今天的题感觉没有区分度啊</p>
<p>我：是啊，没有区分度啊。回去还要补文化课。大家今天都 210，全天下都 210，明天还会更难，肯定会加大区分度，那我可能就被区分下去了…（开始碎碎念）</p>
<p>yjk：是啊……</p>
</blockquote>
<p>于是我俩就在四季桥那里自闭了，和俩二傻子一样蹲在桥边，如果忽略肤色，宛如两尊佛。</p>
<p>不过后来走着走着心态又回来了。回到宿舍后被辅导员骂了一顿，因为手机落在宿舍并且没签到，233.</p>
<p>之后选择去吃晚饭，碰到了胜利一中的神仙，但是显然他们不可能认识我，所以我就像一个狗仔一样单方面盯着他们看……233</p>
<p>晚饭挺不错！这是真的！之后去买了红牛，希望明天能用上。</p>
<p>晚上其实一直在颓火影和拳皇……睡之前写了写博客，<code>hexo -d</code> 之后就睡了。</p>
<p>还是听的《月光》。</p>
<h1 id="rm-Day-quad-2"><a href="#rm-Day-quad-2" class="headerlink" title="$\rm Day\quad 2$"></a>$\rm Day\quad 2$</h1><p>……自闭了。</p>
<p>开场看T1，发现是计数，不会。去搞 T2，觉得很可做，发现40在送；写完去看T3，发现40在送。于是决定写 T2。然后 T2 猜了一波单调性发现可以 64，于是数据分治了一下，拍上了；之后去写了个T3的40。T2推了推，觉得似乎可以斜率优化，但是发现有二次项似乎很难办，就没管。剩下的时间就在做T1……</p>
<p>最大的失误是啥呢？可能就是我T1<strong>把 n 和 m 看反了，并且过了前两个样例</strong>，于是觉得这题64在送。但是死活过不去第三个样例。好久之后才发现看反了，赶紧写了个玄学dfs。赛后一测re了。真开心。T3当时看的时候觉得75都是送，但是最后也没来得及写……于是第二天就这么凉了。</p>
<p>一出来，就自闭了。闲逛了好久，用QQ跟妹子说“真退役了”，用微信跟家长说“已经准备迎接新生活了”，后来就没有后来了。回去一问发现大家也都挂了……yjk哭了，我头一次见他哭。</p>
<p>不用想的，Day2就是考区分度。之前zr做题的时候就明白了，我是那种被区分下去的人。容斥、dp、贪心之类的这些基本功，我都很烂很不扎实，被区分下去是我活该。你说我会为自己以前拼命学多项式感到不值吗？可能确实不值，但是说啥都没用了。</p>
<p>回去的路上还是比较愉快的。车上的电视终于不放上21世纪初的悲情无脑乡村恋爱歌曲，改放《欢乐喜剧人》，于是最终和yjk看了一路233</p>
<p>rqy哭了，可能是因为觉得我们都退役了吧。但是我感觉我和他已经不是一个世界的人了。我一直感觉，如果让我从实力和陪伴里面选一个，我肯定毫不迟疑地选择前者。但，结束了。</p>
<p>晚上回家了，就是在一直颓而已，没啥别的，期间励志要开启新生活，觉得很有斗志。</p>
<h1 id="rm-Day-7"><a href="#rm-Day-7" class="headerlink" title="$\rm Day ~7$"></a>$\rm Day ~7$</h1><p>在校的周六，选择去机房收拾东西，顺便看了眼民间数据成绩单。发现自己和yjk都是省里50多名，还一个分…这就很难了，我们之前没讨论过这个区间该干啥呀？</p>
<h1 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h1><p>之后？之后就是我又滚回来追梦，yjk去文化课了，剩下的人都退役了。</p>
<p>LCEZ55 级的机房故事，也就这么结束了吧？我一直觉得，我们机房没有其它机房可爱，我是罪魁祸首。我身为队长，要张罗日常事务，但是从来没真正关心过谁，加上脾气很差容易着急（虽然现在好很多了？）。并且一开始我很菜，要一直不遗余力的提升自己实力，不顾什么”同学友谊“啊啥的，功利且浮躁。大家平时也不怎么敢跟我交流，于是机房就很冷清。</p>
<p>但机房里也时常会有笑声，比如联赛前，机房里一直其乐融融的。现在看来那似乎是遥远的回忆了。</p>
<p>现在机房里只有我一个人了，我开心吗？终于等到了我喜欢的悠远的寂静，我更快乐吗？</p>
<p>向前走吧。</p>
<p>我还很菜，啥都不会，迷茫且不知所措。</p>
<p>但是人生也就应该是这样的吧。</p>
<p>明天你好。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大家一起加油吧！为了梦想和明天。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活碎片</tag>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【置顶】闲谈</title>
    <url>/2019/12/15/%E9%97%B2%E6%89%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>别名：一句话日记</del></p>
<p>不过似乎写着写着早就不止一二三四五六七八句话了/kk</p>
<p>可能就是用来随时记录自己感悟的东西？</p>
<p>现在已经鸽了</p>
<a id="more"></a>
<h3 id="2-8"><a href="#2-8" class="headerlink" title="2.8"></a>2.8</h3><p>我发现，在家里是不可能写blog的。所以鸽了鸽了。</p>
<h3 id="1-22"><a href="#1-22" class="headerlink" title="1.22"></a>1.22</h3><p>今天决定要补一补之前欠下的日记，发现从 $1.5$ 开始就断更，实在是太多了…多亏了和zay的聊天记录能帮我想起我当时到底在干什么…</p>
<p>晚上因为一些事情陷入了深深的思考……</p>
<h3 id="1-21"><a href="#1-21" class="headerlink" title="1.21"></a>1.21</h3><p>今天决定去找同学玩，上午因为看「碟中谍3」并且搭错了公交鸽了好久233</p>
<p>(PS:我tm打出「碟中谍」才发现原来第一个die和第三个die不是一个die…</p>
<p>下午她要去书店社会实践，本来想继续跟她一起混，结果发现她闺蜜来了之后我就没人认领了…不是很开心地回了家。不过仔细想想的话，其实也是正常。把奇怪的东西逐渐看做正常，也算一种进步吧。</p>
<p>晚上水群+做题，还是阿狸那题，踩了一堆坑总算是做完了。</p>
<p>QAQ本来觉得调整得很好的作息又莫得了。两点才睡，晚安啦。</p>
<h3 id="1-20"><a href="#1-20" class="headerlink" title="1.20"></a>1.20</h3><p>做题是因为本来决定写的一篇blog，相关内容只写了俩题。我觉得吧，要么只整理一道，要么就三道，不知道为啥对「二」很不爽，于是就决定再写一道。</p>
<h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><p>翻了一翻自己的任务清单，精挑细选地删了好多之后发现还是多到做不完？于是开始学线段树合并，发现不是很难。中途思考了一下线段树合并的本质，发现这东西不是很难，于是就疯狂写板子。并且由于复杂度是均摊的，所以没有什么很创新的玩法（比如按秩合并这种）。</p>
<p>成功地混进了胜利一中的群，有种找到组织的喜悦。不过为啥我那么喜欢水群啊QAQ</p>
<p>晚上在poj写了一道求桥的题，调了好半天发现自己十分弟弟地写错了。之后被zay拉着谈感情…可怕</p>
<p>现在不知道为啥十分想回家，感觉自己一天天的是要颓死在这儿了QAQ</p>
<h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><p>上午尝试去做了一下SPOJ的三道Min25的题目，然后就开始写博客，觉得自己效率很高……</p>
<p>其中穿插了一个情节，就是写着写着题突然感觉自己又不会Min25了，于是去uoj群里丢人，结果我凭借我精湛的提问技巧让大家都不知道我在说什么，于是群就很冷，于是我就开始疯狂地「すみません」，场面一度十分尴尬…</p>
<p>于是决定以后还是独立思考问题好了.jpg</p>
<p>然后下午不出意外地开始颓了起来。临吃饭时去拿了zay寄来的Luogu网校教材，看了看确实挺好，于是给金哥推荐了一下，作为小班的教材。然而金哥「挺好」了一句之后，就把教材还给我了233.</p>
<p>无论怎样，zay欠我一杯可乐了嘎嘎嘎嘎。然而自己的体检结果，体内尿素含量过高，所以暂时不能喝可乐，sad</p>
<p>晚上决定看看李煜东的书，挑了道点双的题目开始写，然后写自闭了。最后发现自己把 <code>while</code> 换成 <code>do_while</code> 就过了，于是去问zay。最后发现是我两分代码除了这部分，其余的并不严格相同，比如说我忘了清空……然后就没有然后了。</p>
<p>晚上金哥居然托rqy给zay说：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="4.png" alt=""></p>
<p>我只能233了。</p>
<h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><p>今天决定有心劲一点，结果在机房从 $7：30$ 睡到 $8:30$……可海星</p>
<p>嗯，其实是在学 Min_25筛，学了一上午也没太整明白，就比着题解写了写板子，感觉不太好，那种囫囵吞枣的感觉又涌了上来。不过大致是懂了？</p>
<p>下午继续Min25，顺便写了一下笔记。在看过大多数人让人迷惑的blog之后，发现HN-001神仙 <code>xzz</code> 讲的最清楚明白。于是把大部分知识点给扣清楚了，剩下的小块可能还需要继续追索。</p>
<p>晚上不知道为啥开始一直看《巨人》，从 $90+$ 一直看到了 $123$ 话，期间用 $\rm Min25$ 过掉了杜教筛的板板，觉得自己啥都不会智障的很。</p>
<p>不过好在巨人快看完了？说实话我《巨人》看的没有当年补《海贼》看的详细，因为《海贼》是我去一本一本买的单行本，许多本反复看了好多遍，而巨人甚至连比较长的对白都跳过了。加上作者诡异的紧凑的画风导致观感极差。</p>
<p>不过要说剧情，我比较深的感觉就是，艾伦和三爷，以及他的小伙伴们都回不到原来了。从什么时候开始的呢？大概是从马莱对艾尔迪亚人派出那四个智慧巨人开始的吧，家不家矣，国不国矣。但是你能说出到底是谁错了吗？每个人都坚持着自己心中的正义而已吧……</p>
<p>感觉巨人的思想内核还是很现实的，再加上作者没有尾田那种浪漫主义情怀——毕竟说到底，海贼和巨人的思想内核都很沉重，探索的人性也很复杂，但是尾田却能把海贼画的很浪漫。每次结束战斗都要庆祝，都会看到笑容。我想，其实两部动漫都是在解剖这个社会，但是一个是笑着解剖，一个是哭着解剖吧。</p>
<p>最近感觉很困。听说下周二周三由于高考听力占考场，所以放假。不知道我们放不放。但我觉得不放的可能性更大吧…</p>
<h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><p>今天准备学最短路树，但是中途穿插着一直在看《进击的巨人》，所以效率不高。</p>
<p>结果发现最短路树其实不难，难的是有一堆十分诡异的题目…比如随手套个点分治之类的233</p>
<p>结果下午就自闭了，自闭在 $\rm TJOI$ 的一道题上，大概就是每次询问删一条边之后 $\rm S\to T$ 的最短路是多少，询问之间独立。看题解看了好久也没整明白…菜死我算了。</p>
<p>然后下午明白之后晚上就写啊，写了好久才写对。然后就蒙逼了。</p>
<p>不知道什么，感觉最近不是那么有心劲了…可能是停课必经的一个阶段吧？我不是很想把这个当做自己在一段卑微的感情中受挫的副产物，那也太惨了吧？</p>
<p>不过很自闭就是了……</p>
<p>我一直在想，或许我就是因为不喜欢文化课才学的奥赛吧？从理智还是从情感上来说，我都更应该去学文化课。所以，我在做什么呢？真的是在追梦吗？每天就这么低下的学习紧张度能做成什么呢？</p>
<p>我找了好久，本来以为找到了自己的路，后来才发现原来自己只是兜了个大圈，又回到原地了而已。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>…上午写完鸽了的题解，然后几乎啥都没干……原因是本来打算学整体二分，结果看到动态图连通性这东西觉得可以学一下，就去学了学ETT——然而其实就是大略地看了那么几眼，明白原理就不看了，回过头来发现这东西好像不是给正常人写的……并且跑的似乎也没有暴力快……于是就又回去学整体二分了。</p>
<p>于是就二分了一下午，我是憨憨。</p>
<p>晚上本来打算很有心劲，结果看起了《进击的巨人》，最终漫画从 $55$ 话看到了第 $70$ 话。本来可以看更多，但是中途有 <code>slyz</code> 的神仙组团来精（教）准（我）扶（做）贫（人），比如我被怒斥：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<p>然后就不敢颓了，就去做题了…</p>
<p>结果写了个整体二分套树剖的题，临走也只拿了 $10$ 分，整个人都不好了……</p>
<p>不过还是很开心的，我也是有小伙伴的人了（嚣张.yml）</p>
<p>然后下午发现了一个很秀的表情：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.gif" alt=""></p>
<p>感觉整个人都朋克起来了233</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>颓了一天，下午就返校了。上午主要是看了看B站跨年的回放。⑧说了，邓紫棋天下第一（</p>
<p>晚上突然很难受。还是关于妹子的事，可能我真的需要一段时间才能缓过来吧？感觉自己的祝福，每一句话、每一个字都在痛击自己的心。但是我能怎么样呢？我又能怎么样呢？</p>
<p>又是CSP考完那种无力感：就这样了吗？就这样了吧。</p>
<p>一个人的奥赛室，孤独到让我想哭。是啊，以后就再也不能去找妹子说最近自己心态崩了求安慰之类的话了，也必须要描黑那道若有若无的界限了，感觉生活少了点什么。</p>
<p>但总之，是一个新的开始不是吗？</p>
<p>明天可还要继续啊。</p>
<p>喂喂，pks，我们可是舞台上的战士啊，怎么能这么早就谢幕呢？</p>
<blockquote>
<p>《你的答案》_by 阿冗_</p>
<p>也许世界就这样<br>我也还在路上<br>没有人能诉说<br>也许我只能沉默<br>眼泪湿润眼眶<br>可又不甘懦弱<br>低着头 期待白昼<br>接受所有的嘲讽<br>向着风 拥抱彩虹<br>勇敢的向前走<br>黎明的那道光<br>会越过黑暗<br>打破一切恐惧我能<br>找到答案<br>哪怕要逆着光<br>就驱散黑暗<br>丢弃所有的负担<br>不再孤单<br>不再孤单<br>不再孤单</p>
</blockquote>
<h3 id="Goodbye-2019"><a href="#Goodbye-2019" class="headerlink" title="Goodbye 2019"></a>Goodbye 2019</h3><blockquote>
<p>又是一年啊。 </p>
<p>这一年里，我失去了很多，也获得了不少；看清了很多，也迷茫了不少。每一次相遇，每一次离别都值得回忆；每一份高兴，每一分忧伤也都值得我带到未来。</p>
<p>对于2019，「让它好好地来，让它好好地去」，我更喜欢这么来形容。</p>
<p>明年有什么心愿呢？生而为人，握紧很简单，但是放下却很难。然而握得越紧越发现原来没有握住，看得越重越发现自己扑了个空。所以，我希望，我可以一觉醒来发现自己什么都不记得，这样才可以放下之前的所有，大踏步得走向明天。2020，请让我变得更释然一些吧，好吗？ </p>
<p>总之呢，谢谢各位一年的陪伴。</p>
<p>2020，这个世界，与我重新来过吧。</p>
</blockquote>
<h3 id="12-31"><a href="#12-31" class="headerlink" title="12.31"></a>12.31</h3><p>今天早上很高兴地在早读给妹子写完新年快乐的明信片+信，让隔壁班同学当信使给送去。听他说了下最近隔壁班的八卦，发现以前觉得会厮守很久的情侣不在了，以前觉得根本不搭的两个人在一起了。感觉和他们同班的日子已经远去很久了。</p>
<p>顺便知道了原来喜欢的妹子已经有了男票，于是打算把写好的东西扔进垃圾桶。在信使老鸽的劝说下还是没扔，还是送了出去。最后感觉有点惆怅。从初中到现在，自己似乎一直在趟别人的浑水，感觉自己似乎跟他们早就不是一个世界的人了。</p>
<p>是啊，不是一个世界的人了。可能我真的需要破除『我执』了吧，不想再去纠结这些没头没脑的固执了。于是趁着夜幕还没被拽走，便匆匆来到了奥赛室。</p>
<hr>
<p>冷静思考了思考，发现自己一旦对什么东西有了厌恶感就很难再喜欢上了。所以真正对的那个人应该还没来吧，我需要继续等下去。嗯，从小父母就教导，走丢的时候原地等着是最好的选择。所以也只有等待，才是迎接光明的最好办法吧。</p>
<hr>
<p>然后晚上她用她闺蜜的 qq 给我发信息。不知道为啥。她说她本来以为我今天下午会在班里看电影（因为我们班奥赛退役选手在其它班联欢的时候，在班里看电影），然而实际上我在奥赛室看了一下午的《进击的巨人》（233。所以她就给我拍过来一张照片：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="hello.jpg" alt=""></p>
<p>。。。那个“弄得我很怂”的上文是我问她说每次跟她偶然遇见她为啥都故意不看我233</p>
<p>然后事情是这么发展的：</p>
<blockquote>
<p>她：还有一件信息量比较大的事情</p>
<p>她：我脱单了</p>
</blockquote>
<p>啊。</p>
<p>下午时一直在想，如果她其实和那个男生还没真正确定的话，我去“兴师问罪”是不是有点不太好？</p>
<p>好在事态的发展没让我那么尴尬……</p>
<p>我当时似乎，似乎是，思考了一瞬间，就已经知道该怎么回她了。那些“为什么你有了男朋友而不告诉我？”和“有了男朋友为什么还要给别人以希望”之类的话，已经被扔到了不知处。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="3.png" alt=""></p>
<blockquote>
<p>题外话：</p>
<p>……可能大家都不知道我们到底是什么关系，大概就是她知道我一直喜欢她但是我是这么一种心态：</p>
<blockquote>
<p>喜欢不等于占有</p>
</blockquote>
<p>于是和她就变成了好朋友？起码在聊天软件里还是很铁的（</p>
<p>至于她是什么人，我只能说是很单纯一妹子……就是跟人用qq聊天还用 <code>。。。。</code> 这东西做前后缀的人，现如今几乎没有了吧？</p>
</blockquote>
<p>嗯，就这样了吗？就这样了吧。</p>
<p>晚上看了看C菌的《心魔》，到最后虽然很爽，但是感觉和《逃生2》差不多，爽是爽了，但是没啥深度。</p>
<p>睡了睡了。</p>
<h3 id="12-30"><a href="#12-30" class="headerlink" title="12.30"></a>12.30</h3><p>昨晚不知道为啥宿舍里有一堆蚊子…让人很难过地一点多才睡，于是今天就变成了活死人状态。上午看了看高数，发现到一阶微分方程那里公式已经不是人记的了，于是觉得无聊就不学了。下午和晚上做了做 <code>vfk</code> 曾经出的某场 <code>cf</code>，剩下的时间学了发笛卡尔树就去颓了。</p>
<p>前几天看了梁文道的《我执》，几天晚上方才明白<code>我执</code>的意思，突然很有感触。以下是摘录，转自<a href="https://www.zhihu.com/question/20015896/answer/15644432" target="_blank" rel="noopener">链接</a>，有删改：</p>
<blockquote>
<p>你的名字不是你，你的职业不是你，在哪里上班的那个也不是你，这一切是你的经验，但经验不是你本身。我们经由我们生命的内容来定义自己，我们的年龄、健康、人际关系、财务状况、工作和生活情境以及心理情绪状态等等，但是这些是经验的客体，而不是主体。我们的错误就是会把这些经验当成是我们的主体，然后与它们认同，把它们当成自我的一部分。</p>
<p>一言以蔽之：我执就是在外在事物上所建立的那个虚假的自我感（ 这里的外在事物还包括你的情绪和念头，下面会细谈)。无论你执着什么，你就是在把它当成自我的一部分，而那个东西就是你「我执」的体现。在根本上，并无一个实体的，不变的「我」存在。也正是因为我们把自我感建立在这些外在的事物上，所以当它们变化时，我们的痛苦便产生了。但是这些事物的变化是不可避免的，因为它们的本质便是「无常」。所以，只要你把自我感建立在外在稍纵即逝的事物上，则我们心理上的痛苦就不可避免。</p>
<p>我们的悲哀是，我们终其一生，都只是在为自我填充这一个个意象。财富，权位，知识，还有你执着的任何东西，如果它没有伤害到他人，我想这些都是好东西，但是只要你没有认清这些东西和你的本质是完全无关的，只要你还在这些事物上建立认同感，那你所得到的一切不过是加强我执而已，而当那个意象破灭，则痛苦就将来临。</p>
</blockquote>
<p>于是感觉似乎佛教不是印象里那种玄学的宗教，而是一套科学化理论化的世界观和方法论。</p>
<p>我什么时候才能「看惯风波里，闲步红尘外」呢？</p>
<h3 id="12-29"><a href="#12-29" class="headerlink" title="12.29"></a>12.29</h3><p>上午考的数学和英语，下午考的语文，成功要到了记忆中上一次合格考跟我一个考场、这次也一个考场的可爱妹子的QQ。感觉到达了人生巅峰。</p>
<p>然后晚上回来学了学支配树，发现有神仙说灭绝树就是支配树，然后发现自己还不会灭绝树，然后就去做灭绝树了233</p>
<p>啊，终于马上要放假了，开森。</p>
<h3 id="12-28"><a href="#12-28" class="headerlink" title="12.28"></a>12.28</h3><p>上午在奥赛室背政治……下午考了政治觉得自己还可以。</p>
<p>晚上尝试写了一下「一双木棋」，发现 <code>alpha-beta</code> 只能干出 $70pts$ 来，然后就去颓了。</p>
<h3 id="12-27"><a href="#12-27" class="headerlink" title="12.27"></a>12.27</h3><p>没啥好讲的，明天要合格考了，在发愁自己的政治233</p>
<h3 id="12-26"><a href="#12-26" class="headerlink" title="12.26"></a>12.26</h3><p>上午下午一共做了三道题，从李煜东的蓝书上看来的。中途写挂了好几次，但是最终调出来还是挺有成就感的。</p>
<p>饭卡丢了，有点郁闷。毕竟电话卡和饭卡是一张卡，电话卡丢了还要去电信营业厅补办。。。太麻烦了吧233</p>
<p>……然后……然后就因为一些奇怪的事情陷入了奇怪的思考。感觉自己正在被拽进奇怪的漩涡中，感觉自己似乎如同「奇异人生」里面 <code>Max</code> 经常梦到的场景，在风暴之中，自己在被撕扯着想要登上灯塔。可惜只有我一个人。</p>
<p>看着一堆东西还没学，也不是很想学。后天还要考政治，什么都没背，感觉有点不太好。</p>
<p>似乎我走迷了路。或者说，我经常会走迷了路。高中到现在为止我一直在追求着什么，放弃了很多，但是到现在我也一直不知道我到底在追求些什么。是奥赛吗？我恍惚了。是功成名就吗？我恍惚了。</p>
<p>感觉到现在为止，我只有每个学期刚刚开始，即18年9月 $\sim$ 10月和今年的9月 $\sim$ 10月有认真学过文化课，剩下的时间都在划水；美其名曰学研究奥赛，学来的线性规划或者 <code>HLPP</code> 可能永远也用不上。我在干什么？其他人丰富有趣、值得回忆的高中生活，在我眼里就是一场又一场的白日梦，一次又一次地跌倒再爬起来再欺骗自己：你没跌倒。这一切的一切，真是我想要的吗？</p>
<p>我又在瞎想了。给梁文道做序的某作家（忘了名字）说，为什么人们喜欢寓哲学于文学呢，因为人们喜欢问没有答案的问题，喜欢去体味这种求索的感觉。可能对我来说，这也算是一点心理安慰了吧。</p>
<p>嗯，写完这些感觉内心明显平静了许多。</p>
<h3 id="12-25"><a href="#12-25" class="headerlink" title="12.25"></a>12.25</h3><p>今天有点颓，上午只写了一篇题解，下午做$[\rm SNOI2019]$的D2T1，做了好久，剩下的时间不知道干什么去了。</p>
<p>晚上继续和 <code>ouuuyuuu</code> 出去跑圈。外面开始下雪了，十分开心。但是一边跑，风雪夹带着冷雨扑打过来有点难受。眼镜中途还因为镜面上水太多，想用手套擦，结果擦成了磨砂玻璃…233摘下眼镜来继续跑就会感觉跟喝了一壶一样，看着周围都是一派虚无缥缈的景象。</p>
<p>开始看梁文道的《我执》了。感觉还行。但是毕竟只看了一点，也不知道到底有什么精彩等待着我。</p>
<p>发现自己写文章的时候，可能是因为平时说话说太快了，一直不喜欢加句号。大多数情况下都是一大段全是逗号233</p>
<p>晚上发现胜利一中的神仙们去逛了我的 <code>Luogu</code> 博客，比较开心。因为似乎我也没法跟别人交流了。</p>
<p>瞎扯一句，感觉 <code>rqy</code> 能一个人在这儿奋斗两年，十分厉害。孤独+经常会有的绝望+偶尔的希望，不把人逼自闭已经算是很好了。</p>
<p>诶，刚刚才发现原来自己有三个博客，但是这三个博客上的东西几乎都不一样。。。233</p>
<h3 id="12-24"><a href="#12-24" class="headerlink" title="12.24"></a>12.24</h3><p>平安夜，很自闭233</p>
<p>看了一上午+大半个下午的构造，感觉一般。听 <code>ouuuyuuu</code> 说构造题只能长经验，是学不会的，感觉有点小失落。</p>
<p><del>人总要有梦想，万一我就学会了呢</del></p>
<p>晚上复盘了一下自己的 $\rm CSP-S~2019$ ，感觉虽然和大家都很有差距，但是如果从进步的意义上来讲，比起去年来自己进步还是蛮多的。毕竟去年也就那点水平。</p>
<p>嗯，所以呢，谁知道将来我会不会进步到我想象不到的水平呢？加油吧，我可是想要创造奇迹的笨蛋啊！</p>
<h3 id="12-23"><a href="#12-23" class="headerlink" title="12.23"></a>12.23</h3><p>越来越困了，发现啥都学不会，然后自闭了。</p>
<p>发现去了 <code>pkuwc</code> 的小伙伴们似乎都有约拿了，感觉更自闭了。</p>
<p>……我觉得我现在应该是全校最盼着放寒假的人了。当初觉得似乎机房生活会很轻松，结果发现比文化课生活自闭了不止一个量级。可海星……</p>
<p>发现啥都学不会了，发现比别人拉下的不止一点半点……有点难受，但是一想到马上要放假了（虽然还有一个多月）就会开心一点phh</p>
<h3 id="12-22"><a href="#12-22" class="headerlink" title="12.22"></a>12.22</h3><p>……之前换了几天的 <code>jacman</code> 主题，说实话感觉不是很漂亮。换主题的原因是我关了一次 <code>icloud</code>，然后他就给我吞了……迷惑。于是只能重新建一个主题。不过好在我<del>找回了失去的脑子</del>找到了对应的文件夹，于是九成功复原了。于是现在就又换回了 <code>next</code> 主题。</p>
<p>怎么说呢，虽然 <code>next</code> 主题确实用的比较多，有烂大街的嫌疑，但是你要真让我去挑其他的喜欢的并且配置出来，确实很麻烦。</p>
<p>嗯，这个故事告诉我们要学会备份。 </p>
<h3 id="12-15"><a href="#12-15" class="headerlink" title="12.15"></a>12.15</h3><p>upd:因为不知为啥，hexo的背景炸了，觉得似乎白色也挺漂亮，就决定不设置背景了。</p>
<p>新建了这个文档，本想写很多，结果突然发现自己WC都去不了。</p>
<p>然后就自闭了，我为什么还要死命坚持下去呢？又有什么意义呢？</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Manacher简单题泛做</title>
    <url>/2019/12/15/Manacher%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>在？为啥不用PAM？</del></p>
<p>emm那可能是空间开不下（自我安慰</p>
<a id="more"></a>
<h1 id="1-LG1659-国家集训队-拉拉队排练"><a href="#1-LG1659-国家集训队-拉拉队排练" class="headerlink" title="$1$ LG1659 [国家集训队]拉拉队排练"></a>$1$ LG1659 [国家集训队]拉拉队排练</h1><blockquote>
<p>求前$k$大的奇数长度回文串的长度之积。</p>
<p>$\rm |S|\leq 1e6,K\leq 1e12$</p>
</blockquote>
<p>……一开始觉得挺水，就开始二分最少长度能到多少。写写写…写到最后发现细节很烦人…然后最后发现是错的qaq</p>
<p>二分是没错，只是最后计算错了。大概就是考虑二分出的最小长度是$k$，对于一个大于$k$的长度$l$有好多个，没法知道$l$们到底要算到几，也就是说$7$中一定包含着$3/5/7$，但是对于$l$，其中可能有拆出$7,5$来的，也有可能有拆出$7,5,3$来的，无法同一个长度一起算。</p>
<p>以下是错误代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L = <span class="number">-1</span> ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">	LL ret = <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (y)&#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">			(ret *= x) %= Mod ; </span><br><span class="line">		(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">	LL ret = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">int</span> x = ed[p], i ; </span><br><span class="line">	<span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; p ; ++ i)</span><br><span class="line">		ret += <span class="number">1l</span>l * ((ed[i] - ed[p] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">bool</span>)(ret + (buc[ed[p]]) &gt;= K) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">	ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i + <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]]) ++ base[i] ; </span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) buc[base[i] - <span class="number">1</span>] ++ ;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; MAXN ; i += <span class="number">2</span>) <span class="keyword">if</span> (buc[i]) ed[++ tot] = i ; </span><br><span class="line">	reverse(ed + <span class="number">1</span>, ed + tot + <span class="number">1</span>) ; <span class="keyword">int</span> L = <span class="number">1</span>, R = tot, Mid, ans, pos = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">		Mid = (L + R) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">		<span class="comment">/*if (rand() % 2)</span></span><br><span class="line"><span class="comment">			while (ed[Mid] % 2 == 0 &amp;&amp; Mid &lt; R) ++ Mid ;</span></span><br><span class="line"><span class="comment">		else </span></span><br><span class="line"><span class="comment">			while (ed[Mid] % 2 == 0 &amp;&amp; Mid &gt; L) -- Mid ;*/</span></span><br><span class="line">		<span class="keyword">if</span> (check(Mid)) ans = Mid, R = Mid - <span class="number">1</span> ; <span class="keyword">else</span> L = Mid + <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	pos = ans, res = <span class="number">1l</span>l, _up = ed[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = ed[pos] ; i &lt;= ed[<span class="number">1</span>] ; i += <span class="number">2</span>) fact *= <span class="number">1l</span>l * i ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= pos ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">while</span> (ed[i] &lt; _up) fact /= _up, _up -= <span class="number">2</span> ; </span><br><span class="line">		<span class="keyword">if</span> ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span> &gt; K)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">0</span> ; </span><br><span class="line">			<span class="keyword">while</span> (ed[i] &gt;= ed[pos] &amp;&amp; j &lt; K)</span><br><span class="line">				res = res * <span class="number">1l</span>l * ed[i], ed[i] -= <span class="number">2</span>, ++ j ; </span><br><span class="line">			<span class="keyword">break</span> ; </span><br><span class="line">		&#125; </span><br><span class="line">		res = res * expow(fact, buc[ed[i]] &lt;= K ? buc[ed[i]] : K) % Mod ;</span><br><span class="line">		K -= <span class="number">1l</span>l * ((ed[i] - ed[pos] + <span class="number">2</span>) / <span class="number">2</span>) * <span class="number">1l</span>l * buc[ed[i]] ; </span><br><span class="line">		<span class="keyword">if</span> (K &lt;= <span class="number">0</span>) <span class="keyword">break</span> ; </span><br><span class="line">	&#125; 	 </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察失误点，贡献无法提前计算，那么可以考虑延后计算，这样一定能保证准确凑出来$K$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tot, ns[MAXN], base[MAXN], buc[MAXN], ed[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> N, L ; LL K, res, fact = <span class="number">1</span>, _up ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il LL <span class="title">expow</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">	LL ret = <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (y)&#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">			(ret *= x) %= Mod ; </span><br><span class="line">		(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">	ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; <span class="keyword">int</span> id = <span class="number">0</span>, rt = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span> base[i] = min(base[<span class="number">2</span> * id - i], rt - i) ;</span><br><span class="line">		<span class="keyword">while</span> (ns[i - base[i]] == ns[i + base[i]] &amp;&amp; i + base[i] &lt;= L &amp;&amp; i - base[i] &gt;= <span class="number">1</span>) ++ base[i] ; </span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i + base[i] - <span class="number">1</span>) rt = i + base[i], id = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">1</span> ; -- i)&#123;</span><br><span class="line">		ans += buc[i] ; </span><br><span class="line">		<span class="keyword">if</span> (!(i &amp; <span class="number">1</span>)) <span class="keyword">continue</span> ;		</span><br><span class="line">		<span class="keyword">if</span> (ans &lt;= K)	</span><br><span class="line">			(res *= expow(i, ans)) %= Mod, K -= ans ; </span><br><span class="line">		<span class="keyword">else</span> &#123; (res *= expow(i, K)) %= Mod, K -= ans ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>。。。这题一开始写挂了，然后两天后（就是写这行字的时候）整理这道题，又调了半天才发现为啥二分不对…qaq脑子是个好东西。</p>
<h1 id="2-LG4555-国家集训队-最长双回文串"><a href="#2-LG4555-国家集训队-最长双回文串" class="headerlink" title="$2$ LG4555 [国家集训队]最长双回文串"></a>$2$ LG4555 [国家集训队]最长双回文串</h1><p>这题比第一题友善了很多。。。</p>
<blockquote>
<p>输入长度为$n$的串$S$，求$S$的最长双回文子串$T$,即可将$T$分为两部分$X$，$Y$，（$|X|,|Y|≥1$）且$X$和$Y$都是回文串。</p>
</blockquote>
<p>嗯，其实就是求以每个点为右端点/左端点的最长回文串长度。用Manacher做的话，就是一开始先推出以每个点为轴的最长回文串长度，然后用这个去更新每端点。注意到这么做有些包含在原来求出的最长回文串内部的小回文串可能并不可以求出来，于是再dp一遍即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ; </span><br><span class="line">	<span class="keyword">int</span> i, id = <span class="number">0</span>, rt = <span class="number">0</span> ; ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (rt &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">else</span> base[i] = min(rt - i + <span class="number">1</span>, base[<span class="number">2</span> * id - i]) ;  </span><br><span class="line">		<span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line">		<span class="keyword">if</span> (i + base[i] &gt; rt) rt = i + base[i] - <span class="number">1</span>, id = i ; </span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; base[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//	for (i = 1 ; i &lt;= L ; ++ i) cout &lt;&lt; (char)ns[i] &lt;&lt; " " ;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> l = i / <span class="number">2</span> - (base[i] / <span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">int</span> r = i / <span class="number">2</span> + (base[i] / <span class="number">2</span>) - <span class="number">1</span> ; <span class="keyword">if</span> (ns[i] == <span class="number">35</span>) ++ r ;</span><br><span class="line">		Ls[r] = max(Ls[r], base[i] - <span class="number">1</span>), Rs[l] = max(Rs[l], base[i] - <span class="number">1</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Ls[i] = max(Ls[i], Ls[i + <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Rs[i] = max(Rs[i], Rs[i - <span class="number">1</span>] - <span class="number">2</span>) ;</span><br><span class="line"><span class="comment">//	for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Ls[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//	for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; Rs[i] &lt;&lt; " " ;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) ans = max(ans, Ls[i] + Rs[i + <span class="number">1</span>]) ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】PAM简单题泛做</title>
    <url>/2019/12/15/PAM%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>都是简单的PAM习题</p>
<a id="more"></a>
<h1 id="1-LG5496-【模板】回文自动机"><a href="#1-LG5496-【模板】回文自动机" class="headerlink" title="$1$ LG5496 【模板】回文自动机"></a>$1$ LG5496 【模板】回文自动机</h1><blockquote>
<p>对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。</p>
<p>$|s|\leq 1e6$</p>
</blockquote>
<p>然后就是PAM的板子题<del>咋感觉好像没有不是很板的PAM题呢</del></p>
<p>考虑对自动机上每个点维护一个出现次数$cnt$，那么考虑串里面的任何一个前缀的回文后缀都是其最长回文后缀的回文后缀，所以就可以有转移</p>
<script type="math/tex; mode=display">
cnt_{p}=cnt_{fail_p}+1</script><p>然后就没有然后了。</p>
<h1 id="2-APIO2014-回文串"><a href="#2-APIO2014-回文串" class="headerlink" title="$2$ [APIO2014]回文串"></a>$2$ [APIO2014]回文串</h1><blockquote>
<p>给你一个由小写拉丁字母组成的字符串$s$。我们定义$s$的一个子串的存在值为这个子串在 $s$中出现的次数乘以这个子串的长度。</p>
<p>对于给你的这个字符串$s$，求所有回文子串中的最大存在值。</p>
<p>$|s|\leq 1e6$</p>
</blockquote>
<p>感觉还是比较妙的……或许也算是PAM的基本操作，就是求出每个回文子串的出现次数。考虑一个子串出现第$t$次的时候（$t&gt;1$），一定是作为其他串的回文后缀出现，而显然<strong>“串的最长回文后缀唯一”</strong>的逆命题<strong>“任何串会唯一作为其他串的最长回文后缀”</strong>也是成立的。故若记录以$u$为$fail$的所有子串集合为$\rm S(u)$，那可以直接用</p>
<script type="math/tex; mode=display">
\rm f_u=ctn_u+\sum_{v\in S(u)}f_v</script><p>其中ctn为单独出现的次数，因为可能有多个子串$s$都不作为其他串的最长回文后缀。</p>
<p>emmm一句话概括，PAM处理子串问题的时候有个特性，就是由于是递减式查询，所以一个回文串不会同时作为回文串和其他串的最长回文后缀出现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; i --) </span><br><span class="line">    P.f[P.pre[i]] += P.f[i], ans = max(ans, <span class="number">1l</span>l * P.len[i] * P.f[i]) ;</span><br></pre></td></tr></table></figure>
<p><del>哪那么多P话，就是背啊</del></p>
<h1 id="3-LG5555-秩序魔咒"><a href="#3-LG5555-秩序魔咒" class="headerlink" title="$3$ LG5555 秩序魔咒"></a>$3$ LG5555 秩序魔咒</h1><blockquote>
<p>求两个串的最长公共回文子串以及该长度的出现次数。</p>
<p>$\rm |S|,|T|\leq 10^6$</p>
</blockquote>
<p><del>恭喜发现一个新套路</del></p>
<p>观察起始$\rm PAM$本身是一棵树，添上了一堆奇奇怪怪的$fail$边才变成有向图。所以考虑，如果从奇根或者偶根同时向下dfs，走同样的转移边，那么一定可以到达同样的状态。所以考虑建两个$\rm PAM$，一起dfs，然后算个答案即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ans == P.len[x]) res ++ ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; P.len[x]) res = <span class="number">1</span>, ans = P.len[x] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By the way，奇根/偶根都要$dp$一次。</p>
<h1 id="4-JSOI2013-快乐的-JYY"><a href="#4-JSOI2013-快乐的-JYY" class="headerlink" title="$4$ [JSOI2013]快乐的 JYY"></a>$4$ [JSOI2013]快乐的 JYY</h1><blockquote>
<p>求两个串的不同公共回文串的个数，其中不同意思是下标不同。</p>
<p>$|s|,|t|\leq 10^6$</p>
</blockquote>
<p>……然而这就是前两个题结合起来。考虑先$dp$一遍算出来每个回文子串的出现次数，然后dfs，乘法原理计数，然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x + y &gt; <span class="number">2</span>) ans += <span class="number">1l</span>l * P.f[x] * Q.f[y] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">26</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (P.trie[x][i] &amp;&amp; Q.trie[y][i]) </span><br><span class="line">            dfs(P.trie[x][i], Q.trie[y][i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	P.Init(), Q.Init() ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (S + <span class="number">1</span>) &gt;&gt; (T + <span class="number">1</span>) ; </span><br><span class="line">	N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), M = <span class="built_in">strlen</span>(T + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) P.Insert(S[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, S) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) Q.Insert(T[i] - <span class="string">'A'</span> + <span class="number">1</span>, i, T) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = P.sz ; i ; -- i) P.f[P.pre[i]] += P.f[i] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Q.sz ; i ; -- i) Q.f[Q.pre[i]] += Q.f[i] ; </span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">1</span>) ; dfs(<span class="number">0</span>, <span class="number">0</span>) ; <span class="built_in">cout</span> &lt;&lt; ans&lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-闲扯"><a href="#5-闲扯" class="headerlink" title="$5$ 闲扯"></a>$5$ 闲扯</h1><p>写模板题真是让人感到空虚……</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>字符串/PAM,回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】PAM &amp; Manacher</title>
    <url>/2019/12/15/PAMandManacher/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PAM &amp; Manacher，两种用来处理回文串的玩意儿。</p>
<a id="more"></a> 
<h1 id="1-Manacher"><a href="#1-Manacher" class="headerlink" title="$1$ Manacher"></a>$1$ Manacher</h1><p><del>挺短，背是挺好背的</del></p>
<p>Manacher用于求回文串长度。思想大概就是：</p>
<p>1、加入字符集之外的识别字符（比如<code>#</code>）分隔开原来相邻的字母，这样所有的回文串都变成了以某个字符为中心的（否则如果是偶数长度的回文串还要特判）。</p>
<p>2、考虑借由以前的信息求出新的回文串长度。记录到现在为止最靠右的回文串中最右侧的字符下标&amp;其对称轴的下标，不妨记这个最靠右的串为$\rm S$。那么考虑以当前位置作为对称轴的答案，一定<strong>至少是$\min${隔着$\rm S$的对称轴与其对称的另一个位置ans，$|S|-i+1$}</strong> 。然后就不断扩展即可。</p>
<p>3、关于复杂度证明。我们记<strong>一次帅气的操作</strong>的意义是<strong>成功让$ans_i$的初始值继承了与之对称的点的答案和边界的取$\min$</strong>，记以当前点为轴的最长回文子串为 $\rm T$，$ \rm T$ 的右端点为 $q$。可以知道 .</p>
<ul>
<li>（1）$\rm S$的右端点是单增的；</li>
<li>（2）如果当前旧的$maxlen&lt;i$，即未成功进行一次帅气的操作，那么显然<code>while</code>1次，$maxlen$增大一次；</li>
<li>（3）如果当前的串经过了一次帅气的操作，那么当$q&lt;maxlen$时，直接跳出<code>while</code>；当$q\geq maxlen$时，$q$增大$maxlen$必增大。所以得出结论，进行一次帅气的操作和$maxlen$的增大次数是严格同阶的。</li>
</ul>
<p>So,最终复杂度就是$\Theta(n)$的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id, fars, i ; </span><br><span class="line">	id = <span class="number">0</span>, fars = <span class="number">0</span> ;</span><br><span class="line">	<span class="comment">//id : 最靠右的回文串的中心位置 </span></span><br><span class="line">	<span class="comment">//fars : 迄今为止最靠右的回文串的最右侧 </span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		ns[++ L] = (<span class="keyword">int</span>)In[i], ns[++ L] = <span class="string">'#'</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (fars &lt;= i) base[i] = <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">else</span> base[i] = min(fars - i + <span class="number">1</span>, base[id * <span class="number">2</span> - i]) ;</span><br><span class="line">		<span class="keyword">while</span> (ns[i + base[i]] == ns[i - base[i]]) base[i] ++ ;</span><br><span class="line"> 		<span class="keyword">if</span> (i + base[i] &gt; fars) id = i, fars = i + base[i] - <span class="number">1</span> ;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), </span><br><span class="line">	L = <span class="number">-1</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">	ns[++ L] = <span class="string">'$'</span>, ns[++ L] = <span class="string">'#'</span> ; Manacher(In) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * N + <span class="number">2</span> ; ++ i) ans = max(ans, base[i] - <span class="number">1</span>) ; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-PAM"><a href="#2-PAM" class="headerlink" title="$2$ PAM"></a>$2$ PAM</h1><p>学了PAM，不知道为啥感觉比SAM简单？</p>
<p>其实就是一种自动机，以回文串为状态，左右各添加一个字符为转移的自动机。要点如下：</p>
<p>0、一个串的回文子串至多有 $O(n)$ 个。</p>
<p>1、首先每个节点需要保存这个节点中回文串的长度。</p>
<p>2、显然始状态需要有两个，即奇数长度的 $s_1$ 和偶数长度的 $s_0$ ，称作<strong>“奇根”</strong>和<strong>“偶根”</strong>。那么为了方便呢，奇根的长度设置为 $-1$，偶根长度设置为 $0$。</p>
<p>3、考虑要从 $last$ 指针扩展当前状态，假设当前需要 <code>insert</code> 的字母是 $c$，是这个串里面的第 $p$ 个字符，那我们需要找到一个后缀 $s[j…p-1]\quad s.t.\quad s[j…p-1]$ 本身回文且 $s[j-1]=c$，那么就可以向下扩展。</p>
<p>4、考虑怎么找这个后缀，显然对于一个串 $\rm S$，他的所有回文后缀都是其最长回文后缀的回文后缀。所以考虑$fail$指针，应当从当前状态连向它的<strong>最长回文后缀</strong>。</p>
<p>5、插入新节点时，考虑跳完 $fail$ 后如果没有相应的转移边，就要新建一个状态然后连$fail$.</p>
<p>然后是代码和一点注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PAM</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> trie[MAXN][Sigma] ;</span><br><span class="line">	<span class="keyword">int</span> rt0, rt1, last, sz ;</span><br><span class="line">	<span class="keyword">int</span> len[MAXN], fail[MAXN] ;</span><br><span class="line">&#125;P ;</span><br><span class="line"><span class="keyword">void</span> _init(PAM &amp;p)&#123;</span><br><span class="line">	p.sz = <span class="number">-1</span>, </span><br><span class="line">	p.rt0 = ++ p.sz, p.rt1 = ++ p.sz ;</span><br><span class="line">	p.fail[p.rt0] = p.fail[p.rt1] = p.rt1 ;</span><br><span class="line">	p.last = p.rt0, p.len[p.rt0] = <span class="number">0</span>, p.len[p.rt1] = <span class="number">-1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _insert(PAM &amp;p, <span class="keyword">int</span> x, <span class="keyword">int</span> pos, <span class="keyword">char</span> *s)&#123;</span><br><span class="line">	<span class="keyword">int</span> u = p.last ; </span><br><span class="line">	<span class="keyword">while</span> (s[pos - p.len[u] - <span class="number">1</span>] != s[pos]) u = p.fail[u] ; </span><br><span class="line">	<span class="keyword">if</span> (!p.trie[u][x])&#123;</span><br><span class="line">		<span class="keyword">int</span> fa = p.fail[u] ;</span><br><span class="line">		<span class="keyword">int</span> newn = ++ p.sz ; </span><br><span class="line">		p.len[newn] = p.len[u] + <span class="number">2</span> ; </span><br><span class="line">		<span class="keyword">while</span> (s[pos - p.len[fa] - <span class="number">1</span>] != s[pos]) fa = p.fail[fa] ; </span><br><span class="line">		p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn, </span><br><span class="line">	&#125;</span><br><span class="line">	p.last = p.trie[u][x] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、$\rm \color{red}{WARNING}$，以下两句顺序不要写反：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p.fail[newn] = p.trie[fa][x], p.trie[u][x] = newn,</span><br></pre></td></tr></table></figure>
<p>原因是当 $fa=u$ 时就出现环了。</p>
<h1 id="3-闲扯"><a href="#3-闲扯" class="headerlink" title="$3$ 闲扯"></a>$3$ 闲扯</h1><p>学完才知道，$\rm PAM$ 又简单又好背功能又多……Manacher被打爆了啊喂qwq。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>PAM,回文自动机</category>
      </categories>
      <tags>
        <tag>字符串/PAM,回文自动机</tag>
        <tag>字符串/Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces前11场泛做</title>
    <url>/2019/11/15/cf1-11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯，然后这些题就是从好久之前开始就一直在做的CF前11场的一些题目，都比较简单，但是决定记录一下补补基础qwq</p>
<a id="more"></a>
<h1 id="rm-CF·1C"><a href="#rm-CF·1C" class="headerlink" title="$\rm {CF·1C}$"></a>$\rm {CF·1C}$</h1><blockquote>
<p>求包含给定三点的正多边形最小面积。</p>
</blockquote>
<hr>
<p>先考虑，对于给出的三个正多边形顶点，两两连边之后，中垂线交于正多边形所在圆的圆心——原因是这三个点最优情况下一定是在顶点上的。那么可以凭此求出圆心和半径。</p>
<p>之后对于该多边形，我们考虑，由于其让求的正多边形需要<strong>面积最小</strong>。并且对于给出的三个点，由于在正多边形上的原因，所以圆心与其连线的角都应该是<strong>该正多边形相邻两个顶点在外接圆上所对的圆心角的整数倍</strong></p>
<p>那么我们就做一个<code>double</code>类型的$\gcd$就好了——因为在外接圆大小一定时（三点已确定一个圆），对于正$n$边形，其面积与$n$成正相关。所以取$\gcd$一定是个最好的选择。</p>
<p>最后的面积嘛…大概只需要余弦定理一下就好。此处借鉴的是第一篇题解里面求面积的方法。同时，第三个角必须用$2\pi$减去另外两个角得到，如果不这样误差会相当的大……尤其是乘上一堆之后，面积会很不精确$qaq$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-4</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.00000</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> mark ; <span class="comment">// 0 = exist, 1 = inexist ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">&#125;A, B, C, O, m1, m2, m3 ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ;<span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line">    <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; <span class="comment">// y = kx + b, x = k, y = k ;</span></span><br><span class="line">&#125;L[<span class="number">12</span>] ; <span class="keyword">double</span> Len[<span class="number">4</span>], agl[<span class="number">4</span>], R, angle ; <span class="keyword">int</span> i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is x = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is y = k ;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_Mid</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.x + B.x) / <span class="number">2</span>, (A.y + B.y) / <span class="number">2</span> &#125; ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_verti</span><span class="params">(Node n, Line a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a.mark) <span class="keyword">return</span> (Line) &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (a.mark == <span class="number">1</span>) <span class="keyword">return</span> (Line) &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, n.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = <span class="number">-1.0</span> / a.k, bb = n.y - n.x * kk ; </span><br><span class="line">  	<span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_Line</span><span class="params">(Node A, Node B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A. y == B. y) <span class="keyword">return</span> (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A. x == B. x) <span class="keyword">return</span> (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, A.x, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">double</span> kk = (A.y - B.y) / (A.x - B.x), bb = A.y - A.x * kk ; </span><br><span class="line">  	<span class="keyword">return</span> (Line)&#123;<span class="number">2</span>, kk, bb, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span><span class="params">(Line A, Line B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) )</span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, get_x(A, B), get_y(A, B)&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.y - B.b) / B.k, A.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (B.y - A.b) / A.k, B.y&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, B.x, B.x * A.k + A.b&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, A.x, A.x * B.k + B.b&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">gcd</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(b) &lt; Eps) <span class="keyword">return</span> a ; </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(a) &lt; Eps) <span class="keyword">return</span> b ; </span><br><span class="line">  <span class="keyword">return</span> gcd(b, <span class="built_in">fmod</span>(a, b)) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A.x &gt;&gt; A.y &gt;&gt; B.x &gt;&gt; B.y &gt;&gt; C.x &gt;&gt; C.y ; </span><br><span class="line">  	A.mark = B.mark = C.mark = <span class="number">0</span> ;</span><br><span class="line">    L[<span class="number">1</span>] = get_Line(A, B), L[<span class="number">2</span>] = get_Line(B, C), L[<span class="number">3</span>] = get_Line(A, C) ; </span><br><span class="line">  	m1 = get_Mid(A, B), m2 = get_Mid(B, C), m3 = get_Mid(A, C) ;</span><br><span class="line">    L[<span class="number">4</span>] = get_verti(m1, L[<span class="number">1</span>]), L[<span class="number">5</span>] = get_verti(m2, L[<span class="number">2</span>]) ;</span><br><span class="line">  	O = get_inter(L[<span class="number">4</span>], L[<span class="number">5</span>]), R = (dis(O, A) + dis(O, B) + dis(O, C)) / <span class="number">3.0</span> ;</span><br><span class="line">    Len[<span class="number">1</span>] = dis(A, B), Len[<span class="number">2</span>] = dis(B, C), Len[<span class="number">3</span>] = dis(A, C) ; </span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) agl[i] = <span class="built_in">acos</span>(<span class="number">1</span> - Len[i] * Len[i] / (<span class="number">2</span> * R * R) ); </span><br><span class="line">    agl[<span class="number">3</span>] = <span class="number">2</span> * Pi - agl[<span class="number">1</span>] - agl[<span class="number">2</span>], angle = gcd(agl[<span class="number">3</span>], gcd(agl[<span class="number">1</span>], agl[<span class="number">2</span>])) ; 		<span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (Pi * R * R * <span class="built_in">sin</span>(angle)) / angle) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·2B"><a href="#rm-CF·2B" class="headerlink" title="$\rm CF·2B$"></a>$\rm CF·2B$</h1><blockquote>
<p>给定由非负整数组成的$n \times n$的正方形矩阵，寻找一条路径，以左上角为起点, 每次只能向右或向下走</p>
<p>以右下角为终点。并且，如果我们把沿路遇到的数进行相乘，积应当以最小数目的$0$的结尾.</p>
<p>$n\leq 1,000$</p>
</blockquote>
<p>考虑$0$是怎么来的，那显然是$\times\text{=10}=2\times 5$。所以就把$2,5$分开$dp$。方程也很简单，就从左边和上边填一下表就好了。然后如果原来矩阵里面有$0$并且最后答案$&gt;1$，那么就应该走$0$；否则就输出路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qwq</span><span class="params">(<span class="keyword">int</span> &amp;N, <span class="keyword">int</span> fac)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!N) &#123; zerox = i, zeroy = j ; <span class="keyword">return</span> <span class="number">1</span> ; &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ; <span class="keyword">while</span> (!(N % fac)) ++ res, N /= fac ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mark, <span class="keyword">int</span> kind)</span></span>&#123; <span class="comment">//mark 1 : D, 2 : R ;</span></span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (kind == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp2[x][y] == dp2[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dp5[x][y] &lt;&lt; " " &lt;&lt; dp5[x - 1][y] &lt;&lt; " " &lt;&lt; dp5[x][y - 1] &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x - <span class="number">1</span>][y] + base[x][y][kind]) </span><br><span class="line">          Print(x - <span class="number">1</span>, y, <span class="number">1</span>, kind) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y - <span class="number">1</span> &amp;&amp; dp5[x][y] == dp5[x][y - <span class="number">1</span>] + base[x][y][kind]) </span><br><span class="line">          Print(x, y - <span class="number">1</span>, <span class="number">2</span>, kind) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mark) <span class="keyword">return</span> ; <span class="keyword">if</span> (mark == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"D"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i][j][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="built_in">memset</span>(dp2, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp2)), dp2[<span class="number">1</span>][<span class="number">0</span>] = dp2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(dp5, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp5)), dp5[<span class="number">1</span>][<span class="number">0</span>] = dp5[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp2[i][j] = min(dp2[i - <span class="number">1</span>][j], dp2[i][j - <span class="number">1</span>]) </span><br><span class="line">          						+ (base[i][j][<span class="number">1</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">2</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            dp5[i][j] = min(dp5[i - <span class="number">1</span>][j], dp5[i][j - <span class="number">1</span>]) </span><br><span class="line">          						+ (base[i][j][<span class="number">2</span>] = qwq(base[i][j][<span class="number">0</span>], <span class="number">5</span>)) ;</span><br><span class="line">    Ans = min(dp5[N][N], dp2[N][N]) ;</span><br><span class="line">    <span class="keyword">if</span> (Ans &gt; <span class="number">1</span> &amp;&amp; zerox &amp;&amp; zeroy)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; zerox &lt;&lt; zeroy &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zerox ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; zeroy ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zerox + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"D"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = zeroy + <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"R"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  		dp5[N][N] &gt; dp2[N][N] ? Print(N, N, <span class="number">0</span>, <span class="number">1</span>) : Print(N, N, <span class="number">0</span>, <span class="number">2</span>) ;</span><br><span class="line">    &#125; </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF-·2C"><a href="#rm-CF-·2C" class="headerlink" title="$\rm CF ·2C$"></a>$\rm CF ·2C$</h1><blockquote>
<p>给出三个互不相交的圆，求一个点使得到这三个圆的切线夹角相同。</p>
</blockquote>
<p><del>咋又是计算几何啊</del></p>
<p>设这点为$T$， 三个圆心分别为$A, B,C$。而圆$A$的半径$r_A$与$dis(A,T)$的比值，就是$sin(\frac{1}{2}\angle A_1TA_2)$，其中$A_1$和$A_2$是过T的圆A的两条切线与圆的交点。</p>
<p>那么也就是说，我们如果有$\angle A_1TA_2 = \angle B_1TB_2= \angle C_1TC_2$，那么一定有<script type="math/tex">\frac{r_A}{dis(A,T)} = \frac{r_B}{dis(B,T)} = \frac{r_C}{dis(C,T)}</script></p>
<p>稍微移一下项，就会有<script type="math/tex">\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)}</script></p>
<p>那么我们就可以发现，对于两个点而言，我们要找的目标点$T$满足到两个点的距离等于一个给定的比例（$r_A$和$r_B$给定）。</p>
<p>事实上，这样的点的轨迹是可以刻画的。我们列一个方程即可：</p>
<p>设比例系数为$k(k \geq 1)$, 那么：</p>
<script type="math/tex; mode=display">
\frac{\sqrt{(x_T - x_A)^2 + (y_T - y_A)^2 }}{\sqrt{(x_T - x_B)^2 + (y_T - y_B)^2 }} = k\\
\frac{(x_T - x_A)^2 + (y_T - y_A)^2 }{(x_T - x_B)^2 + (y_T - y_B)^2 } = k^2</script><p>稍微移一下项就会得到</p>
<script type="math/tex; mode=display">
(k^2-1)x_T^2 + (k^2-1)y_T^2 - 2(k^2y_B - y_A)y_T - 2(k^2x_B - x_A)x_T+k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2 = 0</script><p>看起来有点儿长……</p>
<p>令$A = k^2-1, C = - 2(k^2x_B - x_A), D = -2(k^2y_B - y_A), E = k^2x_B^2 - x_A^2 + k^2y_B^2 - y_A^2$</p>
<p>那么就会变成</p>
<script type="math/tex; mode=display">
Ax^2 + Ay^2+ Cx + Dy+E = 0</script><p>由于$A,C,D,E$都是常数，所以这是一个<strong>圆的一般方程。</strong></p>
<p>我们其实也可以发现，当$k=1$时。此时为一条直线（即中垂线），换句话说<strong>当且仅当两个圆半径相等时，点$T$的轨迹是一条直线</strong>。其余的情况则是<strong>一个圆</strong>。</p>
<p>我们不妨先记这种<strong>到两个圆的圆心的距离成定比例的</strong>轨迹为两个圆的<strong>生成曲线</strong>。</p>
<p>那么之后呢，我们发现，圆$A$和圆$C$的生成曲线，与圆$A$和圆$B$的生成曲线，至多有两个交点。那么我们只需要：</p>
<ul>
<li>$(1)~~$判断三组圆的生成曲线是否都相交且交于一点，不是则无解。</li>
<li>$(2)~~$对于其中两个圆的生成曲线的交点，判断是否满足条件，即是我们已经找到了符合<script type="math/tex">\frac{r_A}{r_B} = \frac{dis(A,T)}{dis(B,T)}</script>的点，我们需要判断对于圆$C$是否也满足<script type="math/tex; mode=display">
\frac{r_A}{r_C} = \frac{dis(A,T)}{dis(C,T)}</script></li>
<li>$(3)~~$如果选取的生成曲线恰好有$2$个交点且两个交点$T’,T’’$都满足$(2)$中的条件，那么我们选$sin$值最大的（对于$\leq \frac{\pi}{2}$的角，$sin$值与角的大小成正相关）。</li>
</ul>
<p>然后算法就结束了。中间还有好多好多好多问题，比如圆与圆的交点怎么求，直线与直线的交点怎么求，圆与直线的交点怎么求……果然是道体力题233</p>
<p>代码很繁琐233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-3</span> ; <span class="keyword">int</span> i ;<span class="comment">//以下的mark都是记录状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> xa, ya, xb, yb ; &#125; I[<span class="number">5</span>] ; </span><br><span class="line"><span class="comment">// 0 = inexist, 1 = exist*1, 2 = exist*2 ;</span></span><br><span class="line"><span class="comment">//此处我的Node存的实际上是两个点，即一个一元二次方程的两个解。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span>&#123;</span> <span class="keyword">int</span> mark ; <span class="keyword">double</span> k, b ; <span class="keyword">double</span> x, y ; &#125;L[<span class="number">12</span>] ; </span><br><span class="line"><span class="comment">//0 : // x-axis, 1: // y-axis, 2: // normal ;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark ; <span class="comment">// 1 : circle ; 0 : Line ;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, r ;</span><br><span class="line">    <span class="keyword">double</span> A, B, C, D, E ;</span><br><span class="line">    Circle <span class="keyword">friend</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> Circle &amp;A, <span class="keyword">const</span> Circle &amp;B)&#123;</span><br><span class="line">        <span class="keyword">return</span> (Circle)&#123;<span class="number">0</span>, A.x - B.x, A.y - B.y, A.r - B.r, A.A - B.A, A.B - B.B, A.C - B.C, A.D - B.D, A.E - B.E&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;C[<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">double</span> ansx, ansy ; <span class="keyword">bool</span> check ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Node A, Node B)</span></span>&#123; <span class="keyword">return</span> A.mark &lt; B.mark ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_x</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">0</span> ? A.x : B.x ; &#125; <span class="comment">//which is (x = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_y</span><span class="params">(Line A, Line B)</span></span>&#123; <span class="keyword">return</span> A.mark == <span class="number">1</span> ? A.y : B.y ; &#125; <span class="comment">//which is (y = k) ;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123; <span class="keyword">return</span> (x - y &lt;= Eps) &amp;&amp; (x - y &gt;= -Eps) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disa</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xa - B.xa) * (A.xa - B.xa) + (A.ya - B.ya) * (A.ya - B.ya)); </span><br><span class="line">&#125;<span class="comment">//第一个点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">disb</span><span class="params">(Node A, Node B)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.xb - B.xb) * (A.xb - B.xb) + (A.yb - B.yb) * (A.yb - B.yb)); </span><br><span class="line">&#125;<span class="comment">//第二个点之间的距离</span></span><br><span class="line"><span class="comment">//呃……我承认两个dis写的很麻烦……但是好像也没什么很简单的法子</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">Line_inter</span><span class="params">(Line A, Line B)</span></span>&#123;<span class="comment">//斜截式直线求交点（之前写的直接copy过来的）</span></span><br><span class="line">    <span class="keyword">if</span> (A.mark == B.mark &amp;&amp; (A.mark == <span class="number">1</span> || A.mark == <span class="number">0</span>) ) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">0</span>) || (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">1</span>)) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, get_x(A, B), get_y(A, B), <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">1</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.y - B.b) / B.k, A.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (B.y - A.b) / A.k, B.y, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">2</span> &amp;&amp; B.mark == <span class="number">0</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, B.x, B.x * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">if</span> (A.mark == <span class="number">0</span> &amp;&amp; B.mark == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, A.x, A.x * B.k + B.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">return</span> (Node)&#123;<span class="number">1</span>, (A.b - B.b) / (B.k - A.k), (A.b - B.b) / (B.k - A.k) * A.k + A.b, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node <span class="title">get_inter</span> <span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//“生成曲线”求交点</span></span><br><span class="line">    <span class="keyword">if</span> ((A.mark == <span class="number">0</span> &amp;&amp; B.mark) || (A.mark &amp;&amp; B.mark == <span class="number">0</span>))&#123;<span class="comment">//一条是直线，一个是圆</span></span><br><span class="line">        <span class="keyword">if</span> (!A.mark) &#123;Circle C ; C = A, A = B, B = C ;&#125; <span class="comment">// B is a line ;</span></span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">1</span> + (B.C / B.D) * (B.C / B.D), del ;</span><br><span class="line">        <span class="keyword">double</span> c = A.E - B.E * A.D / B.D + B.E * B.E /((B.D) * (B.D)) ;</span><br><span class="line">        <span class="keyword">double</span> b = (A.C - B.C * A.D / B.D + <span class="number">2</span> * B.C * B.E /((B.D) * (B.D)) ) ; </span><br><span class="line">        <span class="keyword">if</span> ((del = (b * b - <span class="number">4</span> * a * c)) &lt; -Eps) <span class="keyword">return</span> (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125; ; </span><br><span class="line">        <span class="comment">// printf("%lf %lf %lf %lf\n", a, b, c, del) ;</span></span><br><span class="line">        <span class="keyword">double</span> xa =  (-b + <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a), xb = (-b - <span class="built_in">sqrt</span>(del)) / (<span class="number">2</span> * a) ;</span><br><span class="line">        <span class="keyword">double</span> ya = -B.C / B.D * xa - B.E / B.D, yb = -B.C / B.D * xb - B.E / B.D ; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; "-----------------" &lt;&lt; xa &lt;&lt; " " &lt;&lt; ya &lt;&lt; " " &lt;&lt; xb &lt;&lt; " " &lt;&lt; yb &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">return</span> (Node)&#123;<span class="number">2</span>, xa, ya, xb, yb&#125; ;<span class="comment">//此处由于误差等原因，不容易判断是否delta=0的情况，所如果delta=0直接记录两遍，不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A.mark &amp;&amp; !B.mark)&#123;</span><br><span class="line">        Line La, Lb ; <span class="comment">//两条都是直线，那么就直接转化成斜截式求。</span></span><br><span class="line">        <span class="keyword">if</span> (!A.C) La = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - A.E / A.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!A.D) La = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -A.E / A.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> La = (Line)&#123;<span class="number">2</span>, -A.C / A.D, -A.E / A.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (!B.C) Lb = (Line)&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, - B.E / B.D&#125; ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!B.D) Lb = (Line)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -B.E / B.C, <span class="number">0</span>&#125; ; <span class="keyword">else</span> Lb = (Line)&#123;<span class="number">2</span>, -B.C / B.D, -B.E / B.D, <span class="number">0</span>, <span class="number">0</span>&#125; ;  </span><br><span class="line">        <span class="keyword">return</span> Line_inter(La, Lb) ; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (A.mark &amp;&amp; B.mark)&#123;</span><br><span class="line">        Circle C = A - B ; <span class="keyword">return</span> get_inter(C, A) ;</span><br><span class="line">        <span class="comment">//此处需要用到一点小知识，就是两个圆的交点很难求，但是我们可以通过相减求出交线来（必修二知识点），那么就直接把这条线代回第一个if里就好。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Circle <span class="title">make_rat</span><span class="params">(Circle A, Circle B)</span></span>&#123;<span class="comment">//rat = ratio[n.]比例；比率，用来求生成曲线的函数</span></span><br><span class="line">    <span class="keyword">double</span> _k2 = (A.r / B.r) * (A.r / B.r) ; Circle Ans ; <span class="keyword">double</span> t ; </span><br><span class="line">    Ans.A = Ans.B = (_k2 - <span class="number">1</span>), </span><br><span class="line">  	Ans.C = <span class="number">-2</span> * (_k2 * B.x - A.x), </span><br><span class="line">  	Ans.D = <span class="number">-2</span> * (_k2 * B.y - A.y), </span><br><span class="line">    Ans.E = (_k2 * B.x * B.x - A.x * A.x) + (_k2 * B.y * B.y - A.y * A.y), </span><br><span class="line">  	Ans.x = Ans.y = Ans.r = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">if</span> (Ans.A != <span class="number">0</span>) </span><br><span class="line">      Ans.mark = <span class="number">1</span>, t = Ans.A, Ans.A /= t, </span><br><span class="line">  		Ans.B /= t, Ans.C /= t, Ans.D /= t, Ans.E /= t ; </span><br><span class="line">  	<span class="keyword">else</span> Ans.mark = <span class="number">0</span> ; </span><br><span class="line">  	<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_for_Ans</span><span class="params">()</span></span>&#123;<span class="comment">//最后的结果，判断选哪个交点</span></span><br><span class="line">    sort(I + <span class="number">1</span>, I + <span class="number">3</span>, Comp) ;<span class="comment">//我闲的，方便一点</span></span><br><span class="line">    <span class="keyword">if</span> (I[<span class="number">1</span>].mark &lt;= <span class="number">1</span>) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> A1, A11, B1, B11 ;</span><br><span class="line">        I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]) ;</span><br><span class="line">        A1 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        A11 = disa(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y, <span class="number">0</span>, <span class="number">0</span>&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        B1 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">1</span>].x, C[<span class="number">1</span>].y&#125;) / C[<span class="number">1</span>].r ; </span><br><span class="line">        B11 = disb(I[<span class="number">1</span>], (Node)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, C[<span class="number">3</span>].x, C[<span class="number">3</span>].y&#125;) / C[<span class="number">3</span>].r ;</span><br><span class="line">        <span class="keyword">if</span> (equal(A1, A11) &amp;&amp; !equal(B1, B11)) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; equal(B1, B11)) ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!equal(A1, A11) &amp;&amp; !equal(B1, B11)) </span><br><span class="line">          	check = <span class="number">1</span> ;<span class="comment">//如果在误差范围内都不相等就说明无解。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> Ja = <span class="built_in">sin</span>(<span class="number">1</span> / A1), Jb = <span class="built_in">sin</span>(<span class="number">1</span> / B1) ;<span class="comment">//比较角的大小，通过sin来搞</span></span><br><span class="line">            <span class="keyword">if</span> (Ja &gt; Jb) ansx = I[<span class="number">1</span>].xa, ansy = I[<span class="number">1</span>].ya ; </span><br><span class="line">          	<span class="keyword">else</span> ansx = I[<span class="number">1</span>].xb, ansy = I[<span class="number">1</span>].yb ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; ++ i) </span><br><span class="line">      	<span class="built_in">cin</span> &gt;&gt; C[i].x &gt;&gt; C[i].y &gt;&gt; C[i].r ;</span><br><span class="line">    C[<span class="number">4</span>] = make_rat(C[<span class="number">1</span>], C[<span class="number">2</span>]), </span><br><span class="line">  	C[<span class="number">5</span>] = make_rat(C[<span class="number">2</span>], C[<span class="number">3</span>]), </span><br><span class="line">  	C[<span class="number">6</span>] = make_rat(C[<span class="number">3</span>], C[<span class="number">1</span>]), </span><br><span class="line">    I[<span class="number">1</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">5</span>]), </span><br><span class="line">  	I[<span class="number">2</span>] = get_inter(C[<span class="number">5</span>], C[<span class="number">6</span>]), </span><br><span class="line">  	I[<span class="number">3</span>] = get_inter(C[<span class="number">4</span>], C[<span class="number">6</span>]) ; </span><br><span class="line">    <span class="comment">/*cout &lt;&lt; I[1].xa &lt;&lt; " " &lt;&lt; I[1].xb &lt;&lt; " " &lt;&lt; I[1].ya &lt;&lt; " " &lt;&lt; I[1].yb &lt;&lt; " " &lt;&lt; I[1].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[2].xa &lt;&lt; " " &lt;&lt; I[2].xb &lt;&lt; " " &lt;&lt; I[2].ya &lt;&lt; " " &lt;&lt; I[2].yb &lt;&lt; " " &lt;&lt; I[2].mark &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; I[3].xa &lt;&lt; " " &lt;&lt; I[3].xb &lt;&lt; " " &lt;&lt; I[3].ya &lt;&lt; " " &lt;&lt; I[3].yb &lt;&lt; " " &lt;&lt; I[3].mark &lt;&lt; endl ;*/</span></span><br><span class="line">    <span class="keyword">if</span> (!I[<span class="number">1</span>].mark || !I[<span class="number">2</span>].mark || !I[<span class="number">3</span>].mark) <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">'\n'</span>), <span class="number">0</span> ; </span><br><span class="line">  	make_for_Ans() ; (!check) ? <span class="built_in">printf</span>(<span class="string">"%.5lf %.5lf"</span>, ansx, ansy) : <span class="number">1</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·3B"><a href="#rm-CF·3B" class="headerlink" title="$\rm CF·3B$"></a>$\rm CF·3B$</h1><blockquote>
<p>有一辆载重量为$v$的货车， 准备运送两种物品。 </p>
<p>物品$A$的重量为$1$， 物体$B$的重量为$2$， 每个物品都有一个价值。 求货车可以运送的物品的最大价值。</p>
<p>$n\leq 100,000\quad v\leq 1e9$</p>
</blockquote>
<p>其实是一个非常简单的贪心思路，就是如果两件重量为1的商品合成一件的话，比重量为2的要优我们就选合起来的。</p>
<p>$\mathsf {Somebody}$谈过一个小Idea，就是看上去我们期望每次取偶数个。那么我们一开始如果$M$是奇数，就从重量为1的那一堆选一个最大的……（虽然我不知道这个到底有没有用但是听起来挺科学）</p>
<p>有些小细节需要注意。其中拿出来一个说一下：边界问题其实不需要考虑得太仔细，只要一开始memset整个数组为-INF，那么当一种重量的用完了，另一种重量的没用完时，取max之后不会出现越界的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num ,val ;</span><br><span class="line">&#125; base1[MAXN], base2[MAXN] ; <span class="keyword">int</span> N, M, p, v, v1, v2, c ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Ans ; <span class="keyword">int</span> tot1, tot2, t1, t2, i ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(Data a, Data b)</span></span>&#123; <span class="keyword">return</span> a.val &gt; b.val ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">    <span class="built_in">memset</span>(base1, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base1)) ; </span><br><span class="line">    <span class="built_in">memset</span>(base2, <span class="number">-63</span>, <span class="keyword">sizeof</span>(base2)) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;v) ;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">1</span>) base2[++ tot2].val = v, base2[tot2].num = i ;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">/*qwq*/</span>base1[++ tot1].val = v, base1[tot1].num = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(base1 + <span class="number">1</span>, base1 + tot1 + <span class="number">1</span>, Comp), </span><br><span class="line">    sort(base2 + <span class="number">1</span>, base2 + tot2 + <span class="number">1</span>, Comp) ;</span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base1[i].num &lt;&lt; " " &lt;&lt; base1[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="comment">// for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; base2[i].num &lt;&lt; " " &lt;&lt; base2[i].val &lt;&lt; " qwwq " ;</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp; <span class="number">1</span>) ans.pb(base1[<span class="number">1</span>].num), Ans += base1[<span class="number">1</span>].val, ++ t1, M -- ;</span><br><span class="line">    <span class="keyword">while</span> (M &gt; <span class="number">1</span>)&#123;<span class="comment">//此处&gt;1是选v=2时防止越界</span></span><br><span class="line">        v2 = base2[t2 + <span class="number">1</span>].val ;</span><br><span class="line">        <span class="keyword">if</span> (t1 &gt;= tot1 &amp;&amp; t2 &gt;= tot2) <span class="keyword">break</span> ;</span><br><span class="line">        v1 = base1[t1 + <span class="number">1</span>].val + base1[t1 + <span class="number">2</span>].val ; </span><br><span class="line">        <span class="keyword">if</span> (t1 + <span class="number">2</span> &gt; tot1) v1 = base1[t1 + <span class="number">1</span>].val, c = <span class="number">1</span> ; <span class="keyword">else</span> c = <span class="number">2</span> ; </span><br><span class="line">        <span class="keyword">if</span> (v1 &gt;= v2)&#123;</span><br><span class="line">            Ans += v1 ; M -= c ;</span><br><span class="line">            rep(i, <span class="number">1</span>, c) ans.pb(base1[++ t1].num) ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Ans += v2, M -= <span class="number">2</span>, ans.pb(base2[++ t2].num) ; </span><br><span class="line">    &#125;<span class="comment">//因为while的条件是M&gt;1,所以需要判断一下是不是还可以选。</span></span><br><span class="line">    <span class="keyword">if</span> (M &amp;&amp; t1 &lt; tot1) </span><br><span class="line">      Ans += base1[++ t1].val, ans.pb(base1[t1].num) ; </span><br><span class="line">  	<span class="keyword">if</span> (Ans &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0\n"</span>), <span class="number">0</span> ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator k = ans.begin() ; k != ans.end() ; ++ k) <span class="built_in">cout</span> &lt;&lt; *k &lt;&lt; <span class="string">" "</span> ;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·4D"><a href="#rm-CF·4D" class="headerlink" title="$\rm{CF·4D}$"></a>$\rm{CF·4D}$</h1><blockquote>
<p>给出一个限制$(w,h)$和$n$个物品的二维信息$(w_i,h_i)$</p>
<p>求物品二维都满足$w_i&gt;w,~h_i&gt;h$的前提下的最长二维严格上升子序列以及其长度<br>$n \leq 5,000$</p>
</blockquote>
<p>一个比较显然的想法是，由于可以随便安排顺序，所以可以直接按其中一维排一个序，把这个当做下标，然后找另一维的$\mathsf {LIS}$。 那么由于是严格升序，所以要判一下相等。路径就照例是找前驱。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)	&#123; </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), f[i] = <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">if</span> (A &lt;= W || B &lt;= H) <span class="keyword">continue</span> ;</span><br><span class="line">      E[++ tot].w = A, E[tot].h = B, E[tot].num = i ;</span><br><span class="line">  &#125;</span><br><span class="line">  sort(E + <span class="number">1</span>, E + tot + <span class="number">1</span>, Comp) ;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; i ; ++ j)</span><br><span class="line">          <span class="keyword">if</span> (E[j].w &lt; E[i].w &amp;&amp; E[j].h &lt; E[i].h)</span><br><span class="line">              <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                  f[i] = f[j] + <span class="number">1</span>, r[i] = j ;</span><br><span class="line">              &#125; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (f[i] &gt; ans) ans = f[i], End = i ;</span><br><span class="line">  <span class="keyword">while</span>(End) s.push(End), End = r[End] ; <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">while</span> (!s.empty()) <span class="built_in">cout</span> &lt;&lt; E[s.top()].num &lt;&lt; <span class="string">" "</span>, s.pop() ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·5C"><a href="#rm-CF·5C" class="headerlink" title="$\rm CF·5C$"></a>$\rm CF·5C$</h1><blockquote>
<p>给出一个括号序列，求出最长合法子串和它的数量。 合法的定义：这个序列中左右括号匹配。</p>
<p>$n\leq 1,000,000$</p>
</blockquote>
<p>好像是道$sb$题？考虑把所有可以匹配的位置置为$1$，否则为$0$，那么答案就是有最长连续的$1$的段。$dp$一下就好了吧…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> In[MAXN] ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; s ; </span><br><span class="line"><span class="keyword">int</span> N, dp[MAXN], f[MAXN], base[MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) s.push(i)<span class="comment">/*, cout &lt;&lt; "qwq" &lt;&lt; endl */</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!s.empty()) base[s.top()] = base[i] = <span class="number">1</span>, s.pop() ; </span><br><span class="line">    &#125; <span class="keyword">int</span> ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (base[i]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span> ; <span class="keyword">else</span> dp[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      f[i] = max(f[i - <span class="number">1</span>], dp[i]) ; <span class="built_in">cout</span> &lt;&lt; f[N] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">  	<span class="keyword">int</span> maxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (dp[i] == f[N]) ++ ans ; <span class="built_in">cout</span> &lt;&lt; (f[N] ? ans : <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·5D"><a href="#rm-CF·5D" class="headerlink" title="$\rm CF·5D$"></a>$\rm CF·5D$</h1><blockquote>
<p>有一个长度为$l$的道路，你的加速是$a$。</p>
<p>从$[0,d]$的限速是$w$，$[0,l]$的限速是$v$，问你最少花费多少时间从起点到终点。</p>
<p>$w$的限速范围是$[d,d]$，即是说保证在交通标志处的速度不超过$w$即为合法。</p>
</blockquote>
<p>高中物理模拟题？？</p>
<p>其实就是分类讨论一下就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> mark ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span> ; </span><br><span class="line"><span class="keyword">double</span> x_1, x_2, ans, x ;</span><br><span class="line"><span class="keyword">double</span> vnow, a, vmax, L, D, vmaxd ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b &gt; a) swap(a, b) ;</span><br><span class="line">	<span class="keyword">return</span> ((a - b &lt;= eps) &amp;&amp; (b - a &gt;= -eps)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; vmax &gt;&gt; L &gt;&gt; D &gt;&gt; vmaxd ;</span><br><span class="line">	vnow = <span class="built_in">sqrt</span>(<span class="number">0.5</span> * (<span class="number">2</span> * a * D + vmaxd * vmaxd)) ; </span><br><span class="line">	<span class="keyword">if</span> (vnow &gt; vmax) vnow = vmax, mark = <span class="number">1</span> ;</span><br><span class="line">	x_1 = vnow * vnow / <span class="number">2</span> / a, x_2 = (vnow * vnow - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line">	<span class="keyword">if</span> (vnow &gt; vmaxd || equal(vnow, vmaxd))&#123;</span><br><span class="line"><span class="comment">//		if (!mark)&#123;</span></span><br><span class="line">			ans += vnow / a + (vnow - vmaxd) / a ; </span><br><span class="line">			<span class="keyword">if</span> (x_1 + x_2 &lt; D) x = D - x_1 - x_2, ans += x / vnow ;</span><br><span class="line">		<span class="comment">/*&#125;</span></span><br><span class="line"><span class="comment">		else &#123;</span></span><br><span class="line"><span class="comment">			ans += vnow / a + (vnow - vmaxd) / a ;</span></span><br><span class="line"><span class="comment">			x = ans += x / vnow ;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		vnow = vmax, x = vnow * vnow / <span class="number">2</span> / a ;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; L || equal(x, L))&#123;</span><br><span class="line">			ans = vnow / a, ans += (L - x) / vmax ;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			vnow = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * L) ;</span><br><span class="line">			ans = vnow / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	x = (vmax * vmax - vmaxd * vmaxd) / <span class="number">2</span> / a ;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; L - D || equal(x, L - D))&#123;</span><br><span class="line">		ans += (vmax - vmaxd) / a, ans += (L - D - x) / vmax ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		vnow = vmaxd, x = <span class="built_in">sqrt</span>(<span class="number">2</span> * a * (L - D) + vnow * vnow) ;</span><br><span class="line">		ans += (x - vnow) / a, <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·5E"><a href="#rm-CF·5E" class="headerlink" title="$\rm CF·5E$"></a>$\rm CF·5E$</h1><blockquote>
<p>有$\mathsf n$座山组成一个环，两座山互相能看到的要求是相连的圆弧上没有任何其他的山高度比它们高，求能看到的山的组数。</p>
<p>$n\leq 100,000$</p>
</blockquote>
<p>一眼看上去就给人一股单调栈的味道……但是看上去要断环为链？但是如果断环为链的话，有些贡献会算重。但是考虑会算重的正好是算一遍只算一个序列的答案。但是这还不够，因为我们发现成链之后，最高值和次高值在$[1,n]$能互相看到，并且在$[1,n]$和$[n+1,2n]$的交界也能互相看到。所以应该把这部分减去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= L ; ++ i) <span class="built_in">stack</span>[i] = Mp(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">	init(M), ans = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> i, tp = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (tp &amp;&amp; <span class="built_in">stack</span>[tp].first &lt; base[i]) </span><br><span class="line">      ans += <span class="built_in">stack</span>[tp].second, -- tp ;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">stack</span>[tp].first != base[i])  </span><br><span class="line">			ans += (tp &gt; <span class="number">0</span>), <span class="built_in">stack</span>[++ tp] = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line">		<span class="keyword">else</span> ans += (tp &gt; <span class="number">1</span>) + <span class="built_in">stack</span>[tp].second, ++ <span class="built_in">stack</span>[tp].second ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i + N] = base[i] = qr() ;</span><br><span class="line">	pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; St, Ed ;</span><br><span class="line">	St = Mp(<span class="number">-1</span>, <span class="number">0</span>), Ed = Mp(<span class="number">-1</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (St.first &lt; base[i]) </span><br><span class="line">      Ed = St, St = Mp(base[i], <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (St.first == base[i]) ++ St.second ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Ed.first &lt; base[i]) Ed = Mp(base[i], <span class="number">1</span>) ; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Ed.first == base[i]) ++ Ed.second ;</span><br><span class="line">	&#125;</span><br><span class="line">	Ans = Solve(<span class="number">2</span> * N) - Solve(N),</span><br><span class="line">  Ans -= (St.second * St.second + ((St.second == <span class="number">1</span>) ? Ed.second : <span class="number">0</span>)), </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·6D"><a href="#rm-CF·6D" class="headerlink" title="$\rm CF·6D$"></a>$\rm CF·6D$</h1><blockquote>
<p>有一队人，你可以用膜某个人，会对当前人造成$a$点伤害，对旁边的人造成$b$点伤害。血量没了就会伤透心。</p>
<p>不能膜$1$号和$n$号，求最少多少膜多少次让所有人伤透心。</p>
<p>$n\leq 10$</p>
</blockquote>
<p>看数据范围觉得是状压。后来发现其实就跟$\rm CF1110$的那个麻将题差不多，只需要记录$i-1$和$i$的状态即可。于是$f_{i,j,k}$表示前$i$个人，在$i-1$这里还剩$j$血，在$i$这里还剩$k$血，且前$i$个人都伤透心$\min$。然后记录一下路径就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, a, b, blood[MAXN], i, j, k, l ; </span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; From[MAXN][MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> jj, <span class="keyword">int</span> kk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (step &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;	</span><br><span class="line">	Print(step - <span class="number">1</span>, From[step + <span class="number">1</span>][jj][kk].first, From[step + <span class="number">1</span>][jj][kk].second) ;</span><br><span class="line">	<span class="keyword">int</span> tow = dp[step][From[step + <span class="number">1</span>][jj][kk].first][From[step + <span class="number">1</span>][jj][kk].second] ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">1</span> ; qwq &lt;= dp[step + <span class="number">1</span>][jj][kk] - tow ; ++ qwq) <span class="built_in">printf</span>(<span class="string">"%d "</span>, step) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; a &gt;&gt; b ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; blood[i], ++ blood[i] ;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">2</span>][blood[<span class="number">1</span>]][blood[<span class="number">2</span>]] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= blood[i - <span class="number">1</span>] ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= blood[i] ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">int</span> down_ = (j + b - <span class="number">1</span>) / b ;</span><br><span class="line">				<span class="keyword">if</span> (dp[i][j][k] &gt; INF) <span class="keyword">continue</span> ;</span><br><span class="line">				<span class="keyword">int</span>	up_ = max(down_, max((blood [i + <span class="number">1</span>] + b - <span class="number">1</span>) / b, (k + a - <span class="number">1</span>) / a)) ;</span><br><span class="line">				<span class="keyword">for</span> (l = down_ ; l &lt;= up_ ; ++ l)&#123;</span><br><span class="line">					<span class="keyword">int</span> now_j = max(<span class="number">0</span>, k - a * l) ;</span><br><span class="line">          <span class="keyword">int</span> now_k = max(<span class="number">0</span>, blood[i + <span class="number">1</span>] - b * l) ;</span><br><span class="line">					<span class="keyword">if</span> (dp[i + <span class="number">1</span>][now_j][now_k] &gt; dp[i][j][k] + l)</span><br><span class="line">						dp[i + <span class="number">1</span>][now_j][now_k] = dp[i][j][k] + l, </span><br><span class="line">          	From[i + <span class="number">1</span>][now_j][now_k] = Mp(j ,k) ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[N][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; Print(N - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF-·6E"><a href="#rm-CF-·6E" class="headerlink" title="$\rm CF ·6E$"></a>$\rm CF ·6E$</h1><blockquote>
<p>给一个$n$个元素的序列，从中挑出最长的子序列，要求子序列中元素差的最大值不超过$k$。问有几个最长子序列，子序列长度，以及这几个子序起始、终止位置。</p>
<p>$n\leq 100,000$</p>
</blockquote>
<p>憨批题。显然就是个单调队列，但是发现似乎并没有什么很诡异的限制，并且只要求一个最大值最小值。于是果断想到$st$表套二分，复杂度$n\log n-n\log^2 n$……被单调队列吊起来锤233</p>
<p>值得注意的一点是，$st$表回答询问的复杂度，大多数写法都是亚$\log $级别的，而不是传的神乎其神的$O(1)$。但其实只要预处理一下大于等于$x$的$2$的幂即可。</p>
<p>然后CSP前试机的时候顺便写出了单调队列的做法，代码大概长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q[MAXN], p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, h1 = <span class="number">1</span>, t1 = <span class="number">0</span>, h2 = <span class="number">1</span>, t2 = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; base[q[t1]] &lt; base[i]) t1 -- ;</span><br><span class="line">  <span class="keyword">while</span> (h2 &lt;= t2 &amp;&amp; base[p[t2]] &lt; base[i]) t2 -- ;</span><br><span class="line">  q[++ t1] = p[++ t2] = i ; </span><br><span class="line">  <span class="keyword">while</span> (h1 &lt;= t1 &amp;&amp; h2 &lt;= t2 &amp;&amp; base[q[h1]] - base[p[h2]] &gt; K)&#123;</span><br><span class="line">  	l ++ ; <span class="keyword">while</span> (q[h1] &lt; l) ++ h1 ; <span class="keyword">while</span> (p[h2] &lt; l) ++ h2 ;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max(ans, s[i] - s[l - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是二分$st$表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_ST</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> H = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= H ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i + (<span class="number">1</span> &lt;&lt; j) &lt;= N + <span class="number">1</span> ; ++ i)</span><br><span class="line">			dp1[i][j] = max(dp1[i][j - <span class="number">1</span>], dp1[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]), </span><br><span class="line">			dp2[i][j] = min(dp2[i][j - <span class="number">1</span>], dp2[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line">	<span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line">	<span class="keyword">return</span> max(dp1[l][k - <span class="number">1</span>], dp1[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> base[l] ;</span><br><span class="line">	<span class="keyword">while</span> (l + (<span class="number">1</span> &lt;&lt; k) &lt;= r) ++ k ;</span><br><span class="line">	<span class="keyword">return</span> min(dp2[l][k - <span class="number">1</span>], dp2[r - (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) + <span class="number">1</span>][k - <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		dp1[i][<span class="number">0</span>] = dp2[i][<span class="number">0</span>] = base[i] = qr() ;</span><br><span class="line">	build_ST(), ans = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		L = i, R = N ;</span><br><span class="line">		<span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">			Mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">if</span> (query_max(i, Mid) - query_min(i, Mid) &lt;= K) </span><br><span class="line">				t = Mid, L = Mid + <span class="number">1</span> ; </span><br><span class="line">			<span class="keyword">else</span> R = Mid - <span class="number">1</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		L = t ;</span><br><span class="line">		<span class="keyword">if</span> (L - i + <span class="number">1</span> &gt; ans) ans = L - i + <span class="number">1</span>, Ans[cnt = <span class="number">1</span>][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (L - i + <span class="number">1</span> == ans) Ans[++ cnt][<span class="number">0</span>] = i, Ans[cnt][<span class="number">1</span>] = L ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">" "</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, Ans[i][<span class="number">0</span>], Ans[i][<span class="number">1</span>]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·7C"><a href="#rm-CF·7C" class="headerlink" title="$\rm CF·7C$"></a>$\rm CF·7C$</h1><blockquote>
<p>给定一条直线：$Ax+By+C=0$（$A,B$不同时为$0$），找到任意一个点（在$-5e18$~$5e18$之间）让它的横纵坐标均为整数，或者确定没有这样的点。</p>
</blockquote>
<p>sb的exgcd。我当时为什么要做这种题？$\rm Cf$又为什么要出这种题？qwq</p>
<h1 id="rm-CF·7D"><a href="#rm-CF·7D" class="headerlink" title="$\rm CF·7D$"></a>$\rm CF·7D$</h1><blockquote>
<p>一个长度为$n$字符串$\sf S$被叫做$k$阶回文串，当且仅当它本身是一个回文串，而且它长度为$\lfloor \frac{n}{2}\rfloor$的前缀和后缀都是$k-1$阶回文串。任何一个字符串（包括空字符串）都至少是$0$阶字符串。举例来说，<code>abaaba</code>是3阶字符串。</p>
<p>现在给定你一字符串，请你求出其所有前缀的的阶级之和。</p>
<p>$|\sf S|\leq 5,000,000$</p>
</blockquote>
<p>似乎有时候哈希写的比较$6$这种题几乎是秒。考虑$f_i$表示以$i$为结尾的字符串的阶数，那么</p>
<script type="math/tex; mode=display">
f_i=[H[1...\lfloor \frac{i}{2}\rfloor]=H[i-\lfloor \frac{i}{2}\rfloor+1...i]\quad ]\cdot (f_{\lfloor \frac{i}{2}\rfloor}+1)</script><p>答案就是$\sum f_i$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">131</span> ;<span class="keyword">bool</span> mark[MAXN] ;</span><br><span class="line"><span class="keyword">char</span> S[MAXN] ; <span class="keyword">int</span> N, Ans, i, j, h, ans[MAXN] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base1[MAXN], base2[MAXN], times[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	times[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		base1[i] = (base1[i - <span class="number">1</span>] * base + S[i]) % Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		base2[i] = (base2[i - <span class="number">1</span>] * base + S[N - i + <span class="number">1</span>]) % Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) times[i] = times[i - <span class="number">1</span>] * base % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), </span><br><span class="line">	N = <span class="built_in">strlen</span>(S + <span class="number">1</span>), init() ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		h = i / <span class="number">2</span> ;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> t1 = base1[h] % Mod ;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> t2 = (base2[N - i + h] - (base2[N - i] * times[h] % Mod) + Mod) % Mod ;</span><br><span class="line">		ans[i] = (t1 == t2) * (ans[h] + <span class="number">1</span>),  Ans += ans[i] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·8C"><a href="#rm-CF·8C" class="headerlink" title="$\rm CF·8C$"></a>$\rm CF·8C$</h1><blockquote>
<p>平面上有$n\leq 24$个物品，pks从原点出发，求全部拾起并且回到原点行走的最短总距离。注意，他不能同时拿$&gt;2$件物品。</p>
</blockquote>
<p>我寻思着这不就是个欧拉路……只不过加了个限制。那么还是$\sf f_S$表示拿完$\sf S$里的东西，所走的最小距离。每次枚举两个点转移即可。但是注意即使是$\rm Cf$的机子，$2^{24}\cdot 24^2$这东西也不可能跑出来。于是考虑一个剪枝，就是考虑如果把状态中的元素两两分组，那么考虑组与组之间是没有顺序可言的。于是就可以单调地枚举状态，合法就跳出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN], Pre[MAXN], Max ;</span><br><span class="line"><span class="keyword">int</span> N, D[<span class="number">50</span>][<span class="number">50</span>], i, j, k, bit[<span class="number">50</span>], tp ; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Obj[<span class="number">50</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; Obj[<span class="number">0</span>].fr &gt;&gt; Obj[<span class="number">0</span>].sc &gt;&gt; N ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; Obj[i].fr &gt;&gt; Obj[i].sc ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; i ; ++ j)</span><br><span class="line">			D[i][j] = D[j][i] = (Obj[i].fr - Obj[j].fr) * (Obj[i].fr - Obj[j].fr) </span><br><span class="line">      									+ (Obj[i].sc - Obj[j].sc) * (Obj[i].sc - Obj[j].sc) ;</span><br><span class="line">	Max = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i) dp[i] = Inf ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="keyword">sizeof</span>(bit)), tp = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) bit[++ tp] = j + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= tp ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tp ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j != k)&#123;</span><br><span class="line">					<span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]])</span><br><span class="line">						dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>)] + D[bit[k]][bit[j]] + D[<span class="number">0</span>][bit[k]] + D[<span class="number">0</span>][bit[j]], </span><br><span class="line">          Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ^ (<span class="number">1</span> &lt;&lt; bit[j] - <span class="number">1</span>) ;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">					<span class="keyword">if</span> (dp[i] &gt; dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>])</span><br><span class="line">						dp[i] = dp[i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>)] + D[<span class="number">0</span>][bit[k]] + D[bit[k]][<span class="number">0</span>], </span><br><span class="line">        		Pre[i] = i ^ (<span class="number">1</span> &lt;&lt; bit[k] - <span class="number">1</span>) ;</span><br><span class="line">				<span class="keyword">if</span> (dp[i] &lt; <span class="number">1061109567</span>) <span class="keyword">break</span> ;</span><br><span class="line">			&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[Max] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">	<span class="keyword">while</span> (Max)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">		<span class="keyword">int</span> qaq = Max ^ Pre[Max] ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; i &amp; qaq) <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">		Max = Pre[Max] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·9D"><a href="#rm-CF·9D" class="headerlink" title="$\rm CF·9D$"></a>$\rm CF·9D$</h1><blockquote>
<p>用$n$个点组成二叉树，问高度大于等于$h$的有多少个。</p>
<p>$n\leq 35$</p>
</blockquote>
<p>没有限制就是卡特兰数这不必说……但是如果跳出思维定式的话，考虑原来的$dp_i$表示前i个点组成二叉树的方案数，转移就是枚举两个子树——那么如果要考虑高度，只需要加一维高度$j$即可，正好是高度$+1-1$的关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; H ; <span class="keyword">int</span> i, j, k ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; j ; ++ k)</span><br><span class="line">				dp[j][i] += dp[k][i - <span class="number">1</span>] * dp[j - k - <span class="number">1</span>][i - <span class="number">1</span>] ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[N][N] - dp[N][D - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·10C"><a href="#rm-CF·10C" class="headerlink" title="$\rm CF·10C$"></a>$\rm CF·10C$</h1><blockquote>
<p>定义函数$s(x)$，$s(x)$的值等于$x$各数位上的数值之和，定义函数$d(x)$，当$s(x)\leq 9$时$d(x)=s(x)$，否则$d(x)=d(s(x))$。举例来说，$d(6543)=d(6+5+4+3)=d(18)=9$</p>
<p>现在给定一上限$N$，求在$[1….N]$内任取$A$，$B$，$C$满足$A\cdot B\not =C$且$d(C)=d(d(A)⋅d(B))$的组数。</p>
<p>$N\leq 1000000$</p>
</blockquote>
<p>考虑$d()$的本质：</p>
<script type="math/tex; mode=display">
d(x)=\left\{\begin{array}{ll}{x \bmod 9,} & {x \bmod 9 \neq 0} \\ {9,} & {x \bmod 9=0}\end{array}\right.</script><p>那么其实$a\cdot b=c$就一定意味着$d(d(a)\cdot d(b))=d(c)$，所以启发我们可以先求出后一部分的，然后减去前一部分。那么前一半的就是$\leq n$所有数的约数个数和。而这东西有一个经典的$O(n)$做法，就是枚举每一个$i$对它的倍数产生贡献。</p>
<p>那么后一半就可以考虑按照余数分类做，然后乘法原理乘起来即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, base[<span class="number">20</span>], A, B, i, j ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    base[i % <span class="number">9</span>] ++, B += N / i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">8</span> ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= <span class="number">8</span> ; ++ j)</span><br><span class="line">			A += base[i] * base[j] * base[i * j % <span class="number">9</span>] ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; A - B &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·10D"><a href="#rm-CF·10D" class="headerlink" title="$\rm CF·10D$"></a>$\rm CF·10D$</h1><blockquote>
<p>求两个串的最长公共上升子序列。</p>
<ul>
<li><p>$n\leq 500$</p>
</li>
<li><p>$n\leq 5,000$</p>
</li>
</ul>
</blockquote>
<p>第一个$subtask$，考虑$\sf f_{i,j}$表示$A$到$i$，$B$到$j$的最长公共上升子序列。那么转移的时候考虑多枚举一维$k$，当$A_i=B_j$时，可以从$k$转移过来。于是复杂度为$n^3$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">		dp[i][j] = dp[i - <span class="number">1</span>][j] ;</span><br><span class="line">		<span class="keyword">if</span> (base1[i] != base2[j]) <span class="keyword">continue</span> ;</span><br><span class="line">		dp[i][j] = <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt; j ; ++ k)</span><br><span class="line">			<span class="keyword">if</span> (base2[k] &lt; base2[j] &amp;&amp; dp[i][j] &lt; dp[i - <span class="number">1</span>][k] + <span class="number">1</span>)</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][k] + <span class="number">1</span>, f[j] = k ;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>但是考虑其实$j$每次向右只加了$1$，所以对于同一个$i$，有很多决策都是重复的。换句话说就是这个决策（$k$）是否应该选，在$j=k$时就可以求出来，而不用再向前扫一遍，因为在$A_i$定住的时候是没区别的。</p>
<p>于是最后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x) <span class="keyword">return</span> ;</span><br><span class="line">	dfs(pre[x]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, B[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k, n = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (N = qr(), i = <span class="number">1</span> ; i &lt;= N ; ++ i) A[i] = qr() ;</span><br><span class="line">	<span class="keyword">for</span> (M = qr(), i = <span class="number">1</span> ; i &lt;= M ; ++ i) B[i] = qr() ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>, befo = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] != B[j]) f[i][j] = f[i - <span class="number">1</span>][j] ;</span><br><span class="line">			<span class="keyword">else</span> f[i][j] = res + <span class="number">1</span>, pre[j] = befo ;</span><br><span class="line">			<span class="keyword">if</span> (B[j] &lt; A[i]) </span><br><span class="line">				<span class="keyword">if</span> (res &lt; f[i - <span class="number">1</span>][j]) </span><br><span class="line">					res = f[i - <span class="number">1</span>][j], befo = j ; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (ans &lt; f[N][i]) ans = f[N][i], n = i ; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; dfs(n) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·11C"><a href="#rm-CF·11C" class="headerlink" title="$\rm CF·11C$"></a>$\rm CF·11C$</h1><blockquote>
<p>你有一个$01$矩阵。里面有多少个正方形？</p>
<p>其中正方形的边用$1$表示。我们现在只对这些正方形感兴趣：</p>
<p>第一种：每条边与矩阵的边平行的正方形；</p>
<p>第二种：每条边与矩阵的对角线平行的正方形。</p>
<p>$t\leq 10,000\quad 2\leq n,m\leq 250$</p>
</blockquote>
<p>然后就是个搜索，用来练程序实现的。大概就是考虑八连通地去$\sf dfs$ ，然后只搜$1$不搜$0$，记录一下搜过的周长，然后去$check$ 。$check$主要就是分类讨论是平行对角线还是平行边长。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> &amp;step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (base[x][y] != <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">    base[x][y] = <span class="number">-1</span>, ++ step ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = x + dx[i], ky = y + dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (kx &gt;= <span class="number">1</span> &amp;&amp; kx &lt;= N &amp;&amp; ky &gt;= <span class="number">1</span> &amp;&amp; ky &lt;= M) dfs(kx, ky, step) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk1</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + step &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + i][y] != <span class="number">-1</span>) | (base[x][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + step][y + i] != <span class="number">-1</span>) | (base[x + i][y + step] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk2</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lx = step &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x + lx &gt; N || y + step &gt; M) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (base[x + lx][y] != <span class="number">-1</span> || y &lt; step) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j ; i &lt;= step ; ++ i)&#123;</span><br><span class="line">        j = (base[x + lx - i][y - i] != <span class="number">-1</span>) | (base[x + lx - i][y + i] != <span class="number">-1</span>)</span><br><span class="line">            | (base[x + i][y - i] != <span class="number">-1</span>) | (base[x + i][y + i] != <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (j) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;base[i][j]) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (base[i][j] != <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">                res = <span class="number">0</span>, dfs(i, j, res) ;</span><br><span class="line">                <span class="keyword">if</span> (res % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; res / <span class="number">4</span> &lt;= min(N, M))</span><br><span class="line">                    ans += chk1(res / <span class="number">4</span>, i, j) + chk2(res / <span class="number">4</span>, i, j) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-CF·11D"><a href="#rm-CF·11D" class="headerlink" title="$\rm CF·11D$"></a>$\rm CF·11D$</h1><blockquote>
<p>求简单无向图的环数。</p>
<p>$n\leq 19$</p>
</blockquote>
<p>一开始想状压边，但是发现转移比较难转移并且状态数太多。于是就考虑定$\sf f_{s,u,v}$表示走过了集合$\sf s$中的点，起点为$u$终点为$v$的方案数。枚举转移的时候考虑刷表，枚举不在集合$\sf s$中的一个新点转移。</p>
<p>观察到其实转移时并不需要知道是从哪个点转移过来的，这东西也不影响方案数，所以直接默认是从<code>lowbit</code>转移过来的，这样每次需要判一下新的点会不会破坏这个状态的起点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; N &gt;&gt; M, Mx &#x3D; (1 &lt;&lt; N) - 1 ;</span><br><span class="line">for (i &#x3D; 1, j &#x3D; 0 ; j &lt; N ; ++ j, i &lt;&lt;&#x3D; 1) f[i][j] &#x3D; 1 ;</span><br><span class="line">for (i &#x3D; 1 ; i &lt;&#x3D; M ; ++ i) cin &gt;&gt; u &gt;&gt; v, u --, v --, A[u][v] &#x3D; A[v][u] &#x3D; 1 ;</span><br><span class="line">for (s &#x3D; 1 ; s &lt;&#x3D; Mx ; ++ s)&#123;</span><br><span class="line">    for (i &#x3D; 0 ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        if (!((1 &lt;&lt; i) &amp; s) || !f[s][i]) continue ;</span><br><span class="line">        for (j &#x3D; 0 ; j &lt; N ; ++ j)&#123;</span><br><span class="line">            if (!A[i][j] || low(s) &gt; (1 &lt;&lt; j)) continue ;</span><br><span class="line">            if ((1 &lt;&lt; j) &#x3D;&#x3D; low(s) &amp;&amp; (1 &lt;&lt; j &amp; s)) ans +&#x3D; f[s][i] ;</span><br><span class="line">            else if (!(1 &lt;&lt; j &amp; s)) f[s | (1 &lt;&lt; j)][j] +&#x3D; f[s][i] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ((ans - M) &gt;&gt; 1) &lt;&lt; endl ;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>动态规划/普通DP</tag>
        <tag>数学/扩展欧几里德</tag>
        <tag>贪心</tag>
        <tag>计算几何/基础的点、直线与圆</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round-840 Virtual</title>
    <url>/2019/11/14/Codeforces-840/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>virtual了一场div1，发现题目有点清新，但是至今还是没有做$E$，因为$E$是个分块233</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>Leha喜欢各种各样奇怪的事。最近他喜欢上了函数$F(n,k)$。考虑所有集合$[1,2,\dots,n]$ 的有$k$个元素的子集。为这些子集找到其中最小的元素。$F(n,k)$ — 就是所有$k$个元素子集中的最小元素的数学期望。</p>
<p>但是仅仅这个函数还不够使他高兴。他想要在这上面做一些更有趣的事情。他的妈妈给他带来了两个数组$A$和$B$，每个都有$m$ 个整数。对于所有的$i,j$ （$1\leq i,j\leq m$）都有$a_i\geq b_j$。帮助Leha重新排列$A$数组来使得有最大的$\sum_{i=1}^m F(A_i’,B_i)$ ，$A$ 是重排后的数组。</p>
<p>$n\leq 10^5$</p>
</blockquote>
<p>刚看到这题发现可以猜结论233……通过观察样例可以发现，应该是第二个序列中第$k$小的对应第一个序列中第$k$大的……</p>
<p>然后证明，考虑对$F(n,k)$进行变形（以下是$\mathsf{\color{black}{B}\color{red}{enq}}$的过程）</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(n,k)&=\frac{\binom{n-1}{k-1}+2 \cdot \binom{n-2}{k-1}+3 \cdot \binom{n-3}{k-1}+\dots}{\binom{n}{k}}\\&=\frac{\binom{n-1}{k}+\binom{n-2}{k}+\binom{n-3}{k}+\dots}{\binom{n}{k}}\\&=\frac{\binom{n+1}{k+1}}{\binom{n}{k}}\\&=\frac{n+1}{k+1}
\end{aligned}</script><p>然后就是对于每一项，都应该让$k+1$尽量小，让$n+1$尽量大，就变成了一个贪心问题了233</p>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>给定你一些边，可能有重边。对于每个点给定一个$d_i$，如果为$1$表示这个点的度数为奇数，$0$表示这个点的度数为偶数，为$-1$表示这个点的度数没有限制。</p>
<p>你需要选出一些边（不一定联通），使得这些边构成的图符合要求。</p>
<p>$n\leq 3\cdot 10^5$</p>
</blockquote>
<p>首先考虑如果没有<code>-1</code>并且奇度点数量为奇数，那么一定无解。因为整张图的度数之和一定是$2m$为偶数。</p>
<p>发现似乎最简单的方式是生成一棵树，于是决定生成树；并且根据上一句的性质，只要任意时刻保证度数为和偶数即可（不要求连通）。</p>
<p>然后分类讨论：<code>0</code>的点和<code>1</code>的点</p>
<ul>
<li><code>0</code>的点。直接忽略，因为不产生影响；</li>
<li><code>1</code>的点。选择它的上行边、取反其父亲并且忽略这个点。原因还是度数和不变。</li>
</ul>
<p>于是可知这是一个合理的方案……直观上很难感觉起来是对的，但是只要紧握住“度数和为偶数”这个性质不变即可。代码实现上也可圈可点，每个点的状态在没遍历完整棵子树时都是未知，是很鲜明的信竞特点……总之我不会，学到了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//e.g.2: -1表示不能有一种方案，而0则表示我如果一条边都不选，依旧可以满足这个条件 </span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u] = <span class="number">1</span> ; <span class="keyword">int</span> ret = base[u] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[to(k)]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">if</span> (ST(to(k))) </span><br><span class="line">      res[++ tot] = (k + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, ret ^= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (base[u] &lt; <span class="number">0</span>) ret = <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), </span><br><span class="line">  	(base[i] &lt; <span class="number">0</span>) ? mr1 = i : (mr2 ^= base[i]) ;</span><br><span class="line">	<span class="keyword">if</span> (!mr1 &amp;&amp; mr2) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line">	ST(mr1 ? mr1 : <span class="number">1</span>) ;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">  sort(res + <span class="number">1</span>, res + tot + <span class="number">1</span>) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>给定$n(1≤n≤300)$个数，求问有多少种排列方案使得任意两个相邻的数之积都不是完全平方数。由于方案数可能很大，输出方案数$\bmod 10^9+7$的值。</p>
</blockquote>
<p>考虑相邻两个数之积是完全平方数的充要条件，当且仅当将两个数的所有质因子次数$\bmod ~2$ 后，两个数相同时，其乘积才会为完全平方数。</p>
<p>那么也就是说，这种性质可以传递，即$a\cdot b$为完全平方数，$b\cdot c$为完全平方数，那么$a\cdot c$也是。于是可以对所有的数暴力分组，每个组找一个代表元来记录。设每一组中有$cnt_i$个数，前$i$个组的$cnt$前缀和为$s_i$。</p>
<p>那么问题转化成了给定$n$个数，同一组的元素不能放在一起，求排列数。那么就是$f_{i,j}$表示前$i$个组，有$j$对相邻元素的乘积为完全平方数的排列数，转移时考虑，枚举当前这一组被分成了$k$块，插板法插出来的方案数为$\binom{cnt_i-1}{k-1}$，并且会多加上$cnt_i-k$个不合法的位置；然后考虑这$k$块插到了上一个状态中，$j$对不合法相邻的数中，$o$对不合法的数之间（即有$o$对数被拆开了），那么就会少$o$对非法数对。然后就是$\binom{j}{o}$。考虑剩下的了$k-o$块，这$k-o$块可以放到$s_i-j+1$个正常的空隙里面，于是再乘一个$\binom{s_i-j+1}{k-o}$</p>
<script type="math/tex; mode=display">
f_{i,j+cnt_i-k-o}=f_{i-1,j}\times \sum\limits_{k\leq cnt_i,l\leq j} (cnt_i!)\cdot \binom{cnt_i-1}{k-1} \cdot \binom{s_i-j+1}{k-o}\cdot \binom{j}{o}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll d, ll z)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (z)&#123;</span><br><span class="line">		<span class="keyword">if</span> (z &amp; <span class="number">1</span>) (res *= d) %= Mod ;</span><br><span class="line">		( d *= d ) %= Mod, z &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N, dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; base[i] ; <span class="keyword">bool</span> mk = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">			ll p = trunc(<span class="built_in">sqrt</span>(base[i] * grp[j])) ;</span><br><span class="line">			<span class="keyword">if</span> (p * p == base[i] * grp[j])&#123;++ tm[j], mk = <span class="number">1</span> ; <span class="keyword">break</span> ; &#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!mk) grp[++ cnt] = base[i], tm[cnt] = <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">for</span> (Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (Frac[<span class="number">0</span>] = <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N ; ++ i) Frac[i] = Frac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">			Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; tot += tm[i], ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= tot ; ++ j) </span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= tm[i] ; ++ k)	</span><br><span class="line">				<span class="keyword">for</span> (l = <span class="number">0</span>, t = tm[i] - k + j ; l &lt;= j ; ++ l, t --)</span><br><span class="line">					<span class="keyword">if</span>(t &gt;= <span class="number">0</span> &amp;&amp; t &lt; N) </span><br><span class="line">            (dp[i][t] += </span><br><span class="line">             Frac[tm[i]] * Cm[tm[i] - <span class="number">1</span>][k - <span class="number">1</span>] % Mod </span><br><span class="line">           * Cm[j][l] % Mod * Cm[tot - j + <span class="number">1</span>][k - l] % Mod </span><br><span class="line">           * dp[i - <span class="number">1</span>][j] % Mod) %= Mod ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[cnt][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p>这个D曾经单独写过：<a href="http://www.orchidany.cf/2019/04/05/可持久化数据结构·不靠谱的做法——主席树上二分/" target="_blank" rel="noopener">Link</a></p>
<p>233反正就是乱搞就对了</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/计数</tag>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>思维题/构造</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round-711 Virtual</title>
    <url>/2019/11/14/Codeforces-711/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个马来西亚老哥出的一场<code>Div2</code>，题目还算有点意思，于是就virtual了后三个题。</p>
<a id="more"></a>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>给定一段序列，要对着短序列进行涂色。有些位置涂了色，就不能再涂了；没涂色的位置可以涂任意颜色，同一个位置$i$涂不同的颜色$j$有不同的代价。求将整个序列涂成$k$个颜色段的最小代价。</p>
<p>$n,m\leq 100$</p>
</blockquote>
<p>一眼$dp$。然后就是设计状态，记$\mathsf {f_{i,j,k}}$表示前$i$个涂成了$j$段，最后一段颜色是$k$的最小代价，暴力转移即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; val[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= K ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= M ; ++ k)</span><br><span class="line">			dp[i][j][k] = Inf ; </span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)</span></span><br><span class="line"><span class="comment">	for (j = i - 1 ; j &gt;= 1 ; -- j)</span></span><br><span class="line"><span class="comment">		if (base[j]) &#123;pos[i] = j + 1 ; break ;&#125;*/</span></span><br><span class="line"><span class="comment">/*for (i = 1 ; i &lt;= N ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">	for (j = 1 ; j &lt; i; ++ j)</span></span><br><span class="line"><span class="comment">		if (j &gt;= pos[i])&#123;</span></span><br><span class="line"><span class="comment">			for (k = 1 ; k &lt;= M ; ++ k)</span></span><br><span class="line"><span class="comment">				for (l = 1 ; l &lt;= M ; ++ l)</span></span><br><span class="line"><span class="comment">					for (w = 1 ; w &lt;= K ; ++ w)</span></span><br><span class="line"><span class="comment">						if (l != k) dp[i][w][k] = max(dp[i][w][k], dp[j][w - 1][l] + ) ;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else &#123;</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span> (base[<span class="number">1</span>]) dp[<span class="number">1</span>][<span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) dp[<span class="number">1</span>][<span class="number">1</span>][i] = val[<span class="number">1</span>][i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= K ; ++ j)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!base[i])&#123;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k)&#123;</span><br><span class="line">				dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j][k] + val[i][k]);</span><br><span class="line">				<span class="keyword">for</span> (l = <span class="number">1</span> ; l &lt;= M ; ++ l)</span><br><span class="line">					<span class="keyword">if</span> (k != l) </span><br><span class="line">             dp[i][j][k] = min(dp[i][j][k], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][l] + val[i][k]) ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j][base[i]]) ;</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= M ; ++ k )</span><br><span class="line">				<span class="keyword">if</span> (k != base[i]) </span><br><span class="line">           dp[i][j][base[i]] = min(dp[i][j][base[i]], dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k]) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Ans = Inf, i = <span class="number">1</span> ; i &lt;= M ; ++ i) Ans = min(Ans, dp[N][K][i]) ; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (Ans == Inf ? - <span class="number">1</span> : Ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p>有$n$个点和$n$条边，第$i$条边从$i$连到$a_i$ 。 </p>
<p>每条边需要指定一个方向（无向边变为有向边）。问有多少种指定方向的方案使得图中不出现环</p>
</blockquote>
<p>一道计数题，但是比较睿智。给定的图显然是一堆基环树。那么考虑不在环上的边显然怎么定向都无所谓，在环上的边也只会是恰好都顺时针或者恰好都逆时针不合法。乘法原理乘起来就完了。</p>
<p>好早之前做的题了，然后当时这题卡了半天原因是我忘了怎么dfs找环了……大概就是祖先记一记，树上游一游，就做完了…类似于tarjan？…可海星</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>, base = <span class="number">2</span> ;</span><br><span class="line">	<span class="keyword">while</span> (b)&#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * base % Mod ; (base *= base) %= Mod, b &gt;&gt;= <span class="number">1</span> ; &#125;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">	dep[u] = deep, vis[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[to(k)]) dfs(to(k), deep + <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[to(k)] &lt;= <span class="number">1</span>) rop[++ tot] = dep[u] - dep[to(k)] + <span class="number">1</span> ;</span><br><span class="line"> 	&#125;</span><br><span class="line">	vis[u] = <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N, Ans = <span class="number">1</span> ; <span class="keyword">int</span> qaq ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;qaq), Add(i, qaq) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> ( !dep[i] ) dfs(i, <span class="number">1</span>) ; cnt = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= tot ; ++ i) </span><br><span class="line">	    cnt += rop[i], (Ans *= (expow(rop[i]) - <span class="number">2</span> + Mod)) %= Mod ;</span><br><span class="line">	Ans = Ans * expow(N - cnt) % Mod ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>求一年有$2^n$天，$k$个人出现两人生日相同的可能性是多少。</p>
<p>$n,k\leq 10^{18},\rm Mod=1e6+3$</p>
</blockquote>
<p>首先考虑答案就是</p>
<script type="math/tex; mode=display">
\frac{\prod\limits_{i=2^n-k+1}^{2^n-1}i}{2^{n \cdot {k-1}}}</script><p>然后就变成了如何把这个东西求出来<del>传统艺能.jpg</del></p>
<p>1、如果$k&gt;P=1e6+3$，那么根据抽屉原理分子中肯定至少有一项$\bmod \rm P=0$。</p>
<p>2、因为分母是$2$的幂，所以最后实际上就是在求分子中有多少个$2$乘起来</p>
<p>3、考虑如何求分子有多少个$2$。考虑一个引理，就是$2^n-m$和$m$中的$2$的个数一样。证明大概就是考虑令$m=2^p\cdot q$，其中$p$为极大的$2$的幂指数，那么$2^n-m=2^n-2^p\cdot q=2^p(2^{n-p}-q)$。根据整除的性质$a|b-c,a|b\Longleftrightarrow a|c$，而$2\not| ~~ q$，所以$2^n-m$中$2$的次数就是$p$.</p>
<p>4、然后由3中的引理，就有一个比较经典的做法。就是我们可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
(\prod\limits_{i=2^n-k+1}^{2^n-1}i,2^n)&=(\prod\limits_{i=2^n-k+1}^{2^n-1}(2^n-i), 2^n)\\ &=(\prod\limits_{i=1}^{k}i,2^n)\\ &=(k!,2^n)
\end{aligned}</script><p>再结合抽屉原理，只需要枚举$2$的幂就可以算了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; ll Son, Mom ;</span><br><span class="line">ll N, M, Inv, _gcd, qwq, i, base = <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll x, ll y)</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (y)&#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) (res *= x) %= Mod ;</span><br><span class="line">		(x *= x) %= Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res % Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		base &lt;&lt;= <span class="number">1</span> ; <span class="keyword">if</span> (base &gt;= M) &#123; ans = <span class="number">0</span> ; <span class="keyword">break</span> ;&#125; </span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">if</span> (ans) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1 1"</span>), <span class="number">0</span> ;  Son = <span class="number">1</span> ;</span><br><span class="line"> 	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M - <span class="number">1</span> ; i &lt;&lt;= <span class="number">1</span>) qwq += (M - <span class="number">1</span>) / i ;  </span><br><span class="line">	_gcd = expow(<span class="number">2</span>, qwq), </span><br><span class="line">  Inv = expow(_gcd, Mod - <span class="number">2</span>) ; </span><br><span class="line">  Mom = expow(<span class="number">2</span>, N  % (Mod - <span class="number">1</span>) * (M - <span class="number">1</span>) % (Mod - <span class="number">1</span>)) ;</span><br><span class="line">  (Mom *= Inv) %= Mod ; </span><br><span class="line">  <span class="keyword">if</span> (M - <span class="number">1</span> &gt;= Mod) </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%I64d %I64d"</span>, Mom, Mom), <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; M ; ++ i) </span><br><span class="line">    Son = Son * (expow(<span class="number">2</span>, N) - i + Mod) % Mod ; </span><br><span class="line">  (Son *= Inv) %= Mod, </span><br><span class="line">  Son = ((Mom - Son) % Mod + Mod) % Mod ; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; Son &lt;&lt; <span class="string">" "</span> &lt;&lt; Mom &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
        <tag>数学/观察性质,结论与构造</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E2</title>
    <url>/2019/11/14/xiaone-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛第二弹</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>$𝑁$座楼房，立于城中。第$𝑖$座楼，高度$ℎ_𝑖$。你需要一开始选择一座楼，开始跳楼。在第𝑖座楼准备跳楼需要$𝑐_𝑖$的花费。 每次可以跳到任何一个还没有跳过的楼上去。跳楼有代价，每次跳到另外一座楼的代价是两座楼高度的差的绝对值，最后一次从楼上跳到地面上不需要代价（只能跳到地上一次）。求在代价不超过𝑇的情况下，最多跳几次楼。 </p>
</blockquote>
<p>性质题，找不出来人似乎就没了233</p>
<p>考虑最优情况下肯定会是<strong>单调地跳</strong>，即要么单增地跳，要么单减地跳。这样就可以设计状态了$f_{i,j}$为跳到$i$，跳了$j$栋楼最小代价，然后枚举一遍状态即可。</p>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>小$c$切LuoguP5487这题，但是菜如小$c$，他写挂了。</p>
<p>小$c$开始了漫长的<code>debug</code>的阶段，2天过去了小$c$还是没有找到自己程序哪里写错了。于是他打印了自己所有函数的出入口的信息。对于小$c$写的第$i$个函数，他的入口会输出$+i$，他的出口会输出$-i$。</p>
<p>等到他把所有的输出打出来时，发现由于字符集的问题前面的符号消失了。但是他隐约记得某几个函数的出口的输出位置。现在小$c$想知道一个可能的打印序列，如果不存在输出<code>NO</code></p>
</blockquote>
<p>题解里面写这题可以倒着做，即从后向前扫，如果这个括号没有指定成右括号而且他是左括号合法，则标记为左括号；否则为右括号。跑完之后看看是否合法。思想大概就是诡异的贪心，因为左括号只会被“安排”，为了保证左/右平衡，故选择对左括号贪心。</p>
<p>我也是贪心做的，不过是正着做的。没有限制时，如果上一个是<code>(</code>，那我这一个就安排成<code>)</code>就好了，但算上限制时，出问题的就是会把一些左括号限制为右括号，即“强制嵌套”。那么如果原本是<code>()(</code>这样，第三个括号被强制为右括号，就顺便把前一个右括号改成<code>(</code>，即变为<code>(()</code>，留着去跟后面的匹配。合不合法最后再$check$一遍就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i, j ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">cin</span> &gt;&gt; M, i = <span class="number">1</span> ; i &lt;= M ; ++ i) ok[qr()] = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">	<span class="keyword">if</span> (ok[i] &amp;&amp; !stk[base[i]].size())&#123;</span><br><span class="line">		ans[i] = <span class="number">1</span> ; </span><br><span class="line">		stk[base[i]].pb(mat[buc[base[i]]]) ;</span><br><span class="line">		ans[i] = <span class="number">1</span>, ans[mat[buc[base[i]]]] = ans[buc[base[i]]] = <span class="number">0</span> ;</span><br><span class="line">		mat[i] = buc[base[i]], mat[buc[base[i]]] = i ; buc[base[i]] = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!stk[base[i]].size()) stk[base[i]].pb(i), ans[i] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">else</span> mat[i] = stk[base[i]].back(), ans[i] = <span class="number">1</span>, </span><br><span class="line">		 mat[stk[base[i]].back()] = i, stk[base[i]].pop_back(), buc[base[i]] = i ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (!ans[i]) <span class="built_in">stack</span>[++ t] = i ; </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">		 <span class="keyword">else</span> <span class="built_in">stack</span>[t --] = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">if</span> (t) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c%d "</span>, ans[i] ? <span class="string">'-'</span> : <span class="string">'+'</span>, base[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>给定$n\leq 1,000$。求最少需要多少不同的$a_i\in[1,n]$，使得$\forall x, 1\leq x\leq n$，总可以选出某个$\{a\}$的子集来凑出$x$。同时，求最小$|\{a\}|$下凑出所有$x$的方案总数。</p>
</blockquote>
<p>第一问是个贪心……贪心……就是二进制分解的思路，$n$的二进制位数就是答案。感觉如果要证明，证明起来其实是挺自然的。考虑首先二进制划分一定是合法的，同时如果将其中的$&gt;1$个换出去，那么一定凑不出$1$~$n$的所有数。</p>
<p>第二问据说是一个经典的$dp$。考虑状态$f_{i,j,k}$表示带了$i$枚金币，和为$j$，最大值为$k$的方案数。然而对我来说状态并不是很容易定义……emmm。转移的话采用刷表法比较简单，考虑对于一个状态$f_{i,j,k}$，枚举比$k$大的$o$，那么就有$f_{i,j,k}\to f_{i+1,\min(j+o,n),l}$ .</p>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p>已知C国有n个城市，城市间有m条双向道路，每条路有限重。JD公司想修建一些仓库来实现对C国所有城市的配送，仓库必须修建在某个城市。送达每个城市的货物可以由任意一个仓库发出，不过在运输途中必须满足限重的要求。</p>
<p>JD公司想让你设计一个程序来帮助高管决策，q次询问，每次询问计算如果想配送重量为w的物品，至少需要建多少个仓库。</p>
</blockquote>
<p><del>质疑题面在恰饭</del></p>
<p>一个比较显然的思想就是建出最大生成树来。然后比较常规的做法就是边建树边飞询问，考虑加完第一条载重为$val$边之前，现在的连通块个数就是重量为$val-1$的询问的答案，于是离线下来飞就可以了。</p>
<p>然后这东西也可不离线下来再去飞询问。观察性质可以发现假设现在询问的重量为$w_q$，那么对于所有限重$w_o&lt;w_q$的边，一定会分成两个连通块。于是可以直接把最大生成树的边排一个序，然后二分出$&lt;w_q$的个数即为答案。</p>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>给定一个字符串，每次询问一个子串中$A$的个数和$B$的个数的比值为$x:y$的子串的最长长度。</p>
<p>$n,q\leq 100,000$</p>
</blockquote>
<p>一开始我是真没想写这题……但是想了个线段树发现自己假了，然后就被迫入坑。。</p>
<p>考虑推式子</p>
<script type="math/tex; mode=display">
\frac{A_r-A_{l-1}}{B_r-B_{l-1}}=\frac{x}{y}\\
x\cdot (B_r-B_{l-1})=y\cdot (A_r-A_{l-1})\\
y \cdot A_r-x \cdot B_r=y \cdot A_{l-1}-x \cdot B_{l-1}</script><p>然后如果我们令$val_i=y\cdot A_i-x \cdot  B_i$，那么求的就是区间内相同的数相隔的最长距离。天真的我以为这题可以线段树，然后就很开心地想做……去<code>uoj</code>群里问了一圈发现这个被<code>lxl</code>规约到了$n \sqrt n$的问题上面……</p>
<p>然后就觉得，大概可以莫队吧。于是就想上莫队，结果发现这东西似乎并不是很好统计……于是写了半天之后毅然决然地写了一个线段树。最终在luogu上二分这个题的时限，卡到了<code>100ms~6500ms</code>这个范围……然后最终复杂度就应该是$n\sqrt q \log n$。</p>
<p>然后莫队确实可以卡常，大概就是不要傻傻地真把$Q$分成$\sqrt Q$块，因为常数因子导致均值不等式搞出来的结果没有那么对；然后莫队的cmp可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? </span><br><span class="line">      		  blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>奇数块正着排，偶数块倒着排，就会快好多。</p>
<p>然后最后：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写了一下午QAQ</span></span><br><span class="line"><span class="keyword">char</span> s[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qrs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id ;</span><br><span class="line">&#125;q[MAXN] ; <span class="keyword">int</span> l, r, buc[MAXM], val[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> blg[MAXN], T[MAXM &lt;&lt; <span class="number">2</span>], ans[MAXN], Pre[MAXN], Nxt[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, X, Y, M, S, U, base[MAXN], cnt[<span class="number">2</span>][MAXM], pre[MAXN][<span class="number">2</span>], res, res2 ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blg[a.l] == blg[b.l] ? a.r &lt; b.r : blg[a.l] &lt; blg[b.l] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(qrs a, qrs b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blg[a.l] ^ blg[b.l]) ? blg[a.l] &lt; blg[b.l] : ((blg[a.l] &amp; <span class="number">1</span>) ? a.r &lt; b.r : a.r &gt; b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> T[rt] = v, <span class="keyword">void</span>() ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, L, mid, p, v) ;</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, R, p, v) ;</span><br><span class="line">    T[rt] = max(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">0</span>][val[p]]) cnt[<span class="number">0</span>][val[p]] = Nxt[p] ;</span><br><span class="line">    <span class="keyword">if</span> (p == cnt[<span class="number">1</span>][val[p]]) cnt[<span class="number">1</span>][val[p]] = Pre[p] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;<span class="comment">// cout &lt;&lt; T[1] &lt;&lt; endl ;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    cnt[<span class="number">0</span>][val[p]] = min(cnt[<span class="number">0</span>][val[p]], p) ;</span><br><span class="line">    cnt[<span class="number">1</span>][val[p]] = max(cnt[<span class="number">1</span>][val[p]], p) ;</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, MAXM, val[p], cnt[<span class="number">1</span>][val[p]] - cnt[<span class="number">0</span>][val[p]]) ;</span><br><span class="line">    res = T[<span class="number">1</span>] ;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; p &lt;&lt; " : " &lt;&lt; cnt[0][val[p]] &lt;&lt; " " &lt;&lt; cnt[1][val[p]] &lt;&lt; " " &lt;&lt; val[p] &lt;&lt; endl ;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; X &gt;&gt; Y ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        base[i] = s[i] - <span class="string">'A'</span>,</span><br><span class="line">        pre[i][base[i]] = pre[i - <span class="number">1</span>][base[i]] + <span class="number">1</span>,</span><br><span class="line">        pre[i][base[i] ^ <span class="number">1</span>] = pre[i - <span class="number">1</span>][base[i] ^ <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) val[i] = MAXN + Y * pre[i][<span class="number">0</span>] - X * pre[i][<span class="number">1</span>] ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">-1</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Pre[i] = buc[val[i]], buc[val[i]] = i ;</span><br><span class="line">    <span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = N ; i &gt;= <span class="number">0</span> ; -- i) Nxt[i] = buc[val[i]] ? buc[val[i]] : N + <span class="number">1</span>, buc[val[i]] = i ;</span><br><span class="line">    M = qr() ; S = <span class="built_in">pow</span>(M, <span class="number">0.5832</span>) ; U = <span class="built_in">ceil</span>((<span class="keyword">double</span>)M / S) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">0</span>], <span class="number">63</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">0</span>])) ;</span><br><span class="line">    <span class="built_in">memset</span>(cnt[<span class="number">1</span>], <span class="number">-1</span>, <span class="keyword">sizeof</span>(cnt[<span class="number">1</span>])) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= U ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = (i - <span class="number">1</span>) * S + <span class="number">1</span> ; j &lt;= i * S ; ++ j) blg[j] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) q[i].l = qr() - <span class="number">1</span>, q[i].r = qr(), q[i].id = i ;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + M + <span class="number">1</span>, comp) ; l = <span class="number">0</span>, r = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) upd(++ r) ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) del(l ++) ;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) upd(-- l) ;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) del(r --) ;</span><br><span class="line">        ans[q[i].id] = res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道为啥rqy写的莫队套线段树加了个看不太透的优化比我快了一倍，迷乱233</p>
<h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><blockquote>
<p>你的花田一共由$n-2$片花田组成，编号从$1$到$n-2$。</p>
<p>算上你的家和花店，一共有$n$个地点，其中你的家编号为$0$，花店编号为$n-1$。即，家、花田、花店都属于地点，且它们都有一个唯一的$0$~$n-1$的编号。有$m$条双向道路连接这些地点。保证所有地点间都是直接或间接连通的。</p>
<p>你需要从家里出发，经过所有的花田进行收获，再到达花店，再从花店出发经过所有花田进行播种，最后重新回到家中。当你经过一片花田的时候，你可以选择收获、播种或者什么事都不做，也就是说你经过一片未收割的花田时可以不立即收割它，播种亦然。然而，播种必须发生在你完成了所有收获并到花店交货之后。在完成最后一个花田的收获后，你必须在到达花店后才能开始播种。也就是说，在你没有收获完所有花田并到花店交货前，即使你已经经过了花店，你也不能进行播种。（啰嗦了这么多但愿讲明白了）</p>
<p>然而还有一个问题。在收割完花朵后，花田会变得光秃秃的，此时土地里的水分会迅速蒸发。考虑到这个问题，更早被收割的花田也理应更早地被播种。具体来说，你必须保证前$\lfloor \frac{n-2}{2}\rfloor$个被收割的花田也是前$\lfloor \frac{n-2}{2}\rfloor$个被播种的，其中符号$\lfloor \rfloor$表示向下取整。你不需要保证这些花田收割和播种的顺序完全一致，而只需要保证前$\lfloor \frac{n-2}{2}\rfloor$名的集合不变即可。</p>
<p>现在，你需要求出完成上述一系列动作走过的最短路程。</p>
<p>$n \leq 20$</p>
</blockquote>
<p>一眼看出状压$dp$，第二眼看出应该从头和尾分别$dp$，然后没看第三眼就开始写……发现不太对？？有个限制，要求前$\lfloor \frac{n-2}{2}\rfloor$必须相同。然后我就寻思着要压一下顺序？有点难写；寻思着记录一下路径？但是发现变更不对了，因为可能最后的状态根本不重合，然后就没有然后了QAQ。</p>
<p>然后瞅了一眼题解发现很妙。大概就是枚举$size$为$\frac{n}{2}$的状态，将整张地图分为两半。之前预处理一个<code>floyd</code>，然后每次的代价就是</p>
<script type="math/tex; mode=display">
\mathsf{\min _{x\in S,y\in T}(f_{S,x}+dis_{x,y}+g_{T,y})+\min _{x\in S,y\in T}(g_{S,x}+dis_{x,y}+f_{T,y}})</script><p>然后枚举$\mathsf {S,T,x,y}$就完了，复杂度$O(2^{n}+\binom{n}{\lfloor\frac{n}{2}\rfloor}\cdot n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[MAXS][MAXN], pre[MAXS][<span class="number">2</span>], sz[MAXS], ans ;</span><br><span class="line"><span class="keyword">int</span> A[MAXN][MAXN], dis[MAXN][MAXN], N, M, E, f[MAXS][MAXN], stk[MAXN], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E ;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, o ;</span><br><span class="line">    M = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>, ans = Inf ;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span> (f)) ; f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) dis[i][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= E ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; j &gt;&gt; k &gt;&gt; o,</span><br><span class="line">        A[j][k] = A[k][j] = o,</span><br><span class="line">        dis[j][k] = dis[k][j] = o ;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; N ; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]) ;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">2</span> * (dis[<span class="number">0</span>][<span class="number">1</span>] + dis[<span class="number">1</span>][<span class="number">2</span>])), <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) sz[i] = sz[i - (i &amp; (-i))] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> f[i][now] = min(f[i][now], f[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">63</span>, <span class="keyword">sizeof</span>(g)) ; g[<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)][N - <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = (<span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>)) + <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; i) stk[++ cnt] = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> now = stk[j] ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= cnt ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(stk[k] ^ now)) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> g[i][now] = min(g[i][now], g[i ^ (<span class="number">1</span> &lt;&lt; now)][stk[k]] + dis[stk[k]][now]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; g[M][1] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sz[i] != N / <span class="number">2</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">int</span> stA = i, stB = (~i &amp; M), res = Inf, fg = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stA)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stB) </span><br><span class="line">						res = min(res, f[stA][j] + dis[j][k] + g[stB][k]), fg = <span class="number">1</span> ; </span><br><span class="line"><span class="comment">//        if (!fg) res = 0 ;</span></span><br><span class="line">		stB ^= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>), stB |= <span class="number">1</span> ;</span><br><span class="line">		stA ^= <span class="number">1</span>, stA |= (<span class="number">1</span> &lt;&lt; N - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; N ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; j &amp; stB)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; N ; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; k &amp; stA) ans = min(ans, res + f[stB][j] + dis[j][k] + g[stA][k]) ;</span><br><span class="line"><span class="comment">//		if (!fg) ans *= 2 ;</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>校内模拟赛</category>
      </categories>
      <tags>
        <tag>动态规划/状压DP</tag>
        <tag>动态规划/普通DP</tag>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>数据结构/数据结构方法/莫队</tag>
        <tag>数据结构/线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 2</title>
    <url>/2019/11/13/dsu-on-tree-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要就是整理一下dsu on tree的进阶版习题。</p>
<a id="more"></a>
<h1 id="0x01-rm-Cf375D-Tree-and-Queries"><a href="#0x01-rm-Cf375D-Tree-and-Queries" class="headerlink" title="$0x01$ $\rm Cf375D$  Tree and Queries"></a>$0x01$ $\rm Cf375D$  Tree and Queries</h1><blockquote>
<p>给出一棵$n$个结点的树，每个结点有一个颜色$c_i$ 。 询问$q$次，每次询问以$v$结点为根的子树中，出现次数 $≥k$的颜色有多少种。树的根节点是$1$。 </p>
</blockquote>
<p>考虑维护子树里面每种颜色出现的次数，但是显然询问的是一个$buc[c_i]$的后缀和，于是考虑上线段树来维护这个东西，<code>calc</code>到每个点的时候先<code>del</code>掉原来的再<code>upd</code>新的信息……然后就做完了233</p>
<p>然而一开始的时候我调了好久，因为我是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_do</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	ts[base[u]] ++ ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_do(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	ts[base[u]] -- ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) do_del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _count(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)&#123;</span><br><span class="line">	<span class="keyword">bool</span> fg = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (!chk[base[u]]) </span><br><span class="line">		chk[base[u]] = <span class="number">1</span>, </span><br><span class="line">		update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, val), fg = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _count(to(k), u, val) ; </span><br><span class="line">	<span class="keyword">if</span> (!fg) chk[base[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	_count(u, fa, <span class="number">-1</span>) ; do_do(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	_count(u, fa, <span class="number">-1</span>) ; do_del(u, fa) ; _count(u, fa, <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去很对的亚子，但是错就错在<strong>必须每个点独立计算完贡献才能考虑下一个点</strong>，否则下一个点的信息就是错误的——也就是说不能整体<code>del</code>再整体<code>upd</code>，必须逐个逐个的<code>del</code>和<code>upd</code>。。然而事实上关键问题还是在$buc$的统计上出了问题233</p>
<p>于是最后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">	ts[base[u]] ++ ; </span><br><span class="line">	update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">	ts[base[u]] -- ; </span><br><span class="line">	update(<span class="number">1</span>, <span class="number">1</span>, N, ts[base[u]] + <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) </span><br><span class="line">		dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">	calc(u, fa) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">		ans[u].pb(query(<span class="number">1</span>, <span class="number">1</span>, N, qs[u][k] + <span class="number">1</span>, N)) ;</span><br><span class="line">	vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths"><a href="#0x02-rm-Cf741D-Arpa’s-letter-marked-tree-and-Mehrdad’s-Dokhtar-kosh-paths" class="headerlink" title="$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths"></a>$0x02$ $\rm Cf741D$ Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</h1><blockquote>
<p> 一棵根为$1$的树，每条边上有一个字符（$a-v$共$22$种）。 一条简单路径被称为$\rm Dokhtar-kosh$当且仅当路径上的字符经过重新排序后可以变成一个回文串。 求每个子树中最长的$\rm Dokhtar-kosh$路径的长度。 </p>
</blockquote>
<p>似乎是<code>Cf570D</code>的升级版，因为路径可以跨过根所以会显得比较复杂，不过结论还是可以用的：</p>
<blockquote>
<p>我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数</p>
</blockquote>
<p>然后就是考虑怎么维护这个东西。</p>
<ul>
<li><p>不经过根的路径，分治做下去就好，每一层$u$对所有的$son[u]$的$ans$取$\max$.</p>
</li>
<li><p>经过根的路径，发现对于一个$u$，和$v$组合后可以产生贡献，我们只需要关心深度最大的$v$.所以自然想到用一个桶来维护二进制数值的最大深度。但是这个地方还有个问题，就是统计路径的话，$u$和$v$不能在同一棵子树中，容易发现只要满足不在同一棵子树中，那就一定满足$(u,v)$这条路径经过$root$。所以这个地方，对于一个点$u$，考虑一棵子树一棵子树地计算答案，深度做差求；而“经过根节点的路径”包括起点和终点在根节点上的路径，所以需要对$root$单独计算一次。</p>
</li>
</ul>
<p>看上去应该这么实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">	f[dis[u]] = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) _delete(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> &amp; ans, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">		ans = max(ans, f[dis[u]] + dep[u] - <span class="number">2</span> * d) ;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">			ans = max(ans, f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] + dep[u] - <span class="number">2</span> * d) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u, ans, d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	f[dis[u]] = max(f[dis[u]], dep[u]) ;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next) </span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">		dfs(to(k), u, <span class="number">0</span>), ans[u] = max(ans[u], ans[to(k)]) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) </span><br><span class="line">		dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span>, </span><br><span class="line">		ans[u] = max(ans[u], ans[son[u]]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != son[u] &amp;&amp; to(k) != fa) </span><br><span class="line">			calc(to(k), u, ans[u], dep[u]), update(to(k), u) ;</span><br><span class="line">	<span class="keyword">if</span> (f[dis[u]]) </span><br><span class="line">		ans[u] = max(ans[u], f[dis[u]] - dep[u]) ;	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= <span class="number">21</span> ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)]) </span><br><span class="line">			ans[u] = max(ans[u], f[dis[u] ^ (<span class="number">1</span> &lt;&lt; i)] - dep[u]) ;</span><br><span class="line">	f[dis[u]] = max(f[dis[u]], dep[u]) ; vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总感觉……复杂度不是很对？感觉单次运行dfs复杂度很高的亚子……然而还是套用“一个点到根节点最多有$\log n $个轻祖先”这个理论，每个点被访问的次数还是不变的——毕竟子树之间访问不会重复。于是时间复杂度$n\log n$。</p>
<p>唔，感觉这个题还是比较有技巧性的233</p>
<h1 id="0x03-rm-NOIP2018-模拟-·-树"><a href="#0x03-rm-NOIP2018-模拟-·-树" class="headerlink" title="$0x03$ $\rm NOIP2018$模拟 · 树"></a>$0x03$ $\rm NOIP2018$模拟 · 树</h1><p>这道题是从一个神仙的blog里嫖来的，提交的话可以到Luogu上提交：<a href="https://www.luogu.org/problem/U92408" target="_blank" rel="noopener">$\rm Link$</a></p>
<p>题面：</p>
<blockquote>
<p>给定一棵树。</p>
<p>令$[L,R]$描述的是序号在$[L,R]$内的点的集合。</p>
<p>同时，令函数$\boldsymbol F(\{ \rm S\})$表示令集合$\rm S$内的点联通的需要的最小边数。</p>
<p>问题则是求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}\sum_{j=i}^n \boldsymbol F([i,j])</script><p>$n\leq 100,000$</p>
</blockquote>
<hr>
<p>一步转化成求每条边的贡献。结合正难则反可知，一条边的总贡献至多是$\binom{n}{2}$，算多了的集合是那些位于这条边两侧中的其中一侧，不经过这条边的集合。所以考虑分别维护子树内和子树外的两个答案。</p>
<p>子树内的比较容易维护，考虑假设现在有了$\{1,2,3\},\{5,6\}$两个集合，将其视作两个连通块，当加进来$\{4\}$时，会和左右都相连接，不妨假设先与$\{1,2,3\}$合并，那么最后会产生$(1,4),(2,4),(3,4)$三个新的连通块，原来的依旧要加入。所以考虑用<strong>并查集+并查集的$size$</strong>来维护。由于子树内的点在暴力时只会插入不会删除，所以并查集是$\rm van$全没问题的。</p>
<p>之后是子树外的。子树外的和子树内的情况差不多，但是由插入变成了删除。然后就可以考虑用set维护，因为这东西自带的单调性比较nice，并且支持删除操作。所以流程大概就是考虑把删除的点丢到set里面，最初的<code>ans_out</code>显然是$\binom{n}{2}$，每删除一个新的点，设其编号为$x$，<code>set</code>里面第一个比$x$小的元素设为$x_p$第一个比$x$大的元素设为$x_s$，那么$[x_{p}+1,x-1]$还是连续的，$[x+1,x_s-1]$还是连续的，所以新的贡献变成了</p>
<script type="math/tex; mode=display">
calc(x_s-1-(x+1)+1)+calc(x-1-(x_p+1)+1)</script><p>原来的旧贡献$calc(x_s-1-(x_p+1)+1)$理应减去。</p>
<p>所以就做完了，感觉神清气爽，总体来说算是一道很好的题吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line"><span class="keyword">int</span> vis[MAXN], op[MAXN] ;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(LL x)</span></span>&#123; <span class="keyword">return</span> x * (x - <span class="number">1</span>) / <span class="number">2</span> ; &#125;</span><br><span class="line"><span class="keyword">void</span> _clear()&#123;</span><br><span class="line">	s.clear() ;</span><br><span class="line">	ansout = calc(N), ansin = <span class="number">0</span>, </span><br><span class="line">	s.insert(<span class="number">0</span>), s.insert(N + <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x)&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fr[x] ? x : fr[x] = _find(fr[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">	s.insert(u) ; op[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; :: iterator l, r, mid ;</span><br><span class="line">	l = r = mid = s.find(u), l --, r ++ ;</span><br><span class="line">	ansout += calc(*r - *mid - <span class="number">1</span>) + calc(*mid - *l - <span class="number">1</span>) - calc(*r - *l - <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (op[u - <span class="number">1</span>])&#123;</span><br><span class="line">		<span class="keyword">int</span> f1 = _find(u - <span class="number">1</span>), f2 = _find(u) ; </span><br><span class="line">		ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (op[u + <span class="number">1</span>])&#123;</span><br><span class="line">		<span class="keyword">int</span> f1 = _find(u + <span class="number">1</span>), f2 = _find(u) ;</span><br><span class="line">		ansin += bg[f1] * bg[f2], fr[f1] = f2, bg[f2] += bg[f1] ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">	fuck(u) ; <span class="comment">//cout &lt;&lt; u &lt;&lt; endl ;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> _update(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _delete(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)&#123;</span><br><span class="line">	op[u] = <span class="number">0</span>, fr[u] = u, bg[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ; <span class="keyword">else</span> _delete(to(k), u) ; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">		dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">	_update(u, fa), ans += calc(N) - ansout - ansin ; </span><br><span class="line">	<span class="keyword">if</span> (!mk) _delete(u, fa), _clear() ; vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Warning"><a href="#rm-Warning" class="headerlink" title="$\rm Warning$"></a>$\rm Warning$</h1><ul>
<li><p>注意一个地方：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) _delete(u, fa) ;</span><br></pre></td></tr></table></figure>
<p>把这两句写反了会调一下午，欢迎尝试quq</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>dsu on tree</category>
      </categories>
      <tags>
        <tag>树上技巧/dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】树上启发式合并(dsu on tree) · 1</title>
    <url>/2019/11/13/dsu-on-tree-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$\boldsymbol{dsu ~ on ~ tree}$，中文别称“树上启发式合并”（虽然我并不承认这种称谓），大概是一种优雅的暴力，并且跟$dsu$毫无关系。于是我打算叫他$\boldsymbol{Elegantly ~Direct~ Counting~ on~ Tree}$，“优雅的树上暴力统计”。</p>
<a id="more"></a>
<h1 id="rm-0x01-前言-amp-技术分析"><a href="#rm-0x01-前言-amp-技术分析" class="headerlink" title="$\rm 0x01$ 前言$\&amp;$技术分析"></a>$\rm 0x01$ 前言$\&amp;$技术分析</h1><p>严格来说，$\boldsymbol{EDCT}$解决的问题范围并不广泛：</p>
<blockquote>
<p>1、维护子树信息；</p>
<p>2、不能带修改操作。</p>
</blockquote>
<p>但这仍然掩盖不住这种算法自带的有趣的气质。笔者认为，这种算法虽然是个暴力，但是其中的技术含量还是不低的，代码也不是那么的浅显易懂，算是一个比较考察应用能力的算法。</p>
<p>然后来看技术分析。</p>
<p>首先，假设我们有这样一个问题：</p>
<blockquote>
<p>给定一棵有根树树，每个点有一个信息。现在考虑求出每个点子树内的规定的有效信息数量。</p>
<p>$n,q\leq 5\cdot1e5$</p>
<p>一般而言这样的题是可以上莫队的，但是便于展开就开到了$500,000$。</p>
</blockquote>
<p>考虑$n^2$的暴力，即对每个节点都扫一遍子树。很容易发现这样是浪费的，因为会算重。我们考虑怎么对这棵树进行划分才能高效计算。</p>
<p>考虑一种合适的划分方案。结合轻重链剖里面的结论，可以知道，在轻重链剖后，一个点到根不会超过$\log n$条轻边。所以如果对于每个点，假设我们只计算他对轻祖先的贡献，需要至多$\log n$次就可以解决；同时我们考虑重儿子，每个点至多会被当成一次重儿子，所以假设我们只计算他对父亲的贡献，那么至多$1$次就可以解决。所以最后的复杂度是$O(n\log n)$的。</p>
<p>现在考虑实现层面，其实是一种分治的思想。我们考虑首先分治$u$的轻儿子并清除轻儿子的贡献，然后暴力计算重儿子，然后暴力计算一整棵子树的贡献。首先第一步中清除贡献是必要的，因为分治出来的几个子问题相互独立，所以必须要独立计算。之后是重儿子，由于重儿子至多有一个，所以可以直接计算而不会影响其他状态。最终再暴力一遍计算轻儿子的贡献。</p>
<p>所以这样就解决了维护树上信息的问题，复杂度$n\log n$。</p>
<h1 id="0x02-入门题目选整"><a href="#0x02-入门题目选整" class="headerlink" title="$0x02$ 入门题目选整"></a>$0x02$ 入门题目选整</h1><p>感觉大部分<code>blog</code>找的题目都很不清真233</p>
<h2 id="rm-Task1-rm-Cf600E-Lomsat-gelral"><a href="#rm-Task1-rm-Cf600E-Lomsat-gelral" class="headerlink" title="$\rm Task1$ $\rm Cf600E$ Lomsat gelral"></a>$\rm Task1$ $\rm Cf600E$ Lomsat gelral</h2><p>一句话题意</p>
<blockquote>
<p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。 </p>
</blockquote>
<p>考虑套$\rm EDCT$的板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	sz[u] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">		dfs(to(k), u), sz[u] += sz[to(k)] ;</span><br><span class="line">		<span class="keyword">if</span> (sz[to(k)] &gt; sz[son[u]]) son[u] = to(k) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || to(k) == son[u]) <span class="keyword">continue</span> ; </span><br><span class="line">		dfs(to(k), u, <span class="number">0</span>) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">	calc(u, fa, <span class="number">1</span>) ; ans[u] = res ; <span class="keyword">if</span> (son[u]) vis[son[u]] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (!mk) calc(u, fa, <span class="number">-1</span>), res = <span class="number">0</span>, max_cnt = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是最后的<code>calc</code>函数怎么写了。考虑我们最暴力的做法是什么？就是把每个颜色统计一遍。所以这么写就OK了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	buc[clr[u]] += mk ; </span><br><span class="line">	<span class="keyword">if</span> (mk &gt; <span class="number">0</span> &amp;&amp; buc[clr[u]] &gt;= max_cnt)&#123;</span><br><span class="line">		<span class="keyword">if</span> (buc[clr[u]] &gt; max_cnt) </span><br><span class="line">		    res = <span class="number">0</span>, max_cnt = <span class="number">1l</span>l * buc[clr[u]] ;</span><br><span class="line">		res += <span class="number">1l</span>l * clr[u] ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == fa || vis[to(k)]) <span class="keyword">continue</span> ; </span><br><span class="line">		calc(to(k), u, mk) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Task2-Cf570D-Tree-Requests"><a href="#rm-Task2-Cf570D-Tree-Requests" class="headerlink" title="$\rm Task2 ~Cf570D$ Tree Requests"></a>$\rm Task2 ~Cf570D$ Tree Requests</h2><p>一句话题意：</p>
<blockquote>
<p>给定一个以1为根的n个节点的树，每个点上有一个字母$(a-z)$，每个点的深度定义为该节点到1号节点路径上的点数.每次询问$(a,b)$查询以$a$为根的子树内深度为$b$的节点上的字母重新排列之后是否能构成回文串. </p>
</blockquote>
<p>这种应该就是比较裸的$\rm EDCT$。有一步转化需要学会构造，即我们令一个字符的权值$val(x)=\text{1&lt;&lt;(x-‘a’)}$，那么对与一个串$\rm S$，我们令$k=\rm{Xor}_{i=1}^n\it val\rm( S[i])$，那么重排之后可以构成回文串$\Longleftrightarrow$ $size(k)\leq 1$，其中$size(\rm S)$指集合$\rm S$内的元素个数，也就是二进制表示中$1$的个数。所以也是，直接爆算就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	buc[dep[u]] ^= (<span class="number">1</span> &lt;&lt; base[u]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) calc(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getl</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">while</span> (x) ret += (x &amp; <span class="number">1</span>), x &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">bool</span>)(ret &lt;= <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	buc[dep[u]] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; !vis[to(k)]) del(to(k), u) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> mk)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) != fa &amp;&amp; to(k) != son[u]) dfs(to(k), u, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (son[u]) dfs(son[u], u, <span class="number">1</span>), vis[son[u]] = <span class="number">1</span> ;</span><br><span class="line">	calc(u, fa) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; qs[u].size() ; ++ k) </span><br><span class="line">		ans[u].pb(getl(buc[qs[u][k]])) ; </span><br><span class="line">	vis[son[u]] = <span class="number">0</span> ; <span class="keyword">if</span> (!mk) del(u, fa) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>dsu on tree</category>
      </categories>
      <tags>
        <tag>树上技巧/dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】Codeforces Round-814 Virtual</title>
    <url>/2019/11/13/codeforces-814/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一场<code>cn</code> round，然后每次<code>cn</code> round的最后一题都会很奇怪……</p>
<p>⑧说了，计数是不可能会的，这辈子都不可能了QAQ</p>
<a id="more"></a>
<h1 id="Omega"><a href="#Omega" class="headerlink" title="$\Omega $"></a>$\Omega $</h1><p>$\rm virtual$了一场……说实话这种<code>div2 only</code>的场次最后一题就经常比较毒……</p>
<p><del>老规矩，前面几题用来水字数</del></p>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>给出一个长度为$N$的非负整数序列$a_i$与长度为$K$的正整数序列$b_i$，满足$a_i$中刚好有$K$个$0$，且任一正整数在序列$a$和序列$b$中的出现次数的和不会超过$1$。</p>
<p>现在试判断是否存在一种方法，使得用$b_i$中的元素替换$a_i$中的$0$得到的序列不是递增序列。 </p>
</blockquote>
<p>sb一眼题，显然如果递减放进去还是递增就无解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline bool cmp(int a, int b)&#123; return a &gt; b ;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; K ; int j &#x3D; 1 ;</span><br><span class="line">	for (i &#x3D; 1 ; i &lt;&#x3D; N ; ++ i) cin &gt;&gt; base[i] ;</span><br><span class="line">	for (i &#x3D; 1 ; i &lt;&#x3D; K ; ++ i) cin &gt;&gt; t[i] ; sort(t + 1, t + K + 1, cmp) ;</span><br><span class="line">	for (i &#x3D; 1 ; i &lt;&#x3D; N ; ++ i) if (!base[i]) base[i] &#x3D; t[j ++] ;</span><br><span class="line">	for (i &#x3D; 1 ; i &lt; N ; ++ i) if (base[i] &gt; base[i + 1]) return puts(&quot;Yes&quot;), 0 ;</span><br><span class="line">	return puts(&quot;No&quot;), 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>给定两个长度为$n$的不相同序列$a$和$b$，这两个序列至少有一个位置不同</p>
<p>现在需要构造一个长度为$n$的排列$p$，使得$p$与$a$只有一个地方不同，且$p$与$b$也只有一个地方不同</p>
</blockquote>
<p>一眼就可以看出最多有两个位置不同，否则一定不合法。考虑分类讨论，如果只有一个位置不同那就放上那个没出现过的数字；如果有两个位置不同，那就考虑是$A$中第一个位置放多了还是第二个位置放多了，放上$B$的就完了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), Ma[A[i]] ++ ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]), Mb[B[i]] ++ ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (A[i] != B[i]) pos[++ cnt] = i ; </span><br><span class="line">	<span class="keyword">if</span> (cnt == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">			<span class="keyword">if</span> (!Ma.count(i) &amp;&amp; !Mb.count(i)) &#123; A[pos[<span class="number">1</span>]] = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (Ma[A[pos[<span class="number">1</span>]]] &gt; <span class="number">1</span> &amp;&amp; !Ma[B[pos[<span class="number">1</span>]]])&#123; </span><br><span class="line">		A[pos[<span class="number">1</span>]] = B[pos[<span class="number">1</span>]] ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; </span><br><span class="line">		A[pos[<span class="number">2</span>]] = B[pos[<span class="number">2</span>]] ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本来觉得是道构造题，后来发现是道细节模拟题。。。</p>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>给你一个由小写字母构成的字符串.<br>有$q$个询问，每个询问给出数字$m$和小写字母$c$，你可以任意地修改字符串中的$m$个字符，求最多能够使字符串中含有多少个连续相同的字母$c$.<br>每个询问各自独立.<br>$|\rm S|\leq 1,500$</p>
</blockquote>
<p>其实感觉复杂度一点也不对……比如我觉得这题可以做到$5e4$以上……</p>
<p>考虑弱化版（原版）的解法，大概就是用$f_{i,j}$表示前$i$个字符用了$k$次机会最长的连续段有多长。然后就可以直接$O(26n^2)$给预处理出来，每次询问回答一下即可。</p>
<p>但是我们发现这玩意儿复杂度一点也不平衡，因为预处理贼慢但是回答贼快。于是考虑有哪些性质没用。我们考虑预处理出原串中对于一个字符$c$，最近的两个$c$之间的位置来，然后如果要修改就显然先修改跨度小的$c_i$和$c_{i+1}$中间的部分，因为这样肯定不会更劣。同时只有把中间的非$c$区域占满才能使之连通，故每次对于一个给定的$k$，二分查找一下可以占满的区间，剩下的随便铺，对于这些占满的区间提前预处理出贡献的前缀和就完了。复杂度大概是$q\log n+26n$</p>
<p>然而升级版只是口胡，什么时候闲下来再写吧qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">int</span>)S[j] == <span class="string">'a'</span> + i) dp[i][j][<span class="number">0</span>] = dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= N ; ++ k)&#123;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">int</span>)S[j] - <span class="string">'a'</span> == i) dp[i][j][k] = dp[i][j - <span class="number">1</span>][k] + <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">else</span> dp[i][j][k] = max(dp[i][j][k], dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">			ans[i][k] = max(ans[i][k], dp[i][j][k]) ;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;k, &amp;In) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans[(<span class="keyword">int</span>)In - <span class="string">'a'</span>][k] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p> 有$n$个圆，将其分为两组。每组中，只有奇数个圆覆盖的区域的才会算入面积，求可能的最大面积。 </p>
</blockquote>
<p>首先考虑贪心。大概就是说原本的覆盖一定可以看做一团一团独立的子问题。将圆按照面积大小排序，之后考虑选每一堆最大的放到第一堆，然后把与之原本冲突的放到第二堆。这样可以发现最终减去的部分面积变成了之前产生贡献的部分面积……然而这不重要，重要的是这样保证了每次选的一定都是面积最大的圆的集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r &gt; B.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, Comp) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		<span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">			<span class="keyword">if</span> (check_in(base[i], base[j])) ++ mark[j] ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		<span class="keyword">if</span> (!mark[i] || (mark[i] &amp; <span class="number">1</span>)) Ans += get_S(base[i]) ; <span class="keyword">else</span> Ans -= get_S(base[i]) ;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.8lf"</span>, Ans) ;  	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这个贪心似乎不好想，于是考虑一种精妙的$\rm dp$<del>其实更不好想</del>。考虑按照圆从大到小枚举顺次连边，最后连出来的会是一个森林状物。然后对于这个东西， 定义$dp[u][0/1][0/1]$表示以点$u$为根的子树里面，除$u$之外分成两堆之后，两堆分别的高度为偶数/奇数时的最优值。这东西就可以直接分类讨论求和+转移。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(C A, C B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_S</span><span class="params">(C A)</span></span>&#123; <span class="keyword">return</span> Pi * A.r * A.r ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check_in</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r + B.r &gt; dist(A, B) ; &#125;</span><br><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> next, to ;</span><br><span class="line">	&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">int</span> head[MAXN], cnt ;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    	E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    	E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> faa)</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">2</span>][<span class="number">2</span>] ; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">			<span class="keyword">if</span> (to(k) == faa) <span class="keyword">continue</span> ;</span><br><span class="line">			do_dp(to(k), u) ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt;= <span class="number">1</span> ; ++ ii)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt;= <span class="number">1</span> ; ++ jj)</span><br><span class="line">					f[ii][jj] += dp[to(k)][ii][jj] ; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span> ; ii &lt;= <span class="number">1</span> ; ++ ii)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span> ; jj &lt;= <span class="number">1</span> ; ++ jj)</span><br><span class="line">				dp[u][ii][jj] = max(</span><br><span class="line">                	f[ii ^ <span class="number">1</span>][jj] + (<span class="number">1l</span>l * (ii ? <span class="number">-1</span> : <span class="number">1</span>) * base[u].r * base[u].r), </span><br><span class="line">					f[ii][jj ^ <span class="number">1</span>] + (<span class="number">1l</span>l * (jj ? <span class="number">-1</span> : <span class="number">1</span>) * base[u].r * base[u].r)) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(C A, C B)</span></span>&#123; <span class="keyword">return</span> A.r &gt; B.r ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, Comp) ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">			<span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">				<span class="keyword">if</span> (check_in(base[i], base[j])) </span><br><span class="line">					<span class="keyword">if</span> (!fa[j] || base[fa[j]].r &gt; base[i].r) fa[j] = i ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (fa[i]) Add(i, fa[i]) ;	</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)	<span class="keyword">if</span> (!fa[i]) do_dp(i, <span class="number">0</span>), Ans += dp[i][<span class="number">0</span>][<span class="number">0</span>] ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.8lf"</span>, Ans * Pi) ;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>给出$n$个点和每个点的度让你构造出一张无向图满足以下两条性质：</p>
<ul>
<li><p>$1.$点1到点$i$仅有<strong>唯一</strong>一条最短路</p>
</li>
<li><p>$2.$点$1$到点$i$的最短路长度大于等于点$1$到点$i-1$的最短路长度</p>
</li>
</ul>
<p>求能构成满足条件的无向图的个数   $n\leq 50, 2\leq degree_i\leq 3$</p>
</blockquote>
<p>这种计数题会是不可能会的，这辈子都不可能会了qaq</p>
<p>考虑一个$idea$，因为这张图无权，所以最短路一定会是$\it bfs$的分层。那么对于一个$i$来讲，他的要么和$i-1$在同一层，要么就在$i-1$的下一层。</p>
<p>那么考虑记$f_{i,j}$表示前$i$个点中有$j$个和$i$在同一层的方案数。那么考虑这东西的转移跟上一层中点的度数有关，也就是需要记$dp_{k,c_1,c_2}$表示当前层有$k$个点，上一层度数为$2$的点有$c_1$个，度数为$3$的点有$c_2$个这一子状态的方案数。那么有如下：</p>
<script type="math/tex; mode=display">
dp_{i,j,k}=\begin{cases}{1} & (i=j=k=0)\\ \\ {\sum\limits_{l=2}^{k-1} dp_{i,j,k-l-1} \cdot\left(\begin{array}{c}{k-1} \\ {l}\end{array}\right) \cdot N_{l+1}} &(i=j=0,k>0) \\ \\ {(j-1) \cdot dp_{i,j-2,k}+k \cdot dp_{i,j,k-1}} & (i=0,j>0)\\ \\{j \cdot dp_{i-1,j-1,k}+k \cdot dp_{i-1,j+1,k-1}} & (i>0)\\ \\{0}\end{cases}</script><p>其中$N_i$表示<strong>$\boldsymbol{i-}$项链数</strong>，也就是长度为$i$、元素各异、镜像对称的单环的数量，计算方式如下：</p>
<script type="math/tex; mode=display">
N_i=\begin{cases} 1 & (i=2)\\ \frac{(i-1)!}{2} &(i>2)\\ 0 & \rm{otherwise}\\ \end{cases}</script><p>对于第二个转移，就是考虑向上一层插入一个点使其成为度数为$3$的点。考虑因为度数为$3$且题目要求“有位移最短路”，所以同一层中只有可能是简单的平边相连。所以就是考虑枚举原来的点里面可以与新加入的点组成项链的方案数。注意这里项链数必须$&gt;2$原因是题目中强调了不能有两个点之间连$&gt;1$条边。</p>
<p>对于第三个转移，考虑插入一个点使其度数为$2$，这一步转移即考虑$j-1$个点中选择一个可能变成$2$度的点和新加近来这个点相连有$j-1$种方案，相连之后两个点度数都变为$2$；同时考虑另一种可能性，就是这一个点和一个可能变成$3$度的点相连，那么原来的二度点变为三度点，新加进来的变成二度点。</p>
<p>对于第四个转移，考虑这一层最后一个加进来的节点，要么和上一层中一个可能变成$2$度的点相连要么和可能变成$3$度的点相连。</p>
<p>然后最后的答案就是枚举最后一层的点数</p>
<script type="math/tex; mode=display">
ans =\sum_{j=1}^{n}f_{n,j}\cdot g_{0,c_1,c_2}</script><p>其中$c_1$和$c_2$表示枚举到现在有多少个$d=2$和$d=3$的点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">int</span> N, clr1, clr2, base[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> i, j, k, l ; ll dp[MAXN][MAXN] ;</span><br><span class="line">ll Ans, A[MAXN], f[MAXN][MAXN][MAXN], Cm[MAXN][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N  ; Cm[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Cm[i][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">			Cm[i][j] = (Cm[i - <span class="number">1</span>][j] + Cm[i - <span class="number">1</span>][j - <span class="number">1</span>]) % Mod ; </span><br><span class="line">	<span class="keyword">for</span> ( A[<span class="number">1</span>] = A[<span class="number">0</span>] = <span class="number">0</span>, A[<span class="number">2</span>] = A[<span class="number">3</span>] = <span class="number">1</span>, i = <span class="number">4</span> ; i &lt;= N ; ++ i) A[i] = A[i - <span class="number">1</span>] * (i - <span class="number">1</span>) % Mod ;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ; <span class="comment">//Calculate g</span></span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= N ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= N - j ; ++ k)</span><br><span class="line">			<span class="keyword">if</span> (!j &amp;&amp; k)</span><br><span class="line">				<span class="keyword">for</span> (l = <span class="number">2</span> ; l &lt; k ; ++ l)</span><br><span class="line">					(f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j][k - l - <span class="number">1</span>] * Cm[k - <span class="number">1</span>][l] % Mod * A[l + <span class="number">1</span>] % Mod) %= Mod ;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (j &gt;= <span class="number">2</span>) (f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j - <span class="number">2</span>][k] * (j - <span class="number">1</span>) % Mod) %= Mod ;</span><br><span class="line">				<span class="keyword">if</span> (k) (f[<span class="number">0</span>][j][k] += f[<span class="number">0</span>][j][k - <span class="number">1</span>] * k % Mod) %= Mod ; </span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N - i ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= N - i - j ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j) (f[i][j][k] += f[i - <span class="number">1</span>][j - <span class="number">1</span>][k] * j % Mod) %= Mod ;</span><br><span class="line">				<span class="keyword">if</span> (k) (f[i][j][k] += f[i - <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] * k % Mod) %= Mod ;</span><br><span class="line"><span class="comment">//				cout &lt;&lt; f[i][j][k] &lt;&lt; endl ;</span></span><br><span class="line">			&#125;</span><br><span class="line">	<span class="comment">//Calculate dp</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; base[i] ; dp[base[<span class="number">1</span>] + <span class="number">1</span>][base[<span class="number">1</span>]] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = base[<span class="number">1</span>] + <span class="number">2</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= i - base[<span class="number">1</span>] - <span class="number">1</span> ; ++ j)</span><br><span class="line">			<span class="keyword">for</span> (clr1 = clr2 = <span class="number">0</span>, k = <span class="number">1</span> ; k &lt;= i - j ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">if</span> (base[i - j - k + <span class="number">1</span>] &lt;= <span class="number">2</span>) ++ clr1 ; <span class="keyword">else</span> ++ clr2 ;</span><br><span class="line">				(dp[i][j] += (dp[i - j][k] * f[j][clr1][clr2] % Mod)) %= Mod ;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">for</span> (clr1 = clr2 = <span class="number">0</span>, i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (base[N - i + <span class="number">1</span>] == <span class="number">2</span>) ++ clr1 ; <span class="keyword">else</span> ++ clr2 ;</span><br><span class="line">		(Ans += (dp[N][i] * f[<span class="number">0</span>][clr1][clr2]) % Mod) %= Mod ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>思维题/计数</tag>
        <tag>动态规划/普通DP</tag>
        <tag>思维题/构造</tag>
        <tag>贪心</tag>
        <tag>组合计数/有技巧的计数</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】校内模拟赛选整 · E1</title>
    <url>/2019/11/13/xiaonei-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>校内模拟赛选整</p>
<p>大概难度都是TG里面$2$~$3$左右的。</p>
<a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><blockquote>
<p>给定直线上$n\leq 2000$个建筑的坐标，两种覆盖方式，$A:$覆盖长度为$L$，可以用$p$次；$B$：覆盖长度为$2L$，可以用$q$次。求最小的$L$.</p>
</blockquote>
<hr>
<p>首先就是可以知道$p,q$可以缩到$p+q\leq n$，否则答案就是$1$。</p>
<p>之后考虑二分一个$L$，$check$其正确性。$check$时感觉贪心并不是很好贪，可能会有比较妙的贪心，但这个地方选择一种更加稳妥的$dp$。考虑$f_{i,j}$表示两种覆盖分别用了$i,j$个最多能覆盖到哪个建筑，则</p>
<script type="math/tex; mode=display">
f_{i,j}=\max(go_p[f_{i-1,j}+1], go_q[f_{i,j-1}+1])</script><p>其中$go_x[P]$表示在位置$P$使用第$x$种覆盖能够覆盖多少建筑。于是最后复杂度$O(n^2\log n)$.</p>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><blockquote>
<p>定义<code>string</code>类型的递推$f_0=’0’$，$f_1=’1’$，$f_i=f_{i-2}+f_{i-1}$，其中$+$表示<code>string</code>类型的连接。多组询问，询问$f_n$中区间$\rm [L,R]$内的串。$n\leq 1e9,~\rm L\leq R\leq 2e9,\sum (R-L)\leq 1e7$</p>
</blockquote>
<hr>
<p>拿到这题首先应该手写出前$6$项来找规律……</p>
<p>发现$f_i.size()$就是斐波那切数列的第$i$项，并且序号奇偶性相同的两项$f_i,f_j$，当$j&lt;i$时满足$f_j$是$f_i$的前缀，这东西可以数学归纳出来<del>并且肉眼看不出来</del>。</p>
<p>之后可以发现$\rm L,R\leq 2e9$，而斐波那切数列的第$50$项已经超过了这个范围。于是考虑对于一个询问$f_n[L,R]$，先把$n$缩到$50$以内，然后分奇偶性赋值为$48/49$，然后每次考虑把$f_n$分成$f_{n-2}+f_{n-1}$，分治下去。注意到其实是可以预处理一些状态来提速，于是选择预处理前$20$项左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">20</span>) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; f[n].substr(L, R - L + <span class="number">1</span>), <span class="keyword">void</span>() ;</span><br><span class="line">	<span class="keyword">if</span> (L &lt; fib[n - <span class="number">2</span>]) solve(n - <span class="number">2</span>, L, min(R, fib[n - <span class="number">2</span>])) ; </span><br><span class="line">	<span class="keyword">if</span> (R &gt;= fib[n - <span class="number">2</span>]) solve(n - <span class="number">1</span>, max(<span class="number">0l</span>l, L - fib[n - <span class="number">2</span>]), R - fib[n - <span class="number">2</span>]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><blockquote>
<p>我们有一张方格纸，他大概长这样：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2020/01/09/lfSP0I.jpg" alt=""></p>
<p>我们现在要从左上角$(0,0)$到右下角$(n,m)$画一条直线，然后询问它经过黑格子的长度与总长度的比值，并输出一个互质分数的形式。</p>
</blockquote>
<p>sb结论题，以下是结论，觉得证的挺好的（</p>
<blockquote>
<p>无论怎样，$rqy$太强了！！</p>
<p>以下是$rqy$给的严谨证明：</p>
<ul>
<li><p>对于每个二元组$(n,m)$，$(\frac{n}{\gcd(n,m)},\frac{m}{\gcd(n,m)})$ 的本质与$(n,m)$是一样的。</p>
</li>
<li><p>当$n$是偶数<strong>或者</strong>$m$是偶数的时候，答案显然是$\frac{1}{2}$，因为我们可以考虑把所有的颜色翻转，答案是一样的。</p>
</li>
<li><p>余下的情况，由于我们现在已经缩小了问题规模使得$n,m$互质，所以只有可能是$n、m$均为奇数，此时我们考虑如下（前方高能）：</p>
</li>
<li><p>由于横向有$m$段，纵向有$n$段，所以总共这条直线可以分成$n \times m$段，当然，有些段的颜色相同。我们这么做的目的是为了保证<strong>每一段不会跨过每个格子的边界，即同一段的每个部分都会是相同的颜色</strong></p>
</li>
<li><p>通过观察可以得到，对于从左上到右下的第$i$段，它应该在第$\lfloor \frac{i}{n} \rfloor$<strong>列</strong>，第$\lfloor \frac{i}{m} \rfloor$<strong>行</strong>。注意这个地方，虽然$n$表示的是行，但是$\lfloor \frac{i}{n} \rfloor$表示的是列。道理其实很简单：</p>
<ul>
<li>对于第$i$段，它占的部分是$\frac{i}{n \times m}$ ，所以所属的行应该是$\lfloor \frac{i}{n \times m} \cdot n \rfloor$，所属的列为$\lfloor \frac{i}{n \times m} \cdot m \rfloor$，约分一下答案显而易见。 </li>
</ul>
</li>
<li><p>基于前两条，我们会有一个比较平凡的结论：对于某一段$i$，当$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$为偶数的时候，这一段在黑色的格子上；是奇数的时候，这一段在白色格子上。</p>
</li>
<li><p>我们可以考虑对$\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor$搞一些事情：</p>
<script type="math/tex; mode=display">
\lfloor \frac{i}{n} \rfloor + \lfloor \frac{i}{m} \rfloor\begin{align} \\ \\&\equiv\frac{i - i \mod n}{n}+\frac{i - i \mod m}{m} \pmod 2\\ &\equiv 2i - i \mod n - i \mod m \pmod 2\\  & \equiv i \mod n  + i  \mod m \pmod 2\end{align}</script></li>
</ul>
<p>上式的目的其实就是通过对$2$取模建立同余式，由于$n,m$均为奇数，所以在$\mod 2$意义下都是$1$，可以直接除掉。那么接下来我们考虑，这样的$i$有多少个呢？很显然的，在$0 \to n - 1$中，共有$\frac {n-1}{2}$个奇数,$\frac{n+1}{2}$个偶数；在$0 \to m-1$中，共有$\frac {m-1}{2}$个奇数，$\frac {m+1}{2}$个偶数。因为只有奇偶性相同时，才属于黑色格子，所以由中国剩余定理得</p>
<script type="math/tex; mode=display">
\begin{aligned}\sum check(i) &= \frac{n-1}{2} \cdot \frac{m-1}{2} + \frac{n+1}{2} \cdot \frac{m+1}{2} \\& = \frac{2nm + 2}{4}\end{aligned}</script><p>那么最终答案就是</p>
<script type="math/tex; mode=display">
\frac {\sum check(i)}{n \cdot m} = \frac{n \cdot m+1}{2n \cdot m}</script></blockquote>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><blockquote>
<p>给定一棵树，某些点是关键点。每条边有代价，每次可以删掉一条边并且获得这条边的代价。求最少的代价，使得所有关键点不连通。$n\leq 300,000$</p>
</blockquote>
<hr>
<p>直观的想法是$dp$，即记$f_x$表示处理完以$x$为根的子树内的关键点（不互相连通）的最少代价。但是发现这样似乎很难转移，因为转移时要考虑子树之间的关键点是否连通。于是考虑再记$g_x$表示处理完以$x$为根的子树内关键点互相不连通，且不与外界连通的最小代价。</p>
<p>那么考虑转移，记$x$为当前节点，$y$为$x$的子节点：</p>
<ul>
<li><p>当$x$为关键点时，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
f_x&=\sum g_y \\
g_x&=f_x+pre_x
\end{align*}</script></li>
<li><p>当$x$不为关键点时，有</p>
<script type="math/tex; mode=display">
f_x=\min(\sum f_y-f_{y'}+g_{y'})\\
g_x=\min(f_x+pre_x, \sum g_y)</script></li>
</ul>
<p>唔，这个第二个转移的$f_x$还是需要编一编的，大概就是考虑现在只需要不让子树内部连通，那么就可以选出一棵子树来内部不连通，其他子树都不和外部连通，可知这样是最优的（因为天选之子不需要“不和外部连通”）。</p>
<p>学习了，学习了。</p>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><blockquote>
<p>现在有如下一个表达式： $0 ~a_1 b_1 a_2 b_2 … a_n b_n$。其中$a_i$为一个位运算符（$\boldsymbol{and/or/xor}$），$b_i$是一 个整数。每一对$a_i,b_i$有$c_i$的概率会消失，求表达式的结果的期望。  </p>
</blockquote>
<hr>
<p>需要建立某种神秘的条件反射，就是遇到位运算的题目就要想到“位与位之间是无关的”。那么就可以直接按位做，令$f_{i,0/1}$表示计算完前$i$对，现在这一位为$0/1$的概率是多少。转移时别忘了加上当前这一对被删除的概率，即$f_{i-1,0/1}$。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>校内模拟赛</category>
      </categories>
      <tags>
        <tag>数学/观察性质,结论与构造</tag>
        <tag>数学/概率,期望</tag>
        <tag>奇怪的技巧</tag>
        <tag>有趣的二分答案</tag>
        <tag>动态规划/树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】分治在FFT上的应用</title>
    <url>/2019/08/27/fzfft-md/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实就是cdq分治+FFT。</p>
<p>分治FFT解决的问题的一般形式：</p>
<p>给出$g_1,g_2,g_3\cdots g_{n-1},f_0=1$，且</p>
<script type="math/tex; mode=display">
f_i=\sum_{j=1}^{i} f_{i-j} g_j</script><p>求$f_1,f_2\cdots f_{n-1}$</p>
<a id="more"></a>
<p>先展开观察性质</p>
<script type="math/tex; mode=display">
\begin{aligned}f_1&=g_1f_0,\\\ f_2&=g_1f_1+g_2f_0,
\\\ f_3&=g_1f_2+g_2f_1+g_3f_0\\\ f_4&=g_1f_3+g_2f_2+g_3f_1+g_4f_0=g_1^4\end{aligned}</script><p>我们发现如果将整个序列分成两半，前一半对后一半的贡献是：</p>
<script type="math/tex; mode=display">
o_p=\sum_{i=l}^{\rm{mid}}f_ig_{p-i}</script><p>其中$p\in(\rm{mid},r]$，$o$是额外的贡献。</p>
<p>我们发现，其实这是个卷积的形式，毕竟对于普通的卷积定义是：</p>
<script type="math/tex; mode=display">
c_i=\sum_{j\leq i} a_jb_{i-j}</script><p>于是我们就可以通过分治，每次暴力NTT计算前一半对后一半的贡献，类似于cdq分治的操作，复杂度$n\log ^2n$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;<span class="keyword">if</span> (!l) F[l] = <span class="number">1</span> ; <span class="keyword">return</span> ;&#125; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, L = r - l + <span class="number">1</span>, Len = <span class="number">1</span>, l1 = <span class="number">0</span> ;</span><br><span class="line">    cdqNTT(l, mid) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt;= L) Len &lt;&lt;= <span class="number">1</span>, ++ l1 ;</span><br><span class="line">    <span class="built_in">memcpy</span> (P, G, <span class="keyword">sizeof</span>(LL) * (r - l + <span class="number">1</span>)) ;</span><br><span class="line">    <span class="built_in">memcpy</span> (Q, F + l, <span class="keyword">sizeof</span>(LL)*(mid - l + <span class="number">1</span>)) ;</span><br><span class="line">    <span class="built_in">memset</span> (P + r - l + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> (LL) * (Len - r + l)) ;</span><br><span class="line">    <span class="built_in">memset</span> (Q + mid - l + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">sizeof</span> (LL) * (Len - mid + l)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l1 - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(P, Len, <span class="number">1</span>), NTT(Q, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) P[i] = P[i] * Q[i] % Mod ;</span><br><span class="line">    NTT(P, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = mid + <span class="number">1</span> ; i &lt;= r ; ++ i) (F[i] += P[i - l]) %= Mod ; cdqNTT(mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;G[i]) ;</span><br><span class="line">    cdqNTT(<span class="number">0</span>, N - <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, F[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，得出结论我的分治没学好qaq</p>
<p>但是如果换一个角度观察，设出两个形式幂级数，即令</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rm{F}&=\sum f_ix^i\\\
\rm{G}&=\sum g_ix^i
\end{aligned}</script><p>然后我们把他俩卷起来，且因为F本身就是卷积的形式，即有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rm{F} *\rm{G} & =\sum x^i\sum_{j\leq i} f_ig_j
\\\
&= \sum x_i f_{i+1}\\\
&= \rm{F}-f_0
\end{aligned}</script><p>那么先移项，之后两边同时卷一个$\rm{G}-1$ 的逆就可以得到：</p>
<script type="math/tex; mode=display">
\rm{F}= \frac{1}{1-G}</script><p>于是直接求一个逆就完了，复杂度$n\log n$。</p>
<p>不得不说这也算是一个小技巧了qwq</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>技巧/分治</tag>
        <tag>多项式的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】Berlekamp-Massey算法</title>
    <url>/2019/08/26/BM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Berlekamp-Massey</strong>算法用于在$O(n^2)$的时间内求解数列的递推式。</p>
<p>形式化地讲，给定 $a_i(i=1,2,3…n-1,n)$，求一组 $b_j(j=1,2,3…m)$，满足：</p>
<script type="math/tex; mode=display">
\forall i\geq m+1, a_i=\sum _{j=1}^{m} a_{i-j}b_j</script><p>其中或许会有条件限制$m$最小。</p>
<a id="more"></a>
<h1 id="神仙构造"><a href="#神仙构造" class="headerlink" title="神仙构造"></a>神仙构造</h1><p>考虑增量构造。即已知满足前 $i - 1$ 项的递推式，如何求出也满足第 $i$ 项的。</p>
<p>定义 $\Delta_i$ 表示第 $i$ 项与当前递推式之间的差值，$\rm F$ 为当前暂时满足条件的递推式 $\{f_i\}$。</p>
<p>那么定义：</p>
<script type="math/tex; mode=display">
\Delta_i=a_i-\sum_{j=1}^{m}f_ja_{i-j}</script><p>考虑如果 $\Delta_i=0$ 那么就不需要管，现在考虑 $\Delta_i \not =0$  的情况。</p>
<p>考虑一个大体的构造思想，我们最后构造出的 $\rm F$ 尽量是让前面满足的递推关系满足，并且使得新加进来的一组关于 $i$ 的递推关系也满足。</p>
<p>考虑令 $\mathrm{F}_k$ 表示修改过 $k$ 次之后的递推式，$\mathrm{fail}_k$ 表示第 $k$ 个版本的递推式是哪个 $i$ 开始失配的。不妨记算完 $a_{i-1}$ 的 $\rm F$ 是第 $q$ 个版本，即 $\rm F_q$</p>
<p>那么考虑我们需要构造一个这样的 $\mathrm F’:\{f’_1,f’_2,\dots f_{m’}’\}$ ，使得 </p>
<script type="math/tex; mode=display">
\forall p\in[m'+1,i-1]\cap\mathbb Z,\\
\sum_{j=1}^{m'} f'_ja_{p-j}=0</script><p>同时有：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^{m'} f'_ja_{i-j}=\Delta_{i}</script><p>那么显然令 $\mathrm{F}_{q+1}=\mathrm{F_q}+\mathrm{F’}$ 就是答案。</p>
<p>考虑这么一种构造方式：随便选一个历史版本 $o,1\leq o\leq q$ ，令 $\alpha=\frac{\Delta_i}{\Delta_o}$ ，那么 $\rm F’$ 就是：</p>
<script type="math/tex; mode=display">
\{0,0\ldots0,\alpha,-\alpha\cdot \mathrm F_o\}</script><p>其中前缀 $0$ 的个数为 $i-\mathrm{fail}_o-1$ ，最后 $\mathrm {fail} _o$ 项是 $\rm F\it _o$ 整体乘上了 $\alpha$。</p>
<p>思考这样的可行性，设 $p’\in[1,i]\cap\mathbb Z$ ，那么有：</p>
<script type="math/tex; mode=display">
\sum_{j=1}^{m'}f_j'a_{p'-j}=
\begin{cases}
\alpha\cdot(a_{\mathrm{fail}_o}-\sum_{j=1}^{|\mathrm{F}_{o}|}f_{o,j}a_{\mathrm{fail}_o-j})=\alpha\cdot \Delta_{\mathrm{fail}_o}=\Delta_i,\quad &p'=i\\
\alpha\cdot(a_{\mathrm{fail}_o-k}-\sum_{j=1}^{|\mathrm{F}_{o}|}f_{o,j}a_{\mathrm{fail}_o-k-j})=0,\quad &p'=i-k,k\in \mathbb Z_{+}
\end{cases}</script><p>发现刚好满足要求。于是可知 $\mathrm{F}_{q+1}=\mathrm{F_q}+\mathrm{F’}$ 即为答案。</p>
<p>那么考虑如何求最短递推式。发现 $1\leq o\leq q$ 的选取没有限制，所以选 $|\mathrm{F}_o|+i-\mathrm{fail}_o$ 最小的即可。</p>
<h1 id="实现部分"><a href="#实现部分" class="headerlink" title="实现部分"></a>实现部分</h1><p>大概还是很显然的？过程都很清晰，就是模拟了一遍而已。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fail[MAXN] ; </span><br><span class="line"><span class="built_in">vector</span> &lt;LL&gt; f[MAXN] ;</span><br><span class="line">LL delta[MAXN], now ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BM</span><span class="params">(<span class="keyword">int</span> I)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= I ; ++ i)&#123;</span><br><span class="line">      	now = base[i] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= f[M].size() ; ++ j)</span><br><span class="line">            now = now - base[i - j] * f[M][j - <span class="number">1</span>] % Mod ;</span><br><span class="line">        delta[i] = (now % Mod + Mod) % Mod ; </span><br><span class="line">      	<span class="keyword">if</span> (!delta[i]) <span class="keyword">continue</span> ; <span class="keyword">else</span> fail[M] = i ;</span><br><span class="line">        <span class="keyword">if</span> (!M) &#123; </span><br><span class="line">          f[++ M].resize(i) ;</span><br><span class="line">          delta[i] = base[i] ;  <span class="keyword">continue</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Id = M - <span class="number">1</span> ;</span><br><span class="line">        v = f[Id].size() - fail[Id] + i ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i - fail[j] + f[j].size() &lt; v)</span><br><span class="line">                Id = j, v = i - fail[j] + f[j].size() ;</span><br><span class="line">        f[M + <span class="number">1</span>] = f[M] ; ++ M ; </span><br><span class="line">      	<span class="keyword">while</span> (f[M].size() &lt; v) f[M].push_back(<span class="number">0</span>) ;</span><br><span class="line">        LL mul = delta[i] * expow(delta[fail[Id]], Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line">        (f[M][i - fail[Id] - <span class="number">1</span>] += mul) %= Mod  ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; f[Id].size() ; ++ j)</span><br><span class="line">            (f[M][i - fail[Id] + j] -= mul * f[Id][j]) %= Mod ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; f[M].size() ; ++ i)</span><br><span class="line">        p[i + <span class="number">1</span>] = (f[M][i] % Mod + Mod) % Mod, <span class="built_in">cout</span> &lt;&lt; p[i + <span class="number">1</span>] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就没有然后了</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Berlekamp-Massey算法</category>
      </categories>
      <tags>
        <tag>Berlekamp-Massey</tag>
        <tag>数学/常系数齐次线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】快速沃尔什变换</title>
    <url>/2019/08/26/fwt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>快速沃尔什变换(FWT)</strong>是一种广义上的<strong>傅里叶变换</strong>，可以解决<strong>子集并卷积</strong>、<strong>子集交卷积</strong>以及<strong>子集对称差卷积</strong>。</p>
<p>而在OI中决定了FWT胜过FMT的一大原因就是他可以方便地解决<strong>子集对称差卷积</strong>，即：</p>
<script type="math/tex; mode=display">
c_i=\sum_{j\oplus k=i} a_jb_k</script><p>其中$\oplus$表示二进制数的异或运算、集合的对称差运算（虽然”对称差”听起来挺有道理，但是感觉“二进制非进位加法”更有趣）。</p>
<a id="more"></a>
<hr>
<h1 id="再谈线性变换实质"><a href="#再谈线性变换实质" class="headerlink" title="再谈线性变换实质"></a>再谈线性变换实质</h1><p>首先是构造，我们考虑线性变换的本质，需要有:</p>
<script type="math/tex; mode=display">
{\rm FWT(C)}_i={\rm FWT(B)}_i\cdot{\rm FWT(A)}_i</script><p>那么一个思路就是先设一个辅助函数$\varphi(i,x)$出来：</p>
<script type="math/tex; mode=display">
{\rm FWT(F)}_i=\sum_{j\geq 0}\varphi(j,i) \cdot f_j</script><p>那么就会有：</p>
<script type="math/tex; mode=display">
\sum_{j\geq 0}\varphi(j,i) \cdot c_j=\sum_{j\geq 0}\varphi(j,i) \cdot a_j\times \sum_{j\geq 0}\varphi(j,i) \cdot b_j</script><p>然后把</p>
<script type="math/tex; mode=display">
c_i=\sum_{j\oplus k=i} a_jb_k</script><p>带进去并调整：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j\geq 0}\varphi(j,i) \cdot \sum_{p\oplus q=j} a_pb_q & =\sum_{j\geq 0}\varphi(j,i) \cdot a_j \times\sum_{j\geq 0}\varphi(j,i) \cdot b_j\\\
\sum_{p \geq 0} \sum_{q\geq 0}\varphi(p\oplus q,i)\cdot a_pb_q & =\sum_{p\geq 0}\sum_{q\geq 0}\varphi(p,i) \cdot \varphi(q,i)\cdot a_pb_q\\\
\end{aligned}</script><p>发现 $\sum_{p\geq 0}\sum _{q\geq 0}a_pb_q$ 是可以消掉的，于是就有：</p>
<script type="math/tex; mode=display">
\varphi(p\oplus q,i)=\varphi(p,i)\cdot \varphi(q,i)</script><h1 id="构造-varphi"><a href="#构造-varphi" class="headerlink" title="构造$\varphi$"></a>构造$\varphi$</h1><p>对于异或操作来说，异或前后$1$的个数的奇偶性不会改变。即也就是说$i,j$中$1$的个数加起来和$i\oplus j$中1的个数的奇偶性是一样的。形式化地讲：</p>
<script type="math/tex; mode=display">
\rm bitcount(i)+bitcount(j)\equiv bitcount(i~\oplus ~j)~(\bmod 2)</script><p>证明：</p>
<p>考虑$i \oplus j$的每一位：</p>
<ul>
<li>若$i$和$j$的这一位相同，那么就会变成$0$，$1$的个数减二或不变；</li>
<li>如不同，那么就一定是$(xx1xx)\oplus(xx0xx)=(xx1xx)$，$1$的个数还是不变。</li>
</ul>
<p>而我们发现这个引理解决的是相加不变的问题，而我们需要的$\varphi$函数需要满足相乘不变，于是自然而然地想到要放到幂上去。</p>
<p>于是就定义了$\varphi$:</p>
<script type="math/tex; mode=display">
\varphi(s,t)=(-1)^{|s\cap t|}</script><p>换成数值的表示方法：</p>
<script type="math/tex; mode=display">
\varphi(i,j)=(-1)^{\rm bitcount \mathcal{(i ~\rm{and}~ j)}}</script><p>这么定义的原因是：</p>
<script type="math/tex; mode=display">
(i \cap x) \oplus(j \cap x)=(i \oplus j) \cap x</script><p>即<strong>异或对交有分配律</strong>，那么：</p>
<script type="math/tex; mode=display">
{\rm{FWT(F)}}_i=\sum_{j \geq 0}(-1)^{|i\cap j|}f_j</script><p><del>于是就喜提一个指数级算法</del></p>
<h1 id="真正的-rm-FWT"><a href="#真正的-rm-FWT" class="headerlink" title="真正的$\rm{FWT}$"></a>真正的$\rm{FWT}$</h1><p>我们发现似乎这东西没有办法dp，于是考虑：</p>
<blockquote>
<p>每一次考虑新加入第$i$个物品取不取的情况，将当前集合分为$i$取和$i$不取，$i$取的放右边，$i$不取的放左边。</p>
<p>$i$取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小$−1$。$i$不取的话，和$i$取的状态取并后集合大小不变，和$i$不取的状态取并后集合大小同样的不变。 </p>
<p>这样考虑原有状态，左右两边对$i$不取的贡献都是$\text{++}$，因为集合大小不变。左边对$i$取的贡献是$+$，右边对$i$取的贡献是$\text{−−}$，因为都取$i$的话并集增加了$1$，贡献取反。</p>
</blockquote>
<p>然后其实就是个模拟的思路，由于$(1xxxxxx)_2$和$(0xxxxxx)_2$的数量是一致的，所以我们可以将小于$(1000000)_2$的分为一类，大于等于$(1000000)_2$的分为一类，从数值上看就是前一半和后一半。</p>
<p>总之就是个FFT🦋操作的思路啦。</p>
<p>然后对于逆变换，因为我们刚才的结论有：</p>
<script type="math/tex; mode=display">
\begin{aligned}{F[j+k] =F[j+k]+F[i+j+k]} \\\ {F[i+j+k]=F[j+k]-F[i+j+k]}\end{aligned}</script><p>所以我们现在为了得到原来的$F[i+j+k]$和$F[j+k]$，直接</p>
<script type="math/tex; mode=display">
\begin{array}{c}{F[j+k]=\frac{F[j+k]+F[j+i+k]}{2}} \\ {F[j+i+k]=\frac{F[j+k]-F[j+i+k]}{2}}\end{array}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, m = <span class="number">1</span> &lt;&lt; (N - <span class="number">1</span>), x, y ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= m ; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; j += (i &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; i ; ++ k)&#123;</span><br><span class="line">                x = f[j + k], y = f[i + j + k] ;</span><br><span class="line">                f[j + k] = <span class="number">1l</span>l * (g ^ <span class="number">1</span> ? Inv2 : <span class="number">1</span>) * (x + y) % Mod ;</span><br><span class="line">                f[i + j + k] = <span class="number">1l</span>l * (g ^ <span class="number">1</span> ? Inv2 : <span class="number">1</span>) * (x + Mod - y) % Mod ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是时间复杂度就是$n \log n$了。</p>
<h1 id="rm-FWT-做or-and卷积"><a href="#rm-FWT-做or-and卷积" class="headerlink" title="$\rm FWT$做or/and卷积"></a>$\rm FWT$做or/and卷积</h1><p>艹，真是被血坑了。</p>
<p>才发现原来FWT做or/and卷积就是跟FMT一个道理：</p>
<script type="math/tex; mode=display">
\boldsymbol{or}: F[i+j+k]+=F[j+k]\\\
\boldsymbol{and}: F[j+k]+=F[i+j+k]</script><p>然后逆变换就直接把加号改成减号就好了……原因就是“不取这个东西”一定是“取这个东西”的子集。</p>
<p>但是当时我认真学习FMT的时候，<code>Rockdu</code>博客里面FMT的代码是FWT的！！！然后再看别人的代码我就懵O了好久……</p>
<p>真是zz</p>
<p>但是终于理解了<code>JOHNKRAM</code>神仙的话：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2019/08/30/mjCdF1.jpg" alt=""></p>
<p>不得不说是很形象了。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li>其实Lugou上的板子的复杂度是$2^n n$的，我一开始就觉得暴力枚举子集没啥问题，结果最后发现枚举子集不是枚举$(n)_2$的子集，而是枚举$(2^n)_2$的子集……白学了白学了</li>
<li>唉，本来就是功能相同的FWT和FMT，看错代码真是GG</li>
<li>其实只有对称差卷积难理解一些，交并卷积都是很形象的。</li>
</ul>
]]></content>
      <tags>
        <tag>快速沃尔什变换(FWT)</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】快速莫比乌斯变换&amp;子集卷积</title>
    <url>/2019/08/26/fmt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>快速莫比乌斯变换(FMT)</strong>可以方便地解决<strong>子集交卷积</strong>和<strong>子集并卷积</strong>，形式化地讲就是求一个$\rm C$：</p>
<script type="math/tex; mode=display">
c_i=\sum_{k\cup j=i} a_kb_j\\
c_i=\sum_{k\cap j=i} a_kb_j</script><p>而<strong>快速子集变换(FST)</strong>则是在FMT基础上的扩展，解决的也是子集交卷积，但是限制了<strong>状态不重复</strong>，即</p>
<script type="math/tex; mode=display">
c_i=\sum_{\substack{\begin{aligned}~k &\cup j=i\\ k &\cap j= \emptyset \end{aligned}}}a_kb_j</script><p>换个写法：</p>
<script type="math/tex; mode=display">
c_s=\sum_{t\subseteq s}a_sb_{s-t}</script><p>同时，以上两种变换所涉及的交集、并集和差集的对象都是集合（也就是$c_i$的下角标$i$指代的是集合），其二进制表示能更好地展示这一点。</p>
<a id="more"></a>
<h1 id="rm-FMT"><a href="#rm-FMT" class="headerlink" title="$\rm{FMT}$"></a>$\rm{FMT}$</h1><p>首先我们考虑一步线性变换的实质。考虑FFT，其本质是通过DFT使得我们可以直接线性地逐项相乘，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
\rm {C} & =\rm{A*B}\\\
\Longrightarrow \rm{DFT(C)_i} & =\rm{DFT(A)_i\cdot DFT(B)_i}
\end{aligned}</script><p>那么我们同时也希望构造出一种变换使得可以逐项相乘。</p>
<h2 id="1-子集并卷积"><a href="#1-子集并卷积" class="headerlink" title="$(1)$ 子集并卷积"></a>$(1)$ 子集并卷积</h2><p>不妨先扩大一下范围，即若$A\cup B=C$，则一定有$A\subseteq C$且$B \subseteq C$，但是反过来不一定。</p>
<p>那么先考虑$\rm MT$，即考虑一种变换而不思考其复杂度。我们令</p>
<script type="math/tex; mode=display">
\rm MT(F)_i= \mathcal{\sum_{j\subseteq i} f_j}</script><p>则有</p>
<script type="math/tex; mode=display">
\rm{MT(F)_i\cdot MT(G)_i}=\mathcal{\sum _{j,k\subseteq i} f_j\cdot g_k}</script><p>而实际上我们求的是</p>
<script type="math/tex; mode=display">
\rm{P_i}=\mathcal{\sum_{j\cup k=i}f_jg_k}</script><p>而我们发现</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{j\subseteq i}{\rm{P}}_j &=\sum_{d \subseteq i} \sum_{j\cup k=d}f_jg_k\\\ &= \sum_{j,k\subseteq i} f_jg_k\\\ &= \rm{MT(P)_i}\end{aligned}</script><p>也就是说有</p>
<script type="math/tex; mode=display">
\rm MT(F)_i\cdot MT(G)_i =MT(P)_i</script><p>于是就构造出了这样的线性变换，本质就是子集和。</p>
<p>但是普通的子集和是 $O(3^n)$ 的，但是我们的 $n$ 是 $20$ 左右，所以考虑一个dp一样的东西。就是我们每次枚举每一位，那么这一位为0就是这一位为1的子集，所以累加进答案。于是这样的复杂度就变成了$2^nn$ .</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N = (1 &lt;&lt; M) - 1 ;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_or</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = (Mod + f[j] + <span class="number">1l</span>l * g * f[j ^ (<span class="number">1</span> &lt;&lt; i)]) % Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-子集交卷积"><a href="#2-子集交卷积" class="headerlink" title="$(2)$ 子集交卷积"></a>$(2)$ 子集交卷积</h2><p>我们对称思考，即令$\rm{MOT}$表示交卷积的变换，那么应该有：</p>
<script type="math/tex; mode=display">
\rm MOT(F)_i= \mathcal{\sum_{i\subseteq j} f_j}</script><p>那么</p>
<script type="math/tex; mode=display">
\rm{MOT(F)_i\cdot MOT(G)_i}=\mathcal{\sum _{i\subseteq j,i\subseteq k} f_j\cdot g_k}</script><p>我们要求的是</p>
<script type="math/tex; mode=display">
\rm{Q_i}=\mathcal{\sum_{j\cap k=i}f_jg_k}</script><p>则：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum _{i\subseteq j}{\rm}_j &=\sum_{i \subseteq d} \sum_{j\cap k=d}f_jg_k\\\ &= \sum_{i\subseteq j,i\subseteq k} f_jg_k\\\ &= {\rm{MOT(Q)}_i}\end{aligned}</script><p>于是就直接反着求一遍即可。</p>
<p>然后这东西就也还是个dp，复杂度$n \log n$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fmt_and</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> g)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = M ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (~j &gt;&gt; i &amp; <span class="number">1</span>) f[j] = (Mod + f[j] + <span class="number">1l</span>l * g * f[j | (<span class="number">1</span> &lt;&lt; i)]) % Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-优化：增量分治"><a href="#3-优化：增量分治" class="headerlink" title="$(3)$ 优化：增量分治"></a>$(3)$ 优化：增量分治</h2><p>阅读提示：优你🐎的化，这就是个FWT。</p>
<p>以下是以前的翻车现场：</p>
<hr>
<p>实际上我觉得也没怎么优化……</p>
<p>拿并卷积举例，大体上就是我们考虑如果存在$i\subseteq j\subseteq k$，我们朴素的要算两次，但实际上我们对于前半部分的$k$只需要算一次。这样实际上就是我们考虑每次只转移前$n-i$个元素相同的集合。</p>
<p>(以下内容来自<code>Rockdu</code>的$blog$)</p>
<p>于是每当多了一个元素，即我们考虑由$i$层转移到$i+1$层，发现只是多了一个元素的状态——讨论一下这个元素取不取，发现这个元素不取，答案就和原来一样，因为它的子集和不变；如果这个元素要取，那么这个元素不取的情况是它的子集，会多出这个元素不取的子集和。最终我们发现，到第$i$层只需要把第$i$个元素不取的状态加到第$i$个元素取的状态就可以了。</p>
<p>于是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FMT</span><span class="params">(<span class="keyword">int</span> * A, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p = i &lt;&lt; <span class="number">1</span>, j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j += p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k)</span><br><span class="line">                (A[i + j + k] += A[j + k]) %= Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去每次只用计算一半，但是<code>JOHNKRAM</code>神仙是这么说的：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2019/08/29/mbfpBq.png" alt=""></p>
<p>你看他长得和FFT的蝴蝶操作一毛一样，所以还是$n\log n$的。</p>
<hr>
<p>= =假酒害人，假代码更害人</p>
<h1 id="rm-FST"><a href="#rm-FST" class="headerlink" title="$\rm FST$"></a>$\rm FST$</h1><p><del>这个名字不是很吉利</del></p>
<p>这东西其实也不是非要用$\rm FMT$来做，$\rm FWT$也可以。</p>
<p>然后就是考虑在卷积的时候多增加一维，即$f_{i,S}$表示集合$S$中有$i$个元素，于是发现只有当元素个数相加符合时才是对的。</p>
<p>于是一开始将$f_{bct(s),s}$赋值为$f_s$，其中$bct(s)=\rm bitcount(s)$。然后对每一个$f_i$分别做$\rm FMT$，之后按位乘的时候需要</p>
<script type="math/tex; mode=display">
P_{i, S}=\sum_{i=0}^{i} f_{j, S} * g_{i-j, S}</script><p>输出的时候只输出$P_{bct(s),s}$即可。</p>
<p>板子题是<a href="https://loj.ac/problem/152" target="_blank" rel="noopener"><code>LOJ #152</code></a>，略微卡常，被逼无奈写了神奇的取模优化233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 1056701</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> bc[MAXM] ;</span><br><span class="line"><span class="keyword">int</span> N, M ; LL A[MAXN][MAXM], B[MAXN][MAXM], C[MAXN][MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="function">I <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(LL &amp;x)</span> </span>&#123; x += x &gt;&gt; <span class="number">63</span> &amp; Mod ; &#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">Ifmt</span><span class="params">(LL *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) reduce(f[j] -= f[j ^ <span class="number">1</span> &lt;&lt; i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">I <span class="keyword">void</span> <span class="title">fmt</span><span class="params">(LL *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j &gt;&gt; i &amp; <span class="number">1</span>) reduce(f[j] += f[j ^ <span class="number">1</span> &lt;&lt; i] - Mod) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; M = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ; <span class="keyword">register</span> <span class="keyword">int</span> i, j, s ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) bc[i] = bc[i - (i &amp; -i)] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) A[bc[i]][i] = read() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[bc[i]][i] = read() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fmt(A[i]), fmt(B[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= i ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (s = <span class="number">0</span> ; s &lt;= M ; ++ s)</span><br><span class="line">                (C[i][s] += A[j][s] * B[i - j][s]) %= Mod ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Ifmt(C[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, C[bc[i]][i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>实际上国际上根本不通用FMT和FST这两个简写（甚至可能国内也没几个人用FST指代”子集卷积“）,于是就只能233了</p>
<p>upd：有些说明参见FWT的讲解。</p>
<h2 id="rm-Referance"><a href="#rm-Referance" class="headerlink" title="$\rm Referance$"></a>$\rm Referance$</h2><ul>
<li>$[1]$ :<code>Dance of Faith</code>的$blog$ <a href="https://www.cnblogs.com/Dance-Of-Faith/p/8818211.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[2]$ :<code>Rockdu</code>的$blog$ <a href="http://blog.leanote.com/post/rockdu/TX20" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>奇怪的变换</category>
      </categories>
      <tags>
        <tag>快速莫比乌斯变换(FMT)</tag>
        <tag>快速沃尔什变换(FWT)</tag>
        <tag>快速子集变换(FST)</tag>
      </tags>
  </entry>
  <entry>
    <title>随想十 · 繁星</title>
    <url>/2019/08/20/10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>upd2 : 时机依旧不成熟，但睁开了眼睛，发现原来世界是这样的，决定慢慢体会什么是善恶、什么是明暗。终于坚定了不再当行尸走肉的决心，要成为真正独立、有血有肉的人。</p>
<p>upd1 : 时机尚不成熟，双眸是瞎的，看不到一丝光亮，只是一具只会随波逐流的皮肉罢了。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】CF Educational Round70 题解</title>
    <url>/2019/08/19/Er70/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>Educational Round</code>，顾名思义，<strong>教育做人专场</strong>。</p>
<p>这场比赛巧妙地教育了一个初出茅庐的萌新Oier（我）<strong>到底该如何做人</strong>（哭晕）。</p>
<p>比赛链接：<a href="https://codeforces.com/contest/1202" target="_blank" rel="noopener">戳</a></p>
 <a id="more"></a>
<h1 id="A"><a href="#A" class="headerlink" title="$~A$"></a>$~A$</h1><p>题意：给你两个二进制字符串$x$和$y$，将$y$左移$k$位，再与$x$相加，得到字符串$s_k$，最后将其反转得到$res_k$。求当$res_k$字典序最小时的$k$。</p>
<hr>
<p>诡异的贪心……</p>
<p>实不相瞒我想了整整半个多小时（中间伴有间歇性走神）……</p>
<p>其实就是转化的思想，求反串的字典序最小，就是要把正串里面的低位1们尽量消掉。又因为题目里面限制了$x&gt;y$，所以一定存在$x$的二进制表示中至少一个$1$比$y$的最低位$1$靠左。考虑贪心的思想，$x$被消掉的$1$越靠右，反串字典序就越小。所以说我们要找的就是$\boldsymbol{x}$<strong>中能被$\boldsymbol{y}$消掉的最靠右的那个$\boldsymbol{1}$的位置</strong>。</p>
<p>于是扫一遍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">	<span class="keyword">int</span> i, posa = <span class="number">0</span> , posb = <span class="number">0</span> ;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, A + <span class="number">1</span>) ;<span class="built_in">scanf</span>(<span class="string">"%s"</span>, B + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">int</span> La = <span class="built_in">strlen</span>(A + <span class="number">1</span>), Lb = <span class="built_in">strlen</span>(B + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Lb ; ++ i)</span><br><span class="line">	<span class="keyword">if</span> (B[i] == <span class="string">'1'</span>) posb = i ; posb = Lb - posb + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= La ; ++ i)</span><br><span class="line">	<span class="keyword">if</span> (A[i] == <span class="string">'1'</span>) <span class="keyword">if</span> (La - i + <span class="number">1</span> &gt;= posb) posa = La - i + <span class="number">1</span> ;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; posa &lt;&lt; " " &lt;&lt; posb &lt;&lt; endl ;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, posa - posb) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="it-B"><a href="#it-B" class="headerlink" title="$\it{B}$"></a>$\it{B}$</h1><p>题意：给定一个计数器$(x-y)$，对于每次引进的常数$z$，可以选择$\text{((+=x)mod=10)}$ 或者$\text{((+=y)mod=10)}$（$\text{mod=}$就是<code>%=</code>）然后把结果再丢到运算里面继续运算。现在给定一个残缺的$z$序列（省略了中间的某些结果），求$0\text{~}9$两两组合的计数器分别至少需要多少步才能还原这个串的运算。</p>
<hr>
<p>草，我这最短路又是白学了。</p>
<p>首先我们考虑一个显然的$10^4\cdot \Omega(1)$的预处理，就是令$(i-j)$为计数器，从$k$到$o$的最短距离，这玩意儿显然可以BFS，由于是对$10$取模所以大概循环节也在下界为$\Theta(1)$左右酱紫。之后对于询问直接暴力枚举就好了，复杂度大概是$100\cdot O(|S|)\leq 100\times 2,000,000=2e8$……梦想算法……但其实显然那个$100$可以只做$50+$的样子，毕竟是对称的……不过还是梦想算法233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, o ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; <span class="number">10</span> ; ++ k)</span><br><span class="line">                <span class="keyword">for</span> (o = <span class="number">0</span> ; o &lt; <span class="number">10</span> ; ++ o)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> mark[<span class="number">200</span>] ;</span><br><span class="line">                    dis[i][j][k][o] = <span class="number">-1</span> ;</span><br><span class="line">                    <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark)) ;</span><br><span class="line">                    q.push((wk)&#123;k, <span class="number">0</span>&#125;) ;</span><br><span class="line">                    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">                        wk now = q.front() ; q.pop() ;</span><br><span class="line">                        <span class="keyword">if</span> (now.num == o &amp;&amp; now.cnt)&#123;</span><br><span class="line">                            dis[i][j][k][o] = now.cnt ; <span class="keyword">break</span> ;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (mark[now.num]) <span class="keyword">continue</span> ;mark[now.num] = <span class="number">1</span> ;</span><br><span class="line">                        q.push((wk)&#123; (now.num + i) % <span class="number">10</span>, now.cnt + <span class="number">1</span>&#125;) ;</span><br><span class="line">                        q.push((wk)&#123; (now.num + j) % <span class="number">10</span>, now.cnt + <span class="number">1</span>&#125;) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!q.empty()) q.pop() ;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">/*for (i = 0 ; i &lt; 10 ; ++ i)</span></span><br><span class="line"><span class="comment">        for (j = 0 ; j &lt; 10 ; ++ j)</span></span><br><span class="line"><span class="comment">            for (k = 0 ; k &lt; 10 ; ++ k)</span></span><br><span class="line"><span class="comment">                for (o = 0 ; o &lt; 10 ; ++ o)</span></span><br><span class="line"><span class="comment">                    cout &lt;&lt; dis[i][j][k][o] &lt;&lt; " " ;*/</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ; <span class="keyword">int</span> ans = <span class="number">0</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = In[i] - <span class="string">'0'</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; ++ i, <span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; ++ j)&#123; <span class="comment">/*qwqwq*/</span></span><br><span class="line">            <span class="keyword">for</span> (ans = <span class="number">0</span>, k = <span class="number">2</span> ; k &lt;= N ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[i][j][base[k - <span class="number">1</span>]][base[k]] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"-1 "</span>), ans = <span class="number">-1</span> ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += dis[i][j][base[k - <span class="number">1</span>]][base[k]] ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans - N + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（代码渲染会自动把<code>tab</code>映射成<code>force-tab</code>我也懒得管了= =）</p>
<h1 id="mathcal-C"><a href="#mathcal-C" class="headerlink" title="$\mathcal{C}$"></a>$\mathcal{C}$</h1><p>题意：给定一段某个机器人的操作序列<code>WSAD</code>，可以添加一个字符，求最终机器人的最小活动区域面积。</p>
<hr>
<p>首先显然是<strong>行列无关</strong>的，所以分开考虑；接着发现最优策略肯定是让某一步相当于没走，但是假设$x_{min}$和$x_{max}$均在这次改动操作的后面，那么缩小$x_{max}$的时候也会缩小$x_{min}$，相当于没缩——所以应找到一个界点，所有的最大值都在左/右边，对应的所有最小值都在右/左边。</p>
<p>由于每一步操作都是有后效性的，所以考虑直接前缀和上求出$min$和$max$就好。</p>
<p>但是考虑无论怎么移动，都不能越过预处理出来的$x_{min}$、$x_{max}$这个界（否则会出现越贪越大）。也就是说假设有一个$x_{max}$，接着过了一会儿有一个$x_{min}$，为了“拔高”$x_{min}$我们必须要添加一个$W$，所以我们必须要保证任何时刻不会出现$x_{max}$在放上一个$W$之后越界的情况，也就是说$x_{min}$和$x_{max}$出现的位置之间必须要一个$S$才能用来抵消掉我们$W$，需要特判。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; LL ans ; </span><br><span class="line"><span class="keyword">int</span> fhm, fhn, fwm, fwn, pos[<span class="number">2</span>][<span class="number">5</span>], i ; </span><br><span class="line"><span class="keyword">int</span> T, N, Sw[MAXN], Sh[MAXN] ; <span class="keyword">char</span> S[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; </span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        fhm = fwm = -Inf, fhn = fwn = Inf ;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>), N = <span class="built_in">strlen</span>(S + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            Sh[i] = Sh[i - <span class="number">1</span>], Sw[i] = Sw[i - <span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == <span class="string">'W'</span>) Sh[i] = Sh[i - <span class="number">1</span>] + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'S'</span>) Sh[i] = Sh[i - <span class="number">1</span>] - <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'D'</span>) Sw[i] = Sw[i - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'A'</span>) Sw[i] = Sw[i - <span class="number">1</span>] - <span class="number">1</span> ;</span><br><span class="line">        &#125;<span class="comment">//前缀和 : w x h </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fwm = max(Sw[i], fwm), fwn = min(Sw[i], fwn) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) fhm = max(Sh[i], fhm), fhn = min(Sh[i], fhn) ; </span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sh[i] == fhn) &#123; pos[<span class="number">0</span>][<span class="number">4</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_min h</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sw[i] == fwn) &#123; pos[<span class="number">1</span>][<span class="number">4</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_min h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sh[i] == fhm) &#123; pos[<span class="number">0</span>][<span class="number">1</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sw[i] == fwm) &#123; pos[<span class="number">1</span>][<span class="number">1</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_max w</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sh[i] == fhm) &#123; pos[<span class="number">0</span>][<span class="number">3</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = N ; ~i ; -- i) <span class="keyword">if</span> (Sw[i] == fwm) &#123; pos[<span class="number">1</span>][<span class="number">3</span>] = i ; <span class="keyword">break</span> ; &#125; <span class="comment">//last_max h</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sh[i] == fhn) &#123; pos[<span class="number">0</span>][<span class="number">2</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_min h    </span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Sw[i] == fwn) &#123; pos[<span class="number">1</span>][<span class="number">2</span>] = i ; <span class="keyword">break</span> ; &#125;  <span class="comment">//first_min w</span></span><br><span class="line">        ans = <span class="number">1l</span>l * (fwn - fwm - <span class="number">1</span>) * (fhn - fhm - <span class="number">1</span>) ; <span class="comment">//cout &lt;&lt; ans &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">0</span>][<span class="number">3</span>] &lt; pos[<span class="number">0</span>][<span class="number">2</span>] &amp;&amp; Sh[pos[<span class="number">0</span>][<span class="number">3</span>]] - Sh[pos[<span class="number">0</span>][<span class="number">2</span>]] &gt; <span class="number">1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn) * (fwm - fwn + <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">1</span>][<span class="number">3</span>] &lt; pos[<span class="number">1</span>][<span class="number">2</span>] &amp;&amp; Sw[pos[<span class="number">1</span>][<span class="number">3</span>]] - Sw[pos[<span class="number">1</span>][<span class="number">2</span>]] &gt; <span class="number">1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn + <span class="number">1</span>) * (fwm - fwn)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">0</span>][<span class="number">4</span>] &lt; pos[<span class="number">0</span>][<span class="number">1</span>] &amp;&amp; Sh[pos[<span class="number">0</span>][<span class="number">4</span>]] - Sh[pos[<span class="number">0</span>][<span class="number">1</span>]] &lt; <span class="number">-1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn) * (fwm - fwn + <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">1</span>][<span class="number">4</span>] &lt; pos[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; Sw[pos[<span class="number">1</span>][<span class="number">4</span>]] - Sw[pos[<span class="number">1</span>][<span class="number">1</span>]] &lt; <span class="number">-1</span>) </span><br><span class="line">            ans = min(ans, <span class="number">1l</span>l * (fhm - fhn + <span class="number">1</span>) * (fwm - fwn)) ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">        pos[<span class="number">0</span>][<span class="number">1</span>] = pos[<span class="number">1</span>][<span class="number">1</span>] = pos[<span class="number">0</span>][<span class="number">2</span>] = pos[<span class="number">1</span>][<span class="number">2</span>] = Inf ;</span><br><span class="line">        pos[<span class="number">0</span>][<span class="number">3</span>] = pos[<span class="number">1</span>][<span class="number">3</span>] = pos[<span class="number">0</span>][<span class="number">4</span>] = pos[<span class="number">1</span>][<span class="number">4</span>] = -Inf ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmmm好像当时<code>debug</code>了好久的样子。</p>
<h1 id="rm-D"><a href="#rm-D" class="headerlink" title="$\rm{D}$"></a>$\rm{D}$</h1><p>题意：构造一个含有<code>1</code>/<code>3</code>/<code>7</code>的串，使得子序列<code>1337</code>的数量恰好为$x$。</p>
<hr>
<p>这特么就是一个智商题。就是考虑一个最简单的构造<code>133..3337</code>这种，但是不是每一个$x$都可以表示成$\frac{p(p-1)}{2}$这种形式的……所以考虑找出最大的$p~\rm{s.t.}$ $p(p-1)\leq 2x$，然后拼命地向第一组<code>33</code>后面添加<code>7</code>就好了。这样总长度是上限是$2\sqrt x$的，挺稳。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> p = <span class="built_in">sqrt</span>(<span class="number">2</span>*N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p ; i &lt;= <span class="number">2</span>*N ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i * (i - <span class="number">1</span>) &gt; <span class="number">2</span> * N) <span class="keyword">break</span> ;</span><br><span class="line">            L1 = i * (i - <span class="number">1</span>) / <span class="number">2</span>, L2 = N - L1, L1 = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"133"</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L2 ; ++ i) <span class="built_in">putchar</span>(<span class="string">'7'</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L1 - <span class="number">2</span> ; ++ i) <span class="built_in">putchar</span>(<span class="string">'3'</span>) ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"7\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="mathbb-E"><a href="#mathbb-E" class="headerlink" title="$\mathbb{E}$"></a>$\mathbb{E}$</h1><p>题意：给定$N~(\leq 1e5)$个模板串$s_i$和一个文本串$T$，求所有的$s_i+s_j~(i\not=j)$在$T$中出现的次数之和。</p>
<hr>
<p>嗯，顺带复习了一下$AC$自动机。</p>
<p>思路其实也很简单，就是建俩$AC$自动机，一个跑正串，一个跑反串，然后枚举每个合法的i作为中间的结合位点，乘法原理就好了……但其实这种结论能轻易得出还是建立在$AC$自动机掌握十分扎实的基础上啊。</p>
<p>哦对，似乎对于AC自动机的题目，树形dp才是正确的打开方式。每次重新跳fail根本吃不消。。（<code>CF</code>真的有数据去卡这东西，<code>aaa..aa</code>这种……）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> S[MAXN], In[MAXN] ; <span class="keyword">int</span> N ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACm</span>&#123;</span></span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q ; <span class="keyword">int</span> cnt ;</span><br><span class="line">	<span class="keyword">int</span> tr[MAXN][<span class="number">27</span>], res[MAXN] ;</span><br><span class="line">	<span class="keyword">int</span> fail[MAXN], ans[MAXN], e[MAXN] ; </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> v(x) tr[rt][x]</span></span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> Id)</span></span>&#123;	</span><br><span class="line">		<span class="keyword">int</span> i, j = <span class="built_in">strlen</span>(s), k, rt = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i)&#123;</span><br><span class="line">			k = s[i] - <span class="string">'a'</span> ;</span><br><span class="line">			<span class="keyword">if</span> (!v(k)) v(k) = ++ cnt ; </span><br><span class="line">			rt = v(k) ;</span><br><span class="line">		&#125;</span><br><span class="line">		e[rt] ++ ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i, rt = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i) <span class="keyword">if</span> (v(i)) q.push(v(i)) ;</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">			rt = q.front(), q.pop() ;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">26</span> ; ++ i)&#123;</span><br><span class="line">				<span class="keyword">if</span> (!v(i)) v(i) = tr[fail[rt]][i] ; </span><br><span class="line">				<span class="keyword">else</span> fail[v(i)] = tr[fail[rt]][i], q.push(v(i)) ;</span><br><span class="line"><span class="comment">//				if (e[fail[v(i)]]) last[v(i)] = fail[v(i)] ; else last[v(i)] = last[fail[v(i)]] ;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">	void work(char *s)&#123;</span></span><br><span class="line"><span class="comment">		int i, j = strlen(s), p, rt = 0 ; </span></span><br><span class="line"><span class="comment">		for (i = 0 ; i &lt; j ; ++ i)&#123;</span></span><br><span class="line"><span class="comment">			rt = v(s[i] - 'a'), p = rt ; </span></span><br><span class="line"><span class="comment">			while(p) res[i] += e[p], p = fail[p] ;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">if</span> (res[rt] != <span class="number">-1</span>) <span class="keyword">return</span> res[rt] ;</span><br><span class="line">		<span class="keyword">return</span> res[rt] = e[rt] + dfs(fail[rt]) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(res, <span class="number">-1</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">		<span class="keyword">int</span> i, j = <span class="built_in">strlen</span>(s), p, rt = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i) rt = v(s[i] - <span class="string">'a'</span>), ans[i] = dfs(rt) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;P, Q ; LL ans ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; S &gt;&gt; N ; <span class="keyword">int</span> i, j ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, In), P.insert(In, i) ; </span><br><span class="line">		j = <span class="built_in">strlen</span>(In), reverse(In, In + j), Q.insert(In, i) ;</span><br><span class="line">	&#125;</span><br><span class="line">	P.build(), Q.build() ; j = <span class="built_in">strlen</span>(S) ;</span><br><span class="line">	P.work(S), j = <span class="built_in">strlen</span>(S) ; reverse(S, S + j) ; Q.work(S) ;</span><br><span class="line"><span class="comment">//	for (i = 0 ; i &lt; j ; ++ i) cout &lt;&lt; P.res[i] &lt;&lt; " " ; puts("") ;</span></span><br><span class="line"><span class="comment">//	for (i = 0 ; i &lt; j ; ++ i) cout &lt;&lt; Q.res[i] &lt;&lt; " " ;</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; j ; ++ i) ans += <span class="number">1l</span>l * P.ans[i] * Q.ans[j - <span class="number">2</span> - i] ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="mathfrak-F"><a href="#mathfrak-F" class="headerlink" title="$\mathfrak{F}$"></a>$\mathfrak{F}$</h1><p>题意：给定大写字母$A$和$B$的数量，求可以组成多少种不同的最短周期。其中周期的定义式不完全的，即只需要满足$\forall i,s[i]=s[i~\bmod~k]$，$k$就是周期。</p>
<hr>
<p>这真是神仙题……</p>
<p>下文中用$a,b$表示输入的那俩值。</p>
<p>考虑对于一个合法的$k$而言，假设在这个$k$满足$k=\lfloor n/p\rfloor,p\in \mathbb{N}$，那么$p$就是循环节的数量。现在我们假设有$q_a+q_b=k$，即每一段循环节中$A$的数量和$B$的数量。那么一定需要满足的是$q_a\cdot p\leq a$并且$q_b\cdot p\leq b$。</p>
<p>同时考虑一定会有</p>
<script type="math/tex; mode=display">
q_a \leq \lfloor\frac{a}{p}\rfloor, q_b \leq \lfloor\frac{b}{p}\rfloor</script><p>但同时还有一个条件，就是虽然实际上多出去一堆下脚料，但$a_{rest},b_{rest}$必须小于等于$q_a$和$q_b$。也就是说需要有</p>
<script type="math/tex; mode=display">
(p+1)\cdot q_a \geq a,(p+1)\cdot q_b\geq b</script><p>美化一下就是</p>
<script type="math/tex; mode=display">
\lceil \frac{a}{p+1} \rceil \leq q_a\leq \lfloor \frac{a}{p} \rfloor \\\
\lceil \frac{b}{p+1} \rceil \leq q_b\leq \lfloor \frac{b}{p} \rfloor</script><p>就可以通过从$1$到$n$枚举$p$来求得$q_a$和$q_b$，那么根据定义，$q_a$和$q_b$是一段循环节中的$A$和$B$的数量，所以$q_a+q_b$对$k$产生贡献。</p>
<p>还有一个小问题，就是如何保证一定是<strong>最小的$k$</strong>。这个其实也很简单。假设对于每一段完整的循环节他同时也自循环，段和段之间$A$和$B$个数一定相同，所以可以考虑直接把每一段的$A$丢到前面，$B$丢到后面，就避免了自循环这种情况。</p>
<p>然后这东西显然是可以数论分块的，所以我们分一下块就做完了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, L ; LL Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, L = N + M ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> g, l = <span class="number">1</span>, r ; l &lt;= L ; l = r + <span class="number">1</span>)&#123;</span><br><span class="line">        g = L / l, r = L / g ;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; g || M &lt; g) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">int</span> ln = (N + g) / (g + <span class="number">1</span>), hn = N / g ;</span><br><span class="line">        <span class="keyword">int</span> lm = (M + g) / (g + <span class="number">1</span>), hm = M / g ;</span><br><span class="line">        <span class="keyword">if</span> (hn &gt;= ln &amp;&amp; hm &gt;= lm)</span><br><span class="line">            Ans += max(<span class="number">0l</span>l, <span class="number">1l</span>l * (min(hn + hm, r) - max(l, lm + ln) + <span class="number">1</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完结撒🌹fa~</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划/自动机上DP</tag>
        <tag>字符串/AC自动机</tag>
        <tag>思维题/构造</tag>
        <tag>贪心</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>【暂时不置顶】留言板</title>
    <url>/2019/08/09/%E7%95%99%E8%A8%80%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>学rvalue造了个留言板，也顺便整理一些有趣的事情。</p>
<p>看起来似乎是用来留言的？或许吧233</p>
<p>Σ( ° △ °|||)︴这东西是给大家留言的辣，挂友链/踩爆我/吐槽blog的设计都阔以的啊QAQ</p>
<p>Upd on 12.26: 泥萌来都来了不留个言嘛qwq</p>
<a id="more"></a>
<p>以下是被教育做人的经历：</p>
<blockquote>
<p>你眼前看到的景象，只不过是你自己的想象；你所认为你命中将拥有的，只不过是一种偶然。握得越紧越是徒然，看得越重越是无用。此之谓我执。</p>
<p>​                —— 编自梁文道的《我执》</p>
<p>人生有许多道：曾经踏足的是道，即将踏往的也是道，那什么才是道呢？唯有脚下走的才是道。一切精神或者物质都归于虚无，然后从混沌中衍生出三万道。在悲喜间涉足一条无数前人经历过，且将有无数后人奔赴的道，无论是否已经或者将要到达彼岸，然后便不再回头或是左顾右盼，即使有些道繁盛至极，夜灯如昼，无数人一浪又一浪的涌去，造就了世人皆知的辉煌；即使有些道草木凋敝，荒草丛生，只等勇敢的开拓者斩开荆棘，创造一片天地；这些都无所关，无所在意，彼岸何如、来日何方甚至过往旧事都化作一缕云烟，飘渺碧霄，我自撷高山之月色，独随足落处往行。</p>
<p>​                                                                        ——SD队长ckw</p>
<p>笔蘸波涛饰昆仑。</p>
<p>​                ——konoset学长</p>
</blockquote>
<p>居然有人想要我这种老年选手的企鹅号：<code>2836531293</code></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>笔尖生花</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式的快速插值和求值</title>
    <url>/2019/08/07/qzcz/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多项式的求值即给出一支多项式$\rm{F}$，同时给出多个$x$求出相应的${\rm{F}}_{[x]}$</p>
<p>多项式的插值即给出$n+1$个点对$(x,{\rm F}_{[x]}),$ 根据唯一分解定理求出对应的多项式$\rm{F}$</p>
<a id="more"></a>
<h1 id="1-多点求值"><a href="#1-多点求值" class="headerlink" title="$1$ 多点求值"></a>$1$ 多点求值</h1><p>还是分治+构造。</p>
<p>首先一种思维是：用多项式除法来<strong>降次</strong>。</p>
<p>具体来说就是</p>
<script type="math/tex; mode=display">
\rm{F=PQ+R}</script><p>这是带余除法的标准式，其中一定保证了$\deg(\rm{R})\leq \deg(\rm{P})$且$\deg(\rm{R})\leq \deg(\rm{Q})$.</p>
<p>所以假设我们令$\rm{P_{[x]}Q_{[x]}}=0$，那么对于同一个$x$就会有$\rm{F_{[x]}=R_{[x]}}$。</p>
<p>所以我们如果想要分治，那么就需要先构造出一个$\rm{Q}$且$\deg(\rm{Q})=\frac{1}{2}\deg(\rm F)$</p>
<p>那么我们直接让$\rm F$对$\rm Q$取模就可以得到$\rm R$，然后不断分治下去就可以$n \log^2 n$计算了。</p>
<p>设第$i$个需要求值的$x$是$A_i$，那么关于F的构造其实很简单，只需要让他满足$\rm Q_{[A_i]}=0$即可，所以完全可以想到构造一个$m$次的多项式$\rm Q$：</p>
<script type="math/tex; mode=display">
\rm Q=\prod(x-A_i)</script><p>显然这个东西，他还是可以分治来做，于是多点求值似乎就不能再优化了，因为他<strong>复杂度完全平衡了</strong>，即预处理复杂度和运算复杂度都是$\log^2$级别的。</p>
<p>哦，然后对于<a href="https://www.luogu.org/problemnew/solution/P5050" target="_blank" rel="noopener">LuoguP5050</a>这道题，卡常十分严重，所以一开始的版本是这个画风的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC target(<span class="meta-string">"avx"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fgcse"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fgcse-lm"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fipa-sra"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-pre"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-vrp"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fpeephole2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ffast-math"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fsched-spec"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"unroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-labels"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fdevirtualize"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcaller-saves"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcrossjumping"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fthread-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-funroll-loops"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fwhole-program"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-freorder-blocks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fschedule-insns"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-tail-merge"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fschedule-insns2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fstrict-aliasing"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fstrict-overflow"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-falign-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcse-skip-blocks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fcse-follow-jumps"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fsched-interblock"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fpartial-inlining"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"no-stack-protector"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-freorder-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-findirect-inlining"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fhoist-adjacent-loads"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-frerun-cse-after-loop"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-small-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-finline-small-functions"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-ftree-switch-conversion"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-foptimize-sibling-calls"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fexpensive-optimizations"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-funsafe-loop-optimizations"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"inline-functions-called-once"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"-fdelete-null-pointer-checks"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 270009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Gp = <span class="number">3</span> ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; P[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, base[MAXN], F[MAXN], gg[<span class="number">20</span>][MAXN], Ls[MAXN], R[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= Mod ;</span><br><span class="line">        a = a * a % Mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *J, <span class="keyword">const</span> <span class="keyword">int</span> &amp;L, <span class="keyword">const</span> <span class="keyword">int</span> &amp;flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> m = <span class="number">0</span>, i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>, ++ m)&#123;</span><br><span class="line">        rr <span class="keyword">int</span> *rua = gg[m] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k)&#123;</span><br><span class="line">                LL real = J[j + k],</span><br><span class="line">                         iroot = J[j + k + i] * (LL)rua[k] ;</span><br><span class="line">                J[j + k] = (real + iroot) % Mod,</span><br><span class="line">                J[j + k + i] = ((real - iroot) % Mod +Mod)%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    rr <span class="keyword">int</span> Inv = expow(L, Mod - <span class="number">2</span>) ;  reverse(J + <span class="number">1</span>, J + L) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> X[MAXN], Y[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        Ls[rt] = <span class="number">1</span> ;</span><br><span class="line">        P[rt].push_back((-base[l]%Mod+Mod)%Mod) ;</span><br><span class="line">        P[rt].push_back(<span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> lc = rt &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    segNTT(l, mid, rt &lt;&lt; <span class="number">1</span>) ;</span><br><span class="line">    segNTT(mid + <span class="number">1</span>, r, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) ;</span><br><span class="line">    Ls[rt] = Ls[rt &lt;&lt; <span class="number">1</span>] + Ls[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">int</span> Len = <span class="number">1</span>, l1 = <span class="number">0</span> ; <span class="keyword">while</span> (Len &lt; ((Ls[rt] + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l1 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l1 - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = Ls[lc] + <span class="number">1</span> ; i &lt; Len ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = Ls[rc] + <span class="number">1</span> ; i &lt; Len ; ++ i) Y[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Ls[lc] ; ++ i) X[i] = P[lc][i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Ls[rc] ; ++ i) Y[i] = P[rc][i] ;</span><br><span class="line">    NTT(X, Len, <span class="number">1</span>), NTT(Y, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) X[i] = (LL)X[i] * (LL)Y[i] % Mod ;</span><br><span class="line">    NTT(X, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Ls[rt] ; ++ i) P[rt].push_back(X[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t[MAXN], ig[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> gt[MAXN], ft[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">const</span> <span class="keyword">int</span> &amp;len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ;  NTT(g, Len, <span class="number">1</span>),  NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - (LL)t[i] * (LL)g[i] % Mod + Mod) % Mod * (LL)g[i] % Mod ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> G[MAXN] ;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Mod(<span class="keyword">int</span> *f,  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>* Rs)&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">0</span>, O = n - m + <span class="number">1</span>, L , i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= (n &lt;&lt; <span class="number">1</span>) ; ++ i) ig[i] = ft[i] = gt[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= n ; ++ i) ft[i] = f[n - i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) gt[i] = g[m - i] ; l = <span class="number">0</span>, L = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = O ; i &lt; (n &lt;&lt; <span class="number">1</span>); ++ i) ft[i] = gt[i] = <span class="number">0</span> ;</span><br><span class="line">    Inv(gt, ig, O) ; <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>,++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L ; ++ i) t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(ig, L, <span class="number">1</span>), NTT(ft, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) X[i] = <span class="number">1l</span>l * ft[i] * ig[i] % Mod ;</span><br><span class="line">    NTT(X, L, - <span class="number">1</span>) ; reverse(X, X + O) ; <span class="keyword">for</span> (i = O ; i &lt; L ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    O = n + <span class="number">1</span>, L = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) G[i] = Y[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) G[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>))  ;</span><br><span class="line">    NTT(X, L, <span class="number">1</span>) ; NTT (G, L, <span class="number">1</span>)  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) Y[i] = <span class="number">1l</span>l * G[i] * X[i] % Mod, X[i] = <span class="number">0</span> ;</span><br><span class="line">    NTT(Y, L, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m - <span class="number">1</span> ; ++ i) Rs[i] = ((<span class="number">1l</span>l * f[i] - Y[i]) + Mod) % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; <span class="built_in">printf</span>(<span class="string">"%d"</span>, *f), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> T[(Ls[rt] + <span class="number">2</span>) &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">    rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, i, lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    _Mod(f, P[lc], Ls[rt] - <span class="number">1</span>, Ls[lc], T) ; cdqNTT(l, mid, lc, T) ;</span><br><span class="line">    _Mod(f, P[rc], Ls[rt] - <span class="number">1</span>, Ls[rc], T) ; cdqNTT(mid + <span class="number">1</span>, r, rc, T) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">19</span>  ;++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> *rua = gg[i] ; rua[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> gi = rua[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span>/(<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) rua[j] = <span class="number">1l</span>l * rua[j - <span class="number">1</span>] * gi % Mod ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;F[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">    segNTT(<span class="number">1</span>, M, <span class="number">1</span>), <span class="built_in">memset</span>(X, <span class="number">0</span>, <span class="keyword">sizeof</span>(X)), <span class="built_in">memset</span>(Y, <span class="number">0</span>, <span class="keyword">sizeof</span>(Y)) ;</span><br><span class="line">    <span class="keyword">if</span> (N &gt;= M) _Mod(F, P[<span class="number">1</span>], N, M, F) ; cdqNTT(<span class="number">1</span>, M, <span class="number">1</span>, F) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>逼得我差点上指令集</del></p>
<p>然后发现是这个NTT常数太大了，所以考虑直接<strong>边角暴力</strong>，区间长度小到一定地步直接暴力秦九韶并且循环展开：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1024</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">            LL x = base[i], c1, c2, c3, c4, now = f[r - l] ; b[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">16</span> ; ++ j) b[j] = b[j - <span class="number">1</span>] * x % Mod ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=r-l<span class="number">-1</span>;j<span class="number">-15</span>&gt;=<span class="number">0</span>;j-=<span class="number">16</span>)&#123;</span><br><span class="line">                c1=(<span class="number">1l</span>l*now*b[<span class="number">16</span>]+<span class="number">1l</span>l*f[j]*b[<span class="number">15</span>]+<span class="number">1l</span>l*f[j<span class="number">-1</span>]*b[<span class="number">14</span>]+<span class="number">1l</span>l*f[j<span class="number">-2</span>]*b[<span class="number">13</span>])%Mod,</span><br><span class="line">                c2=(<span class="number">1l</span>l*f[j<span class="number">-3</span>]*b[<span class="number">12</span>]+<span class="number">1l</span>l*f[j<span class="number">-4</span>]*b[<span class="number">11</span>]+<span class="number">1l</span>l*f[j<span class="number">-5</span>]*b[<span class="number">10</span>]+<span class="number">1l</span>l*f[j<span class="number">-6</span>]*b[<span class="number">9</span>])%Mod,</span><br><span class="line">                c3=(<span class="number">1l</span>l*f[j<span class="number">-7</span>]*b[<span class="number">8</span>]+<span class="number">1l</span>l*f[j<span class="number">-8</span>]*b[<span class="number">7</span>]+<span class="number">1l</span>l*f[j<span class="number">-9</span>]*b[<span class="number">6</span>]+<span class="number">1l</span>l*f[j<span class="number">-10</span>]*b[<span class="number">5</span>])%Mod,</span><br><span class="line">                c4=(<span class="number">1l</span>l*f[j<span class="number">-11</span>]*b[<span class="number">4</span>]+<span class="number">1l</span>l*f[j<span class="number">-12</span>]*b[<span class="number">3</span>]+<span class="number">1l</span>l*f[j<span class="number">-13</span>]*b[<span class="number">2</span>]+<span class="number">1l</span>l*f[j<span class="number">-14</span>]*b[<span class="number">1</span>])%Mod,</span><br><span class="line">                now=(<span class="number">0l</span>l+c1+c2+c3+c4+f[j<span class="number">-15</span>])%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = (r-l)%<span class="number">16</span><span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; -- j)now=(<span class="number">1l</span>l*now*x+f[j])%Mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, now), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if (l == r) &#123; printf("%d", *f), putchar('\n') ; return ;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> T[(Ls[rt] + <span class="number">2</span>) &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">    rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, i, lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    _Mod(f, P[lc], Ls[rt] - <span class="number">1</span>, Ls[lc], T) ; cdqNTT(l, mid, lc, T) ;</span><br><span class="line">    _Mod(f, P[rc], Ls[rt] - <span class="number">1</span>, Ls[rc], T) ; cdqNTT(mid + <span class="number">1</span>, r, rc, T) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以随便过了。</p>
<h1 id="2-快速插值"><a href="#2-快速插值" class="headerlink" title="$2$ 快速插值"></a>$2$ 快速插值</h1><p>首先思考拉格朗日插值：</p>
<script type="math/tex; mode=display">
\rm{F}=\mathcal{\sum y_i\prod_{i\neq j}\frac{x-x_j}{x_i-x_j}}</script><p>我们发现$\prod (x-x_j)$就是个弟弟，于是考虑：</p>
<script type="math/tex; mode=display">
\rm{G}=\mathcal {\sum \frac{y_i}{\prod_{i\neq j}x_i-x_j}}</script><p>如果我们随便设一个多项式$ \phi(x)$</p>
<script type="math/tex; mode=display">
\phi=\prod(x-x_i)</script><p>那么原式就变成了：</p>
<script type="math/tex; mode=display">
\rm{G}=\mathcal {\sum \frac{y_i}{\frac{\phi(x_i)}{x-x_i}}}</script><p>这东西就可以：<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://s2.ax1x.com/2019/08/28/mH5tyj.jpg" alt=""></p>
<p>就可以<strong>洛</strong>！即</p>
<script type="math/tex; mode=display">
\lim _{x \rightarrow a} \frac{f(x)}{g(x)}=\lim _{x \rightarrow a} \frac{f^{\prime}(x)}{g^{\prime}(x)}</script><p>由于是形式幂级数之间的运算，于是就可以胡搞，也就是</p>
<script type="math/tex; mode=display">
\frac{\phi(x_i)}{x-x_i}=\phi'(x_i)</script><p>显然关于这个$\phi$是可以分治的，分治完求一个导然后再多点求值即可。</p>
<p>回代之后，求个逆就可以求出G，之后接着分治后面的$\prod(x-x_j)$就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300011</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> Len[MAXN], Q[MAXN], R[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, *P[MAXN], *K[MAXN], bx[MAXN], gg[<span class="number">25</span>][MAXN], by[MAXN], cy[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    *++now_w=<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    rr LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * <span class="number">1l</span>l * a % Mod ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % Mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">20</span> ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> *now = gg[i] ; now[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> p = now[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span> / (<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) now[j] = <span class="number">1l</span>l * now[j - <span class="number">1</span>] * p % Mod ; <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *J, <span class="keyword">int</span> L, <span class="keyword">int</span> o)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, m = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) <span class="keyword">if</span> (i &lt; R[i]) swap(J[R[i]], J[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>, ++ m)&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> *now = gg[m] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; L ; j += (i &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; i ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">const</span> LL x = J[j + k], y = <span class="number">1l</span>l * now[k] * J[i + j + k] ;</span><br><span class="line">                J[j + k] = (x + y) % Mod, J[i + j + k] = ((x - y) % Mod + Mod) % Mod ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (o &gt; <span class="number">0</span>) <span class="keyword">return</span> ; <span class="keyword">const</span> <span class="keyword">int</span> inv = expow(L, Mod - <span class="number">2</span>) ;</span><br><span class="line">    reverse(J + <span class="number">1</span>, J + L) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * inv * J[i] % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ft[MAXN], gt[MAXN], ig[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> t[MAXN], G[MAXN], X[MAXN], Y[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">const</span> <span class="keyword">int</span> &amp;len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ;  NTT(g, Len, <span class="number">1</span>),  NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - (LL)t[i] * (LL)g[i] % Mod + Mod) % Mod * (LL)g[i] % Mod ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        P[rt] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] ; Len[rt] = <span class="number">1</span> ;</span><br><span class="line">        P[rt][<span class="number">0</span>] = (-bx[l]+Mod)%Mod , P[rt][<span class="number">1</span>] = <span class="number">1</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> lc = rt &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    solve(l, mid, lc), solve(mid + <span class="number">1</span>, r, rc) ;</span><br><span class="line">    Len[rt] = Len[lc] + Len[rc], P[rt] = <span class="keyword">new</span> <span class="keyword">int</span>[Len[rt] + <span class="number">1</span>] ;</span><br><span class="line">    rr <span class="keyword">int</span> L = <span class="number">1</span>, l1 = <span class="number">0</span> ; <span class="keyword">while</span> (L &lt; ((Len[rt] + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l1 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l1 - <span class="number">1</span>))  ;</span><br><span class="line">    <span class="keyword">for</span> (i = Len[lc] + <span class="number">1</span> ; i &lt; L ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = Len[rc] + <span class="number">1</span> ; i &lt; L ; ++ i) Y[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[lc] ; ++ i) X[i] = P[lc][i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[rc] ; ++ i) Y[i] = P[rc][i] ;</span><br><span class="line">    NTT(X, L, <span class="number">1</span>), NTT(Y, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) X[i] = <span class="number">1l</span>l * X[i] * Y[i] % Mod ;</span><br><span class="line">    NTT(X, L, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[rt] ; ++ i) P[rt][i] = X[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Dev(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; g[len] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= len ; ++ i) g[i - <span class="number">1</span>] = <span class="number">1l</span>l * i * f[i] % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Mod(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> *res, <span class="keyword">int</span> n, <span class="keyword">int</span> m)&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, l = <span class="number">0</span>, i, o = n - m + <span class="number">1</span>, d = n &lt;&lt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; d ; ++ i) ft[i] = gt[i] = ig[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= n ; ++ i) ft[i] = f[n - i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) gt[i] = g[m - i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = o ; i &lt; (n &lt;&lt; <span class="number">1</span>) ; ++ i) ft[i] = gt[i] = <span class="number">0</span> ; Inv(gt, ig, o) ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; (o &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) t[i] = <span class="number">0</span>, R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;<span class="comment">//1</span></span><br><span class="line">    NTT(ig, L, <span class="number">1</span>) ; NTT(ft, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) X[i] = <span class="number">1l</span>l * ft[i] * ig[i] % Mod ;</span><br><span class="line">    NTT(X, L, <span class="number">-1</span>) ; reverse(X, X + o) ;</span><br><span class="line">    <span class="keyword">for</span> (i = o ; i &lt; L ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    o = n + <span class="number">1</span>, L = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; (o &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) G[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) G[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;<span class="comment">//2</span></span><br><span class="line">    NTT(X, L, <span class="number">1</span>) ; NTT(G, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) Y[i] = <span class="number">1l</span>l * X[i] * G[i] % Mod, X[i] = <span class="number">0</span> ;<span class="comment">//3</span></span><br><span class="line">    NTT(Y, L, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m - <span class="number">1</span> ; ++ i) res[i] = ((<span class="number">1l</span>l * f[i] - Y[i]) % Mod + Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line">LL b[<span class="number">100</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqNTT</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> *f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">512</span>) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">            LL x = bx[i], c1, c2, c3, c4, now = f[r - l] ; b[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">16</span> ; ++ j) b[j] = b[j - <span class="number">1</span>] * x % Mod ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=r-l<span class="number">-1</span>;j<span class="number">-15</span>&gt;=<span class="number">0</span>;j-=<span class="number">16</span>)&#123;</span><br><span class="line">                c1=(<span class="number">1l</span>l*now*b[<span class="number">16</span>]+<span class="number">1l</span>l*f[j]*b[<span class="number">15</span>]+<span class="number">1l</span>l*f[j<span class="number">-1</span>]*b[<span class="number">14</span>]+<span class="number">1l</span>l*f[j<span class="number">-2</span>]*b[<span class="number">13</span>])%Mod,</span><br><span class="line">                c2=(<span class="number">1l</span>l*f[j<span class="number">-3</span>]*b[<span class="number">12</span>]+<span class="number">1l</span>l*f[j<span class="number">-4</span>]*b[<span class="number">11</span>]+<span class="number">1l</span>l*f[j<span class="number">-5</span>]*b[<span class="number">10</span>]+<span class="number">1l</span>l*f[j<span class="number">-6</span>]*b[<span class="number">9</span>])%Mod,</span><br><span class="line">                c3=(<span class="number">1l</span>l*f[j<span class="number">-7</span>]*b[<span class="number">8</span>]+<span class="number">1l</span>l*f[j<span class="number">-8</span>]*b[<span class="number">7</span>]+<span class="number">1l</span>l*f[j<span class="number">-9</span>]*b[<span class="number">6</span>]+<span class="number">1l</span>l*f[j<span class="number">-10</span>]*b[<span class="number">5</span>])%Mod,</span><br><span class="line">                c4=(<span class="number">1l</span>l*f[j<span class="number">-11</span>]*b[<span class="number">4</span>]+<span class="number">1l</span>l*f[j<span class="number">-12</span>]*b[<span class="number">3</span>]+<span class="number">1l</span>l*f[j<span class="number">-13</span>]*b[<span class="number">2</span>]+<span class="number">1l</span>l*f[j<span class="number">-14</span>]*b[<span class="number">1</span>])%Mod,</span><br><span class="line">                now=(<span class="number">0l</span>l+c1+c2+c3+c4+f[j<span class="number">-15</span>])%Mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = (r-l)%<span class="number">16</span><span class="number">-1</span> ; j &gt;= <span class="number">0</span> ; -- j)now=(<span class="number">1l</span>l*now*x+f[j])%Mod;</span><br><span class="line">            cy[i] = now ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if (l == r) &#123; printf("%d", *f), putchar('\n') ; return ;&#125;</span></span><br><span class="line">    <span class="keyword">int</span> T[(Len[rt] + <span class="number">2</span>) &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line">    rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, i, lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">    _Mod(f, P[lc], T, Len[rt] - <span class="number">1</span>, Len[lc]) ; cdqNTT(l, mid, lc, T) ;</span><br><span class="line">    _Mod(f, P[rc], T, Len[rt] - <span class="number">1</span>, Len[rc]) ; cdqNTT(mid + <span class="number">1</span>, r, rc, T) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void cdqNTT(int l, int r, int rt, int *f)&#123;</span></span><br><span class="line"><span class="comment">    int T[(Len[rt] + 2) &lt;&lt; 1] ;</span></span><br><span class="line"><span class="comment">    if (l == r) &#123; cy[l] = f[0] ; return ; &#125;</span></span><br><span class="line"><span class="comment">    int mid = (l + r) &gt;&gt; 1, lc = rt &lt;&lt; 1, rc = lc | 1 ;</span></span><br><span class="line"><span class="comment">    _Mod(f, P[lc], T, Len[rt] - 1, Len[lc]), cdqNTT(l, mid, lc, T) ;</span></span><br><span class="line"><span class="comment">    _Mod(f, P[rc], T, Len[rt] - 1, Len[rc]), cdqNTT(mid + 1, r, rc, T) ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdqLg</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        K[rt] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] ;</span><br><span class="line">        K[rt][<span class="number">0</span>] = <span class="number">1l</span>l * by[l] * expow(cy[l], Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line">        K[rt][<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A[MAXN], B[MAXN], C[MAXN], D[MAXN] ;</span><br><span class="line">    rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, lc = rt &lt;&lt; <span class="number">1</span>, rc = lc | <span class="number">1</span>, i ;</span><br><span class="line">    cdqLg(l, mid, lc), cdqLg(mid + <span class="number">1</span>, r, rc) ; <span class="keyword">int</span> L = <span class="number">1</span>, l0 = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; ((Len[rt] + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l0 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l0 - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = Len[lc] + <span class="number">1</span> ; i &lt; L ; ++ i) A[i] = C[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = Len[rc] + <span class="number">1</span> ; i &lt; L ; ++ i) B[i] = D[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[lc] ; ++ i) A[i] = K[lc][i], C[i] = P[lc][i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Len[rc] ; ++ i) B[i] = K[rc][i], D[i] = P[rc][i] ;</span><br><span class="line">    NTT(A, L, <span class="number">1</span>), NTT(B, L, <span class="number">1</span>), NTT(C, L, <span class="number">1</span>), NTT(D, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) A[i] = (<span class="number">1l</span>l * A[i] * D[i] % Mod + <span class="number">1l</span>l * B[i] * C[i] % Mod) % Mod ;</span><br><span class="line">    NTT(A, L, <span class="number">-1</span>) ; K[rt] = <span class="keyword">new</span> <span class="keyword">int</span>[Len[rt] + <span class="number">1</span>] ; <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= Len[rt] ; ++ i ) K[rt][i] = A[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    rr int W ; freopen("2.in", "r", stdin) ;</span></span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>);</span><br><span class="line">    N = read() ; <span class="keyword">int</span> i ; pre() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) bx[i] = read(), by[i] = read() ;</span><br><span class="line">    solve(<span class="number">1</span>, N, <span class="number">1</span>) ; <span class="built_in">memset</span>(X, <span class="number">0</span>, <span class="keyword">sizeof</span>(X)) ; <span class="built_in">memset</span>(Y, <span class="number">0</span>, <span class="keyword">sizeof</span>(Y));</span><br><span class="line">    _Dev(P[<span class="number">1</span>], Q, Len[<span class="number">1</span>]) ; cdqNTT(<span class="number">1</span>, N, <span class="number">1</span>, Q) ; cdqLg(<span class="number">1</span>, N, <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt; N ; ++ i) cout &lt;&lt; K[1][i] &lt;&lt; " " ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) write(K[<span class="number">1</span>][i]) ; fwrite(ch,<span class="number">1</span>,now_w-ch,<span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：すべて分割べることのできる多項式生活最高だ！（一切皆可分治的多项式生活赛高！）</p>
]]></content>
      <tags>
        <tag>技巧/分治</tag>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】常系数齐次线性递推</title>
    <url>/2019/08/07/xxdt/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>$\boldsymbol{k}$阶常系数齐次线性递推</strong>指的是以下问题：</p>
<blockquote>
<p>给出$k$阶线性递推式$\boldsymbol{f}$以及初始项$\boldsymbol{a_0,a_1…a_{k-1}}$，并满足：</p>
<script type="math/tex; mode=display">
a_{n}=\sum_{i=1}^{k} f_{i} \times a_{n-i}</script><p>对于某个$o$，求解$f_o$在某个固定模数下的值。</p>
</blockquote>
<p>然后以下是<code>shadowice1984</code>的人话版本：</p>
<blockquote>
<p>1.它是常系数的，换句话说递推系数和下标n无关</p>
<p>2.它是线性的，换句话说递推式中每一项的次数都是1，没有乱七八糟的2次3次项</p>
<p>3.它是齐次的，换句话说递推式的常数项等于0</p>
</blockquote>
<p>这个问题的弱智解法是$O(k^3\log n)$的矩阵快速幂。但是通过多项式加速可以将复杂度优化至$O(k^2\log n)$甚至$O(k\log k \log n)$.</p>
<p><del>于是这个世界上就再也没有矩阵快速幂了</del></p>
<a id="more"></a>
<h1 id="1-特征向量与特征多项式"><a href="#1-特征向量与特征多项式" class="headerlink" title="$1$  特征向量与特征多项式"></a>$1$  特征向量与特征多项式</h1><p>首先，给定$n$阶矩阵$\boldsymbol{A}$，若存在向量$\boldsymbol{x}$使得$\exists \lambda \in \mathbb {R}$ ，满足：</p>
<script type="math/tex; mode=display">
\tag{1} \boldsymbol{A}\cdot \boldsymbol{x} = \lambda\boldsymbol{x}</script><p>则称$\boldsymbol{x}$是$\boldsymbol{A}$的<strong>特征向量</strong>，$\lambda$称为$\boldsymbol{A}$的特征值，$(1)$式称之为<strong>特征方程</strong>。</p>
<p>同时也可以写作</p>
<script type="math/tex; mode=display">
(\boldsymbol{A}-\lambda\boldsymbol{I})\cdot \boldsymbol{x}= \boldsymbol{0}</script><p>有解的条件是</p>
<script type="math/tex; mode=display">
\tag{2} \det(\boldsymbol{A}-\lambda\boldsymbol{I})=0</script><p>同时定义<strong>特征多项式</strong>为<strong>类形式幂级数</strong>，即不考虑未知数$x$的数学形态，$x$可以为矩阵、向量$  etc.$</p>
<p>我们观察，$(2)$中右边的行列式计算的性质保证了行列式展开后每一项一定至多是$\lambda$的$n$次（主对角线相乘）、$n-1$次$\cdots$ $0$次，那么<strong>特征多项式即为关于$\lambda$的$\det(\boldsymbol{A}-\lambda\boldsymbol{I})$展开</strong>，记为$\boldsymbol{\phi(\lambda)}$.</p>
<p>接着观察$\phi(\lambda)$:</p>
<script type="math/tex; mode=display">
\begin{aligned}
\phi(\lambda)= |\boldsymbol{A}-\lambda \boldsymbol{I}| & = \left[\begin{array}{ccccc}{\ \lambda} & {0} & {\cdots} & {0} & {0} \\\ {0} & {\lambda} & {\cdots} & {0} & {0} \\\ {\cdots} & {\cdots} & {\cdots} & {\cdots} & {\cdots} \\\ {0} & {0} & {\cdots} & {\lambda} & {0} \\\ {0} & {0} & {\cdots} & {0} & {\lambda}\end{array}\right]-\left[\begin{array}{ccccc}{\ 0} & {0} & {\cdots} & {0} & {a_{k}} \\\ {1} & {0} & {\cdots} & {0} & {a_{k-1}} \\\ {0} & {1} & {\cdots} & {0} & {a_{k-2}} \\\ {\cdots} & {\cdots} & {\cdots} & {\cdots} & {\cdots} \\\ {0} & {0} & {\cdots} & {0} & {\lambda}\end{array}\right]\\\ & =\left[\begin{array}{ccccc}{\lambda} & {0} & {\cdots} & {0} & {-a_{k}} \\\ {-1} & {\lambda} & {\cdots} & {0} & {-a_{k-1}} \\\ {0} & {-1} & {\cdots} & {0} & {-a_{k-2}} \\\ {\cdots} & {\cdots} & {\cdots} & {\cdots} & {\cdots} \\\ {0} & {0} & {\cdots} & {-1} & {\lambda-a_{1}}\end{array}\right]
\end{aligned}</script><p>然后对于这个我们可以进行<strong>拉普拉斯展开</strong>（就是用代数余子式展开一个行列式），我们选择最后一列：</p>
<script type="math/tex; mode=display">
\phi(\lambda)=\sum\limits_{i=1}^{k} a_{k-i+1}(-1)^{i+k}\phi(\lambda)_{i, k}</script><p>其中$\phi(\lambda)_{i,k}$表示丢掉$(i,k)$同行同列之后的代数余子式。</p>
<p>这东西可以暴力迭代式化简/直接良序归纳得出他的<del>背诵</del>化简形式：</p>
<script type="math/tex; mode=display">
\phi(\lambda)=(-1)^{n}\left(\lambda^{n}-\sum_{i=1}^{n} a_{i} \lambda^{n-i}\right)</script><p><del>好像胡扯了半天也没扯到点子上，递推在哪？？</del></p>
<h1 id="2-一步转化-构造"><a href="#2-一步转化-构造" class="headerlink" title="$2$  一步转化/构造"></a>$2$  一步转化/构造</h1><p><strong>現在は大力构造時間です！！</strong></p>
<p>我们考虑构造一个这样的数列$\boldsymbol{g}$，满足：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}^n=\sum_{i=0}^{k-1}g_i\boldsymbol{A}^i</script><p>然后我们两边同时左乘一个初始状态$\boldsymbol{F_0}$:</p>
<script type="math/tex; mode=display">
\boldsymbol{F_0\cdot A}^n=\sum_{i=0}^{k-1}g_i\boldsymbol{F_0\cdot A}^i</script><p>我们考虑对于矩阵乘法的$\boldsymbol{res}$矩阵，我们关心的是它的$(0,0)$处的值，不妨记为$\boldsymbol{res_0}$，那么就有：</p>
<script type="math/tex; mode=display">
\boldsymbol{res}_0=(\boldsymbol{F_0\cdot A} ^ n)_0 =\sum_{i=0}^{k-1}g_i(\boldsymbol{F_0\cdot A}^i)_0</script><p>其中$\boldsymbol{X}_p$表示一维向量$\boldsymbol{X}$的第$p$项。</p>
<p>然后使用观察法，我们发现$\boldsymbol{F_0\cdot A}^i$这东西就是转移了$i$次之后的第$0$项，换言之也就是$\boldsymbol{F_0}$的第$i$项，那么就会有：</p>
<script type="math/tex; mode=display">
\boldsymbol{res_0}=\sum_{i=0}^{k-1}g_i\boldsymbol{(F_0)}_i</script><p>所以只要我们可以构造出一组$g$，我们就可以在$O(k)$的时间内求出答案。</p>
<h1 id="3-快速线性递推"><a href="#3-快速线性递推" class="headerlink" title="$3~$ 快速线性递推"></a>$3~$ 快速线性递推</h1><p>现在我们的任务就是构造$\boldsymbol{g}$序列了。</p>
<p>首先我们随便设一个关于$\boldsymbol{A}$的多项式：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}^n=P(\boldsymbol{A})Q(\boldsymbol{A})+R(\boldsymbol{A})</script><p>于是我们发现，似乎根据带余除法的性质$\deg (R(\boldsymbol{A}))\leq \deg(\boldsymbol{A}^n)=n$，正好满足$\deg(\sum_{i=0}^{k-1}g_i\boldsymbol{(F_0)}_i)\leq n$的性质，所以我们考虑当$P(\boldsymbol{A})Q(\boldsymbol{A})$这一项为$\boldsymbol{0}$时，恰好构造出一组可行的答案。</p>
<p>我们结合特征多项式考虑，$\phi(\lambda)=0$，恰好满足我们的需求。于是我们直接令$\boldsymbol{A}^n \bmod \phi(\lambda)$即可求出$R(\boldsymbol{A})=g$。</p>
<p>然后普通的就可以直接$k^2$暴力NTT，如果很闲并且模数是NTT模数的话还可以用$\log^2$的复杂度搞出来。</p>
<p>以下是<a href="https://www.luogu.org/problem/P4723" target="_blank" rel="noopener">LuoguP4723</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Gp 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 251003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line">LL base[MAXN], p[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, L, K, R[MAXN] ;</span><br><span class="line">LL F[MAXN], G[MAXN], P[MAXN], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    rr LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= Mod ;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % Mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;flag)</span></span>&#123;</span><br><span class="line">    rr LL Gn, Gi = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; R[i]) J[i] ^= J[R[i]] ^= J[i] ^= J[R[i]] ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; l ; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        Gn = expow(Gp, (Mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; l ; Gi = <span class="number">1</span>, j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k, Gi = <span class="number">1l</span>l * Gi * Gn % Mod)&#123;</span><br><span class="line">                <span class="keyword">int</span> real = J[j + k], iroot = <span class="number">1l</span>l * J[j + k + i] * Gi % Mod ;</span><br><span class="line">                J[j + k] = (real + iroot) % Mod, J[j + k + i] = (real - iroot + Mod) % Mod ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    rr <span class="keyword">int</span> Inv = expow(<span class="number">1l</span>l * l, Mod - <span class="number">2</span>) ; reverse(J + <span class="number">1</span>, J + l) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; l ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % Mod ;</span><br><span class="line">&#125;</span><br><span class="line">LL t[MAXN], T[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Inv(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        g[<span class="number">0</span>] = expow(f[<span class="number">0</span>], Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _Inv(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) t[i] = f[i] ;  NTT(g, Len, <span class="number">1</span>),  NTT(t, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">2l</span>l - t[i] * g[i] % Mod + Mod) % Mod * g[i] % Mod ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">LL IG[MAXN], Ft[MAXN], Gt[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Div(LL *f, <span class="keyword">const</span> <span class="keyword">int</span> &amp;Len)&#123;</span><br><span class="line">    rr <span class="keyword">int</span> L1 = (K &lt;&lt; <span class="number">1</span>), D, i ;</span><br><span class="line">    <span class="keyword">while</span> (!f[-- L1]) ; <span class="keyword">if</span> (L1 &lt; K) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) Ft[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) Ft[i] = f[i] ; D = L1 - K + <span class="number">1</span> ;</span><br><span class="line">    reverse(Ft, Ft + L1 + <span class="number">1</span>) ; <span class="keyword">for</span> (i = D ; i &lt;= L1 ; ++ i) Ft[i] = <span class="number">0</span> ;</span><br><span class="line">    NTT(Ft, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) P[i] = Ft[i] * IG[i] % Mod ;</span><br><span class="line">    NTT(P, Len, - <span class="number">1</span>) ; <span class="keyword">for</span> (i = D ; i &lt;= L1 ; ++ i) P[i] = <span class="number">0</span> ; reverse(P, P + D) ;</span><br><span class="line">    NTT(P, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) (P[i] *= G[i]) %= Mod ; NTT(P, Len, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; K ; ++ i) f[i] = (f[i] - P[i] + Mod) % Mod ; <span class="keyword">for</span> (i = K ; i &lt;= L1 ; ++ i) f[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    freopen("2.in", "r", stdin) ;</span></span><br><span class="line">    rr <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span>, i ; <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (K &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ; F[<span class="number">0</span>] = <span class="number">1</span> ; Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;p[i]), p[i] = p[i] &lt; <span class="number">0</span> ? p[i] + Mod : p[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; K ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]), base[i] = base[i] &lt; <span class="number">0</span> ? base[i] + Mod : base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) Gt[K - i] = G[K - i] = Mod - p[i] ; T[<span class="number">1</span>] = G[K] = Gt[K] = <span class="number">1</span> ;reverse(Gt, Gt + K + <span class="number">1</span>) ;</span><br><span class="line">    NTT(G, Len, <span class="number">1</span>) ; _Inv(Gt, IG, Len &gt;&gt; <span class="number">1</span>), NTT(IG, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        NTT(T, Len, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (N &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            NTT(F, Len, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) F[i] = F[i] * T[i] % Mod ;</span><br><span class="line">            NTT(F, Len, <span class="number">-1</span>) ; _Div(F, Len) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) (T[i] *= T[i]) %= Mod ; NTT(T, Len, <span class="number">-1</span>) ; _Div(T, Len), N &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; K ; ++ i) (Ans += (F[i] * base[i]) % Mod) %= Mod ; <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>常系数齐次线性递推</category>
      </categories>
      <tags>
        <tag>数学/常系数齐次线性递推</tag>
        <tag>多项式的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式求幂/开根</title>
    <url>/2019/08/07/rooti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>形式化来讲，我们要解决这两个问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
G &= F^k \ (\bmod \ x^n)\\\
G^k &= F \ (\bmod \ x^n)
\end{aligned}</script><p>然而实际上后一个咕了，我曾把这玩意儿当作<code>多项式牛顿迭代</code>的课后题来着……并且更重要的原因没人出这玩意儿的题，所以直接简化成$G^2\equiv F$好了。。。</p>
<a id="more"></a>
<h1 id="1-求幂"><a href="#1-求幂" class="headerlink" title="$1$ 求幂"></a>$1$ 求幂</h1><p>首先思考式子</p>
<script type="math/tex; mode=display">
G=F^k(~\bmod~x^n)</script><p>怎么化开。那么喜闻乐见的就是一步求对数然后exp回去：</p>
<script type="math/tex; mode=display">
\ln G = k \ln F~(\bmod~x^n)\\\
\exp(k\ln F)=G~(\bmod ~x^n)</script><p>对应的是<code>Luogu</code>的<a href="https://www.luogu.org/problem/P5245" target="_blank" rel="noopener"><code>P5245</code></a>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, y ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N, M = <span class="number">1</span> ;</span><br><span class="line">    Gi = expow(Gp, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (M &lt;= N) M &lt;&lt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; In ; y = <span class="built_in">strlen</span>(In) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;F[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; y ; ++ i) K = (K * <span class="number">10</span> + In[i] - <span class="string">'0'</span>) % P ;</span><br><span class="line">    _Ln(F, L, M) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) L[i] = <span class="number">1l</span>l * L[i] * K % P ;</span><br><span class="line">    _Exp(L, G, M) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, G[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法只能应用于$a_0=1$的情况下，原因在写<code>exp</code>的时候整理过。</p>
<p>但这东西显然是可以$\Theta(n\log^2n)$暴力ntt做的，我很快乐地水过了这道题的加强版<a href="https://www.luogu.org/problem/P5273" target="_blank" rel="noopener"><code>P5273</code></a>，即不保证$a_0=1$的版本：</p>
<blockquote>
<p>似乎大家都是诡异的写法，没有人用$O(n\log^2 n)$去暴力艹这道题。</p>
<p>然而事实上是完全可以卡过去的。我的提交虽然加了<code>-O2</code>和<code>#pragma</code><del>显得十分弟弟</del>，但是其实去掉之后也是很快的。不吹，绝对比大部分的普通$O(n\log^2n)$的NTT跑得快。</p>
<p>那么以下是几个优化的措施：<br>$\#1$</p>
<p>预处理原根的次幂——卡常利器。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">19</span>  ;++ i)&#123;</span><br><span class="line">        rr <span class="keyword">int</span> *rua = gg[i] ; rua[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        rr <span class="keyword">int</span> gi = rua[<span class="number">1</span>] = expow(<span class="number">3</span>, <span class="number">998244352</span>/(<span class="number">1</span> &lt;&lt; (i + <span class="number">1</span>))) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span> ; j &lt; (<span class="number">1</span> &lt;&lt; i) ; ++ j) rua[j] = <span class="number">1l</span>l * rua[j - <span class="number">1</span>] * gi % P ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后每次NTT就不需要重新再计算了。</p>
<p>$\#2$</p>
<p>做快速幂的时候注意可以少几次<code>NTT</code>。这点常数优化也是需要的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (K)&#123;</span><br><span class="line">        NTT(F, M, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (K &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            NTT(A, M, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; M ; ++ i) A[i] = <span class="number">1l</span>l * A[i] * F[i] % P ;</span><br><span class="line">            NTT(A, M, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = N ; i &lt; M ; ++ i) A[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; M ; ++ i)</span><br><span class="line">            F[i] = <span class="number">1l</span>l * F[i] * F[i] % P ; NTT(F, M, <span class="number">-1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = N ; i &lt; M ; ++ i) F[i] = <span class="number">0</span> ; K &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$\#3$</p>
<p>不用<code>long long</code>.</p>
<p>这其实一个通用的技巧，因为long long一般都比int多好多常数。同时不要强制类型转换而选择<code>1ll*</code>这种形式。实测可以快许多。</p>
</blockquote>
<p>不得不说，这个预处理原根确实是一个卡常黑科技qwq</p>
<h1 id="2-开根"><a href="#2-开根" class="headerlink" title="$2$ 开根"></a>$2$ 开根</h1><p>普通的开根还是<code>exp</code>和<code>ln</code>：</p>
<script type="math/tex; mode=display">
G^2=F\\\
2 \ln G = \ln F\\\
G = \exp(\frac{\ln F}{2})</script><p>然后就可以胡搞<a href="https://www.luogu.org/problem/P5205" target="_blank" rel="noopener">LuoguP5205</a>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _Invsqr(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span>, i, o ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ; o = expow(<span class="number">2l</span>l, P - <span class="number">2</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>) ;</span><br><span class="line">    _Ln(f, E, M) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) E[i] = E[i] * o % P ; _Exp(E, g, M) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是还是有问题，就是因为需要$\exp$，上述也必须要$F_0=1$。于是当$F_0\neq 1$时，我们可以直接暴力求<strong>二次剩余</strong>，注意这种方法就需要用牛迭来实现开根</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> solveroot&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pint pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span> <span class="keyword">int</span> x, y ; &#125; ;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">mul</span><span class="params">(<span class="keyword">complex</span> a, <span class="keyword">complex</span> b, <span class="keyword">int</span> p, <span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nx = (<span class="number">1l</span>l * a.x * b.x % p + <span class="number">1l</span>l * a.y * b.y % p * rt % p) ;</span><br><span class="line">        <span class="keyword">int</span> ny = (<span class="number">1l</span>l * a.x * b.y % p + <span class="number">1l</span>l * a.y * b.x % p) ;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">complex</span>)&#123;nx % p, ny % p&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">complex</span> <span class="title">expow</span><span class="params">(<span class="keyword">complex</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p, <span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="keyword">complex</span> res = (<span class="keyword">complex</span>)&#123;<span class="number">1</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                res = mul(res, a, p, z), b -- ;</span><br><span class="line">            a = mul(a, a, p, z), b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                res = <span class="number">1l</span>l * a * res % p ;</span><br><span class="line">            a = <span class="number">1l</span>l * a * a % p ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        srand((<span class="keyword">int</span>)<span class="string">'x'</span>+<span class="string">'q'</span>+<span class="string">'I'</span>+<span class="string">'L'</span>+<span class="string">'o'</span>+<span class="string">'v'</span>+<span class="string">'e'</span>+<span class="string">'u'</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">pint <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        seed() ;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> mp(<span class="number">0</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">int</span> x, y ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            x = rand() % p ;</span><br><span class="line">            y = (<span class="number">1l</span>l * x * x + (p - n)) % p ;</span><br><span class="line">            <span class="keyword">if</span> (expow(y, (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p) == p - <span class="number">1</span>) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">complex</span> now = (<span class="keyword">complex</span>)&#123;x, <span class="number">1</span>&#125;, ansp, ansn ;</span><br><span class="line">        ansp = expow(now, (p + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p, y),</span><br><span class="line">        ansn = (<span class="keyword">complex</span>)&#123;p - ansp.x, ansp.y&#125; ;</span><br><span class="line">        <span class="keyword">if</span> (ansp.x &gt; ansn.x) swap(ansp, ansn) ;</span><br><span class="line">        <span class="keyword">return</span> mp(ansp.x, ansn.x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">。。。。。</span><br><span class="line">LL Ig[MAXN], pf[MAXN] ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> solveroot ;</span><br><span class="line"><span class="keyword">void</span> _sqr(LL *f, LL *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        g[<span class="number">0</span>] = solve(f[<span class="number">0</span>], P).fr ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    rr <span class="keyword">int</span> i, l = <span class="number">0</span>, Len = <span class="number">1</span> ;</span><br><span class="line">    _sqr(f, g, (len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) pf[i] = Ig[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) Ig[i] = <span class="number">0</span>, pf[i] = <span class="number">2</span> * g[i] % P ;</span><br><span class="line">    _Inv(pf, Ig, len) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) <span class="comment">/* */</span> t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; ( l - <span class="number">1</span> )) ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len ; ++ i) g[i] = (g[i] + f[i]) % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>) ; NTT(Ig, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = g[i] * Ig[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt; Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后为了做这道题还去学了<code>Cipolla</code>，然后还顺便发现luogu上少一道二次剩余的板子就顺手出了道题2333</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式ln/exp</title>
    <url>/2019/08/07/lnexp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>其实这两个东西只是一个拓展，思想也是简单的思想，只不过由于$\ln$运算的乘方转乘法很好用，所以大部分套路都是<strong>先多项式$\ln$乱搞一通再多项式$\exp$回去</strong>。</p>
<p>形式化地讲，我们就是要解决以下两个问题：</p>
<script type="math/tex; mode=display">
\begin{aligned}
1)\quad G&= \ln F \ (\bmod \ p)\\\
2)\quad G&= e^{F} \ (\bmod \ p)
\end{aligned}</script><a id="more"></a>
<h1 id="1-ln"><a href="#1-ln" class="headerlink" title="$1~\ln$"></a>$1~\ln$</h1><p>其实就是瞎jb记一下式子啦</p>
<script type="math/tex; mode=display">
G'= F'\cdot \frac{1}{F}=\frac{F'}{F}</script><p>……然后就先对F求个导+求个逆然后再不定积分回去就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[MAXN], B[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Dev(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> i ; g[len - <span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; len ; ++ i) g[i - <span class="number">1</span>] = i * f[i] % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Invdev(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">0</span> ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; len ; ++ i) g[i] = f[i - <span class="number">1</span>] * expow(i, P - <span class="number">2</span>) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Ln(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    _Dev(f, A, len), _Inv(f, B, len) ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span> ; <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(A, Len, <span class="number">1</span>), NTT(B, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) A[i] = <span class="number">1l</span>l * A[i] * B[i] % P ;</span><br><span class="line">    NTT(A, Len, <span class="number">-1</span>), _Invdev(A, g, len) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也算是小清新的多项式板子了，毕竟没有诡异的清空和鬼畜的码长。</p>
<h1 id="2-exp"><a href="#2-exp" class="headerlink" title="$2~\exp$"></a>$2~\exp$</h1><script type="math/tex; mode=display">
\begin{aligned}
G &= G_h - \frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G &= G_h-\frac{\ln G_h -F}{\frac{1}{G_h}}\\\
\Longrightarrow G &=G_h-G_h\ln G_h+G_hF\\\
\Longrightarrow G &=G_h(1-\ln G_h+F)\\\
\end{aligned}</script><p>然后需要的知识点就是<strong>牛顿迭代</strong>了，这玩意儿之前写过，懒得再叙述一遍了……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _Ln(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> i, Len = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">    _Dev(f, A, len) ; _Inv(f, B, len) ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt;= Len ; ++ i) cout &lt;&lt; A[i] &lt;&lt; " " &lt;&lt; B[i] &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>) ;</span><br><span class="line">    NTT(A, Len, <span class="number">1</span>), NTT(B, Len, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) A[i] = A[i] * B[i] % P ;</span><br><span class="line">    NTT(A, Len, <span class="number">-1</span>), _Invdev(A, g, len) ; <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t)), <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B)),  <span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> C[MAXN], D[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Exp(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123; g[<span class="number">0</span>] = <span class="number">1</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    _Exp(f, g, len + <span class="number">1</span> &gt;&gt; <span class="number">1</span>) ; <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span>, i ;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt; (len &lt;&lt; <span class="number">1</span>)) Len &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; (len &lt;&lt; <span class="number">1</span>) ; ++ i) C[i] = D[i] = <span class="number">0</span> ; _Ln(g, C, len) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; ++ i) D[i] = f[i] ;</span><br><span class="line">    NTT(g, Len, <span class="number">1</span>), NTT(C, Len, <span class="number">1</span>), NTT(D, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) g[i] = (<span class="number">1l</span>l + D[i] - C[i] + P) * g[i] % P ;</span><br><span class="line">    NTT(g, Len, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = len ; i &lt;= Len ; ++ i) g[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较重要的就是<strong>清空</strong>，由于$\exp$是迭代实现的，所以要进行多次$\ln$。。。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式带余除法</title>
    <url>/2019/08/07/chumod/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>解决一类</p>
<script type="math/tex; mode=display">
G=F\cdot P+R ~(\bmod~x^n)</script><p>其中$F, G$给定，求解$P$和$R$</p>
<p><del>然而最后变成了老年选手的多项式瞎吹？</del></p>
<a id="more"></a>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>这就很苟，最近要被多项式除法给整疯了，原因大概是我换一道模板就需要换一种写法……原来那种怎么改都不对就很智障……</p>
<p>然后划式子过程就很苟，是一种诡异的构造方式，前置芝士大概是$F(\frac{1}{x})=F^T(x)$，其中$T$表示转置——当然是一个不严谨的记号，意思就是把这个形式幂级数的系数<code>reverse</code>掉。</p>
<p>以下是过程：</p>
<script type="math/tex; mode=display">
\begin{aligned}
G(x)&=F(x)P(x)+R(x)\\\
G(\frac{1}{x})&=F(\frac{1}{x})P(\frac{1}{x})+R(\frac{1}{x})\\\
\because A_r&= x^nA(\frac{1}{x})\\\
\therefore x^nG(\frac{1}{x})&=x^nF(\frac{1}{x})P(\frac{1}{x})+x^nR(\frac{1}{x})\\\
\Longrightarrow x^nG(\frac{1}{x})&=x^mF(\frac{1}{x})\cdot x^{n-m}P(\frac{1}{x})+x^{m-1}\cdot x^{n-m+1}R(x)\\\
\Longrightarrow G_r(x)&=F_r(x)\cdot P_r(x)+x^{n-m+1}R_r(x)\\\
\Longrightarrow G_r(x)&=F_r(x)\cdot P_r(x)+x^{n-m+1}R_r(x) ~(\bmod x^{n-m+1})\\\
\Longrightarrow P_r(x)&=F_r(x)\cdot G_r^{-1}(x)~(\bmod x^{n-m+1})\\\
\end{aligned}</script><p>之后求出$P_r$之后就可以回代原式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
G=F\cdot P+R\\\
R = G - F\cdot P
\end{aligned}</script><p>于是就完了</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>但是实际写法有些问题，比如板子<a href="https://www.luogu.org/problem/P4512" target="_blank" rel="noopener">P4512 【模板】多项式除法</a></p>
<p>这其实就直接做就好，不是很需要考虑清零什么的。但是我总觉得在<code>Inv</code>之后是不是需要重新算一下<code>R</code>……不清楚诶。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LL Ft[MAXN], Gt[MAXN], IG[MAXN] ;</span><br><span class="line"><span class="keyword">void</span> _Div()&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, O = N - M + <span class="number">1</span> ;</span><br><span class="line">    reverse(Ft, Ft + N), reverse(Gt, Gt + M) ;</span><br><span class="line">    l = <span class="number">0</span>, L = <span class="number">1</span> ; <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = O ; i &lt; N ; ++ i) Ft[i] = Gt[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    _Inv(Gt, IG, O), NTT(IG, L, <span class="number">1</span>), NTT(Ft, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) P[i] = Ft[i] * IG[i] % Mod ; NTT(P, L, - <span class="number">1</span>) ; reverse(P, P + O) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; O ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, P[i]) ; <span class="keyword">for</span> (<span class="keyword">int</span> i = O ; i &lt; N ; ++ i) P[i] = <span class="number">0</span> ;</span><br><span class="line">    O = N, L = <span class="number">1</span>, l = <span class="number">0</span> ; <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(P, L, <span class="number">1</span>), NTT(G, L, <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) Q[i] = (P[i] * G[i]) % Mod ; NTT(Q, L, <span class="number">-1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, ++ N, ++ M ; <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;F[i]), Ft[i] = F[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;G[i]), Gt[i] = G[i] ; _Div() ;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; M - <span class="number">1</span> ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, (F[i] - Q[i] + Mod) % Mod) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是之后线性递推时需要进行的取模操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _Div(LL *f, <span class="keyword">int</span> Len)&#123;</span><br><span class="line">    <span class="keyword">int</span> L1 = (K &lt;&lt; <span class="number">1</span>), D, i ;</span><br><span class="line">    <span class="keyword">while</span> (!f[-- L1]) ; <span class="keyword">if</span> (L1 &lt; K) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) Ft[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) Ft[i] = f[i] ; reverse(Ft, Ft + L1 + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (D = L1 - K + <span class="number">1</span>, i = D ; i &lt;= L1 ; ++ i) Ft[i] = <span class="number">0</span> ; NTT(Ft, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) P[i] = Ft[i] * IG[i] % Mod ; NTT(P, Len, - <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = D ; i &lt;= L1 ; ++ i) P[i] = <span class="number">0</span> ; reverse(P, P + D) ; NTT(P, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) Q[i] = (P[i] * G[i]) % Mod ; NTT(Q, Len, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; K ; ++ i) f[i] = (f[i] - Q[i] + Mod) % Mod ; <span class="keyword">for</span> (i = K ; i &lt;= L1 ; ++ i) f[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main_function</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) G[K - i] = Mod - p[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) Gt[i] = G[i] ; reverse(Gt, Gt + K + <span class="number">1</span>) ;</span><br><span class="line">    NTT(G, Len, <span class="number">1</span>) ; _Inv(Gt, IG, Len &gt;&gt; <span class="number">1</span>), NTT(IG, Len, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br></pre></td></tr></table></figure>
<p>看上去很正常，只是多了几个预处理而已。但是不知为何当时写的就很迷。。。并且从这个板子开始我明白了，<strong>多项式长度+是否清空</strong>这个组合绝对是多项式入门里面最难受的细节。</p>
<p>之后就更迷了，多点求值这玩意儿实在毒瘤：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Mod(<span class="keyword">int</span> *f,  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>* Rs)&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">0</span>, O = n - m + <span class="number">1</span>, L , i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= (n &lt;&lt; <span class="number">1</span>) ; ++ i) ig[i] = ft[i] = gt[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= n ; ++ i) ft[i] = f[n - i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) gt[i] = g[m - i] ; l = <span class="number">0</span>, L = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = O ; i &lt; (n &lt;&lt; <span class="number">1</span>); ++ i) ft[i] = gt[i] = <span class="number">0</span> ;</span><br><span class="line">    Inv(gt, ig, O) ; <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>,++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L ; ++ i) t[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(ig, L, <span class="number">1</span>), NTT(ft, L, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) X[i] = <span class="number">1l</span>l * ft[i] * ig[i] % Mod ;</span><br><span class="line">    NTT(X, L, - <span class="number">1</span>) ; reverse(X, X + O) ; <span class="keyword">for</span> (i = O ; i &lt; L ; ++ i) X[i] = <span class="number">0</span> ;</span><br><span class="line">    O = n + <span class="number">1</span>, L = <span class="number">1</span>, l = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; (O &lt;&lt; <span class="number">1</span>)) L &lt;&lt;= <span class="number">1</span>, ++ l ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) G[i] = Y[i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m ; ++ i) G[i] = g[i] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>))  ;</span><br><span class="line">    NTT(X, L, <span class="number">1</span>) ; NTT (G, L, <span class="number">1</span>)  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; L ; ++ i) Y[i] = <span class="number">1l</span>l * G[i] * X[i] % Mod, X[i] = <span class="number">0</span> ;</span><br><span class="line">    NTT(Y, L, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= m - <span class="number">1</span> ; ++ i) Rs[i] = ((<span class="number">1l</span>l * f[i] - Y[i]) + Mod) % Mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就很烦……鬼知道你tm什么时候忘清空或者忘开<code>long long</code>了就要调一年……艹</p>
<h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>最后趁机说一下写多项式的心得<del>其实就是瞎吹</del>：</p>
<ul>
<li>好烦啊（</li>
<li>代码好长啊（</li>
<li>为什么踏马每次徒手写NTT都会挂啊（</li>
<li>学了半天原来FFT是最没用的啊（</li>
<li>调死我了啊</li>
<li>还不如直接照着模板背呢，每天早读背一发，那个什么教辅不是说来着？“背虽传统，也最实用”（</li>
<li>卧槽每次写一道板子就要交上一整页<del>，我不要面子的吗</del>（</li>
</ul>
<p>正经一点的话，大概就是我这几个板子都是用数组写的，所以会有<code>memset</code>或者<code>for for for</code>之类的，闲得很凌乱。再加上之前很智障地每次都要重新推一遍蝴蝶操作的<code>Rev</code>数组，就显得很弱智。于是决定下一次多项式复习的时候，自己可以学的更成体系，也可以用上<code>operator</code>和<code>vector</code>这两个利器。</p>
<p>upd：就在落笔不到5min之后想到了一个问题，就是你会发现在多项式题目里面有$\mod x^n$和$\mod \rm{NTTPrime}$ 两种约束，一直以为的是<code>不同的运算有不同的约束</code>，但这是$\color{red}{\text{错的}}$ 。真正的区别是，前者是对次数的约束，后者是对系数的约束。</p>
<p>= =也就只有我会智障到现在才明白。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】形式幂级数的牛顿迭代</title>
    <url>/2019/08/01/diedai/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多项式的牛顿迭代，是借助泰勒展开进行的一种对于形式幂级数的常规操作，解决的主要问题是：</p>
<script type="math/tex; mode=display">
G(F) \equiv 0~(\bmod x^n)</script><p>给定形式幂级数$G$，求解$F$。</p>
<p>而解决途径则是通过对降半次的$F_0$向上迭代解决的。</p>
<a id="more"></a>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>假设我们现在已经求出了$G(F_0)\equiv 0~(\bmod~x^{\frac{n}{2}})$</p>
<p>首先之前标准的式子左边在$F_0(x)$处进行泰勒展开，可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned} G(F(x)) &=G\left(F_{0}(x)\right) \\\ &+\frac{G^{\prime}\left(F_{0}(x)\right)}{1 !}\left(F(x)-F_{0}(x)\right) \\\ &+\frac{G^{\prime \prime}\left(F_{0}(x)\right)}{2 !}\left(F(x)-F_{0}(x)\right)^{2} \\\ &+\cdots (\mod ~x^n)\end{aligned}</script><p>但是我们考虑在$\mod ~x^n$意义下，$F$和$F_0$的最后$\frac{n}{2}$项相同，所以在上面的式子，$(F-F_0)^k,~k&gt;2$时，最低次项的次数一定会大于$2\cdot\lfloor \frac{n}{2}\rfloor$，也就是说在$\mod~x^n$意义下都是全0项。那么我们就可以得到：</p>
<script type="math/tex; mode=display">
G(F(x)) \equiv G\left(F_{0}(x)\right)+G^{\prime}\left(F_{0}(x)\right)\left(F(x)-F_{0}(x)\right) \quad\left(\bmod x^{n}\right)</script><p>然后因为$G(F)=0~(\bmod~x^n)$，所以我们可以得到：</p>
<script type="math/tex; mode=display">
F(x)\equiv F_0(x) - \frac{G(F_0(x))}{G^{\prime}\left(F_{0}(x)\right)} \quad\left(\bmod x^{n}\right)</script><p>于是直接递推就好。</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p><del>接下来看几个课后练习</del></p>
<h3 id="1-G-2-equiv-F-bmod-x-n"><a href="#1-G-2-equiv-F-bmod-x-n" class="headerlink" title="$(1)~G^2\equiv F~(\bmod~x^n)$"></a>$(1)~G^2\equiv F~(\bmod~x^n)$</h3><script type="math/tex; mode=display">
\begin{aligned}  
G^2&=F\\\
G^2-F&=0\\\
\end{aligned}</script><p>令$T(G)=G^2-F$,<del>套用公式</del>可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
T(G)&=G^2-F,F\Longleftrightarrow \mathbb{C} \\\
G &= G_h-\frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G&=G_h-\frac{G_h^2-F}{2G_h}\\\
\Longrightarrow G&=\frac{G_h^2+F}{2G_h}
\end{aligned}</script><h3 id="2-G-equiv-e-F-bmod-x-n"><a href="#2-G-equiv-e-F-bmod-x-n" class="headerlink" title="$(2)~G\equiv e^{F}~(\bmod ~x^n)$"></a>$(2)~G\equiv e^{F}~(\bmod ~x^n)$</h3><p><del>按照套路应该</del>两边同时取$\ln$:</p>
<script type="math/tex; mode=display">
\ln G=F~(\bmod~x^n)</script><p>之后我们令$T(G)=\ln G-F$，<del>套用公式可以得到</del></p>
<script type="math/tex; mode=display">
\begin{aligned}
G &= G_h - \frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G &= G_h-\frac{\ln G_h -F}{\frac{1}{G_h}}\\\
\Longrightarrow G &=G_h-G_h\ln G_h+G_hF\\\
\Longrightarrow G &=G_h(1-\ln G_h+F)\\\
\end{aligned}</script><h3 id="3-G-k-equiv-F-bmod-x-n"><a href="#3-G-k-equiv-F-bmod-x-n" class="headerlink" title="$(3)~G^k\equiv F~(\bmod ~x^n)$"></a>$(3)~G^k\equiv F~(\bmod ~x^n)$</h3><script type="math/tex; mode=display">
T(G) = G^k-F=0</script><p><del>套用公式可以得到</del></p>
<script type="math/tex; mode=display">
\begin{aligned}
G &= G_h - \frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G &= G_h-\frac{G_h^k-F}{kG_h^{k-1}}\\\
\Longrightarrow G &=\frac{(k-1)G_h^k+F}{kG_h^{k-1}}
\end{aligned}</script><p>然后就算这个东西就变成$\log^3~\text{or}~\log^2$可以算的东西了。</p>
<h3 id="4-2G-ln-G-equiv-F-bmod-x-n"><a href="#4-2G-ln-G-equiv-F-bmod-x-n" class="headerlink" title="$(4)~2G \ln G\equiv F~(\bmod x^n)$"></a>$(4)~2G \ln G\equiv F~(\bmod x^n)$</h3><script type="math/tex; mode=display">
T(G)\equiv 2G\ln G-F~(\bmod~x^n)</script><p>同样的台词……</p>
<script type="math/tex; mode=display">
\begin{aligned}
G &= G_h - \frac{T(G_h)}{T'(G_h)}\\\
\Longrightarrow G &= G_h-\frac{2G_h\ln G_h-F}{2\ln G_h+2G_h\cdot \frac{1}{G_h}}\\\
\Longrightarrow G &=\frac{2G_h\ln G_h-F}{(2\ln+1)G_h}
\end{aligned}</script><p>然后这东西好像是可以$\log^2$做的……不过有些小朋友特别喜欢出无脑的多项式板子，像这种东西就很没有意思qaq。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】多项式求逆</title>
    <url>/2019/07/27/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给定$F(x)$，求$G(x)$满足$G(x)\cdot F(x) \equiv1~(\bmod x^n)$.</p>
<p>不妨考虑$G’(x)\cdot F(x) =1~(\bmod x^{\frac{n}{2}})$</p>
<p>则有如下：</p>
<script type="math/tex; mode=display">
\because G'\cdot F =1~(\bmod x^{\frac{n}{2}})\\\ ~G\cdot F \equiv1~(\bmod x^{\frac{n}{2}})\\\
\therefore G' -G\equiv0~(\bmod x^{\frac{n}{2}})\\\ 
\Longrightarrow G'^2+G^2-2G'G\equiv0~(\bmod x^{n})</script><p>两端同时卷上一个$F(x)$则有：</p>
<script type="math/tex; mode=display">
\because F\cdot G\equiv1~(\bmod x^n)\\\
\therefore G\equiv 2G'-FG'^2~(\bmod x^n)</script><p>以此为递推式即可递推出$G(x)$的值，时间复杂度$O(n\log^2 n)$.</p>
<a id="more"></a>
<h1 id="1"><a href="#1" class="headerlink" title="$1~$"></a>$1~$</h1><p><a href="https://www.luogu.org/problem/P4238" target="_blank" rel="noopener">【模板】多项式求逆</a></p>
<p>就是板子，NTT一下就好= =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300023</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> t[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, base[MAXN], Ans[MAXN], rev[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (y) </span><br><span class="line">		res = ((y &amp; <span class="number">1</span>) ? <span class="number">1l</span>l * res * x % Mod : res), </span><br><span class="line">		x = <span class="number">1l</span>l * x * x % Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *J, <span class="keyword">int</span> L, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">	rr <span class="keyword">int</span> Gn, Gi = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (i &lt; rev[i]) J[i] ^= J[rev[i]] ^= J[i] ^= J[rev[i]] ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; L ; i &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		Gn = expow(G, (Mod - <span class="number">1</span>) / (i &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">		<span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; L ; Gi = <span class="number">1</span>, j += (i &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">			<span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; i ; ++ k, Gi = <span class="number">1l</span>l * Gi * Gn % Mod)&#123;</span><br><span class="line">				rr <span class="keyword">int</span> real = J[j + k], iroot = <span class="number">1l</span>l * J[j + k + i] * Gi % Mod ;</span><br><span class="line">				J[j + k] = (real + iroot) % Mod, J[j + k + i] = (real - iroot + Mod) % Mod ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">int</span> Inv = expow(L, Mod - <span class="number">2</span>) ;  reverse(J + <span class="number">1</span>, J + L) ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; L ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv_NTT</span><span class="params">(<span class="keyword">int</span> Len, <span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span>&#123;<span class="comment">//递推 </span></span><br><span class="line">	<span class="keyword">if</span> (Len &lt;= <span class="number">1</span>)&#123; B[<span class="number">0</span>] = expow(A[<span class="number">0</span>], Mod - <span class="number">2</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	Inv_NTT((Len + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, A, B) ; rr <span class="keyword">int</span> Lim = <span class="number">1</span>, len = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (Lim &lt; (Len &lt;&lt; <span class="number">1</span>)) Lim &lt;&lt;= <span class="number">1</span>, ++ len ; rr <span class="keyword">int</span> i, j, k ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Lim ; ++ i) rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len<span class="number">-1</span>)) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i) t[i] = A[i] ; </span><br><span class="line">    NTT(t, Lim, <span class="number">1</span>), NTT(B, Lim, <span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Lim ; ++ i) B[i] = <span class="number">1l</span>l * (<span class="number">2l</span>l - <span class="number">1l</span>l * t[i] * B[i] % Mod + Mod) % Mod * B[i] % Mod ;</span><br><span class="line">    NTT(B, Lim, <span class="number">-1</span>) ; <span class="keyword">for</span> (i = Len ; i &lt;= Lim ; ++ i) B[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">	Inv_NTT(N, base, Ans) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p><a href="https://www.luogu.org/problem/P4239" target="_blank" rel="noopener">【模板】多项式求逆（加强版）</a></p>
<p>然而就是把模数换成了非NTT模数= =</p>
<p>于是就做一遍MTT就好了，这里写的是带有共轭优化的版本= =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 300020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM MAXN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod (1000000007)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span> ; <span class="keyword">int</span> T[MAXN] ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> t[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, base[MAXN], Ans[MAXN], rev[MAXN]  ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (y) </span><br><span class="line">		res = ((y &amp; <span class="number">1</span>) ? <span class="number">1l</span>l * res * x % Mod : res), </span><br><span class="line">		x = <span class="number">1l</span>l * x * x % Mod, y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> r, i ;</span><br><span class="line">&#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM], qaq ; <span class="keyword">int</span> L1, L2, P ;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> + (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp; Q)&#123; <span class="keyword">return</span> (node)&#123;J.r + Q.r , J.i + Q.i&#125; ; &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> - (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp; Q)&#123; <span class="keyword">return</span> (node)&#123;J.r - Q.r , J.i - Q.i&#125; ; &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp; Q)&#123; <span class="keyword">return</span> (node)&#123;J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r&#125; ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">const</span> <span class="keyword">int</span> &amp;Lim, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; rev[i]) qaq = J[i], J[i] = J[rev[i]], J[rev[i]] = qaq ; </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(rr <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Lim ; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(rr <span class="keyword">int</span> l = <span class="number">0</span> ; l &lt; j ; ++ l)&#123;</span><br><span class="line">                rr node T = w[Lim / j * l] ; <span class="keyword">if</span> (flag &lt; <span class="number">0</span>) T.i *= <span class="number">-1</span> ;</span><br><span class="line">                rr node Nx = J[k + l], Ny = T * J[k + j + l] ; J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> *J, <span class="keyword">int</span> *K, <span class="keyword">int</span> Length, <span class="keyword">int</span> P, <span class="keyword">int</span> Lim, <span class="keyword">int</span> *ret)</span></span>&#123;</span><br><span class="line">    rr node ia, ib, a1, a2, b1, b2 ; rr <span class="keyword">int</span> t, k, q1, q2, q3 ;  </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; (Length &lt;&lt; <span class="number">1</span>) ; ++ i) A[i] = B[i] = (node)&#123;<span class="number">0</span>, <span class="number">0</span>&#125; ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; Lim ; i &lt;&lt;= <span class="number">1</span>) <span class="keyword">for</span>(k = <span class="number">0</span> ; k &lt; i ; ++ k) w[Lim / i * k] = (node)&#123;<span class="built_in">cos</span>(k * Pi / i) , <span class="built_in">sin</span>(k * Pi / i)&#125; ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= Length ; ++ i) A[i].r = J[i] &amp; <span class="number">32767</span>, A[i].i = J[i] &gt;&gt; <span class="number">15</span>, B[i].r = K[i] &amp; <span class="number">32767</span>, B[i].i = K[i] &gt;&gt; <span class="number">15</span> ;</span><br><span class="line">    FFT(A, Lim, <span class="number">1</span>), FFT(B, Lim, <span class="number">1</span>), t = Lim - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Lim ; ++ i)&#123;</span><br><span class="line">        k = (Lim - i) &amp; t ; </span><br><span class="line">		ia = (node)&#123; A[k].r, -A[k].i &#125;, ib = (node)&#123; B[k].r, -B[k].i &#125; ; </span><br><span class="line">        a1 = (ia + A[i]) * (node) &#123;<span class="number">0.5</span>, <span class="number">0</span>&#125;, a2 = (A[i] - ia) * (node) &#123;<span class="number">0</span>, <span class="number">-0.5</span>&#125; ;</span><br><span class="line">        b1 = (ib + B[i]) * (node) &#123;<span class="number">0.5</span>, <span class="number">0</span>&#125;, b2 = (B[i] - ib) * (node) &#123;<span class="number">0</span>, <span class="number">-0.5</span>&#125; ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * (node)&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  </span><br><span class="line">	FFT(t1, Lim, <span class="number">-1</span>), FFT(t2, Lim, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Length ; ++ i)&#123; </span><br><span class="line">        q1 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].r / Lim + <span class="number">0.5</span>) % P, q2 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].i / Lim + <span class="number">0.5</span>) % P ;</span><br><span class="line">        q3 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t2[i].r / Lim + <span class="number">0.5</span>) % P, ret[i] = ((<span class="number">1l</span>l * q3 &lt;&lt; <span class="number">30</span>) % P + (<span class="number">1l</span>l * q2 &lt;&lt; <span class="number">15</span>) % P + q1) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv_MTT</span><span class="params">(<span class="keyword">int</span> Len, <span class="keyword">int</span> *A, <span class="keyword">int</span> *B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Len &lt;= <span class="number">1</span>)&#123; </span><br><span class="line">		B[<span class="number">0</span>] = expow(A[<span class="number">0</span>], Mod - <span class="number">2</span>) ; </span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">	Inv_MTT(Len &gt;&gt; <span class="number">1</span>, A, B) ; rr <span class="keyword">int</span> Lim, len = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (Lim = <span class="number">1</span> ; Lim &lt;= Len ; Lim &lt;&lt;= <span class="number">1</span>) ++ len ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Lim ; ++ i) </span><br><span class="line">		rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len<span class="number">-1</span>)) ;</span><br><span class="line">	MTT(A, B, Len, Mod, Lim, T), MTT(T, B, Len, Mod, Lim, t) ;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Len ; ++ i) B[i] = <span class="number">1l</span>l * (<span class="number">2l</span>l * B[i] - t[i] + Mod) % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))  c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span> ,c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; rr <span class="keyword">int</span> i, Np ; </span><br><span class="line">	<span class="keyword">for</span> (Np = <span class="number">1</span> ; Np &lt; N ; Np &lt;&lt;= <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) base[i] = qr() ;</span><br><span class="line">	Inv_MTT(Np, base, Ans) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开了一发O2发现快了三倍，woc…</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】洛谷三月月赛 Derivation</title>
    <url>/2019/07/26/biaodashishu2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一般在考场上写出这种东西的人，我们称之为：巨  魔  码  怪。</p>
<a id="more"></a>
<p>小 R 学会微积分中求导这一概念后，他的数学老师要求他开始做一部分导数的练习题加深自己的理解。</p>
<p>但颖悟绝伦的小 R 对繁复的练习题并不感兴趣。他希望你帮他设计一个程序，计算一个给定函数 $f(x)$ 的导数。</p>
<p>第一行一个正整数 T，表示小 R 要完成的练习题数量，亦即测试数据的组数。<br>每组测试数据的第一行是一个非空字符串，描述了输入的函数 $f(x)$。设 $p=998244353$。</p>
<p>字符串中可能包含的元素有：</p>
<p>1、系数为 $1$ 的单项式，包括 $x^2,x^0$ 等，我们保证指数为非负整数为 $1$ 时不省略，不会超过 $p-1$。所有幂号用 <code>^</code> 代替。<br>2、常数，如 $0,19260817$ 等；我们保证一切常数是非负整数且不超过 $p-1$。<br>3、复合函数。将以上两种函数组合的方式可以为加乘幂，括号等。数学中会省略乘号和括号，但我们保证任意情况下都不省略（也不会无意义冗余，即不存在 <code>((x)),(3)+(4)</code>）；保证任何指数都是常数，即不存在 $x^{g(x)}$的情况。</p>
<p>测试数据的第二行为两个整数，值在$[0,p)$之间。你需要输出两个整数，表示这些整数代入导函数后的值模 $p$ 的结果。</p>
<p>本题中认为 $0^0=1$。</p>
<hr>
<hr>
<p>这道题也是很神= =</p>
<p>首先求导不求导的，先把树建出来，然后就会发现这个题的本质还是合并左右孩子。但是有一点很神，就是合并时要用<strong>扩展欧拉定理</strong>合并，原因是我们存在<code>^</code>这个运算。然后就考虑我们可以存储当<code>x=v</code>时对所有扩欧展开时的模数取模，更新的时候按秩更新就好了= =</p>
<p>还有就是在调这题时，我发现了一个以前程序的bug。</p>
<p>关于建树时的鬼畜判断，我当时是这么加的判断:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tp = <span class="number">0</span>, <span class="built_in">memset</span>(brac, <span class="number">0</span>, <span class="keyword">sizeof</span>(brac)) ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = i ; </span><br><span class="line">		<span class="keyword">if</span> (In[i] == <span class="string">')'</span>) brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">blablabla....</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (brac[l] == r) l ++, r -- ;</span><br><span class="line">    blablabla...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这东西每次<code>memset</code>显然会超时，于是便采用一个退化版本<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (In[l] == <span class="string">'('</span> &amp;&amp; In[r] == <span class="string">')'</span>) l ++, r -- ; <span class="comment">// 1</span></span><br><span class="line">    blablabla...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tm当时自己因为这个调了好久也是很佛了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod[MAXM], n, v ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i * i &lt;= x ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!(x % i))&#123;</span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>) ; </span><br><span class="line">            <span class="keyword">while</span> (!(x % i)) x /= i ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ret = ret / x * (x - <span class="number">1</span>) ; <span class="keyword">return</span> ret ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _prework()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mod ; i &gt; <span class="number">1</span> ; i = phi(i)) </span><br><span class="line">        mod[++ n] = i ; mod[++ n] = <span class="number">1</span>, mod[++ n] = <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> brac[MAXN], stk[MAXN], tp ;</span><br><span class="line"><span class="keyword">char</span> op[MAXN], In[MAXN] ; <span class="keyword">int</span> N, T ; </span><br><span class="line"><span class="keyword">int</span> root, L[MAXN], R[MAXN], tot ; ll val[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isop</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == <span class="string">'+'</span> || x == <span class="string">'*'</span> || x == <span class="string">'^'</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = i ; </span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">')'</span>) brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (In[l] == <span class="string">'('</span> &amp;&amp; In[r] == <span class="string">')'</span>) l ++, r -- ; <span class="comment">// 1</span></span><br><span class="line">    rr <span class="keyword">int</span> rt = <span class="number">0</span>, rt1 = <span class="number">0</span>, rt2 = <span class="number">0</span>, x = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l ; i &lt;= r ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) i = brac[i] + <span class="number">1</span> ; <span class="keyword">if</span> (i &gt; r) <span class="keyword">break</span> ; </span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'+'</span> &amp;&amp; !isop(In[i - <span class="number">1</span>])) &#123; rt = i ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'*'</span>) rt1 = i ; <span class="keyword">if</span> (In[i] == <span class="string">'^'</span> &amp;&amp; !rt2) rt2 = i ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt) x = rt ; <span class="keyword">else</span> <span class="keyword">if</span> (rt1) x = rt1 ; <span class="keyword">else</span> x = rt2 ; </span><br><span class="line">    <span class="keyword">if</span> (!x)&#123;</span><br><span class="line">        x = r ; </span><br><span class="line">        <span class="keyword">if</span> (In[r] == <span class="string">'x'</span>) op[x] = <span class="string">'X'</span>, val[x] = <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">else</span> op[x] = <span class="string">'?'</span>, <span class="built_in">sscanf</span>(In + l, <span class="string">"%lld"</span>, &amp;val[x]), val[x] %= Mod ;</span><br><span class="line">        L[x] = R[x] = <span class="number">0</span> ; <span class="keyword">return</span> x ; </span><br><span class="line">    &#125;</span><br><span class="line">    op[x] = In[x], L[x] = build(l, x - <span class="number">1</span>), R[x] = build(x + <span class="number">1</span>, r) ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ll y[MAXM], dy[MAXM] ; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> a * b &lt; p ? a * b :  a * b % p + p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> a + b &lt; p ? a + b : (a + b) % p + p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">expow</span><span class="params">(ll a, ll b, ll p)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = mul(res, a, p) ;</span><br><span class="line">        a = mul(a, a, p) ; b &gt;&gt;= <span class="number">1</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    Node res ; </span><br><span class="line">    <span class="keyword">if</span> (!L[x] &amp;&amp; !R[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (op[x] == <span class="string">'X'</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">       					res.y[i] = v % mod[i], res.dy[i] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                res.y[i] = val[x] % mod[i], res.dy[i] = <span class="number">0</span> ;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node l = dp(L[x]), r = dp(R[x]) ; </span><br><span class="line">        <span class="keyword">if</span> (op[x] == <span class="string">'+'</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                res.y[i] = add(l.y[i], r.y[i], mod[i]), </span><br><span class="line">                res.dy[i] = add(l.dy[i], r.dy[i], mod[i]) ; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[x] == <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                res.y[i] = mul(l.y[i], r.y[i], mod[i]), </span><br><span class="line">                res.dy[i] = add(mul(l.dy[i], r.y[i], mod[i]), mul(l.y[i], r.dy[i], mod[i]), mod[i]) ; </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            rr ll calc ;</span><br><span class="line">            res.y[n] = res.dy[n] = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i) <span class="comment">// 1</span></span><br><span class="line">                res.y[i] = expow(l.y[i], r.y[i + <span class="number">1</span>], mod[i]),</span><br><span class="line">                calc = (!(l.y[i] % mod[i]) &amp;&amp; (r.y[i + <span class="number">1</span>] % mod[i + <span class="number">1</span>] == <span class="number">1</span>)) ?</span><br><span class="line">                 		<span class="number">1</span> : expow(l.y[i], (r.y[i + <span class="number">1</span>] + mod[i + <span class="number">1</span>] - <span class="number">1</span>) % mod[i + <span class="number">1</span>], mod[i]),</span><br><span class="line"> 				res.dy[i] = mul(mul(l.dy[i], r.y[i], mod[i]), calc, mod[i]) ; </span><br><span class="line">          <span class="comment">//calc: 此题认为0^0=1，因此判一下。s</span></span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="keyword">return</span> res ; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _prework() ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ; <span class="keyword">int</span> i ;  </span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		In[<span class="number">1</span>] = <span class="string">'('</span>, <span class="built_in">scanf</span>(<span class="string">"%s"</span>, (In + <span class="number">2</span>)) ; </span><br><span class="line">        N = <span class="built_in">strlen</span>(In + <span class="number">1</span>), In[++ N] = <span class="string">')'</span> ;</span><br><span class="line">        Init(), tot = <span class="number">0</span>, root = build(<span class="number">1</span>, N); </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">2</span> ; ++ i)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v ; Node res = dp(root) ; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, res.dy[<span class="number">1</span>] % Mod, <span class="string">" \n"</span>[i == <span class="number">1</span>]) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有，就是当时自己觉得自己已经理解了怎么操作就开始瞎写，结果就开始疯狂地挂，于是发现了这两个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> a * b &lt; p ? a * b :  a * b % p + p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> a + b &lt; p ? a + b : (a + b) % p + p ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平心而论，这两个函数是最不起眼的两个函数……但是对于某些老年OI降智选手确实致命性的打击：<strong>这两个函数不是凭空存在的，是为了配合扩展欧拉定理的</strong>！</p>
<p>基本形式大概就是：</p>
<script type="math/tex; mode=display">n^k\equiv \begin{matrix} \qquad\ n^{[k\ \ mod \ \ \varphi(m)]+\varphi(m)} \   \ (k\geq \varphi(m))\\\ n^k \qquad\ (k<\varphi(m)) \end{matrix}  \qquad\  (mod \ \ m)</script><p>也就是说最后的$+p$是必要的= = 这也是很佛。。</p>
<hr>
<p>然后就是我当时还奇怪为什么兔队写的这么快，结果写上一篇文章时发现原来是自己的复杂度写假了，如果按上文中的写，复杂度应该是$O(q|S|\log|S|\log^2p)$。</p>
<p>于是为了优化掉这个log我们需要写一遍后缀表达式版的求导= = </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span> ll y[MAXM], dy[MAXM] ; &#125;;</span><br><span class="line"><span class="keyword">char</span> stk[MAXM] ; Node Ans[MAXN] ; <span class="keyword">int</span> ans, i, j, tp, pt ;</span><br><span class="line"><span class="keyword">char</span> In[MAXN], op[MAXN], res[MAXN] ; <span class="keyword">int</span> T, N, L, mod[MAXM], n ; ll val[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = x ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i * i &lt;= x ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!(x % i))&#123;</span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">while</span> (!(x % i)) x /= i ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) ret = ret / x * (x - <span class="number">1</span>) ; <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _prework()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mod ; i &gt; <span class="number">1</span> ; i = phi(i))</span><br><span class="line">        mod[++ n] = i ; mod[++ n] = <span class="number">1</span>, mod[++ n] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="keyword">return</span> a * b &lt; p ? a * b :  a * b % p + p ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll a,ll b,ll p)</span></span>&#123; <span class="keyword">return</span> a + b &lt; p ? a + b : (a + b) % p + p ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll a, ll b, ll p)</span></span>&#123;</span><br><span class="line">    rr ll res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = mul(res, a, p) ;</span><br><span class="line">        a = mul(a, a, p) ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'('</span>)  <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'+'</span>)  <span class="keyword">return</span> <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'*'</span>)  <span class="keyword">return</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'^'</span>)  <span class="keyword">return</span> <span class="number">4</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;a, <span class="keyword">const</span> <span class="keyword">char</span> &amp;b)</span></span>&#123; <span class="keyword">return</span> calc(a) &gt;= calc(b) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _prework() ; <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">            ll ret = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(In[i]))&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isdigit</span>(In[i]))</span><br><span class="line">                    ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + In[i] - <span class="string">'0'</span>, ++ i ;</span><br><span class="line">                i --, val[++ L] = ret, res[L] = <span class="string">'N'</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'x'</span>) val[++ L] = <span class="number">1</span>, res[L] = <span class="string">'X'</span> ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = In[i] ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (stk[tp] != <span class="string">'('</span>)</span><br><span class="line">                    res[++ L] = stk[tp --] ;</span><br><span class="line">                tp -- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (tp &amp;&amp; Comp(stk[tp], In[i]))</span><br><span class="line">                    res[++ L] = stk[tp --] ; stk[++ tp] = In[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tp) res[++ L] = stk[tp --] ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> o = <span class="number">1</span> ; o &lt;= <span class="number">2</span> ; ++ o)&#123;</span><br><span class="line">            rr <span class="keyword">int</span> v ; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v) ;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= L ; ++ j)&#123;</span><br><span class="line">                rr Node ret ;</span><br><span class="line">                <span class="keyword">if</span> (!calc(res[j])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (res[j] == <span class="string">'X'</span>)</span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                            ret.y[i] = v % mod[i], ret.dy[i] = <span class="number">1</span> ;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                            ret.y[i] = val[j] % mod[i], ret.dy[i] = <span class="number">0</span> ;</span><br><span class="line">                    Ans[++ pt] = ret ; <span class="keyword">continue</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                rr Node p1 = Ans[pt --] ; rr Node p2 = Ans[pt --] ; </span><br><span class="line">                <span class="keyword">if</span> (res[j] == <span class="string">'+'</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                        ret.y[i] = add(p1.y[i], p2.y[i], mod[i]),</span><br><span class="line">                        ret.dy[i] = add(p1.dy[i], p2.dy[i], mod[i]) ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res[j] == <span class="string">'*'</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">                        ret.y[i] = mul(p1.y[i], p2.y[i], mod[i]),</span><br><span class="line">                        ret.dy[i] = add(mul(p1.dy[i], p2.y[i], mod[i]), mul(p1.y[i], p2.dy[i], mod[i]), mod[i]) ;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rr ll calcc ; swap(p1, p2) ;</span><br><span class="line">                    ret.y[n] = ret.dy[n] = <span class="number">0</span> ;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span> ; i &gt;= <span class="number">1</span> ; -- i) <span class="comment">// 1</span></span><br><span class="line">                        ret.y[i] = expow(p1.y[i], p2.y[i + <span class="number">1</span>], mod[i]),</span><br><span class="line">                        calcc = (!(p1.y[i] % mod[i]) &amp;&amp; (p2.y[i + <span class="number">1</span>] % mod[i + <span class="number">1</span>] == <span class="number">1</span>)) ?</span><br><span class="line">                                <span class="number">1</span> : expow(p1.y[i], (p2.y[i + <span class="number">1</span>] + mod[i + <span class="number">1</span>] - <span class="number">1</span>) % mod[i + <span class="number">1</span>], mod[i]),</span><br><span class="line">                        ret.dy[i] = mul(mul(p1.dy[i], p2.y[i], mod[i]), calcc, mod[i]) ;</span><br><span class="line">                &#125;</span><br><span class="line">                Ans[++ pt] = ret ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Ans[pt].dy[<span class="number">1</span>] % Mod), pt -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        L = <span class="number">0</span>, <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完我才发现我的大常数是救不了的了，兔爷写的60ms，我写的1120ms，这tm20倍的常数宛如写了$\rm{|S|\log|S|}$……不过说会话比建树的快了些。</p>
<p>看了看题解似乎应该是兔爷多写了一层欧拉展开，于是又消掉一个log = =</p>
<blockquote>
<p>$O(q|S|\log^2 p)$ <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.jpg" alt=""></p>
<p>$O(q|S|\log |S| log^2 p)$ <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.jpg" alt=""></p>
</blockquote>
<p>卡常真是荼毒人名= =</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>表达式/表达式树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】表达式树入门</title>
    <url>/2019/07/26/biaodashishu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>严格来讲，我们所谈的<strong>表达式树</strong>是对一个计算式的中缀表达式所构造的<strong>二叉树形结构</strong>，在求解表达式的值时十分的方便。</p>
<p>对于一棵表达式树，其中每一个节点都表示一个字符，特别的是<strong>数值只会是叶子节点</strong>，这些数值由其祖先节点——均是“计算符号”的节点连接起来。而计算方式则是：</p>
<script type="math/tex; mode=display">
\rm{S_u=calc(S_{v_1}, S_{v_2})}</script><p>其中u为当前节点，calc函数的计算方式取决于点$u$上的符号。</p>
<p>从而只需要递归计算即可。</p>
<a id="more"></a>
<h1 id="1-递归建树"><a href="#1-递归建树" class="headerlink" title="$1$ 递归建树"></a>$1$ 递归建树</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == <span class="string">'+'</span> || x == <span class="string">'-'</span> || x == <span class="string">'*'</span> || x == <span class="string">'/'</span> || x == <span class="string">'^'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (brac[l] == r) <span class="keyword">return</span> build(l + <span class="number">1</span>, r - <span class="number">1</span>) ; </span><br><span class="line">	rr <span class="keyword">int</span> rt = <span class="number">0</span>, ls = <span class="number">0</span>, rs = <span class="number">0</span>, x = <span class="number">0</span> ; </span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> k = l ; k &lt;= r ; ++ k)&#123;</span><br><span class="line">		<span class="keyword">if</span> (In[k] == <span class="string">'('</span>) k = brac[k] + <span class="number">1</span> ; <span class="keyword">if</span> (k &gt; r) <span class="keyword">break</span> ; </span><br><span class="line">		<span class="keyword">if</span> ((In[k] == <span class="string">'+'</span> || In[k] == <span class="string">'-'</span>) &amp;&amp; k != l &amp;&amp; !isop(In[k - <span class="number">1</span>])) &#123; rt = k ; <span class="keyword">break</span> ; &#125;<span class="comment">//!</span></span><br><span class="line">		<span class="keyword">if</span> (In[k] == <span class="string">'*'</span> || In[k] == <span class="string">'/'</span>) ls = k ; <span class="keyword">if</span> (In[k] == <span class="string">'^'</span> &amp;&amp; !rs) rs = k ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rt) x = rt ; <span class="keyword">else</span> <span class="keyword">if</span> (ls) x = ls ; <span class="keyword">else</span> x = rs ; </span><br><span class="line">	<span class="keyword">if</span> (!x) &#123; </span><br><span class="line">		x = r, op[x] = <span class="string">'?'</span> ; </span><br><span class="line">		<span class="built_in">sscanf</span>(In + l, <span class="string">"%d"</span>, &amp;val[x]) ; </span><br><span class="line">		val[x] %= Mod ; <span class="keyword">return</span> x ; </span><br><span class="line">	&#125;</span><br><span class="line">	op[x] = In[x] ; L[x] = build(l, x - <span class="number">1</span>), R[x] = build(x + <span class="number">1</span>, r) ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	rr <span class="keyword">int</span> res = <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">while</span> (b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= Mod ;</span><br><span class="line">		(a *= a) %= Mod ; b &gt;&gt;= <span class="number">1</span> ;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'?'</span>) <span class="keyword">return</span> val[x] ; </span><br><span class="line">	rr <span class="keyword">int</span> l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = <span class="number">0.0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'+'</span>) res = (l + r) % Mod ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'-'</span>) res = (l - r) % Mod ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'*'</span>) res = (l * r) % Mod ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'/'</span>) res = l * expow(r, Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line">	<span class="keyword">if</span> (op[x] == <span class="string">'^'</span>) res = expow(l ,r) ; <span class="keyword">return</span> res ; 	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; In + <span class="number">1</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = i ; </span><br><span class="line">		<span class="keyword">if</span> (In[i] == <span class="string">')'</span>) brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ;</span><br><span class="line">	&#125;</span><br><span class="line">	root = build(<span class="number">1</span>, N), <span class="built_in">cout</span> &lt;&lt; dp(root) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也没啥好说的，这道题是NOIP2013普及组的<a href="https://www.luogu.org/problem/P1981" target="_blank" rel="noopener">表达式求值</a>。然后建树的时候需要注意优先级……</p>
<p>但其实这个地方想说的不是这个东西，而是一个复杂度的问题。喜闻乐见的这个玩意儿的复杂度是$O(n^2)$的，但是在我加了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((In[k] == <span class="string">'+'</span> || In[k] == <span class="string">'-'</span>) &amp;&amp; k != l &amp;&amp; !isop(In[k - <span class="number">1</span>])) &#123; </span><br><span class="line">  rt = k ; <span class="keyword">break</span> ; </span><br><span class="line">&#125;<span class="comment">//!</span></span><br></pre></td></tr></table></figure>
<p>中的break之后，他就可以在400ms内的龟速把1e6的数据给艹过去了……也算是很迷</p>
<p>但听说似乎真正$O(|S|)$的建树其实只需要预处理一下每个位置之前最近的符号就好……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Code[r][<span class="number">1</span>] &gt;= l) rt = Code[r][<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Code[r][<span class="number">2</span>] &gt;= l) rt = Code[r][<span class="number">2</span>] ;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        op[rt] = In[rt], </span><br><span class="line">      	L[rt] = build(l, rt - <span class="number">1</span>), </span><br><span class="line">      	R[rt] = build(rt + <span class="number">1</span>, r) ; <span class="keyword">return</span> rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    op[r] = <span class="string">'?'</span>, <span class="built_in">sscanf</span>(In + l, <span class="string">"%d"</span>, &amp;val[r]) ; val[r] %= Mod ; <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'?'</span>) <span class="keyword">return</span> val[x] ;</span><br><span class="line">    <span class="keyword">int</span> l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = <span class="number">0.0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'+'</span>) res = (l + r) % Mod ;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'*'</span>) res = (l * r) % Mod ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">    N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'+'</span>) Add = i ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'*'</span>) Mul = i ;</span><br><span class="line">        Code[i][<span class="number">1</span>] = Add, Code[i][<span class="number">2</span>] = Mul ;</span><br><span class="line">    &#125;</span><br><span class="line">    root = build(<span class="number">1</span>, N) ; <span class="built_in">cout</span> &lt;&lt; dp(root) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这似乎就是线性的了（flag * 1）。然而测了一下速发现：</p>
<blockquote>
<p>$n^2$写法 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.jpg" alt=""> </p>
<p>$|S|$写法 <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.jpg" alt=""></p>
</blockquote>
<p>似乎并没有什么区别……于是这就很佛了。。（fo * 1）</p>
<h1 id="2-用栈建树"><a href="#2-用栈建树" class="headerlink" title="$2$ 用栈建树"></a>$2$ 用栈建树</h1><p>这其实是在UOJ群里面<code>iki9</code>推荐的方式，我看到似乎兔队也是这么建的，于是就打算学一学。</p>
<p>然后其实也是蛮简单的，大概就是先用$|S|$的时间转化成后缀表达式，然后再用$|S|$的时间求出来。</p>
<p>转后缀表达式也挺简单，就是注意一定要是先计算优先级高的、后计算低的，所以我们需要一个优先级单调递减的栈来保存。</p>
<p>计算的时候用一个栈记录，每遇到一个计算符就弹出最顶上的俩数计算。因为后缀表达式的完备性所以一定是可行的。</p>
<p>好了我去写了……</p>
<hr>
<p>……这踏马是什么操作啊喂…先贴代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">char</span>&gt; stk ; <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; Ans ; <span class="keyword">int</span> ans, i ;</span><br><span class="line"><span class="keyword">char</span> In[MAXN], op[MAXN], res[MAXN] ; <span class="keyword">int</span> N, L, val[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'('</span>)  <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'+'</span>)  <span class="keyword">return</span> <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'-'</span>)  <span class="keyword">return</span> <span class="number">2</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'*'</span>)  <span class="keyword">return</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'/'</span>)  <span class="keyword">return</span> <span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x ==<span class="string">'^'</span>)  <span class="keyword">return</span> <span class="number">4</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calc(a) &gt;= calc(b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>), N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(In[i]))&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(In[i]))</span><br><span class="line">                ret = (ret &lt;&lt; <span class="number">1</span>) + (ret &lt;&lt; <span class="number">3</span>) + In[i] - <span class="string">'0'</span>, ++ i ;</span><br><span class="line">            i --, val[++ L] = ret, res[L] = <span class="string">'N'</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk.push(In[i]) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (stk.top() != <span class="string">'('</span>)</span><br><span class="line">                res[++ L] = stk.top(), stk.pop() ;</span><br><span class="line">            stk.pop() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; Comp(stk.top(), In[i]))</span><br><span class="line">                res[++ L] = stk.top(), stk.pop() ;</span><br><span class="line">            stk.push(In[i]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) res[++ L] = stk.top(), stk.pop() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= L ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!calc(res[i])) &#123; Ans.push(val[i]) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">        <span class="keyword">int</span> p1 = Ans.top() ; Ans.pop() ; <span class="keyword">int</span> p2 = Ans.top() ; Ans.pop() ;</span><br><span class="line">        <span class="keyword">if</span> (calc(res[i]) == <span class="number">2</span>) &#123;<span class="keyword">int</span> p = (p1 + p2) % Mod ; Ans.push(p) ; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (calc(res[i]) == <span class="number">3</span>) &#123;<span class="keyword">int</span> p = (p1 * p2) % Mod ; Ans.push(p) ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans.top() % Mod &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再贴结果：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="3.png" alt=""></p>
<p>？？？</p>
<p>思考了思考，似乎刚才递归那种写法不是$O(|S |)$的？嗯，很有道理，那玩意儿复杂度应该是$O(|S|\log |S|)$的啊，毕竟tm终究是棵完全二叉树……</p>
<p>我佛了</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>语义树</category>
      </categories>
      <tags>
        <tag>表达式/表达式树</tag>
        <tag>树模型</tag>
        <tag>奇怪的技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>随想九 · 意义</title>
    <url>/2019/07/18/Nine/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Let’s say sunshine for everyone 人们说生活总是充满阳光<br>But as far as I can remember 但在我的记忆中<br>We’ve been migratory animals 我们一直只是如野兽般流浪<br>Living under changing weather 四季变换，我们如常<br>Someday we will foresee obstacles 总有一天，我们会看见那些困难阻碍<br>Through the blizzard through the blizzard 在那片风雪之中，在那片风雪之后<br>Today we will sell our uniform 如今我们将曾经的校服变卖<br>Live together live together 一同离去，一同启程</p>
</blockquote>

        <div id="aplayer-ZnoKwUDn" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-ZnoKwUDn"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "Obstacles",
              author: "Syd Matters",
              url: "Obstacles.flac",
              pic: "/2019/07/18/Nine/lis.png",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<a id="more"></a>
<h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>最近暑假了，一直颓的很。并不想说太多，每天晚上昏睡之际眼前的火苗会在第二天早上太阳升起时熄灭，似乎也不再是什么稀罕事。不过倒是也有所收获。先是去B站看<code>C菌</code>的《奇异人生二·实况》，才知道有《Life is Strange》这么一款游戏，于是索性只看了《二》，自己从steam上买了第一部，津津有味地玩了起来。奈何CPU是1.8GHz的，仅达到了最低配的要求，故画面体验有些差，但倒也无妨。但或许游戏时长有点多？别人都说“15小时通关”，似乎我也是在拽平均分了。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<p>奇怪的是一直没有官方的的汉化包（但是2和续作都有汉化包，只有1官方没发布），于是只能凭很渣的英语阅读能力来玩，中间自然也是和看《哈利波特》一样，有许多细节是看不懂的，但是95%+还是没有问题。可惜玩完之后，毕竟是12 P.M.了，不知是真的出于困倦，亦或是别的原因，我并没有什么特别的感觉，大概就是“啊，结束了”便没了后文。</p>
<p>之后的一天半<strong>全</strong>用来看韩剧《秘密森林》，豆瓣上9分+的悬疑力作，确实不错；但是看完到现在似乎已经过了10个小时多，自己却一点深刻的感觉也没有，仅仅也是“啊，结束了”。我逼自己在脑海里构思出过几个结论，诸如“剧情好，情节紧凑”、“主角们身上的品质值得学习”之类的老套的东西，毕竟自己不喜欢接受“我浪费了时间”这种事实。</p>
<p>但是我从QQ音乐上（我一直不用网易云）搜到了Life is Strange的soundtrack，听了听最后选择Cloye后的BGM，或者说谢场曲，<code>Obstacles</code>，渐渐地有了感觉。这时我才意识到，或许这真是一款伟大的游戏。</p>
<h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>到现在我才发现，一个真正的爱的东西，或许一张照片就能表达，不许要各个角度的拍摄、点缀——此感慨大概是来源于我本来想把自己很有感触的片段啊、镜头啊、台词啊都整理出来，丢到博客上封存起来。但碍于自己实力不够又太懒，最终决定放弃了。当然，或许这个感慨也仅是一个心理安慰而已吧。</p>
<p>不知怎的，最近无论做什么事都有种“却道天凉好个秋”的感觉。纵然坐在屏幕前，单曲循环着<code>Obstacles</code>的我心中不断闪回无数个游戏中的镜头，我从来没意识到的感动、满足在心中游动，我却只想淡淡地描述它，仿佛真的有什么东西一说出口，就会化作烟云飘飞走，再也不回。</p>
<p>最后我选择了Cloye，毫不犹豫地，毁掉了小镇。大概是太感性了吧，看着C菌玩出的拯救小镇的结局最后，棺材上翩翩落下的那只蓝蝴蝶和最后的Max的笑，我感到一阵目眩。经过了23个小时的奋战，我仿佛已经和Max融为了一体：我会感叹超能力滥用的危害，我看着Cloye开心的样子自己也会喜不自胜，看到游戏中周围的场景也恨不得赶紧拍一张，也十分想拥有和Max一样的书画方式，句里话间贯穿着充满浓郁美国西部风味的笑话，但却永远不失简约和得体。我感叹自己身为Max所经历的一切，不断变换的结局，不断迎来的挑战，直到最后才发现可以改变事实的自己有多么无力，才发现Cloye活着才是我唯一想要的。无论最后Cloye是否为此牺牲了，我都会很感慨和Cloye在一起厮混、感慨我成功救下了Kate，感慨自己房间的小清新和Cloye房间的独特，感慨Max和Cloye的那种爱情和友情不断相互叠加，创造出的那种至美至真的情感。</p>
<p>整体上来看，这应该是个悲伤的故事——无论选哪种结局。但是或许也只有悲剧会把生活中的美好撕碎给人看，之后人们才会从那些碎片里面重新拾起向前走的动力吧。</p>
<p>我很想和Max和Cloye做朋友。那一定是一件很幸福的事情吧。</p>
<h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>从现在开始，我开始很惧怕看一部新剧或者玩一部新的游戏。我害怕情节会太妙、人物会太精致导致我沉浸其中无法自拔，正如我看《哈利波特》、我看《言叶之庭》、我玩《生化危机7》、我玩Life is Strange一样，要缓好几天才能缓过来。我会泄气为什么我的生活没有那么多缤纷的元素——没有魔法、没有值得我守护的东西、没有改变时间的超能力、没有跨越鸿沟的极致爱情；我会感慨为什么我没有主人公那种超凡脱俗的品质、惊人的意志或者优秀的人际关系。仿佛每多一部文学作品，就如同我心底黑暗的夜空多了一颗星点，但我却只能蜷缩在远处黑暗的角落，瑟瑟地发着抖，看着天空中的光芒我竟会觉得刺眼，觉得避之不及。不知道什么时候，我连欣赏美好的能力都没了。</p>
<p>确实，虽然上文提到的<code>Obstacles</code>这支歌确实是Life is Strange在我心中最完美的诠释，但是我毫不留情面地把它移出了我的曲库。不在于别的，只是因为我不想再一听某首歌就有想哭的冲动，不想再听一首歌就感到自己有多么孤独。rqy口中的“早在心里哭过了”或许就是这种感觉吧。</p>
<p>我又能做什么呢？无论周围有多少人跟我成天开玩笑啊、斗嘴啊，我真的把他们打心底当作过理解我的人吗？我感觉自己每天就如同一座空壳一样，行尸走肉般地担心着一切。大概我是很难把心敞开给谁的把，或者即使我敞开了我也不认为自己敞开了吧；以此为理由说“大概是因为没有另一半造成的”，也不过是病急乱投医吧。我就仿佛一只迷途的小船，永远不知道自己的下一站在哪里。-</p>
<p>其实说到底，还是我根本不知道如何去生活。之前积累的浮躁让我不知道该如何面对平常人的生活，来到高中之后我才知道“哦，原来努力才是硬道理”。或许是rqy太强了，强到他的光芒洒在我眼前时会让我有种我也可以轻松到达那个高度的错觉——整个高一仿佛只有最后一星期不是浮躁的。</p>
<p>或许，我一直是个很好的$\rm{Admirator}$  (羡慕者)而不是一个好的$\rm{Doer}$(实践者)吧。</p>
<h1 id="4"><a href="#4" class="headerlink" title="$4$"></a>$4$</h1><p>我一直想知道自己现在到底为何而活，活的意义又是什么。</p>
<p>放眼四周全是烟雾弥漫，我畏惧了。</p>
<p>或许只要我强一些，在文化课上、或者在奥赛上取得了骄人的成绩我就可以全身心投入其中一者了。但奈何实力不足，两者都不是我的拿手项。我开始慌了。之前的岁月仿佛都是虚度，自己去年多么弱，今年似乎也并没有什么实质的变化。我开始慌了。</p>
<p>大家都说“不能功利地搞OI啊”，周围mcfx、rqy的成功也都反复论证了这一点。但是我，我…对我而言，似乎没有比这个更高的精神动力了啊。周围异样的目光接踵而来，因为我不是强者，不可能说出什么“走自己的路，让别人说去吧”的豪言壮语——按着传统的步调都不能取胜，自己的步调大概只是飞蛾扑火吧。</p>
<p>我似乎觉得有些奇怪，大概自己本来就不是搞OI的人，或许是个文学家更合适；但是看到期末考试惨不忍睹的语文分数，我又迷茫了；大概自己本来就没有多努力，但是我感觉今年省选前自己已经够努力了啊，或许只是方向错了——但是方向又在哪呢，我又迷茫了。</p>
<p>似乎天地之大，只有我一个人整日沉浸在迷茫之中无法脱身：人与人真是不一样啊。有些人就是可以无问西东、敢想敢干；我则只会是一个杂鱼，睡死在漫无边际的冬日。</p>
<p>每到这个时候，我都好想逃跑，我想跑到Max和Cloye的那个小镇，和他们一起无忧无虑地活着，没有文化课的压力，没有升学的压力，没有豪言壮语的压力，没有OI的压力，就只是简单地活着……最重要的，我可以不思考我为何而活。</p>
<p>当然，以上都是一个高中生的无病呻吟而已。说到底，我还是没有任何勇气的蝼蚁，不知道该怎样直面生活的痛击，不知道如何自在地活，敏感，而颓废。</p>
<blockquote>
<p>除了勇气，我什么都不缺。</p>
</blockquote>
<p>Life is Strange，Max，Cloye，寄托着的，是我遥不可及的一个梦啊。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png" alt=""></p>
<h1 id="5"><a href="#5" class="headerlink" title="$5$"></a>$5$</h1><p>终于我要重新上路了，过去的快乐我想抹去，过去的心酸我想埋葬。眼泪垂青过的土地是翻上来的新泥，在心里死了好几次也必须重生。</p>
<p>至于文学作品，我能想到的最好的结束便是如下：</p>
<blockquote>
<p>或许，<br>每一份精致的艺术作品都是一个有条不紊的世界；<br>有关那个世界的回忆，不如折叠起来，就留在那个世界吧。</p>
</blockquote>
<p>是啊，Max和Cloye的故事，就留给阿卡迪亚湾和他们即将抵达的西雅图吧；秋月孝雄和雪野百香里的故事就留在那个古色古香的雨亭吧。一切的一切都是碎片，在时空里面穿行，倏而消失不见，倏而又出现在我眼前。铭记和沉沦没有意义；这个世界的一切，无论多么无聊与不可期待，明天太阳升起时，便还要继续。</p>
<p>意义？似乎意义这东西本身就是没有意义的。理解生命、理解生活反而是某种屈从，而真正的英雄则是命运的斗士——就好像JO5里面的主角们，坚定地举起反抗命运的大旗。</p>
<p>明日是否如同今日一样沉沦？我不知道。我只知道把握住下一秒就足够了。之前的生活的每一帧仿佛都像是飘在空中的泡影而已，洗刷着存在于虚妄中的记忆，一次一次，如同枷锁一样阻遏着我的前进。</p>
<p>所以，请君勿言什么明天更好之类的P话了，在绝望中求生才是人生的常态。就如同从峭壁中生出的兰花，挤落一捻石尘都是成功。</p>
<hr>
<p>《随想》系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">$Link$</a></p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】Old-NOIP 泛做三</title>
    <url>/2019/07/11/old-NOIP-0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$NOIP2016$以及之前年份$NOIP$中优秀题目的泛做。</p>
<p>以下的题是我做了之后不禁感慨“啊，真是个好题”的题们……</p>
<a id="more"></a>
<p>然后首先打出难度标签：<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p>
<p><del>然后以下题目按照得较高的部分分的难度排序</del></p>
<h1 id="1-2013F-华容道"><a href="#1-2013F-华容道" class="headerlink" title="$  1  2013F$ 华容道"></a>$  1  2013F$ 华容道</h1><p><a href="https://www.luogu.org/problem/P1979" target="_blank" rel="noopener">$Link$</a></p>
<p>可能这道题很难…但是它有70分的暴力分！70分！在loj你甚至可以获得80分！tm这样的话暴力和正解有什么区别吗…从得分的时间分布上来讲，想正解就是大写的不值……</p>
<p>首先我们思考什么信息是有用的，嗯，空白格子的位子和当前棋子的位置，所以只要我们用BFS（而不是DFS，DFS的状态开销极大，但更可能的是我DFS的打开方式不对吧/sigh）的话，状态数就是$O(n^2m^2)$的，然后总复杂度就是$O(qn^2m^2)$，大概是四亿零500万的运算量上限…然而一开始我算成了四千五百万还纳闷为什么开了<code>-O2</code>在1s以内还跑不出来……</p>
<p>先贴个暴力吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)) ;</span><br><span class="line">	ans = Inf, vis[ex][ey][sx][sy] = <span class="number">1</span> ;</span><br><span class="line">	q.push((state)&#123;ex, ey, sx, sy, <span class="number">0</span>, <span class="number">1</span>&#125;) ; </span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		state n = q.front() ; q.pop() ;</span><br><span class="line">		<span class="keyword">if</span> (n.sx == tx &amp;&amp; n.sy == ty) ans = min(ans, n.s) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">			<span class="keyword">int</span> kx = n.bx + dx[k], ky = n.by + dy[k], px, py ; </span><br><span class="line">			<span class="keyword">if</span> (kx == n.sx &amp;&amp; ky == n.sy) </span><br><span class="line">        px = n.bx, py = n.by ; <span class="keyword">else</span> px = n.sx, py = n.sy ;</span><br><span class="line">			<span class="keyword">if</span> (!base[kx][ky] || kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span> || vis[kx][ky][px][py]) <span class="keyword">continue</span> ;</span><br><span class="line">			vis[kx][ky][px][py] = <span class="number">1</span> ;</span><br><span class="line">      q.push((state)&#123;kx, ky, px, py, n.s + <span class="number">1</span>, n.num + <span class="number">1</span>&#125;) ;</span><br><span class="line">		&#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ans &gt;= Inf) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Q ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i][j]) ;</span><br><span class="line">	<span class="keyword">while</span> (Q --) <span class="built_in">cin</span> &gt;&gt; ex &gt;&gt; ey &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty, bfs() ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>喜闻乐见…不过自己打暴力的能力还是不行啊，还得练啊qaq</p>
<p>之后就是更加喜闻乐见的状态压缩。我们思考，这$n^2m^2$个状态都他娘的有鸟用吗（李云龙疾呼态），如果空白格子不在目标格子周围，那么无论空白格子怎么移动都不可能用爱发电。所以我们考虑吧直接预处理出来每个<strong>空白格子与目标格子（即起始格子）相邻的状态</strong>之间的代价，之后直接对此跑个$SPFA$就好了，毕竟最坏情况下SPFA的复杂度也只是$O(nM)$的，大概就是$O(n\cdot 4nm)&lt;\frac{O(n^2m^2)}{7.5}$，也算是很稳的复杂度了。</p>
<p>然后我们思考这样的复杂度是多少。考虑目标格子有$nm$种情况，空白格子在有效情况下只能在其四周，故状态数是$O(4nm)=nm$的。</p>
<p>然后关于代码实现这块需要比较深入的理解。首先我们先预处理出来当当前格子在随便一个格子上，空白格子想要转到另一个方向的步数。这样就可以抽象成一张空白图上先有的一个一个树（也就是一坨森林）。然后为了让这些森林之间能连上边，再将“空白格子和目标格子换了个位置”这种转移连上边（不连的话就不存在从一个格子到另一个格子的转移了）。同时不要忘了对状态的编号。即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _get(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d)&#123; <span class="keyword">return</span> x * <span class="number">120</span> + y * <span class="number">4</span> + d ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> fx, <span class="keyword">int</span> fy, <span class="keyword">int</span> ox, <span class="keyword">int</span> oy, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Id = _get(ox, oy, d) ; </span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis)), </span><br><span class="line">    dis[fx][fy] = <span class="number">1</span>, q.push((state)&#123;fx, fy&#125;) ; </span><br><span class="line"><span class="comment">//    cout &lt;&lt; fx &lt;&lt; " " &lt;&lt; fy &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        state n = q.front() ; </span><br><span class="line">        <span class="keyword">int</span> nx = n.x, ny = n.y ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = nx + dx[k], ky = ny + dy[k] ; </span><br><span class="line">            <span class="keyword">if</span> (kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span>) <span class="keyword">continue</span> ; </span><br><span class="line">            <span class="keyword">if</span> (base[kx][ky] &amp;&amp; !dis[kx][ky] &amp;&amp; (kx != ox || ky != oy)) </span><br><span class="line">                dis[kx][ky] = dis[nx][ny] + <span class="number">1</span>, q.push((state)&#123;kx, ky&#125;) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; <span class="number">3</span>) <span class="keyword">return</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = ox + dx[k], ky = oy + dy[k] ; </span><br><span class="line">        <span class="keyword">if</span> (kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span>) <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="keyword">if</span> (dis[kx][ky] &amp;&amp; (kx != fx || ky != fy) &amp;&amp; base[kx][ky])</span><br><span class="line">            Add(Id, _get(ox, oy, k), dis[kx][ky] - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    Add(Id, _get(fx, fy, d) ^ <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; base[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">         <span class="keyword">if</span> (!base[i][j]) <span class="keyword">continue</span> ;</span><br><span class="line">         <span class="keyword">if</span> (base[i - <span class="number">1</span>][j]) bfs(i - <span class="number">1</span>, j, i, j, <span class="number">0</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i + <span class="number">1</span>][j]) bfs(i + <span class="number">1</span>, j, i, j, <span class="number">1</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i][j - <span class="number">1</span>]) bfs(i, j - <span class="number">1</span>, i, j, <span class="number">2</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i][j + <span class="number">1</span>]) bfs(i, j + <span class="number">1</span>, i, j, <span class="number">3</span>) ; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们考虑在SPFA之前，我们需要求出空白格子从(ex,ey)到(sx, sy)周围需要的步数作为起始点，然后SPFA就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; MAXS ; ++ k) f[k] = Inf, vis[k] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> Id = _get(sx, sy, k), kx = sx + dx[k], ky = sy + dy[k] ;</span><br><span class="line">        <span class="keyword">if</span> (dis[kx][ky]) f[Id] = dis[kx][ky] - <span class="number">1</span>, Q.push(Id), vis[Id] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = Q.front() ; Q.pop() ; vis[n] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; k ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (f[to(k)] &gt; f[n] + E[k].val)&#123;</span><br><span class="line">                f[to(k)] = f[n] + E[k].val ; </span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>, Q.push(to(k)) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-2012C-开车旅行"><a href="#2-2012C-开车旅行" class="headerlink" title="$2~2012C$ 开车旅行"></a>$2~2012C$ 开车旅行</h1><p> <a href="https://www.luogu.org/problem/P1081" target="_blank" rel="noopener">$Link$</a></p>
<p>不得不说2012的题目质量是真心好啊……</p>
<p>首先这题为了看上去不是那么毒瘤，于是加了一个70分的暴力分。然而…细节贼多——或者说只是我不细心，比如说把A和B怎么走看反了、算比值的时候用了个假<code>double</code>之类的……</p>
<p>于是70分好像有个头就会写吧= = 不知道当年什么区分度= =</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Path</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1, v2 ;</span><br><span class="line">    <span class="keyword">int</span> Id1, Id2 ;</span><br><span class="line">&#125;P[MAXN] ; <span class="keyword">int</span> i, j ; <span class="keyword">double</span> o, q ;</span><br><span class="line"><span class="keyword">int</span> res, ans, N, M, T, base[MAXN], s[MAXN], x[MAXN], p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mabs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GO</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> H)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span> ; res = ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (j = S ; j &lt;= N &amp;&amp; j ; u ^= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (u) <span class="keyword">if</span> (res + ans + P[j].v1 &gt; H) <span class="keyword">return</span> ; </span><br><span class="line">      				 <span class="keyword">else</span> res += P[j].v1, j = P[j].Id1 ;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/*pkspks*/</span> <span class="keyword">if</span> (res + ans + P[j].v2 &gt; H) <span class="keyword">return</span> ; </span><br><span class="line">      									<span class="keyword">else</span> ans += P[j].v2, j = P[j].Id2 ;</span><br><span class="line">        <span class="comment">//        cout &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; q = Inf  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; M ;  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;s[i], &amp;x[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = Inf, w = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="built_in">abs</span>(base[i] - base[j]) ;</span><br><span class="line">            <span class="keyword">if</span> (qwq &lt; tp || (qwq == tp &amp;&amp; base[w] &gt; base[j])) </span><br><span class="line">              	tp = qwq, w = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        P[i].Id1 = w, P[i].v1 = tp ; tp = Inf, w = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="built_in">abs</span>(base[i] - base[j]) ;</span><br><span class="line">            <span class="keyword">if</span> (qwq &lt; tp &amp;&amp; (qwq &gt; P[i].v1 || (qwq == P[i].v1 &amp;&amp; base[P[i].Id1] &lt; base[j])))</span><br><span class="line">                tp = qwq, w = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        P[i].Id2 = w, P[i].v2 = tp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    GO(2, T), cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//    GO(4, T), cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//    for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; P[i].v1 &lt;&lt; " " &lt;&lt; P[i].Id1 &lt;&lt; " " &lt;&lt; P[i].v2 &lt;&lt; " " &lt;&lt; P[i].Id2 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line">      GO(i, T) ; o = <span class="number">1.0</span> * res ? (<span class="number">1.0</span> * ans) / (<span class="number">1.0</span> * res) : Inf ; </span><br><span class="line">      <span class="keyword">if</span> (o &lt; q ||(o == q &amp;&amp; base[p] &lt; base[i])) q = o, p = i ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      GO(s[i], x[i]), <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans, res) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后感觉从暴力到正解完全不是一个难度的。首先考虑到底是什么地方阻碍了社会的发展——初始化似乎是$n^2$的，走似乎是$&lt;n^2$的，那么从初始化入手：</p>
<h2 id="rm-Part-1-初始化的优化"><a href="#rm-Part-1-初始化的优化" class="headerlink" title="$\rm{Part~1}$ 初始化的优化"></a>$\rm{Part~1}$ 初始化的优化</h2><p>我们思考如果当前轮到第$i$高的城市了，并且此时所有现存城市中不存在编号在$i$之前的城市，即$i$是最左边的城市，那么对其有用的信息只会在第$i-1,i-2,i+1$或者第$i+2$的城市中选取。这就提示我们似乎如果从值域上考虑就是$O(4n)$的了——只要我们保证不存在在$i$左边的城市、即对应城市不可走的情况。</p>
<p>然后这个时候有个很神仙的想法就是<strong>双向链表优化</strong>，我们考虑按高度排完序之后，对相邻元素建立双向链表。然后<strong>按照从左到右的顺序枚举城市、get信息然后删除掉这个城市</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(BASE A, BASE B)</span></span>&#123; <span class="keyword">return</span> A.h &lt; B.h ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(BASE A, BASE B)</span></span>&#123; <span class="keyword">return</span> A.id &lt; B.id ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inlaw</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123; <span class="keyword">return</span> (pos &gt; N || !pos) ? Inf : <span class="number">0</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; q = Inf  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) pre[i] = i - <span class="number">1</span>, nxt[i] = i + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i].h), base[i].id = i ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; M ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;s[i], &amp;x[i]) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, cmp) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Tid[base[i].id] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Tid[i] ;</span><br><span class="line">        d[<span class="number">1</span>].h = inlaw(pre[t]) + <span class="built_in">abs</span>(base[pre[t]].h - base[t].h),</span><br><span class="line">        d[<span class="number">2</span>].h = inlaw(pre[pre[t]]) + <span class="built_in">abs</span>(base[pre[pre[t]]].h - base[t].h) ;</span><br><span class="line">        d[<span class="number">3</span>].h = inlaw(nxt[t]) + <span class="built_in">abs</span>(base[nxt[t]].h - base[t].h), </span><br><span class="line">        d[<span class="number">4</span>].h = inlaw(nxt[nxt[t]]) + <span class="built_in">abs</span>(base[nxt[nxt[t]]].h - base[t].h) ;</span><br><span class="line">        d[<span class="number">1</span>].id = base[pre[t]].id, d[<span class="number">2</span>].id = base[pre[pre[t]]].id, </span><br><span class="line">        d[<span class="number">3</span>].id = base[nxt[t]].id, d[<span class="number">4</span>].id = base[nxt[nxt[t]]].id, </span><br><span class="line">        sort(d + <span class="number">1</span>, d + <span class="number">5</span>, cmp) ;</span><br><span class="line">        P[i].Id1 = d[<span class="number">1</span>].id, P[i].v1 = d[<span class="number">1</span>].h, </span><br><span class="line">        P[i].Id2 = d[<span class="number">2</span>].id, P[i].v2 = d[<span class="number">2</span>].h ; </span><br><span class="line">        pre[nxt[t]] = pre[t], nxt[pre[t]] = nxt[t] ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后初始化的工作就优化完了。至此可以在<code>Luogu</code>获得75pts的好成绩。</p>
<h2 id="rm-Part-2-走的优化"><a href="#rm-Part-2-走的优化" class="headerlink" title="$\rm{Part~2}$ 走的优化"></a>$\rm{Part~2}$ 走的优化</h2><p>…然而只有第一个优化情况并不会好转多少。查看数据之后发现原来最后几个点的$s$和$x$都完全是随的那种……所以就复杂度爆炸。然后我们考虑这么一个喜闻乐见的事情——限制似乎只有“小于x”和“可以继续走”诶，于是似乎相邻的几步如果都不超过限制是不是就可以一起走？于是想到<strong>倍增预处理</strong>。</p>
<p>我们用$A_{i,j}$表示从i号点开始，走$2^j$<strong>轮</strong>之后$A$走过的路程；同理$B_{i,j}$表示从i号点开始，走$2^j$<strong>轮</strong>之后$B$走过的路程。并且选择用$f_{i,j}$表示从i开始走$2^j$轮之后到达的点。然后值得注意的是最后可能走的不满一整轮，于是特判一下A能不能再走一次就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, cmp2) ;<span class="comment">//重排回来= =</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">    	f[i][<span class="number">0</span>] = P[P[i].Id2].Id1 ;	</span><br><span class="line">    	<span class="keyword">if</span> (P[i].Id2) </span><br><span class="line">        A[i][<span class="number">0</span>] = <span class="built_in">abs</span>(base[P[i].Id2].h - base[i].h) ; </span><br><span class="line">		  <span class="keyword">if</span> (P[P[i].Id2].Id1)</span><br><span class="line">        B[i][<span class="number">0</span>] = <span class="built_in">abs</span>(base[P[i].Id2].h - base[P[P[i].Id2].Id1].h) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">			f[j][i] = f[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>], </span><br><span class="line">			A[j][i] = A[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] + A[j][i - <span class="number">1</span>], </span><br><span class="line">			B[j][i] = B[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] + B[j][i - <span class="number">1</span>] ;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GO</span><span class="params">(<span class="keyword">int</span> S, ll H)</span></span>&#123;</span><br><span class="line">	ans = res = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) </span><br><span class="line">		<span class="keyword">if</span> (f[S][j] &amp;&amp; A[S][j] + B[S][j] &lt;= H) </span><br><span class="line">			ans += A[S][j], res += B[S][j], H -= (A[S][j] + B[S][j]), S = f[S][j] ;</span><br><span class="line">	<span class="keyword">if</span> (A[S][<span class="number">0</span>] &lt;= H) ans += A[S][<span class="number">0</span>] ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-2016B-天天爱跑步"><a href="#3-2016B-天天爱跑步" class="headerlink" title="$3~2016B$ 天天爱跑步"></a>$3~2016B$ 天天爱跑步</h1><p><a href="https://www.luogu.org/problem/P1600" target="_blank" rel="noopener">$Link$</a></p>
<p>……当年的毒瘤题，还记得那还是我第一次参加NOIP（普及组），不出所料地考挂，然后rqy不出所料地考好……</p>
<p>咳，偏题了，然后对于这道题，我索性把每个部分分都写了一遍：</p>
<h2 id="rm-Part-1-25pts"><a href="#rm-Part-1-25pts" class="headerlink" title="$\rm{Part~1}$ 25pts"></a>$\rm{Part~1}$ 25pts</h2><p>$n,m\leq 1000$</p>
<p>其实就是LCA一下然后$nm$的统计答案就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	fa[now][<span class="number">0</span>] = f, dep[now] = dep[f] + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; <span class="keyword">else</span> build(to(k), now) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">	h = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ; </span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= h ; ++ j)</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">			fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dep[u] &lt; dep[v]) u ^= v ^= u ^= v ; l = dep[u] - dep[v] ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (dep[fa[u][k]] &gt;= dep[v]) u = fa[u][k] ;</span><br><span class="line">	<span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ; <span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k] ; <span class="keyword">return</span> fa[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), Add(x, y) ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">0</span>), Setup() ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s[i], &amp;e[i]), </span><br><span class="line">  	lca1[i] = t = lca(s[i], e[i]), </span><br><span class="line">  	_up[i] = -(dep[t] &lt;&lt; <span class="number">1</span>) + (dep[s[i]] + dep[e[i]]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i, <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans), ans = <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j) t = lca(e[j], i), p = lca(s[j], i), </span><br><span class="line">  			w1 = -(dep[p] &lt;&lt; <span class="number">1</span>) + (dep[i] + dep[s[j]]), </span><br><span class="line">  			w2 = dep[i]  +  dep[e[j]] -  (dep[t] &lt;&lt; <span class="number">1</span>), </span><br><span class="line">  		  ans += (w1 == base[i]) * (_up[j] == w1 + w2) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Part-2-15pts"><a href="#rm-Part-2-15pts" class="headerlink" title="$\rm{Part~2}$ 15pts"></a>$\rm{Part~2}$ 15pts</h2><p>这部分是链，保证$i$到$i+1$有一条边。</p>
<p>那么其实这个问题就转化成了在一个序列上，与点$i$相隔恰好为$t[i]$的点的个数，顺便注意判断一下走没走完就好。但是这个地方我用了一个肥肠zz的写法，就是每次加完之后删除到这个点停止的那些点，而“那些点”的求法则是我手写了一个很诡异的二分……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tink&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Nodes</span>&#123;</span></span><br><span class="line">		<span class="keyword">int</span> s, e, n ;</span><br><span class="line">	&#125;u[MAXN], v[MAXN] ; <span class="keyword">int</span> t1, t2 ;</span><br><span class="line">	<span class="keyword">int</span> be[MAXN], bs[MAXN], res[MAXN], k1 = <span class="number">0</span>, k2 = <span class="number">0</span> ;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Nodes a, Nodes b)</span> </span>&#123; <span class="keyword">return</span> a.e &lt; b.e ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Nodes a, Nodes b)</span> </span>&#123; <span class="keyword">return</span> a.e &gt; b.e ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">bool</span> m)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">1</span>, r = (m ? k2 : k1) + <span class="number">1</span> , mid, l0, l1 ; </span><br><span class="line">		<span class="keyword">if</span> (!m)&#123;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (u[mid].e &lt; p) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">			&#125; l0 = l, l = <span class="number">1</span>, r = k1 + <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (u[mid].e &lt; p + <span class="number">1</span>) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">			&#125; l1 = l ; </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = l0 ; i &lt; l1 ; ++ i) bs[u[i].s] -- ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (v[mid].e &lt; p) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">			&#125; l0 = l, l = <span class="number">0</span>, r = k2 + <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">				<span class="keyword">if</span> (v[mid].e &lt; p + <span class="number">1</span>) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">			&#125; l1 = l ;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = l0 ; i &lt; l1 ; ++ i) be[v[i].s] -- ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) &#123;</span><br><span class="line">			t1 = qr(), t2 = qr() ; </span><br><span class="line">			<span class="keyword">if</span> (t1 &lt; t2) bs[t1] ++, u[++ k1] = (Nodes)&#123;t1, t2, k1&#125; ;</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/**/</span>be[t1] ++, v[++ k2] = (Nodes)&#123;t1, t2, k2&#125; ;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(u + <span class="number">1</span>, u + k1 + <span class="number">1</span>, cmp1) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) res[i] += bs[i - base[i]], del(i, <span class="number">0</span>) ;	</span><br><span class="line">		sort(v + <span class="number">1</span>, v + k2 + <span class="number">1</span>, cmp1) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">1</span> ; -- i) res[i] += be[i + base[i]], del(i, <span class="number">1</span>) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="built_in">cout</span> &lt;&lt; res[p] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Part-3-20pts"><a href="#rm-Part-3-20pts" class="headerlink" title="$\rm{Part~3}$ 20pts"></a>$\rm{Part~3}$ 20pts</h2><p>保证所有起点都在根（1号点）。</p>
<p>其实这个部分也是挺水的。就是考虑一个树形DP即可。然后判断也很好判断，如果这个点的开眼时间正好是根到它的距离（深度差），那么就会一定会满足到它的点和到它的子树内的所有的点。否则就肯定不行，也就是一个都不满足。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[MAXN], dis[MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">            dis[to(k)] = dis[now] + <span class="number">1</span>, sum += dfs(to(k), now) ; </span><br><span class="line"> 		&#125;</span><br><span class="line"> 		dp[now] += sum ; <span class="keyword">return</span> dp[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)), dis[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) dp[e[i]] ++ ; dp[<span class="number">1</span>] = dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">          	<span class="keyword">if</span> (base[i] == dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, dp[i]) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是现在就有了60pts的优秀分数。似乎这样的话就可以直接把剩下的部分弃了去写T3的期望DP辽233</p>
<h2 id="rm-Part-4-and-5-40pts"><a href="#rm-Part-4-and-5-40pts" class="headerlink" title="$\rm{Part~4~and~5}$  40pts"></a>$\rm{Part~4~and~5}$  40pts</h2><p>剩下的部分没有选择分开写<del>所以就不算谢了每个部分分是不是</del>，因为剩下的两个部分实在是太像了，都要用到一种思想——<strong>桶</strong>. <del>其实80pts还有一种不是很想写的写法在这里就留个图吧：</del></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<p>然后我们思考桶的解法。我们把每一段路程拆成向上和向下两段。下文中设$x$为当前节点。</p>
<ul>
<li><p>对于向上的路径</p>
<ul>
<li>首先可以产生贡献的点就是子树内的$buc[dep[x]+ base[x]]$，这个我们用作差来求解（原因是我们可能会遍历许多棵子树所以会产生数值相同但不合法的贡献）。</li>
<li>其次我们需要知道，如果一个人的起点和终点的LCA在子树内但不是$x$，那么也不会产生贡献。解决方案是每次dfs完一个点向上回溯的时候删除掉子树内所有以该点为LCA的点。</li>
<li>同时也需要我们更新以该节点为起点的路径的桶。</li>
</ul>
</li>
<li><p>对于向下的路径</p>
<ul>
<li>首先对于一条路径$(u,v)$，当对点i产生贡献时可以推出来式子：</li>
</ul>
<script type="math/tex; mode=display">
dep_v-dis_{u,v}=dep_i-base_i</script><pre><code> 那么也就是说我们可以通过把每条路径的$dep_v-dis_{u,v}$压到桶里面，然后每次计算贡献。
</code></pre><ul>
<li>同时我们还是需要消除贡献，即消除那些对于儿子而言在父亲那里停止的路径，方法就是在向下迭代之前先把所有以当前点为终点的贡献加上，到儿子时通过作差就可以减去这部分。注意向上回溯时还是需要删除那些蜷缩在子树内的路径。</li>
</ul>
</li>
</ul>
<p>之后还有需要注意的，就是如果在一条路径的LCA处正好可以观察到这条路径，那么就需要<code>-1</code>，因为我们上升下降统计了两遍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Prepare&#123; <span class="comment">//25</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	    E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	    fa[now][<span class="number">0</span>] = f, dep[now] = dep[f] + <span class="number">1</span>, H = max(H, dep[now]) ;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)</span><br><span class="line">	        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; <span class="keyword">else</span> build(to(k), now) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    h = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ; </span><br><span class="line">	    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= h ; ++ j)</span><br><span class="line">        	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    	        fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (dep[u] &lt; dep[v]) u ^= v ^= u ^= v ; l = dep[u] - dep[v] ; </span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (dep[fa[u][k]] &gt;= dep[v]) u = fa[u][k] ;</span><br><span class="line">	   	<span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ; <span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k] ; <span class="keyword">return</span> fa[u][<span class="number">0</span>] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">	    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">wo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="keyword">return</span> -(dep[c] &lt;&lt; <span class="number">1</span>) + (dep[a] + dep[b]) ; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> pks&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> Prepare ;</span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v1[MAXN], v2[MAXN], v3[MAXN] ;</span><br><span class="line">	<span class="keyword">int</span> buc_d[MAXN &lt;&lt; <span class="number">2</span>], buc_u[MAXN &lt;&lt; <span class="number">2</span>], ans[MAXN] ;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> co = base[now] + dep[now], ks ; <span class="keyword">if</span> (co &lt;= H) ks = buc_d[co] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next) <span class="keyword">if</span> (fa ^ to(k)) dfs1(to(k), now) ;</span><br><span class="line">		buc_d[dep[now]] += cnbt[now] ; <span class="keyword">if</span> (co &lt;= H) ans[now] = buc_d[co] - ks ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v1[now].size() ; ++ k) -- buc_d[dep[v1[now][k]]] ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> co = dep[now] - base[now] + N, ks = buc_u[co] ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v2[now].size() ; ++ k) ++ buc_u[v2[now][k] + N] ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next) <span class="keyword">if</span> (fa ^ to(k)) dfs2(to(k), now) ;</span><br><span class="line">		ans[now] += buc_u[co] - ks ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v3[now].size() ; ++ k) -- buc_u[v3[now][k] + N] ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Solve5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      cnbt[s[i]] ++, v1[LCA[i]].push_back(s[i]) ; dfs1(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      v2[e[i]].push_back(dep[e[i]] - _up[i]), </span><br><span class="line">    	v3[LCA[i]].push_back(dep[e[i]] - _up[i]) ;  dfs2(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (dep[s[i]] - dep[LCA[i]] == base[LCA[i]]) -- ans[LCA[i]] ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Prepare ; <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) x = qr(), y = qr(), Add(x, y) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s[i], &amp;e[i]) ;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>), Setup() ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      LCA[i] = lca(s[i], e[i]), _up[i] = wo(s[i], e[i], LCA[i]) ; </span><br><span class="line">    pks :: Solve5() ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，然后这道题就完了。不得不说虽然当时用心做了，但是过上几周再反过头来看还是觉得有些细节理解的并不到位、或者说是满分做法中的有些流程当时根本没有仔细推导。</p>
<p>不过不得不说这个题还是非常妙的。或许有时候题面复杂、需求复杂会让人忘记这道题到底有多巧妙…反正就是感觉这道题用“桶+即时修改”这个组合思想还是很<code>nice</code>的。</p>
<h1 id="4-2012F-疫情控制"><a href="#4-2012F-疫情控制" class="headerlink" title="$4~2012F$ 疫情控制"></a>$4~2012F$ 疫情控制</h1><p><a href="https://www.luogu.org/problem/P1084" target="_blank" rel="noopener">$Link$</a></p>
<p>…这个题之所以放在最后一个是因为我真的不知道部分分该怎么写啊。</p>
<p>嗯，首先是二分，这倒是可以想到。之后一开始想的是似乎不断把城市向上移动就好了，毕竟越靠上越优；但是样例就把我这种写法卡掉了，原因很浅显，我忽略了绕过根继续走的那些点可以继续产生贡献……于是就很GG。</p>
<p>…于是我选择统计了那些可以跨越根的节点。对于最终每个被覆盖的节点，我用的是直接更新<code>vector</code>预处理出来挂在每个点底下的叶子节点，check的时候直接判一下每个节点的mark。然而这样写的很繁琐，并且复杂度也是个迷…最后只能不了了之了</p>
<p>所以大概这个题我想出了50%~60%？…然而还是没有分数。</p>
<h2 id="rm-Part-1-倍增！倍增！倍增！"><a href="#rm-Part-1-倍增！倍增！倍增！" class="headerlink" title="$\rm{Part~1}$ 倍增！倍增！倍增！"></a>$\rm{Part~1}$ 倍增！倍增！倍增！</h2><p>首先喜闻乐见的是，我们向上跳的时候van♂全可以用倍增来搞，只要预处理出$2^k$级祖先就好了。</p>
<p>然后注意顺便判断一下可不可以拐弯，即跳到根之后是否在二分的时间内可以继续向下跳。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; Army[MAXN], Pest[MAXN] ;</span><br><span class="line"><span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line"><span class="built_in">memset</span>(Army, <span class="number">0</span>, <span class="keyword">sizeof</span>(Army)) ;</span><br><span class="line"><span class="built_in">memset</span>(Pest, <span class="number">0</span>, <span class="keyword">sizeof</span>(Pest)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    t = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (!fa[t][j] || Sum[base[i]] - Sum[fa[t][j]] &gt; x) <span class="keyword">continue</span> ; </span><br><span class="line">  			<span class="keyword">else</span> t = fa[t][j] ;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) res[t] = <span class="number">1</span> ; </span><br><span class="line">  			<span class="keyword">else</span> &#123; </span><br><span class="line">          	t = base[i] ; </span><br><span class="line">          	<span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) </span><br><span class="line">              	<span class="keyword">if</span> (fa[t][j] &gt; <span class="number">1</span>) t = fa[t][j] ; </span><br><span class="line">          	Army[++ n] = mp(x - Sum[base[i]], t) ; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Part-2-转化！转化！转化！"><a href="#rm-Part-2-转化！转化！转化！" class="headerlink" title="$\rm{Part~2}$ 转化！转化！转化！"></a>$\rm{Part~2}$ 转化！转化！转化！</h2><p>这个地方有个肥肠有意思的点，就是我们思考假设一个叶子节点没有被覆盖，那么就说明一定存在它的某一级祖先的整棵子树没有被覆盖。那么这就提示我们可以考虑<strong>直接判断根的每个儿子是否都被覆盖了（树形结构的优越性）</strong> </p>
<p>嗯，于是对于我们上一部分打完mark之后的那些点（暂时是只有不会拐弯的被打了mark），我们直接考虑不进行一次$O(n)$的<code>dfs</code>就可以完成<code>push_up</code>的操作。</p>
<p>然后我们考虑如何操作那些可以拐弯的点。思考最优的方案一定是越高越好，所以不妨就让他拐过来之后落在根的儿子上。于是我们需要统计这个的代价，并对收集来的两个信息分别排序。之后就直接双指针扫一遍根的全部儿子，看看是否全部都被覆盖了即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> x = <span class="number">1</span>, y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa[rt][<span class="number">0</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">        push_down(to(k)) ; x &amp;= res[to(k)] ; y = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">1</span> &amp;&amp; x &amp;&amp; y) res[rt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">	push_down(<span class="number">1</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>] ; k ; k = E[k].next) </span><br><span class="line">  	<span class="keyword">if</span> (res[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> Pest[++ m] = mp(E[k].v, to(k)) ;</span><br><span class="line">	j = <span class="number">1</span> ; sort(Army + <span class="number">1</span>, Army + n + <span class="number">1</span>, cmp), sort(Pest + <span class="number">1</span>, Pest + m + <span class="number">1</span>, cmp) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">  	  <span class="keyword">if</span> (!res[Army[i].sc]) res[Army[i].sc] = <span class="number">1</span> ;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (Army[i].fr &gt;= Pest[j].fr) res[Pest[j].sc] = <span class="number">1</span> ;</span><br><span class="line">    	<span class="keyword">while</span> (res[Pest[j].sc] &amp;&amp; j &lt;= m) ++ j ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j &gt; m ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，贴个总程序吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> cnt, head[MAXN], n, m ; <span class="keyword">bool</span> res[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, P, Sum[MAXN], ans, base[MAXN], fa[MAXN][<span class="number">25</span>], i, j, l, r, mid ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    P += w ;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; Army[MAXN], Pest[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span></span>&#123; <span class="keyword">return</span> a.fr &lt; b.fr ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">        Sum[to(k)] = Sum[now] + E[k].v ; dfs(to(k), now) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> x = <span class="number">1</span>, y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa[rt][<span class="number">0</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">        push_down(to(k)) ; x &amp;= res[to(k)] ; y = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">1</span> &amp;&amp; x &amp;&amp; y) res[rt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t ; n = m = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Army, <span class="number">0</span>, <span class="keyword">sizeof</span>(Army)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Pest, <span class="number">0</span>, <span class="keyword">sizeof</span>(Pest)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        t = base[i] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (!fa[t][j] || Sum[base[i]] - Sum[fa[t][j]] &gt; x) <span class="keyword">continue</span> ; <span class="keyword">else</span> t = fa[t][j] ;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) res[t] = <span class="number">1</span> ; <span class="keyword">else</span> &#123; t = base[i] ; <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) <span class="keyword">if</span> (fa[t][j] &gt; <span class="number">1</span>) t = fa[t][j] ; Army[++ n] = mp(x - Sum[base[i]], t) ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(<span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>] ; k ; k = E[k].next) <span class="keyword">if</span> (res[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> Pest[++ m] = mp(E[k].v, to(k)) ;</span><br><span class="line">    j = <span class="number">1</span> ; sort(Army + <span class="number">1</span>, Army + n + <span class="number">1</span>, cmp), sort(Pest + <span class="number">1</span>, Pest + m + <span class="number">1</span>, cmp) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!res[Army[i].sc]) res[Army[i].sc] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Army[i].fr &gt;= Pest[j].fr) res[Pest[j].sc] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (res[Pest[j].sc] &amp;&amp; j &lt;= m) ++ j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j &gt; m ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> a, b, c ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), Add(a, b, c) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; dfs(<span class="number">1</span>, <span class="number">0</span>) ; Init() ;</span><br><span class="line">    l = <span class="number">0</span>, r = P ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid - <span class="number">1</span>, ans = mid ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Afterword"><a href="#rm-Afterword" class="headerlink" title="$\rm{Afterword}$"></a>$\rm{Afterword}$</h1><p>其实总感觉自己做这些题还是有些力不从心233</p>
<p>不得不说类似于“二分答案”这种东西是很有OI风味的，毕竟是一种特殊的思想…不知道自己什么时候能把类似的所有思想真正地打包学会啊qaq</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>技巧/倍增</tag>
        <tag>贪心</tag>
        <tag>树模型</tag>
        <tag>奇怪的技巧</tag>
        <tag>搜索/剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】Old-NOIP 泛做一</title>
    <url>/2019/07/11/old-noip/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先简介一下这篇文章的来历……</p>
<p>此时的我正在瞎翻之前做过的、看起来还可以的NOIP水题，觉得哪个地方值得注意就整了下来。然而实际上我是只想整理“泛做二”里的题目。不过一想似乎自己基础不扎实，于是才有了这篇水文。</p>
<a id="more"></a>
<h1 id="1-2013B-火柴排队"><a href="#1-2013B-火柴排队" class="headerlink" title="$1~2013B$ 火柴排队"></a>$1~2013B$ 火柴排队</h1><p><a href="https://www.luogu.org/problem/P1966" target="_blank" rel="noopener">Link</a></p>
<p>这真是个水题。但是之前做的时候没意识到一些问题，前几天翻来看看又把这个题秒了一遍。</p>
<p>观察整个式子，我们拆开之后就发现是在最小化$-\sum a_ib_i$，也就是最大化$\sum a_ib_i$。然后根据选修4-5里面的<strong>排序不等式</strong>，逆序和&lt;乱序和&lt;顺序和，直接找逆序对就好。</p>
<p><del>偷偷学数学真有用啊/kk</del></p>
<h1 id="2-2014C-飞扬的小鸟"><a href="#2-2014C-飞扬的小鸟" class="headerlink" title="$2 ~2014C$ 飞扬的小鸟"></a>$2 ~2014C$ 飞扬的小鸟</h1><p><a href="https://www.luogu.org/problem/P1941" target="_blank" rel="noopener">Link</a></p>
<p>……一道gou题。</p>
<p>当时全天下都知道状态$f_{i,j}$就我不会转移…背包其实挺显然的，上升的时候做完全背包，注意由于即使🐦在天花板里面($h= m$)时也可以跳，所以多转移几次， 且注意既可以从i-1转移过来，也可以从现在的i转移过来；下降的时候做反向值域的01背包。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; ans = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;up[i], &amp;dw[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      Wd[i][<span class="number">0</span>] = <span class="number">-1</span>, Wd[i][<span class="number">1</span>] = M + <span class="number">1</span> ; <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k), S[k] = <span class="number">1</span>, <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;Wd[k][<span class="number">0</span>], &amp;Wd[k][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">/*for (i = 2 ; i &lt;= N ; ++ i)</span></span><br><span class="line"><span class="comment">        for (j = Wd[i][0] + 1 ; j &lt; Wd[i][1] ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            dp[i][j] = dp[i - 1][j + dw[i]] ;</span></span><br><span class="line"><span class="comment">            for (k = 0 ; k &lt;= (j - Wd[i - 1][0] - 1) / up[i] ; ++ k)</span></span><br><span class="line"><span class="comment">                dp[i][j] = min(dp[i - 1][j - k * up[i]] + k, dp[i][j]) ;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = up[i] + <span class="number">1</span> ; j &lt;= M + up[i] ; ++ j)</span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j - up[i]], dp[i][j - up[i]]) + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = M + <span class="number">1</span> ; j &lt;= M + up[i] ; ++ j) </span><br><span class="line">          	dp[i][M] = min(dp[i][M], dp[i][j]) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M - dw[i] ; j ++) </span><br><span class="line">          	dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][j + dw[i]]) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= Wd[i][<span class="number">0</span>] ; ++ j) dp[i][j] = Inf ; </span><br><span class="line">      	<span class="keyword">for</span> (j = Wd[i][<span class="number">1</span>] ; j &lt;= M ; j ++) dp[i][j] = Inf ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) ans = min(ans, dp[N][i]) ; </span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">19260817</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, <span class="number">1</span>, ans),<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) S[i] = S[i - <span class="number">1</span>] + S[i] ; l = <span class="number">1</span>, r = N, p ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = Inf ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) ans = min(ans, dp[mid][i]) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">19260817</span>) l = mid + <span class="number">1</span>, p = mid ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; S[p] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-2001C-统计单词数"><a href="#3-2001C-统计单词数" class="headerlink" title="$3~2001C$ 统计单词数"></a>$3~2001C$ 统计单词数</h1><p><a href="https://www.luogu.org/problem/P1026" target="_blank" rel="noopener">$Link$</a> 一道很水的DP，难点（如果可以称之为难的话）在于判断。然后此处用的是哈希，判断的时候就瞎判就好了（雾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p ; </span><br><span class="line"><span class="keyword">char</span> D[MAXLEN][<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">const</span> UN LL base = <span class="number">131</span> ;</span><br><span class="line">LL Hash[MAXLEN][MAXLEN], H[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">stack</span>&lt; pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; s, s2 ;</span><br><span class="line"><span class="keyword">const</span> UN LL Mod = <span class="number">192183781721L</span>L ;</span><br><span class="line"><span class="keyword">int</span> dp[MAXLEN][<span class="number">50</span>], Len, Length[<span class="number">10</span>], o ;</span><br><span class="line"><span class="keyword">int</span> P, M, K, i, j, k, di, dj ; <span class="keyword">char</span> S[MAXLEN] ;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Hashh</span><span class="params">(<span class="keyword">int</span> Mark)</span></span>&#123;</span><br><span class="line">	UN LL res = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (!Mark) &#123;</span><br><span class="line">		<span class="keyword">for</span> (k = j ; k &lt;= i ; ++ k)</span><br><span class="line">			res = (res * base + S[k]) % Mod ; </span><br><span class="line">		<span class="keyword">return</span> res ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= Length[Mark] ; ++k)</span><br><span class="line">		res = (res * base + D[Mark][k]) % Mod ;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	LL res[<span class="number">7</span>] ;</span><br><span class="line">	<span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">	<span class="keyword">for</span> (di = <span class="number">1</span>; di &lt;= M ; ++ di)</span><br><span class="line">		<span class="keyword">for</span> (dj = x ; dj &lt;= y - Length[di] ; ++ dj)</span><br><span class="line">			<span class="keyword">if</span> (Hash[dj][dj + Length[di]] == H[di]) ++ res[di] ;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">		p = s.top() ;</span><br><span class="line">		res[p.first] &gt; res[p.second] ? res[p.second] : res[p.first] = <span class="number">0</span> ; </span><br><span class="line">		s.pop(), s2.push(p) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!s2.empty()) s.push(s2.top()), s2.pop() ;</span><br><span class="line">	<span class="keyword">return</span> res[<span class="number">1</span>] + res[<span class="number">2</span>] + res[<span class="number">3</span>] + res[<span class="number">4</span>] + res[<span class="number">5</span>] + res[<span class="number">6</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; P &gt;&gt; K ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; P ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%20s"</span>, S + i * <span class="number">20</span>) ;	<span class="built_in">cin</span> &gt;&gt; M ; Len = <span class="built_in">strlen</span>(S) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, D[i]), Length[i] = <span class="built_in">strlen</span>(D[i]) - <span class="number">1</span>, H[i] = Hashh(i) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; i ; ++ j)&#123;</span><br><span class="line">			<span class="keyword">bool</span> flag = <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">for</span> (di = <span class="number">0</span> ; di &lt;= min(Length[j], Length[i]) ; ++ di)</span><br><span class="line">				<span class="keyword">if</span> (D[j][di] != D[i][di])&#123; flag = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">			<span class="keyword">if</span> (flag) s.push(&#123;i, j&#125;), ++ o ;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= i ; ++ j) </span><br><span class="line">			Hash[j][i] = Hashh(<span class="number">0</span>) ;</span><br><span class="line">	<span class="comment">/*for (i = 0 ; i &lt; Len ; ++ i) </span></span><br><span class="line"><span class="comment">		for (j = 0 ; j &lt; i ; ++ j) </span></span><br><span class="line"><span class="comment">			printf("%d%c", Sum(j, i)," \n"[j == i - 1]) ;*/</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= K ; ++ k)</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (j = k - <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">				dp[i][k] = max(dp[i][k], dp[max(<span class="number">0</span>, j - <span class="number">1</span>)][k - <span class="number">1</span>] + Sum(j, i)) ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dp[Len - <span class="number">1</span>][K] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-2005B-过河"><a href="#4-2005B-过河" class="headerlink" title="$4~2005B$ 过河"></a>$4~2005B$ 过河</h1><p><a href="https://www.luogu.org/problem/P1052" target="_blank" rel="noopener">$Link$</a></p>
<p>也是一道很水的DP。整理这个题的原因是因为好久之前的当时做这题时用了一种诡异的做法，即通过对$\sqrt{1e9}$取模进行压缩，但是这显然不对因为1：我的写法没有处理mod之后位置相同的情况；再者转移过程也十分地不服责任：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mod=<span class="number">32501</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">bool</span> pos[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,l,r,m,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x; <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">		pos[x%mod]=<span class="number">1</span>;	<span class="keyword">if</span>(l==r&amp;&amp;x%l==<span class="number">0</span>)cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;	<span class="built_in">cout</span>&lt;&lt;cnt; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mod;i++) f[i]=MAXN;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mod;i++)</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)&#123;</span><br><span class="line">		<span class="keyword">int</span> k=i%mod;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=j)f[i]=min(f[i],f[i-j]+pos[k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[mod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但问题是，它过了，这就很迷。仔细想想，似乎可能是因为石头数量太小了，只有100，所以随机丢到空间里去期望意义上每$1e7$会有一块石头，且mod之后位于同一个位置的概率的相反数是$32501$，所以很难有这种数据出现……换句话说，数据水死了。</p>
<p>然而真正的做法应该是“2520缩”，意思就是因为题目中的 s~t 的取值范围是 1~10，所以取$lcm(1,2,..,10)=2520$是可行的。</p>
<h1 id="5-2009B-Hankson的趣味题"><a href="#5-2009B-Hankson的趣味题" class="headerlink" title="$5~2009B$ Hankson的趣味题"></a>$5~2009B$ Hankson的趣味题</h1><p><a href="https://www.luogu.org/problem/P1072" target="_blank" rel="noopener">$Link$</a></p>
<p>整这个题只是因为情怀……</p>
<p>遥不可及的过去啊……<a href="https://pks-loving.blog.luogu.org/solution-p1072" target="_blank" rel="noopener">Solution</a></p>
<h1 id="6-2004D-虫食算"><a href="#6-2004D-虫食算" class="headerlink" title="$6~2004D$ 虫食算"></a>$6~2004D$ 虫食算</h1><p><a href="https://www.luogu.org/problem/P1092" target="_blank" rel="noopener">$Link$</a></p>
<p>整这个题更是因为情怀了……</p>
<p>当时是何时？不记得是末冬还是暑假，只记得我十分开心地去高中部培训，吃早饭之前跟rqy瞎聊，聊什么“是不是只要我发明出可以处理负权边的Dijkstra就可以上清华了”，不自觉地聊到了这道题。嗯…场景什么的都历历在目，尤其是餐厅东边洒落的白色的阳光，一直在我的记忆中闪亮…</p>
<p>可惜我不是当年那个我了，rqy也不是当年那个rqy了，大家都在迈着自己的步子踏实地前进，终于还是会分道扬镳吧……</p>
<p>诶诶我在干什么，qaq，学习，学习……</p>
<p>暴力就是枚举全排列，但显然只有30pts。 于是考虑一个可行性剪枝，其实就是每次dfs刚开始先check一遍合不合法。但是整理这个题的目的也不在于此，而在于其中的<code>pos</code>数组，其实就是用来记录从低位到高位每个未知数的出现顺序的。那么实际上这也是一个优秀的剪枝，因为在dfs里面我们可以根据此对靠近低位的未知数先赋值、先判断（第一个剪枝）。</p>
<p>所以大概就是可行性剪枝和最优性剪枝相辅相成的结果，比较巧妙。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> _Char ; <span class="keyword">int</span> pos[MAX] ;</span><br><span class="line"><span class="keyword">int</span> Ans[MAX] ; <span class="keyword">bool</span> mark[MAX] ;</span><br><span class="line"><span class="keyword">int</span> N, A[MAX], B[MAX], C[MAX], tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i) <span class="built_in">cout</span> &lt;&lt; Ans[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> NA = Ans[A[i]], NB = Ans[B[i]], NC = Ans[C[i]] ;</span><br><span class="line">        <span class="keyword">if</span>((NA + NB + X) % N != NC) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        X = (NA + NB + X) / N ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Speed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Ans[A[<span class="number">0</span>]] + Ans[B[<span class="number">0</span>]] &gt;= N) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">        <span class="keyword">int</span> NA = Ans[A[i]], NB = Ans[B[i]], NC = Ans[C[i]] ;</span><br><span class="line">        <span class="keyword">if</span> (NA == <span class="number">-1</span> || NB == <span class="number">-1</span> || NC == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> ((NA + NB) % N != NC &amp;&amp; (NA + NB + <span class="number">1</span>) % N != NC) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Speed()) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (sum == N + <span class="number">1</span>)&#123;<span class="keyword">if</span> (Judge()) Print() ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">        <span class="keyword">if</span>(!mark[i])&#123;</span><br><span class="line">            Ans[pos[sum]] = i, mark[i] = <span class="number">1</span> ;</span><br><span class="line">            dfs(sum + <span class="number">1</span>) ;</span><br><span class="line">            Ans[pos[sum]] = <span class="number">-1</span>, mark[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work_pos</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>(!mark[x])  mark[x] = <span class="number">1</span>,  pos[++ tot] = x ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    fill(Ans, Ans + MAX + <span class="number">2</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; A[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; B[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; C[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i) </span><br><span class="line">      work_pos(A[i]), work_pos(B[i]), work_pos(C[i]) ;</span><br><span class="line">    fill(mark, mark + MAX + <span class="number">2</span>, <span class="number">0</span>) ; dfs(<span class="number">1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-Afterword"><a href="#rm-Afterword" class="headerlink" title="$\rm{Afterword}$"></a>$\rm{Afterword}$</h1><blockquote>
<p>遥望扬州满地雪，不知已是惊蛰节。</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>奇怪的技巧</tag>
        <tag>动态规划/背包模型</tag>
        <tag>NOIP系列</tag>
        <tag>数学/不等式</tag>
        <tag>搜索/剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【泛做】Old-NOIP 泛做二</title>
    <url>/2019/07/11/Old-NOIP2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>事实上我不久前才发现原来NOIP里面的一些题是很好的……</p>
<p>然后大概接下来整理的都是些我认为挺有难度的吧qwq</p>
<p>但是感觉似乎这么好的题放在一块有点憋屈……于是就缩短了篇幅增多了篇目</p>
<a id="more"></a>
<h1 id="1-2011F-观光公交"><a href="#1-2011F-观光公交" class="headerlink" title="$1~2011F$ 观光公交"></a>$1~2011F$ 观光公交</h1><p><a href="https://www.luogu.org/problem/P1315" target="_blank" rel="noopener">$Link$</a></p>
<p>这题我还是去年的3月19号做的，显然是抄的题解，于是现在又要重做一遍/sad</p>
<p>那么其实贪心的思路很简单，找最多人经过的那条路。由于$n$是$1000$所以直接$O(nk)$的暴力就很稳了。然后注意消除后效性——大体上就是如果你这一站用了什么“氮气加速”，结果下一站还得在那等着，就没有任何作用了，这种情况就<code>gg[i]=i+1</code>，你只能拯救下一站下车的乘客；否则你也可以拯救更多的，就是<code>gg[i]=gg[i+1]</code>，也算是一种状态转移的思想吧。在我看来似乎这是本题唯一的难点了……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> w,f,t;</span><br><span class="line">&#125;p[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> max_each[<span class="number">100001</span>],sum_max[<span class="number">100001</span>],get[<span class="number">100001</span>],time[<span class="number">100001</span>],gg[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m,k,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">cin</span>&gt;&gt;time[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;p[i].w&gt;&gt;p[i].f&gt;&gt;p[i].t;</span><br><span class="line">    	max_each[p[i].f] = max(p[i].w,max_each[p[i].f]);</span><br><span class="line">      sum_max[p[i].t]++ ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">			sum_max[i]+=sum_max[i<span class="number">-1</span>];</span><br><span class="line">		get[<span class="number">1</span>]=max_each[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">			get[i]=max(get[i<span class="number">-1</span>],max_each[i<span class="number">-1</span>])+time[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">			ans+=(get[p[i].t]-p[i].w);</span><br><span class="line">		&#125;<span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">  	    gg[n]=gg[n<span class="number">-1</span>]=n;</span><br><span class="line">				<span class="keyword">int</span> maxn=<span class="number">0</span>,f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">      	  gg[i]=get[i+<span class="number">1</span>]&lt;=max_each[i+<span class="number">1</span>]?i+<span class="number">1</span>:gg[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        	<span class="keyword">if</span>(sum_max[gg[i]]-sum_max[i]&gt;maxn&amp;&amp;time[i])&#123;</span><br><span class="line">            maxn=sum_max[gg[i]]-sum_max[i];f=i;</span><br><span class="line">        	&#125;</span><br><span class="line">        ans-=maxn;time[f]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)get[i]=max(get[i<span class="number">-1</span>],max_each[i<span class="number">-1</span>])+time[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>拿什么拯救我当年幼稚的码风啊</del></p>
<h1 id="2-2015C-斗地主"><a href="#2-2015C-斗地主" class="headerlink" title="$2~2015C$ 斗地主"></a>$2~2015C$ 斗地主</h1><p><a href="https://www.luogu.org/problem/P2668" target="_blank" rel="noopener">Link</a></p>
<p>一道喜闻乐见的搜索题。其实蛮简单的，就是每次把能出的牌出一遍就好了，就是调有点难调，在这个时候输出调试法+肉眼查错法比什么<code>gdb</code>好用多了。</p>
<p>以下是整理的细节：</p>
<ul>
<li>至于如何出单牌和对子，只需要每次dfs时每次最后把不能出花的都出了就好，就是这样：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">14</span> ; ++ j) <span class="keyword">if</span> (buc[j]) step ++ ; Ans = min(Ans, step) ; <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>
<pre><code> 反之如果在出单牌/对子的时候再设置回溯——没有必要且严重扩展了状态数。
</code></pre><ul>
<li>还是剪枝，大概就是一个最优性剪枝：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>
​    可能是因为太套路了我一直记不住= =</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ; </span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//单顺子 </span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">      <span class="keyword">if</span> (!buc[j + k - <span class="number">1</span>] || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">        cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -- ;</span><br><span class="line">			dfs(m - cnt, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] ++ ;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//双顺子 </span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">      <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">2</span> || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">         cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">     &#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">2</span> ;</span><br><span class="line">			dfs(m - cnt * <span class="number">2</span>, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">2</span> ;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//三顺子 </span></span><br><span class="line">		<span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">      <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">3</span> || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">        cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">3</span>  ;</span><br><span class="line">			dfs(m - cnt * <span class="number">3</span>, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">3</span> ;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j)&#123; <span class="comment">//炸弹 or 四带二  </span></span><br><span class="line"> 		<span class="keyword">int</span> p[<span class="number">3</span>], tot = <span class="number">0</span>, q[<span class="number">3</span>], cnt = <span class="number">0</span> ; </span><br><span class="line">		<span class="keyword">if</span> (buc[j] &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">14</span> ; ++ k)&#123;</span><br><span class="line">				<span class="keyword">if</span> (j != k)&#123;</span><br><span class="line">					<span class="keyword">if</span> (buc[k] &gt;= <span class="number">2</span> &amp;&amp; cnt &lt; <span class="number">2</span>) q[++ cnt] = k ; </span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (buc[k] &amp;&amp; tot &lt; <span class="number">2</span>) p[++ tot] = k ; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;   </span><br><span class="line">			<span class="keyword">if</span> (tot &lt; <span class="number">2</span> &amp;&amp; cnt &lt; <span class="number">2</span>) &#123; buc[j] -= <span class="number">4</span> ; dfs(m - <span class="number">4</span>, step + <span class="number">1</span>) ; buc[j] += <span class="number">4</span> ; &#125; </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (cnt &lt; <span class="number">2</span>)  &#123; </span><br><span class="line">        buc[p[<span class="number">2</span>]] --, buc[p[<span class="number">1</span>]] --, buc[j] -= <span class="number">4</span> ; </span><br><span class="line">        dfs(m - <span class="number">6</span>, step + <span class="number">1</span>) ; buc[p[<span class="number">2</span>]] ++, buc[p[<span class="number">1</span>]] ++, buc[j] += <span class="number">4</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; </span><br><span class="line">        buc[q[<span class="number">2</span>]] -= <span class="number">2</span>, buc[q[<span class="number">1</span>]] -= <span class="number">2</span>, buc[j] -= <span class="number">4</span> ; </span><br><span class="line">        dfs(m - <span class="number">8</span>, step + <span class="number">1</span>) ; buc[q[<span class="number">2</span>]] += <span class="number">2</span>, buc[q[<span class="number">1</span>]] += <span class="number">2</span>, buc[j] += <span class="number">4</span> ; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j)&#123; <span class="comment">// 三带XXX </span></span><br><span class="line">		<span class="keyword">if</span> (buc[j] &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">			buc[j] -= <span class="number">3</span> ;</span><br><span class="line">          	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">14</span> ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span>( !buc[k] || k == j )  <span class="keyword">continue</span> ;</span><br><span class="line">                buc[k] -- ; dfs(m - <span class="number">4</span>, step + <span class="number">1</span>) ; buc[k] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">13</span> ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span>( buc[k] &lt;= <span class="number">1</span> || j == k) <span class="keyword">continue</span> ;</span><br><span class="line">                buc[k] -= <span class="number">2</span> ; dfs(m - <span class="number">5</span>, step + <span class="number">1</span>) ; buc[k] += <span class="number">2</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            buc[j] +=<span class="number">3</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">14</span> ; ++ j) </span><br><span class="line">    <span class="keyword">if</span> (buc[j]) step ++ ; Ans = min(Ans, step) ; </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>= =其实这题最恶心的还是粗心地写错，毕竟那么多函数都是<code>ctrl c</code>+<code>ctrl v</code>的，鬼知道什么地方就崩掉了……</p>
<h1 id="3-2015-text-C-G-斗地主加强版"><a href="#3-2015-text-C-G-斗地主加强版" class="headerlink" title="$3~2015\text{C+/G}$  斗地主加强版"></a>$3~2015\text{C+/G}$  斗地主加强版</h1><p><a href="https://www.luogu.org/problem/P2540" target="_blank" rel="noopener">Link</a></p>
<p>直接粘一份代码过来你甚至可以获得74pts的好成绩= =</p>
<p>其实主要思想就是<strong>拆牌</strong>，原因是假设你又两组三张，一组炸，你的思路是出三次，但实际上只需要两次就可以——把一组三张拆成一单+一对，然后带走只需要两次。</p>
<p>但是我并不想写诡异的剪枝，于是索性根据题解区写了一个DP。即设$dp_{i,j,k,l,o}$表示剩下的单张有$i$个，对牌有$j$个，三张有$k$组，四张有$l$组，王有$o$个的最小出牌次数。然后转移就是朴素的转移，同时由于拆牌的存在，我们需要多加两组拆牌的转移，这就需要我们先枚举三张和炸才能转移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> l = <span class="number">0</span> ; l &lt;= N ; ++ l)</span><br><span class="line">		<span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= N ; ++ k)</span><br><span class="line">			<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">				<span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= N ; ++ j)</span><br><span class="line">					<span class="keyword">for</span> (rr <span class="keyword">int</span> o = <span class="number">0</span> ; o &lt;= <span class="number">2</span> ; ++ o)&#123;</span><br><span class="line">						rr <span class="keyword">int</span> res = <span class="number">100</span> ;</span><br><span class="line">						<span class="comment">// Single</span></span><br><span class="line">						<span class="keyword">if</span> (i) res = min(res, dp[i - <span class="number">1</span>][j][k][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (j) res = min(res, dp[i][j - <span class="number">1</span>][k][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (k) res = min(res, dp[i][j][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (l) res = min(res, dp[i][j][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (o) res = min(res, dp[i][j][k][l][o - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (o &gt; <span class="number">1</span>) res = min(res, dp[i][j][k][l][o - <span class="number">2</span>] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="comment">// T -&gt; 1</span></span><br><span class="line">						<span class="keyword">if</span> (i &amp;&amp; k) res = min(res, dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (k &amp;&amp; o) res = min(res, dp[i][j][k - <span class="number">1</span>][l][o - <span class="number">1</span>] + <span class="number">1</span>) ; </span><br><span class="line">						<span class="comment">// T -&gt; 2</span></span><br><span class="line">						<span class="keyword">if</span> (j &amp;&amp; k) res = min(res, dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="comment">// F -&gt; 2</span></span><br><span class="line">						<span class="keyword">if</span> (l &gt; <span class="number">1</span>) res = min(res, dp[i][j][k][l - <span class="number">2</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (j &amp;&amp; l)  res = min(res, dp[i][j - <span class="number">1</span>][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i - <span class="number">2</span>][j][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i][j - <span class="number">2</span>][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (o &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i][j][k][l - <span class="number">1</span>][o - <span class="number">2</span>] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="keyword">if</span> (i &amp;&amp; o &amp;&amp; l) res = min(res, dp[i - <span class="number">1</span>][j][k][l - <span class="number">1</span>][o - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">						<span class="comment">// CHAI</span></span><br><span class="line">						<span class="keyword">if</span> (l) res = min(res, dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>][l - <span class="number">1</span>][o]) ;</span><br><span class="line">						<span class="keyword">if</span> (k) res = min(res, dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>][l][o]) ;</span><br><span class="line">						<span class="comment">// Trans</span></span><br><span class="line">						dp[i][j][k][l][o] = min(res, dp[i][j][k][l][o]) ;</span><br><span class="line">					&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拆牌分别是“炸拆成三张和单张”以及“三张拆成对子和单张”。</p>
<p>然后由于顺子这种东西不能根据数量转移，所以就还是dfs暴力算（dp按理说也是暴力吧/kk），最后加回来就完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ; </span><br><span class="line"> 	<span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//单顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">          <span class="keyword">if</span> (!buc[j + k - <span class="number">1</span>] || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">        	<span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">5</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">           		<span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= j + p - <span class="number">1</span> ; ++ k) buc[k] -- ;</span><br><span class="line">            	dfs(m - p, step + <span class="number">1</span>) ;   </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= j + p - <span class="number">1</span> ; ++ k) buc[k] ++ ;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//双顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">          <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">2</span> || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">        	<span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">3</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">            	pos = j + p - <span class="number">1</span> ; </span><br><span class="line">              <span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">2</span> ;</span><br><span class="line">            	dfs(m - cnt * <span class="number">2</span>, step + <span class="number">1</span>) ; </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">2</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//三顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">          <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">3</span> || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        	<span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">2</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">            	pos = j + p - <span class="number">1</span> ; </span><br><span class="line">              <span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">3</span> ;</span><br><span class="line">            	dfs(m - cnt * <span class="number">3</span>, step + <span class="number">1</span>) ; </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">3</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span>(tong)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j) tong[buc[j]] ++ ; tong[<span class="number">5</span>] = buc[<span class="number">14</span>] ;</span><br><span class="line">    Ans = min(Ans, step + dp[tong[<span class="number">1</span>]][tong[<span class="number">2</span>]][tong[<span class="number">3</span>]][tong[<span class="number">4</span>]][tong[<span class="number">5</span>]]);<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-2015E-子串"><a href="#4-2015E-子串" class="headerlink" title="$4~2015E$ 子串"></a>$4~2015E$ 子串</h1><p><a href="https://www.luogu.org/problem/P2679" target="_blank" rel="noopener">$Link$</a></p>
<p>又是一道情怀题，还记得当时做的时候觉得可难了…（当时的pks：这个转移是人能想出来的吗？）</p>
<p>但其实状态很简单，$f_{i,j,k,0/1}$记录A到了$i$，B到了$j$，A迄今为止分成$k$段，$A[i]$选或者不选的方案数。</p>
<p>然后转移时考虑分类讨论：</p>
<ul>
<li><p>首先  $A[i] = B[j]:$</p>
<ul>
<li>1 ： $f_{i,j,k,1} = f_{i-1,j-1,k-1,1} + f_{i-1,j-1,k-1,0} + f_{i-1,j-1,k,1}$ 也就是{i,j}和前面的是一段/不是一段且和前面的段之间有空格/不是一段且和前面的段之间没空格（讨论空格是为了保证转移的完整性）。</li>
<li>2 ： $f_{i,j,k,0} = f_{i - 1,j, k, 1} + f_{i -1, j, k, 0}$ 前面一位选/不选</li>
</ul>
</li>
<li><p>否则 $A[i]\not = B[j]$</p>
<ul>
<li>1：  $f_{i,j,k,1} = 0\\$ 不合法的转移<br>2： $f_{i,j,k,0} = f_{i - 1,j, k, 1} + f_{i -1, j, k, 0}$</li>
</ul>
</li>
</ul>
<p>其实感觉这个方程…怎么说呢，挺有学习意义的。这其实也算是做了一个状态的前缀和，因为理论上是要从$k\text{~}i-1$中转移的，但因为是方案数，所以可以直接做一个前缀和过来；同时因为此时我们的“主元”是$A$，所以如果不选的话只能是从$(i-1,j)$转移过来而不是$(i,j-1)$（即$k$这一维限制的是$i$） 。</p>
<p>然而还有另外一种定义状态的方式；</p>
<p>其余的都差不多，还是$f_{i,j,k,1}$表示必选，但是$f_{i,j,k,0}$则表示<strong>“可选可不选”</strong>。那我们来思考这样如何转移：</p>
<ul>
<li>1：$f_{i,j,k,1} = (f_{i-1,j-1,k,1} +f_{i - 1,j-1, k-1, 0})\cdot [A_i=B_j] $ 还是分类讨论“连不连成一整段”</li>
<li>2：$f_{i,j,k,0} = f_{i−1,j,k,0}+f_{i,j,k,1}$，即<strong>保证了这一位不选的上一位的选/不选</strong>和<strong>保证了这一位必选</strong>的方案数。</li>
</ul>
<p>思想也大体相同。注意数据范围的限制，滚一下就好了。</p>
<p>嗯，是一道不错的题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++) <span class="built_in">cin</span> &gt;&gt; A[i] ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++) <span class="built_in">cin</span> &gt;&gt; B[i] ;</span><br><span class="line">    <span class="keyword">for</span>(d = i = <span class="number">1</span>; i &lt;= N; i ++, d ^= <span class="number">1</span>)&#123;</span><br><span class="line">        dp[d][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= K ;k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] == B[j]) </span><br><span class="line">                f[d][j][k] = (dp[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>] + f[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k]) % mod ;</span><br><span class="line">                <span class="keyword">else</span> f[d][j][k] = <span class="number">0</span> ; </span><br><span class="line">              	dp[d][j][k] = (dp[d ^ <span class="number">1</span>][j][k] + f[d][j][k]) % mod ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[N &amp; <span class="number">1</span>][M][K]% mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-2011C-Mayan游戏"><a href="#5-2011C-Mayan游戏" class="headerlink" title="$5~2011C$ Mayan游戏"></a>$5~2011C$ Mayan游戏</h1><p><a href="https://www.luogu.org/problem/P1312" target="_blank" rel="noopener">Link</a></p>
<p>想当年这可真是噩梦……</p>
<p>简单来讲就是爆搜吧，只不过记得当时没想到是真的每次搜一遍$7\cdot5$的方阵……</p>
<p>然后这是以前的笔记：</p>
<ul>
<li>1、每次搜索要保留本次的状态，这是比较好想的，我也成功的想到了。但是问题是我们不能单纯地用一个二维数组来$copy$，需要记录步数，因为如果单纯的reset会导致之前走过的也消失。于是最终我们需要一个三维数组来记录。后半段是$qcr$告诉我的。 </li>
<li><p>2、还有就是一个小小的剪枝。就是由于对于每一个格子，我们考虑它向两边替换，而我们为了避免重复搜索，所以就决定<strong>单向搜索</strong>，即对于每个块，如果他左边也是一个块，那就不去$exchange$，只考虑右边；而如果左边是空白格，才$exchange$。显然这个剪枝的优化性是很显著的。</p>
</li>
<li><p>3、我一开始写的$remove()$、$down()$和$check()$十分的麻烦——或者说专一?反正之后我懒得调试了，直接听的$qcr$的，每次执行这几个函数的时候，直接<strong>全屏扫一遍</strong>。</p>
</li>
<li><p>4、$qcr$给我讲了一个很神的$down()$函数——其实也不算多神，只是很简单地处理了每一行的悬空态方块，但是说“神”的原因则是因为“简单”。对，简单，而有时往往我会想复杂。</p>
</li>
<li><p>5、对于$exchange$，我们要不断的$while(remove()) ~;$，因为会不断地有新情况出现。</p>
</li>
<li><p>6、最后我挂了……几个点来着……忘记了。反正原因是因为，每次$remove()$之前应该先$down()$，然而我并没有$down()$干净233</p>
</li>
<li><p>7、最后再说一个剪枝儿，不是必要性的，但是确实可以加快速度。就是我们再每次遍历$7 \times 5$的时候，遇到空白的，不是<code>continue</code>而是<code>break</code>，因为我们$down$一定是完备的，即从下向上枚举时，如果下方的已经clear了，上方的不可能悬空。所以可以少好几次空遍历。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span> <span class="keyword">int</span> x, y ;&#125; ; <span class="built_in">stack</span> &lt;D&gt; s ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ans</span>&#123;</span> <span class="keyword">int</span> x, y, d  ;&#125; res[<span class="number">100</span>] ; <span class="keyword">int</span> Remove[<span class="number">50</span>][<span class="number">50</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, T[<span class="number">30</span>][<span class="number">30</span>], base[<span class="number">4000</span>][<span class="number">10</span>][<span class="number">10</span>], qwq[<span class="number">4000</span>][<span class="number">30</span>], color[<span class="number">30</span>], i, j, t, tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ttt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)&#123;</span><br><span class="line">        ttt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            <span class="keyword">if</span>(T[di][dj] == <span class="number">-1</span>) ++ ttt ;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(! ttt) <span class="keyword">continue</span> ;</span><br><span class="line">                T[di][dj - ttt] = T[di][dj], T[di][dj] = <span class="number">-1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">remove</span><span class="params">()</span></span>&#123; <span class="comment">// void -&gt; bool</span></span><br><span class="line">    <span class="keyword">bool</span> Mark = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(Remove, <span class="number">0</span>, <span class="keyword">sizeof</span>(Remove)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)&#123;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span> &amp;&amp; di &gt;= <span class="number">2</span> &amp;&amp; di &lt;= <span class="number">4</span> </span><br><span class="line">                &amp;&amp; T[di][dj] == T[di + <span class="number">1</span>][dj] &amp;&amp; T[di][dj] == T[di - <span class="number">1</span>][dj])&#123;</span><br><span class="line">                Remove[di + <span class="number">1</span>][dj] = Remove[di - <span class="number">1</span>][dj] = Remove[di][dj] = <span class="number">1</span>, </span><br><span class="line">                Mark = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span> &amp;&amp; dj &gt;= <span class="number">2</span> &amp;&amp; dj &lt;= <span class="number">6</span> </span><br><span class="line">                &amp;&amp; T[di][dj] == T[di][dj + <span class="number">1</span>] &amp;&amp; T[di][dj] == T[di][dj - <span class="number">1</span>])&#123;</span><br><span class="line">                Remove[di][dj + <span class="number">1</span>] = Remove[di][dj - <span class="number">1</span>] = Remove[di][dj] = <span class="number">1</span>, </span><br><span class="line">                Mark = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Mark) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            T[di][dj] = (!Remove[di][dj]) ? T[di][dj] : <span class="number">-1</span> ;</span><br><span class="line">    down() ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prepare</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//copy</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            base[x][di][dj] = T[di][dj] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _reset(<span class="keyword">int</span> x)&#123;<span class="comment">//copy_back</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            T[di][dj] = base[x][di][dj] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_work</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (judge())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= N ; ++ di)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, res[di].x, res[di].y, res[di].d) ;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (step == N + <span class="number">1</span>) <span class="keyword">return</span> ; Prepare(step) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)&#123;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] == <span class="number">-1</span>) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (di &gt; <span class="number">1</span> &amp;&amp; T[di - <span class="number">1</span>][dj] == <span class="number">-1</span>)&#123;</span><br><span class="line">                swap(T[di][dj], T[di - <span class="number">1</span>][dj]) ; down() ; <span class="keyword">while</span> (remove()) ;</span><br><span class="line">                res[step] = (Ans)&#123;di - <span class="number">1</span>, dj - <span class="number">1</span>, <span class="number">-1</span>&#125; ; </span><br><span class="line">                dfs_work(step + <span class="number">1</span>) ; _reset(step) ; res[step] = (Ans)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (di &lt; <span class="number">5</span> &amp;&amp; T[di][dj] != T[di + <span class="number">1</span>][dj])&#123;</span><br><span class="line">                swap(T[di][dj], T[di + <span class="number">1</span>][dj]) ; down() ; <span class="keyword">while</span>(remove()) ;</span><br><span class="line">                res[step] = (Ans)&#123;di - <span class="number">1</span>, dj - <span class="number">1</span> ,<span class="number">1</span>&#125; ; </span><br><span class="line">                dfs_work(step + <span class="number">1</span>) ; _reset(step) ; res[step] = (Ans)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="built_in">memset</span>(T, <span class="number">-1</span>, <span class="keyword">sizeof</span>(T)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">5</span> ; ++ i) T[i][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">5</span> ; ++ i)</span><br><span class="line">        <span class="keyword">while</span>((t = qr()) != <span class="number">0</span>) T[i][++ T[i][<span class="number">0</span>]] = t ;</span><br><span class="line">    dfs_work(<span class="number">1</span>) ; <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="text-Afterwords"><a href="#text-Afterwords" class="headerlink" title="$\text{Afterwords}$"></a>$\text{Afterwords}$</h1><p>“</p>
<p>准确来说，没有人在到达之前知道自己到底要去哪儿。</p>
<p>”</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
        <tag>贪心</tag>
        <tag>奇怪的技巧</tag>
        <tag>NOIP系列</tag>
        <tag>搜索/剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】NOIP2017泛做</title>
    <url>/2019/07/11/NOIP2017/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$NOIP2017$的泛做。</p>
<a id="more"></a>
<h1 id="Omega"><a href="#Omega" class="headerlink" title="$\Omega$"></a>$\Omega$</h1><p>嗯，这个代表“前言”的字母很帅。</p>
<p>先来总结一下每个题的难度，A题<code>提高（证明）/普及-（找规律）</code>, B题<code>提高</code>， C题<code>提高+</code>，总结来看，Day1比较送；D题<code>普及+</code>，E题<code>省选-</code>，F题<code>省选-</code>，Day2不如Day1水。</p>
<p>PS: <code>提高</code>以NOIP提高组平均难度为准，<code>省选</code>以弱省省选为准（比如以<code>SNOI2019</code>平均难度作为基准线）</p>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><p>由于当时场上切了这道题，导致我对“找规律“这种投机取巧的做题方式情有独钟，从而在某些计数题时不好好想DP反而猜sb规律……感觉很GG……</p>
<p>其实这个题就是给一个方程：</p>
<script type="math/tex; mode=display">
ax+by \not= t \quad x,y, \in\mathbb{N},\quad t\in \mathbb{N+} \quad (a,b)= 1</script><p>求$\max{t}$</p>
<p>呃，首先，我想了一种很zz的证明方式：</p>
<ul>
<li><p>当$t = a \cdot b - a - b$时，$t$满足这个方程</p>
<ul>
<li><p>我们通过移项可以得到：</p>
</li>
<li><script type="math/tex; mode=display">
ax+by-ab+a+b=0 \\\
a(x-b +1) + b(y+1) = 0 \\\</script></li>
<li><p>观察这个式子，要么有$y+1=0$且$x-b+1=0$，要么有</p>
<script type="math/tex; mode=display">
a(b-x-1) = b(y+1)\cdots(1)</script></li>
<li>第一种情况显然不成立，那么我们考虑第二种情况。此时因为$(a,b)=1$，所以会有$b~|~(b-x-1) \to b ~|~(x+1)$, 同理$a~|~(y+1)$ .但同时我们将$(1)$式搞一搞就可以得到<script type="math/tex">\frac{a}{b} = \frac{b-(x+1)}{y+1}</script>但因为$a,b \in \mathbb{N+}$，所以会有$b&gt;(x+1)$ ; 因为$b~|~(x+1)$，有$b\leq x+1$或$x+1=0$（舍） ，矛盾，故此时$t$满足这个方程。</li>
</ul>
</li>
<li><p>当$t&gt;a\cdot b-a-b$时，$t$总不满足。</p>
<blockquote>
<p>不妨设$t_0=a\cdot b-a-b, ~t=t_0+k, ~k\in\mathbb{N+}$</p>
<p>此时……然后就不会了2333——以下是借鉴的<a href="https://www.cnblogs.com/xxzh/p/9178564.html" target="_blank" rel="noopener">星星之火OIer</a>巨佬的思路：</p>
</blockquote>
</li>
<li><p>对于任意正整数$k\geq ab−a−b+1$，即$k+a+b\geq ab+1$</p>
<ul>
<li>设$k+a+b = \mu a+m~~(k\geq b,1\leq m &lt;a)$. 同时：<script type="math/tex; mode=display">
\because (a,b)=1\\\
\therefore \exists x_0,y_0 \in \mathbb{Z} \quad s.t. \quad ax_0+by_0=1 \\\
\therefore \exists x_1,y_1∈\mathbb{Z}，−(b−1)\leq x_1\leq 0 \quad s.t.\quad  ax_1+by_1=m\\\</script>这里的意思其实是设$−(b−1)\leq x_1\leq 0$，一定存在整数$y_1$使得$ax_1+by+_1=m$成立。原因就是在整数$x_1$的取值中一共有$b$个数，$y_1=(m−ax_1)/b$，根据鸽笼原理之类的zz定理，我们总是可以找到$x_1$使得$m−ax_1$能被$b$整除。</li>
</ul>
</li>
</ul>
<p>显然，$y_1\geq 1(ax_1\leq 0,m &gt;0, b&gt;0, 因此y_1\geq 1,)$。于是，取$x=\mu+x_1−1,y=y_1−1$。注意到$x_1,y_1$的取值范围，得$x,y\geq 0$， 即有$ax+by=k$</p>
<hr>
<p>？？？不知不觉写了小半个下午？？看起来A题确实是结论题了（sigh</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  A, B ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A * B - A - B ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><p> ……像这种题不就是看脸题吗…手一抖就调不出来了$\rm{qaq}$</p>
<p>题解以前写过，于是直接把主要部分引用过来（以前的码风还真是抽搐</p>
<blockquote>
<p><strong>读入</strong>：</p>
<p>我们先用$while$按字符读入每个程序的第一行，抠出需要检验的复杂度，$O(1)$用$0$来存$[n^0=1  $ $~~~$ $ (n!=0)]$.</p>
<p>注意，有可能有两位数，需要多扣一位……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span>(o!=<span class="string">')'</span>)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(o==<span class="string">'1'</span>&amp;&amp;!chk) </span><br><span class="line">	   need_check=<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">if</span>(o==<span class="string">'n'</span>)&#123;</span><br><span class="line">  	   <span class="built_in">cin</span>&gt;&gt;o&gt;&gt;o;</span><br><span class="line">        need_check=o<span class="number">-48</span>;</span><br><span class="line">	   chk=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">     o=getchar();</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">isdigit</span>(o)&amp;&amp;chk)need_check*=<span class="number">10</span>,need_check+=(o<span class="number">-48</span>); </span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>
<p>至于最后为什么要再$gatchar()$一次……自己试试就知道了。</p>
<p>那么接下来就要按行读入循环了，比较简单。</p>
<p><strong>初始化</strong>：</p>
<p>为了使码风简洁，所以写到函数里了。这个地方我用到了三个栈，一个用来记录每个循环的答案（因为有可能有多个相互独立的循环），一个用来记录每次$F$时读入的循环上下界。以上两个都是$int$栈,还有一个$char$栈，存储每次定义的循环变量，而这个字符栈搭配一个$bool$性的数组，用于记录是否可用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> MAX 1000000</span></span><br><span class="line">&gt;<span class="keyword">int</span> i,x,y,t,tt,num,cntf,cnte,res,ans[MAX],T,l,now,need_checks,stk[MAX];</span><br><span class="line">&gt;<span class="keyword">bool</span> check[<span class="number">150</span>],flag,spj,chk;</span><br><span class="line">&gt;<span class="keyword">char</span> s[<span class="number">3010</span>],o,stkk[MAX]; </span><br><span class="line">&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(check,<span class="number">0</span>,<span class="keyword">sizeof</span>(check));</span><br><span class="line">&gt;<span class="built_in">memset</span>(stkk,<span class="number">0</span>,<span class="keyword">sizeof</span>(stkk));</span><br><span class="line">&gt;<span class="built_in">memset</span>(stk,<span class="number">0</span>,<span class="keyword">sizeof</span>(stk));</span><br><span class="line">&gt;now=t=tt=cntf=cnte=res=flag=spj=chk=<span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>$ps:$虽然不知道用一个二进制位的$0$来初始化字符数组会怎样……不过好像海星。</p>
<p>$cnte$和$cntf$用来记录$F$和$E$的数量，$num$、$t$、$tt$都是栈的指针，$spj$用来判断一个独立循环是否结束（如果结束就把当前的得到压入栈）,$now$用来搭配$spj$记录当前独立循环体的时间复杂度， $chk$用于读入每个程序的第一行（即含有需要判断的时间复杂度的那一行），$flag$用于判断输出。</p>
<p><strong>主要操作</strong></p>
<p>对于读入的东西，分类讨论，然后$continue$……没什么可说的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">while</span>(l--)&#123;</span><br><span class="line">   gets(s);</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);)&#123;</span><br><span class="line">    		<span class="keyword">while</span>(s[i]==<span class="string">' '</span>)i++;</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">'F'</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cntf&gt;cnte&amp;&amp;cnte)&#123;</span><br><span class="line">				ans[++num]=now;</span><br><span class="line">				now=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">         	cntf++,i++;</span><br><span class="line">         	<span class="keyword">continue</span>;</span><br><span class="line">     	&#125;</span><br><span class="line">     	<span class="keyword">if</span>(s[i]==<span class="string">'E'</span>)&#123;</span><br><span class="line">     		y=stk[t],t--;</span><br><span class="line">			x=stk[t],t--;</span><br><span class="line">         	cnte++;</span><br><span class="line">         	<span class="keyword">if</span>(cnte==cntf)spj=<span class="number">1</span>;</span><br><span class="line">         	<span class="keyword">if</span>(x!=MAX)&#123;</span><br><span class="line">         		<span class="keyword">if</span>(y==MAX)now++;</span><br><span class="line">         		<span class="keyword">if</span>(y&lt;x)now=<span class="number">0</span>;</span><br><span class="line">         	&#125;</span><br><span class="line">         	<span class="keyword">else</span>&#123;</span><br><span class="line">         		<span class="keyword">if</span>(y!=MAX)now=<span class="number">0</span>;</span><br><span class="line">         	&#125;</span><br><span class="line">         	check[stkk[tt]-<span class="string">'a'</span>]=<span class="number">0</span>;</span><br><span class="line">         	tt--,i++;</span><br><span class="line">         	<span class="keyword">if</span>(spj)&#123;</span><br><span class="line">         		ans[++num]=now;</span><br><span class="line">				now=<span class="number">0</span>;</span><br><span class="line">				spj=<span class="number">0</span>;</span><br><span class="line">         	&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">     	&#125;</span><br><span class="line">         <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i])&amp;&amp;s[i]!=<span class="string">'n'</span>)&#123;</span><br><span class="line">         	<span class="keyword">if</span>(check[s[i]-<span class="string">'a'</span>]&amp;&amp;!flag)&#123; </span><br><span class="line">         	<span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         	flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">         	stkk[++tt]=s[i];</span><br><span class="line">         	check[s[i]-<span class="string">'a'</span>]=<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     	<span class="keyword">else</span> &#123;  </span><br><span class="line">         	<span class="keyword">if</span>(s[i]==<span class="string">'n'</span>)&#123;</span><br><span class="line">     		my_push(s[i],s[i+<span class="number">1</span>]);</span><br><span class="line">			i+=<span class="number">2</span>;</span><br><span class="line">         &#125;               </span><br><span class="line">         my_push(s[i],s[i+<span class="number">1</span>]);</span><br><span class="line">         &#125;</span><br><span class="line">     	i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>唯一需要注意的是入栈操作，因为要把字符压入整型，所以我又写了个函数来入栈。入栈的时候当然需要注意是不是两位数……</p>
<p>哦，还有，如果这次轮到$n$入栈了，那么就随便入栈一个大于一百的数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">my_push</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isdigit</span>(a))&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">isdigit</span>(b))&#123;</span><br><span class="line">		stk[++t]=(a<span class="number">-48</span>)*<span class="number">10</span>+b<span class="number">-48</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> stk[++t]=a<span class="number">-48</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="string">'n'</span>)stk[++t]=MAX;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>最后判断一下输入输出即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(!flag&amp;&amp;cntf!=cnte)&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">while</span>(num)&#123;</span><br><span class="line">	   res=max(res,ans[num]); </span><br><span class="line">	   num--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag) <span class="keyword">if</span>(res==need_check) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			 <span class="keyword">else</span> 				 <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>嗯~o(<em>￣▽￣</em>)o这就是满分做法了。</p>
</blockquote>
<p>唉，时光一去不复返啊。</p>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><p>……其实不算是个新题，只是似乎当时这道题场上很卡常？感觉就是好多东西的杂糅，先SPFA判个全$0$环，再倒着记搜一遍……感觉已经不算什么新题了，T3出成这样感觉很失望qaq……</p>
<p>但怎么说呢，也是个练习码力的机会吧，转移方程挺好想的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q ;  </span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; vis ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fr, to, next, v ;</span><br><span class="line">&#125;E[MAXM] ; <span class="keyword">int</span> head[MAXN][<span class="number">2</span>], cnt ;</span><br><span class="line"><span class="keyword">int</span> T, N, L, M, K, P, A, B, C, ss[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Es[MAXM][<span class="number">2</span>], dfn[MAXN], low[MAXN], tot ; </span><br><span class="line"><span class="keyword">bool</span> flag ; LL Ans, dp[MAXN][MAXK], dist[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u][<span class="number">1</span>], head[u][<span class="number">1</span>] = cnt ; </span><br><span class="line">	E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v][<span class="number">0</span>], head[v][<span class="number">0</span>] = cnt ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> k ; </span><br><span class="line">	vis.reset() ;</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-63</span>, <span class="keyword">sizeof</span>(dp)), cnt = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= L + <span class="number">3</span> ; ++ k) </span><br><span class="line">		dist[k] = Inf, ss[k] = head[k][<span class="number">1</span>] = head[k][<span class="number">0</span>] = <span class="number">0</span> ; 		</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> now, k ; </span><br><span class="line">	q.push_front(<span class="number">1</span>), vis[<span class="number">1</span>] = <span class="number">1</span>, dist[<span class="number">1</span>] = <span class="number">0</span>, ++ ss[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		now = q.front(), vis[now] = <span class="number">0</span>, q.pop_front() ;</span><br><span class="line">		<span class="keyword">for</span> (k = head[now][<span class="number">1</span>] ; k ; k = E[k].next)&#123;</span><br><span class="line">			<span class="keyword">if</span> (dist[to(k)] &gt;= dist[now] + E[k].v)&#123;</span><br><span class="line">				++ ss[to(k)] ; </span><br><span class="line">				dist[to(k)] = dist[now] + E[k].v ;</span><br><span class="line">				<span class="keyword">if</span> (ss[to(k)] &gt;= N)&#123; flag = <span class="number">1</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">				<span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line">					<span class="keyword">if</span> (q.empty() || dist[to(k)] &lt; dist[q.front()]) </span><br><span class="line">						q.push_front(to(k)) ; <span class="keyword">else</span> q.push_back(to(k)) ; vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dp_work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dp[now][op] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[now][op] ; dp[now][op] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = head[now][<span class="number">0</span>] ; k ; k = E[k].next)&#123;</span><br><span class="line">		LL t = op - dist[to(k)] + dist[now] - E[k].v ; </span><br><span class="line">		<span class="keyword">if</span> (t &gt; K || t &lt; <span class="number">0</span>) <span class="keyword">continue</span> ; dp[now][op] = (dp[now][op] + dp_work(to(k), t)) % P ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[now][op] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> i ; <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">	<span class="keyword">while</span>(T --)&#123;</span><br><span class="line">		L = <span class="number">200000</span>, Init() ; Ans = <span class="number">0</span> ;</span><br><span class="line">		N = qr(), M = qr(), K = qr(), P = qr() ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) A = qr(), B = qr(), C = qr(), _Add(A, B, C) ;</span><br><span class="line">		SPFA() ; dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span> ; L = N ; <span class="keyword">if</span> (flag) &#123; flag = <span class="number">0</span>, <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ; <span class="keyword">continue</span> ; &#125; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) Ans = (Ans + dp_work(N, i)) % P ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想了一下，似乎出题人是故意把时间押给$B$的，所以$C$比较送。</p>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p>也是挺送的一道题，注意开<code>long long</code>就好…用并查集维护一下最上面和最下面的两个洞在不在一条“连通链”上即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hole</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> x,y,z;</span><br><span class="line">&#125;c[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">find</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[a]!=a)a=find(f[a]);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> xz,<span class="keyword">long</span> <span class="keyword">long</span>  yz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c[find(yz)].z&gt;c[find(xz)].z) f[find(yz)]=f[find(xz)];</span><br><span class="line">	<span class="keyword">else</span> f[find(xz)]=f[find(yz)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(hole a,hole b)</span>z</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">    d=(a.z-b.z)*(a.z-b.z)+(a.y-b.y)*(a.y-b.y)+(a.x-b.x)*(a.x-b.x);</span><br><span class="line">    <span class="keyword">if</span>(d&lt;=<span class="number">4</span>*r*r)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="number">0</span>));</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;h&gt;&gt;r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;c[i].x,&amp;c[i].y,&amp;c[i].z);</span><br><span class="line">	    	f[i]=i;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	     <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	      <span class="keyword">if</span>(f[i]!=f[j]&amp;&amp;check(c[i],c[j]))unionn(i,j);</span><br><span class="line">	    <span class="keyword">bool</span> cc=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	      <span class="keyword">if</span>(c[i].z+r&gt;=h&amp;&amp;c[find(i)].z-r&lt;=<span class="number">0</span>)</span><br><span class="line">		  &#123;</span><br><span class="line">		  	cc=<span class="number">1</span>;</span><br><span class="line">		  	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">		  &#125;</span><br><span class="line">		  <span class="keyword">if</span>(!cc)<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		  cc=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>wtm以前的码风是有多犀利啊，字符间不加空格大括号也不换行</del></p>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><p>emmm第一眼状压，第二眼需要把树高加到状态里，那么就是$f_{s,h}$表示现在选的点集为$S$，树高为$h$的最小花费。转移的时候大概就是朴素的</p>
<script type="math/tex; mode=display">
f_{s,i} = \min\limits _{t \in s}\{f_{t,i-1}+cost_{t\to s}\}</script><p>然后这个cost显然是可以在可接受的复杂度以内$prework$出来的。于是最终的复杂度就是$\Theta(3^n\cdot n^2)$</p>
<blockquote>
<p>求“子集的子集”的复杂度严格来讲是$3^n$而不是$4^n$，原因在于我们事实上一共有$\sum \binom{n}{k}2^k$个子集，逆向二项式展开<del>或者叫二项式收缩</del>一下就可以得到<script type="math/tex">\sum \binom{n}{k}2^k = \sum \binom{n}{k}1^{n-k}\cdot 2^k = (1+2)^n = 3^n</script>代码实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(t = S ; t ; t = (t - <span class="number">1</span>) &amp; S)</span><br></pre></td></tr></table></figure><br>呃，至于这句话的原理暂不可知，但是挺好用是真的qwq</p>
</blockquote>
<p>但是复杂度上限此时是$531441\times 12^2= 76527504$，不可过（但事实上根本不可能跑满所以也过了），以下是<code>Flash_hu</code>巨佬的$\Theta(3^nn)$的做法：</p>
<p>我们发现似乎同一树高的所有节点，完全可以同时转移。所以我们不妨设$f_{s,t}$表示已选点集为$s$，下一层要加入的点集为$t$时， 新加入的所有点与原有点之间最小的边权之和——用于预处理。 具体的转移我们可以考虑如下：</p>
<script type="math/tex; mode=display">
f_{s,t} = \min \{f_{s,t-lowbit(j)}+cost_{k, s}\}, k=\log _2lowbit(j)</script><p>其中$cost_{k,s}$表示点$k$到连通块$s$的最短距离。可以用$lowbit$的原因是答案无序，所以这一部分的复杂度是$O(3^nn).$</p>
<p>那么接下来考虑原先的$dp$，设$g_{s,h}$表示已选点集为$s$，当前树高为$h$的最小代价，即目标函数。那么转移就是：</p>
<script type="math/tex; mode=display">
g_{s,h} = \sum_{t\in s}g_{s-t, h-1}+h\cdot f_{s-t,t}</script><p>同样是显然的。所以最后的复杂度就是$O(3^nn)$ 。答案的话最后直接对所有$g_{_{2^n-1,h}},h\in[1,n]$取个最小值就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt, T, D[MAX][MAX], a, b, c ;</span><br><span class="line"><span class="keyword">int</span> F[MAXN][MAX], Next[MAX], Ans, Sup, Now ;</span><br><span class="line"><span class="keyword">int</span> N, M, i, j, k, Log[MAX], Max, A[MAXN][MAXN] ;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(A, <span class="number">63</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">63</span>, <span class="keyword">sizeof</span>(F)), Ans = Inf ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; Max = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), </span><br><span class="line">        A[a][b] = A[b][a] = min(c, A[a][b]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Log[<span class="number">1</span> &lt;&lt; i] = i ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) F[<span class="number">0</span>][<span class="number">1</span> &lt;&lt; i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = Sup = Max ^ i; j ; j = (j - <span class="number">1</span>) &amp; Sup) Next[j] = cnt, cnt = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = cnt ; j ; j = Next[j])&#123;</span><br><span class="line">            Now = Log[j &amp; (-j)] + <span class="number">1</span>, T = Inf ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= N ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>) &amp; i) T = min(T, A[Now][k]) ; </span><br><span class="line">            D[i][j] = D[i][j ^ (j &amp; -j)] + T ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= Max; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (k = j ; k ; k = (k - <span class="number">1</span>) &amp; j)</span><br><span class="line">                F[i][j] = min(F[i][j], F[i - <span class="number">1</span>][j ^ k] + i * D[j ^ k][k]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Ans = min(Ans, F[i][Max]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><p>一道我不是很会的线段树题……</p>
<p>怎么说呢，感觉这个做法未曾见过吧。大概就是维护$n+1$棵动态开点的线段树，其中对每一行的前$m-1$个元素维护一个线段树，然后对最后一列单独维护一棵线段树。线段树上每个点维护自己子树内到底有多少个点被删了，用来协助寻找现在的位置。在此基础上再维护$n+1$个<code>vector</code>，用来记录从每棵线段树中弹出的点即可。</p>
<p>呃，现在的我似乎并没有很好地理解这个题的做法，有些马虎…所以希望日后再看的时候能看的更清明一点吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> vio&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAXV 2010</span></span><br><span class="line">    <span class="keyword">int</span> x, y, t, i, j ; </span><br><span class="line">    <span class="keyword">int</span> base[MAXV][MAXV] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                base[i][j] = ++ t ; </span><br><span class="line">        <span class="keyword">while</span>(Q --)&#123;</span><br><span class="line">            x = qr(), y = qr(), t = base[x][y] ;</span><br><span class="line">            <span class="keyword">for</span> (i = y + <span class="number">1</span> ; i &lt;= M ; ++ i) base[x][i - <span class="number">1</span>] = base[x][i] ; </span><br><span class="line">            <span class="keyword">for</span> (i = x + <span class="number">1</span> ; i &lt;= N ; ++ i) base[i - <span class="number">1</span>][M] = base[i][M] ; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (base[N][M] = t)) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> segment_T&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAXN 400010</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rr register int</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; del[MAXN &lt;&lt; <span class="number">4</span>] ; <span class="keyword">int</span> Max ; </span><br><span class="line">    <span class="keyword">int</span> rt[MAXN &lt;&lt; <span class="number">4</span>], L[MAXN &lt;&lt; <span class="number">4</span>], R[MAXN &lt;&lt; <span class="number">4</span>], dfn, val[MAXN &lt;&lt; <span class="number">4</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) root = ++ dfn ; val[root] ++ ; <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ; rr mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) update(L[root], l, mid, pos) ; <span class="keyword">else</span> update(R[root], mid + <span class="number">1</span>, r, pos) ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ; rr mid = (l + r) &gt;&gt; <span class="number">1</span>, dif = mid - l + <span class="number">1</span> - val[L[root]] ; </span><br><span class="line">        <span class="keyword">if</span> (dif &gt;= pos) <span class="keyword">return</span> query(L[root], l, mid, pos) ; <span class="keyword">else</span> <span class="keyword">return</span> query(R[root], mid + <span class="number">1</span>, r, pos - dif) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">delcase2</span><span class="params">(<span class="keyword">int</span> x, ll y)</span></span>&#123;</span><br><span class="line">        rr now_p = query(rt[N + <span class="number">1</span>], <span class="number">1</span>, Max, x) ; update(rt[N + <span class="number">1</span>], <span class="number">1</span>, Max, now_p) ;</span><br><span class="line">        ll ret = now_p &lt;= N ? <span class="number">1L</span>L * now_p * M : del[N + <span class="number">1</span>][now_p - N - <span class="number">1</span>] ; del[N + <span class="number">1</span>].pb(y ? y : ret) ; <span class="keyword">return</span> ret ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">delcase1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        rr now_p = query(rt[x], <span class="number">1</span>, Max, y) ; update(rt[x], <span class="number">1</span>, Max, now_p) ; </span><br><span class="line">        ll ret = now_p &lt; M ? <span class="number">1L</span>L * (x - <span class="number">1</span>) * M + now_p : del[x][now_p - M] ; del[x].pb(delcase2(x, ret)) ; <span class="keyword">return</span> ret ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rr x, y ; Max = max(N, M) + Q ; </span><br><span class="line">        <span class="keyword">while</span> (Q --) x = qr(), y = qr(), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, y != M ? delcase1(x, y) : delcase2(x, <span class="number">0</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Q ;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">5000</span> &amp;&amp; M &lt;= <span class="number">5000</span>) vio :: Solve1() ;</span><br><span class="line">    <span class="keyword">else</span> segment_T :: Solve2() ;<span class="comment">/*pkspkspks*/</span> <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="varPhi"><a href="#varPhi" class="headerlink" title="$\varPhi$"></a>$\varPhi$</h1><p>现在来看，乐观估计，自己应该可以得到$100+100+100+100+55+30=485pts$，当且仅当自己的码力已经很强。如果是悲观估计，那大概是$100+70+40+80+55+30=375pts$。继续努力吧，现在还差得很远啊……</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
        <tag>数学/扩展欧几里德</tag>
        <tag>数据结构/线段树</tag>
        <tag>NOIP系列</tag>
        <tag>暴力,brute-force</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】用舞蹈链(DLX)解决一类数独问题</title>
    <url>/2019/07/11/dlx2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>考虑精准覆盖问题的本质——我们把行看做决策，把列看做任务，那么其实质就是通过决策来完成任务。</p>
<p>那么我们来考虑数独问题的本质，对于一个$n^2\cdot n^2$的数独而言，他的目标函数有四个：</p>
<ul>
<li><p>1、$r(i,j):$对于第$i$行，必须要有数字$j$</p>
</li>
<li><p>2、$c(i,j):$对于第$i$列，必须要有数字$j$</p>
</li>
<li><p>3、$p(i,j):$对于第$i$个宫，必须要有数字$j$</p>
</li>
<li><p>4、$e(i,j):$对于第$(i,j)$个格子，必须要有数字</p>
</li>
</ul>
<p>由此可知，我们有$4\times (n^2\cdot n^2)$的任务量。</p>
<p>同时我们可以用$n^6$的状态表示我们的决策，即$(i,j,k)$表示第$i$行$j$列填了数字$k$。</p>
<p>结合两者考虑，我们可以建出一个新的网格图，有$n^6$行、$4n^4$列。考虑向网格中填“$1$”表示一个决策完成了一个任务，那么对于每一个决策$(i,j,k)$，它理应可以完成$4$个任务，所以一共有$16n^4$个1.</p>
<p>至此建模完毕，一个$n^2\cdot n^2$的数独问题可以转化成一个$n^6$行、$4n^4$列，有$16n^4$个$1$的精准覆盖问题。</p>
<a id="more"></a>
<p>下面是代码实现部分，以<a href="https://www.spoj.com/problems/SUDOKU/" target="_blank" rel="noopener">SPOJ1110-SUDOKU</a>为例：</p>
<ul>
<li>首先是对状态进行编号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; </span><br><span class="line">  	<span class="keyword">return</span> (a &lt;&lt; <span class="number">8</span>) + (b &lt;&lt; <span class="number">4</span>) + c + <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> &amp;c)</span></span>&#123; </span><br><span class="line">  	x --, c = x % <span class="number">16</span>, x /= <span class="number">16</span>, b = x % <span class="number">16</span>, x /= <span class="number">16</span>, a = x ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理其实也很简单，就是i的后续状态(j,k)有$n^4=256$种组合，同理j的后续状态有$n^2=16$种组合。</p>
<p>然后就是连边，对于每个点判断一下，如果当前枚举到的数字是这个点的数字那么就需要<code>insert</code>，同理如果没有数字的话那就都<code>insert</code>一遍，毕竟比起有数字的点，可行的决策数要更多。至此我们就保证了原图中存在数字的方格被<code>insert</code>了，不存在数字的方格的所有可能情况也被<code>insert</code>了，之后直接<code>dance</code>就可以啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t[O][O], op ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> POS = <span class="number">0</span>, Row = <span class="number">1</span>, Col = <span class="number">2</span>, Sub = <span class="number">3</span> ; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		read(), Init() ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">16</span> ; ++ j)&#123;</span><br><span class="line">				t[i][j] = base[i][j] == <span class="string">'-'</span> ? <span class="number">0</span> : base[i][j] - <span class="number">64</span> ;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">16</span> ; ++ k)&#123;</span><br><span class="line">					<span class="keyword">if</span> (t[i][j] &amp;&amp; t[i][j] != k + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">					op = encode(i, j, k) ; </span><br><span class="line">          Insert(op, encode(POS, i, j)),</span><br><span class="line">					Insert(op, encode(Row, i, k)), </span><br><span class="line">          Insert(op, encode(Col, j, k)), </span><br><span class="line">          Insert(op, encode(Sub, (i / <span class="number">4</span>) * <span class="number">4</span> + j / <span class="number">4</span>, k)) ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;		</span><br><span class="line">		dance(<span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; ++ i, <span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">16</span> ; ++ j) <span class="built_in">printf</span>(<span class="string">"%c"</span>, (<span class="keyword">char</span>)(res[i][j] + <span class="number">65</span>)) ;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是一道要求出所有解的题：<a href="https://www.luogu.org/problem/P1074" target="_blank" rel="noopener">NOIP2009D 靶形数独</a></p>
<p>此处需要我们求出所有可能的精准覆盖方案然后取最大值，于是小小改动一下<code>dance</code>就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">gs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || y == <span class="number">1</span> || x == <span class="number">9</span> || y == <span class="number">9</span> )   <span class="keyword">return</span> <span class="number">6</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || y == <span class="number">2</span> || x == <span class="number">8</span> || y == <span class="number">8</span> )   <span class="keyword">return</span> <span class="number">7</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">3</span> || y == <span class="number">3</span> || x == <span class="number">7</span> || y == <span class="number">7</span> )   <span class="keyword">return</span> <span class="number">8</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">4</span> || y == <span class="number">4</span> || x == <span class="number">6</span> || y == <span class="number">6</span> )   <span class="keyword">return</span> <span class="number">9</span> ; <span class="keyword">return</span> <span class="number">10</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line">	<span class="keyword">if</span> (!now_c)&#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, z, ret = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; step ; ++ i)</span><br><span class="line">			decode(ans[i], x, y, z), g[x][y] = z + <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span> ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span> ; ++ j)</span><br><span class="line">				ret += g[i][j] * gs(i + <span class="number">1</span>, j + <span class="number">1</span>) ;</span><br><span class="line">		res = max(res, ret) ; <span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = now_c ; i ; i = B[i].r) </span><br><span class="line">    now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; Del(now_c) ;  </span><br><span class="line">	<span class="keyword">for</span> (rr <span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d)&#123;</span><br><span class="line">		ans[step] = B[i].ro ; </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line">		dance(step + <span class="number">1</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line">	&#125;</span><br><span class="line">	Back(now_c) ; <span class="keyword">return</span>  ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>撒花~ <del>（撒自己XD</del></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>精准覆盖/舞蹈链/DLX</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】舞蹈链(DLX)入门</title>
    <url>/2019/07/11/dlx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“<br>在一个全集$X$中若干子集的集合为$S$，精确覆盖（$\boldsymbol{Exact~Cover}$）是指，$S$的子集$S*$，满足$X$中的每一个元素在$S*$中恰好出现一次。在计算机科学中，精确覆盖问题指找出这样的一种覆盖，或证明其不存在。<br>”</p>
<a id="more"></a>
<h1 id="0x01-精准覆盖问题"><a href="#0x01-精准覆盖问题" class="headerlink" title="$0x01$ 精准覆盖问题"></a>$0x01$ 精准覆盖问题</h1><p>……其实是一种决策问题，给定$n$行长度为$m$的$0,1$序列，要求选出一些行，使得每一列有且仅有一个$1$，这就是精准覆盖问题。</p>
<p>诚然，我搜索贼菜，所以暂且不考虑爆搜，引进一种叫做“X算法”的东西，其本质上是每次选取一行，之后删掉所有与这行冲突的行，同时删掉与这行冲突的列，成为一个更小的矩阵，迭代下去。如果什么时候删没了，就说明是一种可行解；否则恢复原来的状态。</p>
<p>我们思考这种简洁做法的流程，发现朴素的删除与恢复无非就是将矩阵的这一个元素由$0$或$1$赋值成$-1$，记录一下状态回溯的时候再赋值回去，整个过程十分地漫长且繁复。而所谓所谓的”<strong>舞蹈链算法</strong>$\rm{DLX~(Dancing-Links ~X ~Algorithm)}$“算法则是专门用来加速这一过程。</p>
<p>在本人看来，$\rm{DLX}$更像是一种包装好的数据结构，一种加速措施，能更好的让爆搜达到其理论复杂度（所以本质上还是爆搜XD）……不过说实话“像翩翩起舞的舞者”我倒是看不出来…我觉得更像是一对牛仔裤上拉链，拉来拉去的那种感觉……</p>
<p><del>诶，什么时候我的Preface开始这么意识流了啊</del></p>
<h1 id="0x02-text-Dancing-Links"><a href="#0x02-text-Dancing-Links" class="headerlink" title="$0x02$ $\text{Dancing-Links}$"></a>$0x02$ $\text{Dancing-Links}$</h1><p>其实算法的本质就是链表，这玩意儿插入删除都是$\Theta(1)$的。我们考虑建立一个<strong>十字循环链表</strong>，即每个元素在链表里是四联通的，并且左右成环、上下成环，目的是方便知道某些操作该什么时候停止。本质上来讲，一个求解矩阵（此处代指上文提到的$n$行$0,1$序列）初始的$\text{Dancing-Links}$ 共有$\text{1+m+Count(‘1’)}$ 个元素，其中$Count(‘1’)$指矩阵中$1$的个数。</p>
<p>前$\text{m+1}$个元素，大概就是列标元素（$m$个）左右连成一片，最左边的$0$号元素用来判断是否$\text{worked-out}$整个矩阵，和所有列标元素串成一条左右连通的链表。然后剩下的的元素就是真实存在的元素…该怎么连怎么连那种感觉…</p>
<p>那么每个元素记录$6$个值，上下左右和行标列标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, u, d, co, ro ;</span><br><span class="line">&#125;B[MAX &lt;&lt; <span class="number">1</span>] ;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[i].l = i - <span class="number">1</span>, B[i].r = i + <span class="number">1</span>, B[i].u = B[i].d = i ;</span><br><span class="line">	B[M].r = <span class="number">0</span>, B[<span class="number">0</span>].l = M, cnt = M, <span class="built_in">memset</span>(Ro, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Ro))  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中$R_o[]$数组记录每一行的第一个元素（第一个加进来的元素</p>
<p>然后<code>Insert</code>函数用于插入……毕竟是链表嘛<del>，就要有个链表的样子</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">	Cs[C] ++, B[++ cnt].ro = R, B[cnt].co = C ;</span><br><span class="line">	B[cnt].u = C, B[cnt].d = B[C].d, B[C].d = B[B[C].d].u = cnt ; </span><br><span class="line">	<span class="keyword">if</span> (Ro[R] &lt; <span class="number">0</span>) Ro[R] = B[cnt].l = B[cnt].r = cnt ; </span><br><span class="line">	<span class="keyword">else</span> B[cnt].l = B[Ro[R]].l, B[cnt].r = Ro[R], B[Ro[R]].l = B[B[Ro[R]].l].r = cnt ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后$C_s[]$数组用来记录每一列的元素个数，用来剪枝。</p>
<p>然后就是删除和恢复，都是以列为参数的函数，也都是很平凡的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">	B[B[C].l].r = B[C].r, B[B[C].r].l = B[C].l ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].d ; i != C ; i = B[i].d)  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r)</span><br><span class="line">			B[B[j].d].u = B[j].u, B[B[j].u].d = B[j].d, Cs[B[j].co] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Back</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].u ; i != C ; i = B[i].u)  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l)</span><br><span class="line">			B[B[j].d].u = j, B[B[j].u].d = j, Cs[B[j].co] ++ ;</span><br><span class="line">	B[B[C].l].r = C, B[B[C].r].l = C ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是主函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dance</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!B[<span class="number">0</span>].r)&#123; <span class="keyword">return</span> (<span class="keyword">bool</span>)(ans = step) ; &#125; <span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = B[<span class="number">0</span>].r ; i ; i = B[i].r) </span><br><span class="line">		now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; </span><br><span class="line">	Del(now_c) ; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d) &#123;</span><br><span class="line">		Ans[step] = B[i].ro ; <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line">		<span class="keyword">if</span> (dance(step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span> ;  <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	Back(now_c) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个小剪枝，就是刚才说的$C_s[]$。如果每次从含有最少$1$的那一列开始删，似乎可以快好几倍。</p>
<p>我发现整理算法的文章写起来真是难受啊，还是意识流比较管用。</p>
<p>最后是全部的程序（<a href="https://www.luogu.org/problemnew/show/P4929" target="_blank" rel="noopener">$Luogu4929$</a>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I_used_to_rule_the_world___Seas_would_rise_when_I_gave_the_word___Now_in_the_morning_I_sleep_alone___Sweep_the_streets_I_used_to_own Init</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I_used_to_roll_the_dice___Feel_the_fear_in_my_enemy_s_eyes___Listen_as_the_crowd_would_sing_Now_the_old_king_is_dead__Long_live_the_king Done</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> One_minute_I_held_the_key__Next_the_walls_were_closed_on_me__And_I_discovered_that_my_castles_stand__Upon_pillars_of_salt_pillars_of_sand work </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 30010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, u, d, co, ro ;</span><br><span class="line">&#125;B[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> cnt, ans ; </span><br><span class="line"><span class="keyword">int</span> N, M, Ans[MAX], Ro[MAX], Cs[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, <span class="built_in">memset</span>(Ro, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Ro)) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[i].l = i - <span class="number">1</span>, B[i].r = i + <span class="number">1</span>, B[i].u = B[i].d = i ;</span><br><span class="line">    B[M].r = <span class="number">0</span>, B[<span class="number">0</span>].l = M, cnt = M  ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    Cs[C] ++, B[++ cnt].ro = R, B[cnt].co = C ;</span><br><span class="line">    B[cnt].u = C, B[cnt].d = B[C].d, B[C].d = B[B[C].d].u = cnt ; </span><br><span class="line">    <span class="keyword">if</span> (Ro[R] &lt; <span class="number">0</span>) Ro[R] = B[cnt].l = B[cnt].r = cnt ; </span><br><span class="line">    <span class="keyword">else</span> B[cnt].l = B[Ro[R]].l, B[cnt].r = Ro[R], B[Ro[R]].l = B[B[Ro[R]].l].r = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    B[B[C].l].r = B[C].r, B[B[C].r].l = B[C].l ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].d ; i != C ; i = B[i].d)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r)</span><br><span class="line">            B[B[j].d].u = B[j].u, B[B[j].u].d = B[j].d, Cs[B[j].co] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Back</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].u ; i != C ; i = B[i].u)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l)</span><br><span class="line">            B[B[j].d].u = j, B[B[j].u].d = j, Cs[B[j].co] ++ ;</span><br><span class="line">    B[B[C].l].r = C, B[B[C].r].l = C ;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dance</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!B[<span class="number">0</span>].r)&#123; <span class="keyword">return</span> (<span class="keyword">bool</span>)(ans = step) ; &#125; <span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[<span class="number">0</span>].r ; i ; i = B[i].r) </span><br><span class="line">        now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; </span><br><span class="line">    Del(now_c) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d) &#123;</span><br><span class="line">        Ans[step] = B[i].ro ; <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line">        <span class="keyword">if</span> (dance(step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span> ;  <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	Back(now_c) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            &#123; <span class="built_in">cin</span> &gt;&gt; k ; <span class="keyword">if</span> (k) Insert(i, j) ;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dance(<span class="number">0</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    I_used_to_rule_the_world___Seas_would_rise_when_I_gave_the_word___Now_in_the_morning_I_sleep_alone___Sweep_the_streets_I_used_to_own() ; </span><br><span class="line">    I_used_to_roll_the_dice___Feel_the_fear_in_my_enemy_s_eyes___Listen_as_the_crowd_would_sing_Now_the_old_king_is_dead__Long_live_the_king() ;</span><br><span class="line">    One_minute_I_held_the_key__Next_the_walls_were_closed_on_me__And_I_discovered_that_my_castles_stand__Upon_pillars_of_salt_pillars_of_sand() ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">/*</span></span><br><span class="line"><span class="comment">             	I hear Jerusalem bells are ringing   Roman Cavalry choirs are singing</span></span><br><span class="line"><span class="comment">             	Be my mirror my sword and shield     My missionaries in a foreign field</span></span><br><span class="line"><span class="comment">                For some reason I can't explain	     Once you know there was never'</span></span><br><span class="line"><span class="comment">                Never an honest word			     That was when I ruled the world</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>精准覆盖</category>
      </categories>
      <tags>
        <tag>精准覆盖/舞蹈链/DLX</tag>
      </tags>
  </entry>
  <entry>
    <title>随想八 · 逃吧</title>
    <url>/2019/06/11/8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是一篇时间跨度很长的文章，也是「随想」系列里面我认为最丧的一篇文章。</p>
<p>你确定要看吗？或许也没有想象的那么丧。可能今天我是这么写的，后天我就不这么认为了。毕竟本质上，这只是一篇闲扯的文章。</p>
<a id="more"></a>
<p>灵长类动物的情绪往往会表征在行为上。从一开始只会因希望发泄而抢、砸物品，演变到脱离出群落、独自对着天上的月亮皎洁、地上的蚂蚁成群，最后演变出音乐、文章、涂鸦。同时，不得不承认，情感是推动艺术发展的内在力量，而瞬时的情绪则是艺术诞生的缘由。</p>
<p>所以，这篇文章写了很久也就不奇怪了——我的情绪起伏有时会很严重，从内环境角度分析，就是雌性激素含量的起伏变化。而这篇文章，不同于其他的文章，是必须要在我十分情绪化的状态下才能写出来。</p>
<p>就好像，比起平日里活跃的过头的我，我更倾向于认为现在这个自己才是真正的自己。只有在现在这个状态，可能会被叫做「抑郁情绪堆积」之类的，我才能够感到“啊，原来我还活着”。</p>
<p>正如，比起四处高呼“为了兴趣而学”、“勇敢学下去”、“别放弃啊”的我，我更倾向于认为那个懦弱无能的我才是真的我。</p>
<p>正如，我一直以来认为的，「短暂的快乐只会带来空虚，无尽的悲伤才会带来充实」。</p>
<hr>

        <div id="aplayer-yXOMZnXg" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-yXOMZnXg"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "Space Oddity",
              author: "(Mix)",
              url: "Space Oddity.mp3",
              pic: "/2019/06/11/8/qwq.png",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h1 id="时间轴：19年夏"><a href="#时间轴：19年夏" class="headerlink" title="时间轴：19年夏"></a>时间轴：19年夏</h1><h2 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h2><p>最近有在看《哈利·波特》，以前从未读过的我现在俨然成了异类，不过倒也是兴趣使然。本是读英文版的，第一部却读了接近一个月，每日尝读10页已算不错的收获了。读完首卷后尝试整理下单词，苦于如同伸手摘繁星，不知从何而始，亦不知到何处是个尽头。于是第二卷便一直搁置在书桌的角落，未尝得到时间用于阅读。</p>
<p>恰逢高考端午连休，索性用假期的最后一天把《哈》电影的3\4\5\6看完了。看完的感触自然是有的，虽然未触及结局，但早在知乎上被剧透了个差不多。大概就是类似父母的感觉？看着哈利、罗恩和赫敏每部电影都更成熟的模样，不禁感慨时间的流逝确是一去不回，顺便也为自己一只没有过铁三角那样金石可镂的友情而忧伤，大概是自己太孤独了吧。</p>
<p>但我却很在意一个新出场的人物，卢娜，卢娜·洛夫古德。她是后期“铁六角”的一员，经常在哈利需要的时候帮助他——但这不是最重要的，最重要的是，不知为何，她似乎对我有一种天然的吸引力，$\rm{gorgerous}$，就是这个词。可能是因为扮演这个角色的演员演绎的太完美了，把精灵/空灵、机敏/睿智的混合演绎的栩栩如生，也可能是角色本身就很讨喜，或者说扮演者自己的颜值加了很大的分（我认为是很漂亮的）——总之，我才明白如果在我的梦境里出现一位类似“洛神”的存在，那形象大概就是她，卢娜，的样子了。无论是小说里的描写、电影里的演绎，亦或者是杂糅，我都欣然接受这样一位精灵入驻我遥不可及的梦。</p>
<p>我这种感情缘何而起呢？大概是她身上的那种超然脱俗的感觉吧。在电影里，扮演者恰如其分地把卢娜的超然演绎了出来——她看得透生死，看得透哈利有多难过，看得透一切，却又像一块无瑕的宝玉不受沾染。大概是因为几乎所有人，及时天性是善的，也会因为后天知识的输入、阅历的增长而变得混浊、扭曲、纠结、迷茫，但她似乎并没有。书中的设定，她是拉文克劳的学生，并且有着拉文克劳人固有的聪慧机敏，但是那一切似乎都没有成为她超脱的枷锁。</p>
<p>她有爱，心中有说不出的温度。她的父亲是某本奇妙的畅销杂志《The Quibbler（唱唱反调）》的主编。那是一本被赫敏嫌弃的奇怪的杂志，但她却很喜欢，并且四处推销，用她那精灵一般的嗓音推销——看到那儿时，我突然感觉有什么东西开始在黑暗里发光。哈利波特到了后期，完全变成了黑暗童话，充满了紧张、喧嚣和压抑。但每次卢娜一出现，只要说几句话，似乎就可以马上呼唤一阵清风徐来，涤荡心灵。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="http://b-ssl.duitang.com/uploads/item/201701/29/20170129133646_i5Bh3.thumb.224_0.gif" alt=""></p>
<p>那是梦，是遥遥无期的梦，梦里有她，一个虚构的人物，有着不存在的身份，不存在的音容笑貌。我特意去搜索过扮演者的相关信息，发现成年后的扮演者似乎并不出彩，身上再也没有那种精灵的气息。</p>
<p>好在由于时间实在不够用，只能看到《混血王子》。之后还有两部决定留在下次大休，也就是合格考之后看。我猜大概我看完全部的《哈》之后，自己会变得很惆怅——惆怅好几天的那种吧，毕竟上次看完《言叶之庭》就是这样。美好的东西结束了，总是感觉很悲伤。</p>
<p>但天下没有不散的宴席，你说对吧。哦，对，这句话我第一次见还是在《家有儿女》里面呢。</p>
<h2 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h2><p>但其实，我更向往的，是这么一种生活，这么一种无忧无虑的生活吧？</p>
<p>一个人，静静地待在一个四周有着连绵蜿蜒的山、静静流淌的水，大地被一望无尽的、软绵绵的绿草覆盖，天与山与水之间只有一间小小的棚屋，用石头垒的，可能会有着红色的顶，但那样太突兀；可能会有着棕色的顶，但那样太沉寂。屋里炉子上煮着茶或者咖啡，一张简单但是温暖的床，一床蓬松到恰好的被子，一只没那么柔软的枕头，几把带背儿的椅子，一张古色古香的桌子。房里，墙上可能会放着一两只精致的挂钟，桌上可能会放着一个插有各色鲜艳花儿的花瓶。</p>
<p>平时我唯一做的事，就是坐在山坡上，感受着草的柔软与细腻，目送着天边云彩的来去匆匆，眺望着潺潺流过的河流。可能，在一望无际间，会有一棵大大的树，有时我也会爬上树梢，无奈斜阳来了又去，感慨星点来了又回。</p>
<p>是啊，就让我一个人，原远离这个世界，不行吗？</p>
<p>我一直在想，既然我知道有很简单很简单的生活，但为什么我每天都活在惶恐、活在忧虑、活在无奈中？我受够了因为一点美好的机遇而沾沾自喜、因为一点不堪的经历就要担惊受怕的日子了。我受够这必须要忍受一切、必须要提防一切的日子了。我受够这种不够单调的日子了。</p>
<p>是啊，这种跌宕起伏的生活才有趣，我又何尝不知道？</p>
<p>但，我不想了啊，只是觉得，太难走下去了啊。</p>
<p>「地球online」这个游戏，确实不公平吧。规则限定了只有前进的人才能活下去，剥夺了想要原地踏步的人的权利。所以讽刺的是，或许世界上最难的事，就是「过最简单的生活」这件事吧。</p>
<p>为什么，连「我和世界互相忘记」这种对整个游戏根本无关痛痒的决策，也不是免费的呢？</p>
<h2 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h2><p>嗯，胆小啊、懦弱啊，我知道。</p>
<p>「除了勇气，我什么都不缺。」这话，本就是说给自己听的。「未来的路又在哪呢？」这话，说了千百遍也还是颓唐。</p>
<p>所以，如果可以的话，把我绑架到加拿大北部、瑞士、丹麦之类的地方——让这世界，忘了我吧。</p>
<h1 id="时间轴：2019年秋"><a href="#时间轴：2019年秋" class="headerlink" title="时间轴：2019年秋"></a>时间轴：2019年秋</h1>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Prufer序列泛做</title>
    <url>/2019/05/26/Prufer%E5%BA%8F%E5%88%97%E6%B3%9B%E5%81%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Prufer数列是无根树的一种数列，常用来求解树的计数问题。</p>
</blockquote>
<a id="more"></a>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="$Preface$"></a>$Preface$</h1><p>嗯，最近学了学一个叫做<code>Prufer</code>序列的东西，然后主要是跟树的计数有关。</p>
<h2 id="基本概念与基本操作"><a href="#基本概念与基本操作" class="headerlink" title="基本概念与基本操作"></a>基本概念与基本操作</h2><p>首先下定义：Prufer序列是一个长度为$n-2$的序列。</p>
<p>我们考虑给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数$n&gt;2$的树总存在叶子节点，因此一棵$n$个节点的无根树唯一地对应了一个长度为$n-2$的数列，数列中的每个数都在$1$到$n$的范围内。而这就是这棵树的$\boldsymbol{Prufer}$<strong>序列</strong>。</p>
<blockquote>
<p>为什么是$n-2$？</p>
<p>我们观察一棵树，$n-1$条无向边决定了总度数为$2n-2$，同时由于每个节点当自己是被删成叶子的时候不会被算进去，所以每个节点需要减去一的贡献，换句话说就是$Prufer$序列的长度为$n-2$。</p>
</blockquote>
<p>emmm然后一个比较平凡的结论就是<strong>$\boldsymbol{P rufer}$序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。</strong></p>
<p>同时我们接下来要不加证明地断言<strong>任何一个长为$n-2$、取值范围在$1$到$n$之间的数列都唯一地对应了一棵$n$个节点的无根树.</strong></p>
<p><del>严格证明大家可以去Mt67的博客上翻（</del></p>
<p>想要更好的意会以上内容，需要我们考虑如何实现Prufer的呈现与复原：(摘自<code>ProJ7-Jeffy</code>的博客)</p>
<p>（1）无根树转化为 $Prufer$ 序列。<br>首先定义无根树中度数为<code>1</code>的节点是叶子节点。<br>找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下<code>2</code>个节点。<br>如下图的树对应的 $Prufer$ 序列就是 <code>3，5，1，3</code>。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""><br>具体实现可以用一个 <code>set</code> 搞定，维护度数为 <code>1</code> 的节点。复杂度 $O(n\log n)$。<br>（2）$Prufer$序列转化为无根树。<br>设点集 <code>V={1,2,3,...,n}</code>，每次取出 $Prufer$ 序列中最前面的元素$u$，在<code>V</code>中找到编号最小的没有在 $Prufer$ 序列中出现的元素$v$，给 $u，v$ 连边然后分别删除，最后在 <code>V</code> 中剩下两个节点，给它们连边。最终得到的就是无根树。<br>具体实现也可以用一个 <code>set</code>，维护 $Prufer$ 序列中没有出现的编号。复杂度 $O(n\log n）$。 </p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li><p>$n$个点有标号无根树共有$n^{n-2}$种。</p>
<ul>
<li>$\rm{Proof}:$ 仔细想想…似乎Prufer序列一共$n-2$项，于是就乘法原理就好了……</li>
</ul>
</li>
<li>接上一个，有根树的话因为对于每种方案里面的$n$个点都可以当作根，所以总数量是$n^{n-2}\cdot n=n^{n-1}$。</li>
</ul>
<hr>
<ul>
<li><p>假设每个点的度数已经确定了，设第$i$号点的度数为$d_i$，则显然有$\sum_{i=1}^{n}(d_i - 1)=n-2$，那么对于每个节点度数确定的带标号无根树数量就是</p>
<script type="math/tex; mode=display">
\frac{(n-2)!}{\prod_{i=1}^n(d_i-1)}</script><ul>
<li>$\rm{Proof}:$ 大概是一个排列组合的思想，我们可以认为是一共$n$种元素，选$n-2$个，每种元素有且必须有$d_i-1$个，求排列数。然后比较显然的是$(n-2)!$是总排列数，而每个元素一共有$d_i-1$个位置，对于同一种元素的同一种位置排布，我们多算了$A_{(d_i-1)}^{(d_i-1)}=(d_i-1)!$次的，所以分母上乘法原理起来去除这些贡献就好。</li>
</ul>
</li>
<li><p>接上一个, $n$ 个节点的度依次为 $d_1,d_2,…,d_{n-m}$，另外有 $m$ 个节点度数未知，求有多少种生成树？</p>
<ul>
<li>我们考虑首先计算一下$Prufer$序列该剩下多少未知项，设其数目为$\omega$，则$\omega=(n-2)-\sum_{d_i ~is~known} (d_i-1)$。那么本着瞎**去重的原则，我们考虑应该在分母上乘一个$\omega!$。而同时由于我们存在$m$个度数并未确定的点，在$Prufer$序列中占据了$\omega$个位置，所以我们分子上应该再乘上一个$m^{\omega}$。故总方案数就变成了：</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
\frac{(n-2)!m^{\omega}}{\omega!\cdot \prod_{i=1}^{n-m}(d_i-1)}</script><h1 id="A-HNOI2008-明明的烦恼"><a href="#A-HNOI2008-明明的烦恼" class="headerlink" title="$A$ [HNOI2008]明明的烦恼"></a>$A$ [HNOI2008]明明的烦恼</h1><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1005" target="_blank" rel="noopener">bzoj1005</a></p>
<p>其实就是上面<code>扩展</code>里面的一个推论，然后我们就用<code>python</code>水过去就好了233</p>
<p><del>然而BZOJ的Py只会一直Pending，所以还是什么时候再写一发高精度吧</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = input()</span><br><span class="line">Fac = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N - <span class="number">1</span>) :</span><br><span class="line">    Fac = Fac + [Fac[i - <span class="number">1</span>] * i]</span><br><span class="line">Ans = Fac[N - <span class="number">2</span>]</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">Sum = N - <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, N) :</span><br><span class="line">    di = input()</span><br><span class="line">    <span class="keyword">if</span> di == <span class="number">-1</span> :</span><br><span class="line">    	cnt = cnt + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> : </span><br><span class="line">        Ans = Ans / Fac[di - <span class="number">1</span>]</span><br><span class="line">        Sum = Sum - (di - <span class="number">1</span>)</span><br><span class="line">Ans = Ans / Fac[Sum]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, Sum) :</span><br><span class="line">    Ans = Ans * cnt</span><br><span class="line"><span class="keyword">print</span> (Ans)</span><br></pre></td></tr></table></figure>
<h1 id="B-小猴打架"><a href="#B-小猴打架" class="headerlink" title="$B$ 小猴打架"></a>$B$ 小猴打架</h1><p>由于在BZOJ上是权限题，所以不得已去Luogu做…<del>国内最大的盗版题市场</del></p>
<p><a href="https://www.luogu.org/problemnew/show/P4430" target="_blank" rel="noopener">Luogu4430</a></p>
<p> 我们发现这个题的Aim在于让我们求无根树有多少种不同的生成方式，比普通的Prufer序列多一个加边的顺序——毕竟Prufer只能处理树的形态不同&amp;标号不同，所以我们理所当然地乘上一个$(n-1)!$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//用sb代码来填补博文太短的空白</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; Frac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; N ; ++ i) (Ans *= N) %= Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) Frac[i] = Frac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line">	(Ans *= Frac[N - <span class="number">1</span>]) %= Mod, <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】CF#Global Round 1の题解(A $\to$ G)</title>
    <url>/2019/05/10/Codeforces-1110/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自从省选完之后状态一直不佳，感觉自己刚燃起的希望又熄灭了。所以就打算来整理一下省选之前因为懒而没整的一些题。然后你会发现前两句话一点关系都没有XD</p>
<p>这里是总链接<a href="http://codeforces.com/contest/1110" target="_blank" rel="noopener">$Link$</a>.</p>
<h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/难度-普及－-yellow.svg" alt=""></p>
<p>题意：求$\sum_{i=1}^{k} a_i\times b^{k-i}$的奇偶性， $k = \Theta(n \log n)$ </p>
<p>……其实很容易想麻烦，比如说逐个判断，整体判断啥的。但其实只要对结果都$\bmod ~10$，然后判断奇偶性就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; b &gt;&gt; k ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= k ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">   reverse (base + <span class="number">1</span>, base + k + <span class="number">1</span>) ;</span><br><span class="line">   <span class="keyword">for</span> (i = k ; i &gt;= <span class="number">1</span> ; -- i) Sum = Sum * b + base[i], Sum %= <span class="number">10</span> ;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; (Sum &amp; <span class="number">1</span> ? <span class="string">"odd"</span> : <span class="string">"even"</span>) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<p><del>其实就是在水字数</del></p>
<h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/难度-普及%2B-red.svg" alt=""></p>
<p>题意：给定一条网格纸，$n, m, k$, 分别表示点数，总长度，胶带的数量。对于输入的$n$个点，保证位置递增， 求覆盖所有的点所需的最小胶带长度（胶带数量$\leq k$）。</p>
<p>其实是个制杖题。我们考虑如果$k$是无限大，那么最优的方式一定是单点覆盖。所以如果胶带不够的话，就是要去额外多粘$N-k$个空白的区间。所以我们就可以排个序，求出$N-k$个空白区间的长度，再加上单点的长度和$n$，得到答案。注意空白区间的两头开的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;now), (i &gt; <span class="number">1</span> ? (d[i - <span class="number">1</span>] = now - Last - <span class="number">1</span>) : <span class="number">1</span>), Last = now ;</span><br><span class="line">nth_element(d + <span class="number">1</span>, d + N - K + <span class="number">1</span>, d + N) ; <span class="comment">//Last row, now - Last + 1 -&gt; now - Last</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N - K ; ++ i) Ans += d[i] ; Ans += N ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<p>emmm怎么说呢，是个显然又不显然的贪心，大概还是跟<code>OI素养</code>直接挂钩的吧（sigh</p>
<h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p>
<p>题目简述    :    定义函数$f(a)$</p>
<script type="math/tex; mode=display">
f(a) = \max_{0 < b < a}{\gcd(a \oplus b, a \> \& \> b)}</script><p>给出 $q$ 个询问，每个询问为一个整数$a_i$。你需要对于每个询问，求出$f(a_i)$的值。$q=O(10^3),a=O(2^{25}).$</p>
<p>也算是比较巧妙的一道题，当然这个难度评级是给的分块打表的，毕竟思维难度摆在那里……首先我们考虑这个式子的结构，最大化一个gcd，那么我们不妨考虑如果$gcd(x,y)$,存在$x=0$或者$y=0$时，$gcd(x,y)=y$或者$gcd(x,y)=x$。</p>
<p>所以我们考虑，对于任意的$a$，我们只需要去尝试构造一种方案 ，使得$a\oplus b$最大并且$a~\&amp; ~b$最小。那么不妨考虑直接选一个与$a$所有位上都相反的数$b$，就可以保证$a~\oplus~b$最大且$a~\&amp;~b=0$，最后的答案就是$2^{k-1}-1$，其中$k$是二进制下$a$的位数。其中合法性是不言而喻的，因为根据构造，$b$的第$k$位（二进制位下最大的那一位）上必定是$0$，所以似乎就做完了？</p>
<p>然而并不是，因为$b\not =0$，所以当$~a=2^{w}-1，w\in \mathbb N~$时就会不合法。此处又有一个精妙的构造，我们发现当$a$的二进制位上都是$1$时，$\forall b&lt;a,\exists a  ~\&amp; ~b=b, a~\oplus~b=a-b$, 于是最后就相当于求$\max \gcd (a-b,b)$，运用辗转相除或者更相减损的思想可以立即看出是$\max \gcd(a,b)$，于是只需要找出$a$最大的因子就好了——此处暴力即可。</p>
<p>于是最后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 34000000</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span> &lt;MAXN&gt; check ; <span class="keyword">int</span> T, N, i, O ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_fac</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span> ; i &lt;= x ; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (!(x % i)) <span class="keyword">return</span> (x /= i) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">25</span> ; ++ i) check[(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N) ;</span><br><span class="line">        <span class="keyword">if</span> (check[N]) </span><br><span class="line">            O = get_fac(N), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, O) ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; i &lt;&lt;= <span class="number">1</span>, O = i) ; </span><br><span class="line">            O --, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, O) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不说是一道比较神的的题了，Brainstorm，Brainstorm…..</p>
<h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p>
<p>题目详述：你在玩一个叫做 <code>Jongmah</code> 的游戏，你手上有 $n$ 个麻将，每个麻将上有一个在 $1$ 到 $m$ 范围内的整数 $a_i$。为了赢得游戏，你需要将这些麻将排列成一些三元组，每个三元组中的元素是相同的或者连续的。你只能使用手中的麻将，并且每个麻将只能使用一次。请求出你最多可以形成多少个三元组。</p>
<p><del>这道题准确预报了今年各省省选里面的毒瘤雀魂题</del></p>
<p>一道动态规划，感觉思路清新、解法自然<del>，给出题人点赞.</del> 然后底下是我丢到Luogu的题解：</p>
<blockquote>
<p>$dp.$</p>
<p>其实主要思想都差不多，但我发这篇$sol$为了阐明一种观点：复杂度同阶的$DP$，不同的状态设计，会导致代码难度、时空复杂度等截然不同。</p>
<p>我们定义状态$dp_{i,j_{1},j_{2}}$表示考虑了前$i$大序号的麻将($mahJong$)，其中有$j_{1}$个$[i - 1, i, i + 1]$类型、有$j_{2}$个$[i, i + 1, i + 2]$类型的组合，最多组成多少个三元组。</p>
<p>这样定义状态的原因是：我们发现如果单纯用$1$维状态转移，那么状态势必是“前$i$大序号的麻将包含的三元组个数”，但是此状态不明确——无法准确定义“包含”的意思。而此处我们定义包含指<strong>三元组右端点也$\leq i$</strong>，那么$[i - 1, i, i + 1]$和$[i, i + 1, i + 2]$便需要单独定义出来。</p>
<p>转移的时候直接枚举有多少个$[i + 1,i+2, i+3]$即可（因为我们使用$i$更新$i+1$而不是用$i-1$更新$i$，如是做细节少、思考难度小）</p>
</blockquote>
<p>然后转移的时候也要顺便计算$[i,i,i]$的数量。而由于如果存在三个$[i,i+1,i+2]$，那么我们直接拆成三个$[i,i,i]$，三个$[i+1,i+1,i+1]$, 三个$[i+2,i+2,i+2]$即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Sum[ qrd() ] ++ ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; <span class="number">3</span> ; ++ k)</span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span> ; l &lt; <span class="number">3</span> ; ++ l)</span><br><span class="line">                <span class="keyword">if</span> (Sum[i] &lt; j + k + l) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> dp[i][k][l] = max(dp[i][k][l], dp[i - <span class="number">1</span>][j][k] + (Sum[i] - j - k - l)/<span class="number">3</span> + l) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[M][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p>
<p>题目简述：给定数列$c$和$t$，每次操作都可以选择一个$1&lt;i&lt;n$，令$c_i$变成$c_i’$，其中$c_i’=c_{i+1}+c_{i-1}-c_i$。问是否可以经过若干次操作，使得$\forall c_i=t_i$. </p>
<p>……我管这种题叫做“疯狂暗示题”，其实也是一种做题技巧的问题。打完比赛反思了一下，似乎有好几个关键信息没有捕捉到。比如说“若干次操作”，没有限定操作次数，就说明无论怎么操作，其背后一定有某些本质不变的东西，否则应该出成一个交互题，在$k$步之内完成任务的那种感觉。而同时，每次操作一个$c_i$，都只会跟$c_{i-1}$、$c_{i+1}$有关。所以，一切的一切都在引导我们向<code>差分</code>靠拢。</p>
<p>我们思考对于一个$c_i$，令其满足$c_{i-1}+d_1=c_i, ~c_i+d_2=c_{i+1}$，那么我们新的$c_i’$就是</p>
<script type="math/tex; mode=display">
c_i'=c_i-d_1+c_i+d_2-c_i=c_i-d_1+d_2</script><p>那么我们就会发现</p>
<script type="math/tex; mode=display">
c_{i+1}-c_i' = d_1\\\ c_i'-c_{i-1} = d_2</script><p>换句话说，其实就是相邻两个差换了位置！那么也就是说无论怎样，差分数组里面每个数出现的次数都是不变的，直接排个序检查就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]) ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]) ;</span><br><span class="line">   <span class="keyword">if</span> (A[<span class="number">1</span>] != B[<span class="number">1</span>] || A[N] != B[N]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) Da[i] = A[i] - A[i - <span class="number">1</span>] ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) Db[i] = B[i] - B[i - <span class="number">1</span>] ;</span><br><span class="line">   sort(Da + <span class="number">2</span>, Da + N + <span class="number">1</span>), sort(Db + <span class="number">2</span>, Db + N + <span class="number">1</span>) ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Da[i] != Db[i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ; <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br></pre></td></tr></table></figure>
<p>感觉其实$C/D/E$都是比较好的思维题……但是接下来一个就不是了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p>
<p>题目简述 ：给定一棵以$1$为根的$n$个节点有根树， 给定$m$次询问， 形如 <code>v l r</code>， 输出以$v$为起点，终点编号为$l$ ~$r$以内的叶子中最短的路径距离。</p>
<p>根据dfs序的相关知识，我们需要一棵线段树来维护dfs序上的路径长度最小值。但是很多人（比如我）会认为一定需要线段树上个树什么的，但其实有更简单的策略。</p>
<p>不妨直接令当前点到其他所有的点的距离是一个数组$dis$。思考如果我们把当前点的当前子节点设为$x$, 那么我们如果向下递归$x$，就会有$x$到$x$子树内的所有节点的$dis$，比其父亲的dis都小一个$E[k].v$，$x$到其他节点的距离都会大一个$E[k].v$，那么就如同状态转移一样，每次向下递归的时候先统计一遍$Ans$，再更新一下距离即可。</p>
<p>其实这个题是一个$tricky$题，比如我们为了用一个dis数组表示到叶子的距离，可以把非叶子之间的距离都设成$\rm{Inf}$ ；比如我们为了飞速统计答案，可以把询问离线下到一个<code>vector</code>里面，在dfs的时候直接统计出全部答案。</p>
<p>不失为一道好题啊qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf (1LL &lt;&lt; 55)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next ; ll c ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, A, i, q ; </span><br><span class="line">ll tag[MAXN &lt;&lt; <span class="number">2</span>], S[MAXN &lt;&lt; <span class="number">2</span>], Ans[MAXN], dis[MAXN], B ;</span><br><span class="line"><span class="keyword">int</span> cnt, head[MAXN], Last[MAXN], Lr[MAXN], Rr[MAXN] ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; query[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(<span class="keyword">const</span> ll &amp;a, <span class="keyword">const</span> ll &amp;b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">max</span><span class="params">(<span class="keyword">const</span> ll &amp;a, <span class="keyword">const</span> ll &amp;b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	Last[u] = u ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; </span><br><span class="line">		dis[to(k)] = dis[u] + E[k].c ; </span><br><span class="line">		dfs(to(k), u), Last[u] = max(Last[u], Last[to(k)]) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span></span>&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].c = w, </span><br><span class="line">	E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, E[cnt].c = w, </span><br><span class="line">	E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123; </span><br><span class="line">	S[rt] = min(S[rt &lt;&lt; <span class="number">1</span>], S[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tag[rt] == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">	rr <span class="keyword">int</span> lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">	tag[lc] += tag[rt], tag[rc] += tag[rt], </span><br><span class="line">	S[lc] += tag[rt], S[rc] += tag[rt], tag[rt] = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ul &lt;= l &amp;&amp; ur &gt;= r)&#123;</span><br><span class="line">		S[rt] += k, tag[rt] += k ; <span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	push_down(rt) ; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul ,ur, k) ;</span><br><span class="line">	<span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, k) ; push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		S[rt] = dis[l] ; <span class="keyword">return</span> ; </span><br><span class="line">	&#125; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">	build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r), push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">querys</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> S[rt] ;</span><br><span class="line">	rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; rr ll res = Inf ; push_down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (ql &lt;= mid) res = min(res, querys(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr)) ;</span><br><span class="line">	<span class="keyword">if</span> (qr &gt; mid) res = min(res, querys(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr)) ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k : query[u]) </span><br><span class="line">		Ans[k] = querys(<span class="number">1</span>, <span class="number">1</span>, N, Lr[k], Rr[k]) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line"> 		update(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>, N, E[k].c), update(<span class="number">1</span>, <span class="number">1</span>, N, to(k), Last[to(k)], -(E[k].c &lt;&lt; <span class="number">1</span>)), </span><br><span class="line">		work(to(k), u) ; update(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>, N, -E[k].c), update(<span class="number">1</span>, <span class="number">1</span>, N, to(k), Last[to(k)], E[k].c &lt;&lt; <span class="number">1</span>) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%I64d"</span>, &amp;A, &amp;B), Add(A, i, B) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;q, &amp;Lr[i], &amp;Rr[i]), query[q].push_back(i) ; </span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>) ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (i != Last[i]) dis[i] = Inf ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="comment">// by _pks</span></span><br><span class="line">	work(<span class="number">1</span>, <span class="number">0</span>) ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// by _pks by _pks by _pks by_pks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>by_pks其实是用来占位的因为我喜欢同一个代码块里，每一行的长度都是递增的XD</del></p>
<h1 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89-darkviolet.svg" alt=""></p>
<p>题目大意：给出一棵N个点的树，初始时某些节点是白色，其他节点没有颜色，有两个人在树上博弈。每一回合，一方可以将一个没有颜色的点染成白色，然后另一方可以将一个没有颜色的点染成黑色。如果在某次染色后树上存在三个点ABC满足有边$(A,B)(B,C)$且ABC都有颜色且颜色相同，则该颜色对应的人获胜。假设两人绝顶聪明，问最后结果如何。$T\leq 5e5,\sum n\leq 5e5$</p>
<p>emmmm一道我不会的题。其实总觉得这种博弈论有一种一脉相承的精妙之处，但是自己总是不能稔熟于心……GG</p>
<p>然后我选择搬了<code>Itst</code>巨佬的思路过来</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>首先我们考虑，黑色是不可能获胜的，毕竟原来就已经有一堆白点了……</p>
<p>其次我们考虑先忽略原树中的所有已经被染过色的点，然后用一种比较前卫的方式来分类讨论——<code>度数讨论法</code>。</p>
<ul>
<li>假设有一个点的度数$\geq 4$，换句话说这个联通块的点的个数要$\geq 5$，那么根据白色先手的原则，白色的一定可以取$3$个节点，并且一定可以取$3$个连续的节点。所以白色赢；</li>
<li>如果存在一个点的度数$=3$，且它所连的$3$个点至少有$2$个点不是叶子节点，那么我们如果考虑讲树平展开之后，先选中间的点，就可以保证白色赢；</li>
<li>其余的情况我们可以考虑大力分类讨论树的形态：<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></li>
</ul>
<p>我们发现，对于前两种情况都是draw的。而对于第三种情况，如果总点数是<strong>奇数个</strong>，那么<strong>白色必赢</strong>。我们考虑从左向右染色，白色第一次考虑染从左往右第二个非叶子节点，那么黑色只能染第一个；白色染第四个，黑色只能染第三个……以此类推。到最后一定会出现白色染了$2n$这个点，黑色去染$2n-1$这个点，那么白色接下来就可以染$2n+1$这个点，Winner！</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>接下来我们如果要算上原本就是白色的点呢？对于这种情况，一般都是转化回我们已经讨论完的<code>0x01</code>去。我们考虑把一个白色点拆成$4$个无色点。<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png" alt=""></p>
<p>其中A就是原来的$1$号点，原图上哪些点跟$1$连了边，现在也和$A$连，换句话说就是$A$多了一棵三个节点的子树。那么接下来我们考虑其可行性。</p>
<ul>
<li>如果$A$被染成黑色，那么白色没有必要再染子树内的点，这种情况等价于不连子树。</li>
<li>如果$A$被染成白色，那么黑色一定要染$B$点，那么此时这棵子树又没用了，所以也等价于不连子树。</li>
</ul>
<p>嗯，然后这个题就完了。我们可以发现就是一个大力分类讨论的过程——题还是挺好的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Input[MAXN] ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> In[MAXN], qaq ;</span><br><span class="line"><span class="keyword">int</span> T, N, head[MAXN], A, qwq, B, i, j, ans, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">	E[++ cnt].to = v, In[v] ++ ;</span><br><span class="line">	E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, In[u] ++ ; </span><br><span class="line">	E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N), ++qwq ;</span><br><span class="line">		fill(In, In + N + <span class="number">4</span>, <span class="number">0</span>) ;</span><br><span class="line">		fill(head, head + N + <span class="number">4</span>, <span class="number">0</span>), ans = <span class="number">0</span>, qaq = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, Input) ; <span class="keyword">if</span> (N &lt; <span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">"Draw"</span>) ; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) ans += Input[i] == <span class="string">'W'</span> ;</span><br><span class="line">			<span class="built_in">puts</span>(ans &gt;= <span class="number">2</span> ? <span class="string">"White"</span> : <span class="string">"Draw"</span>) ;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> Linshi = <span class="number">0</span> ;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line">				<span class="keyword">if</span> (Input[i] == <span class="string">'W'</span>)&#123;</span><br><span class="line">					head[++ N] = <span class="number">0</span>, Add(i + <span class="number">1</span>, N), In[N] = <span class="number">3</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N &amp;&amp; ans &lt;= <span class="number">0</span>; ++ i)&#123;</span><br><span class="line">				<span class="keyword">if</span> (In[i] &gt; <span class="number">3</span>) ans ++ ;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="number">3</span>)&#123; Linshi = <span class="number">0</span> ;</span><br><span class="line">					<span class="keyword">for</span> (j = head[i] ; j ; j = E[j].next) Linshi += (In[to(j)] &gt;= <span class="number">2</span>) ;</span><br><span class="line">					ans += Linshi &gt; <span class="number">1</span>, qaq ++ ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (qaq == <span class="number">2</span> &amp;&amp; (N % <span class="number">2</span>)) ans ++ ; <span class="built_in">puts</span>(ans ? <span class="string">"White"</span> : <span class="string">"Draw"</span>) ;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">// 		if (qwq == 20) return 0 ;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Global Round的题目质量不低蛤。</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划/普通DP</tag>
        <tag>思维题/构造</tag>
        <tag>树模型</tag>
        <tag>有技巧的差分</tag>
        <tag>博弈论/组合游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>【探究向】主席树上的不靠谱解法</title>
    <url>/2019/04/05/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%8D%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91%E4%B8%8A%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>yy出来的假复杂度做法，但是据说有一个很强的剪枝？</p>
<a id="more"></a>
<h1 id="rm-0x00-Preface"><a href="#rm-0x00-Preface" class="headerlink" title="$\rm{0x00~}Preface$"></a>$\rm{0x00~}Preface$</h1><p>某天机房里，<del>公认的ezi</del> lwy跟wxl随口说了一道luogu上的题，wxl来了兴趣，被pks听见了，于是pks就瞅了一眼这题，然后说了一句”这不就是sb主席树上二分吗？随便一个$\Theta(n \log^2n)$就可以过啊”</p>
<p>然后pks那一整个晚上都在搞这个假算法，$\rm{QAQ}$</p>
<p>于是就有了本文，整理了两道主席树的正确（？）应用。</p>
<h1 id="rm-0x01-faebdc的烦恼"><a href="#rm-0x01-faebdc的烦恼" class="headerlink" title="$\rm{0x01~}$faebdc的烦恼"></a>$\rm{0x01~}$faebdc的烦恼</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P1997" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1997</a></p>
<p>呃，其实这不是一道很难的题。因为本来就保证了数列不降，所以我们直接记录一下每个数出现区间的左右端点，瞎搞就好。但是既然我说了要主席树上二分，就一定要写写看吧qaq</p>
<p>我们考虑在我的<a href="">这篇博客</a>里面曾经介绍过的$T3$中的算法，我们直接去查询左右儿子值域区间内中数的个数，看看哪个可行，然后暴力找就好。</p>
<p>但是…他TLE了两个点，因为我是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;Left,<span class="keyword">const</span> <span class="keyword">int</span> &amp;Right,<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> aft[l] ; </span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, qwq ;</span><br><span class="line">    <span class="keyword">if</span> (sum[Right] - sum[Left] &lt; k) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= k) </span><br><span class="line">        <span class="keyword">if</span> ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= k) </span><br><span class="line">        <span class="keyword">if</span> ((qwq = query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i ++)  base[i] = qr() + ADD, aft[i] = base[i] ;</span><br><span class="line">    sort (aft + <span class="number">1</span>, aft + N + <span class="number">1</span>),Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>), </span><br><span class="line">	  T[<span class="number">0</span>] = build(<span class="number">1</span>, Len) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i ++) </span><br><span class="line">      pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft, </span><br><span class="line">  		T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) ;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>, r = b - a + <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">           	<span class="keyword">register</span> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, mid) &gt; <span class="number">0</span>) ans = mid, l = mid + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像很正常？但是，这个复杂度是完全错误的。最大的时候甚至可以到达单次$m \log n$的复杂度——注意是单次。因为我们每次询问的时候，如果查询了左区间不合法，那么不代表右区间合法——毕竟是二分里的<code>check</code>环节。而上一个类似方法的题，可以保证我们如果左区间的数的出现次数不超过$\frac{1}{2}$，那么右区间一定满足——但显然的是，本题不具有这个性质。</p>
<p>所以，总结一下，主席树上不可以二分。</p>
<p>但是如果我们加一点剪枝呢？</p>
<p>我们考虑，对于主席树上的每一个点维护一个$maxx$一个$minx$，记录区间内<strong>单个数值出现的最大次数和最小次数</strong>，那么我们在$check$的时候就可以直接用这种方式判——如果$r$版本的主席树内出现的最大次数减去$l-1$版本内出现的数的最小次数$k&lt;q$（$q$是二分出的$val$），那么一定不满足。</p>
<p>比较显然的是，这不是一种最优性剪枝，而是一种可行性剪枝。但是对付这道题却有着不错的效果，跑的奇快。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD 393216</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100073</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> a, b, c, pos, N, base[MAXN], mx[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], mn[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], aft[MAXN], M, i ;</span><br><span class="line"><span class="keyword">int</span> cnt, Len, T[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], L[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], R[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], sum[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ; &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;last, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> rt = ++ cnt, mid ;</span><br><span class="line">    sum[rt] = sum[last] + <span class="number">1</span>, R[rt] = R[last], L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">    	mx[rt] = mn[rt] = sum[rt] ; </span><br><span class="line">        <span class="keyword">return</span> rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ;</span><br><span class="line">    <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">    mn[rt] = min(mn[L[rt]], mn[R[rt]]), mx[rt] = max(mx[L[rt]], mx[R[rt]]) ;</span><br><span class="line">    <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;Left,<span class="keyword">const</span> <span class="keyword">int</span> &amp;Right,<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">1</span> ; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, qwq ;</span><br><span class="line">    <span class="keyword">if</span> (mx[L[Right]] - mn[L[Left]] &gt;= k &amp;&amp; query(L[Left], L[Right], l, mid, k)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mx[R[Right]] - mn[R[Left]] &gt;= k &amp;&amp; query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M; <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i)  base[i] = qr() + ADD, aft[i] = base[i] ;</span><br><span class="line">    sort (aft + <span class="number">1</span>, aft + N + <span class="number">1</span>), Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft, T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        a = qr(), b = qr() ;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>, mid, r = b - a + <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">           	mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, mid)) ans = mid, l = mid + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-0x02-CF840D-Destiny"><a href="#rm-0x02-CF840D-Destiny" class="headerlink" title="$\rm{0x02~}CF840D~Destiny$"></a>$\rm{0x02~}CF840D~Destiny$</h2><p>传送门：<a href="http://codeforces.com/problemset/problem/840/D" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/840/D</a></p>
<p>简化版题意：每次给出三个参数$l,r,k$，询问区间$[l,r]$内是否存在出现次数严格大于$\frac{r-l+1}{k}$的数。如果存在就输出最小的那个$ans$，否则输出$-1$.</p>
<p>这个东西……就直接查询就好了啊……由于不用二分，所以复杂度相对来说稳定了一些。于是我就没有加上文中提到过的那个诡异的优化。我们每次先查左半边，就可以保证在值域上最小，也就是说每次我们都可以求出最小的合法$ans$了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt ;</span><br><span class="line">    sum[rt] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        L[rt] = build(l, mid) ;</span><br><span class="line">        R[rt] = build(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt ;</span><br><span class="line">    sum[rt] = sum[last] + <span class="number">1</span> ;</span><br><span class="line">    R[rt] = R[last] ;</span><br><span class="line">    L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ;</span><br><span class="line">        <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> Left, <span class="keyword">int</span> Right, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> aft[l] ; <span class="keyword">int</span> qwq ;</span><br><span class="line">    <span class="comment">// if (sum[Right] - sum[Left] &lt;= k) return -1 ;</span></span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; k) </span><br><span class="line">		<span class="keyword">if</span> ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; k) </span><br><span class="line">		<span class="keyword">if</span> ((qwq = query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++) base[i] = qr(), aft[i] = base[i] ;</span><br><span class="line">    sort(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) ;</span><br><span class="line">    Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>) ; </span><br><span class="line">    T[<span class="number">0</span>] = build(<span class="number">1</span>, Len) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">        pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft;</span><br><span class="line">        T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c) ; <span class="keyword">int</span> k = (b - a + <span class="number">1</span>) / c ;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, k) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，加上那优化之后，总用时大约$27000ms$，而我这个不加优化的版本足足跑了$56677ms$……真丢人啊</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构/可持久化/可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>防守战线[ZJOI2013] &amp; 志愿者招募[NOI2008]</title>
    <url>/2019/04/05/fszx-and-zyzzm/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-0x01-ZJOI2013-防守阵线"><a href="#rm-0x01-ZJOI2013-防守阵线" class="headerlink" title="$\rm{0x01}$ [ZJOI2013]防守阵线"></a>$\rm{0x01}$ [ZJOI2013]防守阵线</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3337" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3337</a></p>
<p>首先就是要明白怎么建模，大概就是：</p>
<script type="math/tex; mode=display">
\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots n)\\\
\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} x_{j} \geq d_i \quad (i = 1,2,3\cdots m)</script><p>其中$x_j$表示$j$这个地方有几座塔。</p>
<p>那我们首先把它对偶过去，就会得到：</p>
<script type="math/tex; mode=display">
\text{最大化} \quad \sum d_iy_i \quad(i = 1, 2,3 \cdots m) \\\
\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} y_{j} \leq c_i\quad (i = 1,2,3\cdots n)</script><p>然后我们考虑，似乎价值不能带小数啊，毕竟题目中规定了价值都为整数<del>(事实上并没有规定但是数据是这样给的)</del>，换句话说我们不能存在建某座塔的一部分(比如只建一半)。</p>
<p>那么这就是<strong>整数线性规划问题</strong>，换句话说就是<strong>自变量取值范围是$\Z$的线性规划</strong>。</p>
<p>呃，这问题已经被证明是$\rm{NP-Hard}$的问题了…但是，有一种矩阵叫做<strong>全幺模矩阵</strong>，即<strong>元素只会是$\boldsymbol{0,1,-1}$的矩阵</strong>，被证明肯定至少有一组最优解保证整数线性规划与实数线性规划的方案一致。</p>
<p><del>啥，你说啥？你要关于全幺模矩阵这个性质的争鸣？是百家争鸣那个争鸣吗？学OI呢别瞎讨论历史</del> </p>
<p>然后就可以一发单纯形给艹过去啦~开心心~</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e9</span> ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">double</span> A[MAXN][MAXM] ;</span><br><span class="line"><span class="keyword">int</span> N, M, B, E, i, j, k, p ; <span class="keyword">double</span> res, t, cost[MAXM], _need[MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> e, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">	cost[l] /= A[l][e], t = A[l][e], A[l][e] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (i != e) A[l][i] /= t ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">if</span> (i != l &amp;&amp; <span class="built_in">abs</span>(A[i][e]) &gt; eps)&#123;</span><br><span class="line">			cost[i] -= A[i][e] * cost[l] ;  </span><br><span class="line">			<span class="keyword">for</span> (p = <span class="number">1</span> ; p &lt;= M ; ++ p) <span class="keyword">if</span> (p != e) A[i][p] -= A[i][e] * A[l][p] ;</span><br><span class="line">			A[i][e] = - A[i][e] * A[l][e] ;</span><br><span class="line">		&#125; </span><br><span class="line">	res += _need[e] * cost[l] ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (i != e) _need[i] -= _need[e] * A[l][i] ;</span><br><span class="line">	_need[e] = - _need[e] * A[l][e] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">double</span> MINX = INF ; j = <span class="number">0</span>, k = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j) <span class="keyword">if</span> (_need[j] &gt; eps) <span class="keyword">break</span> ; <span class="keyword">if</span> (j &gt; M) <span class="keyword">return</span> res ; </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (A[i][j] &gt; eps &amp;&amp; MINX &gt; cost[i] / A[i][j]) k = i, MINX = cost[i] / A[i][j] ;</span><br><span class="line">		<span class="keyword">if</span> (MINX &gt;= INF) <span class="keyword">return</span> INF ;  Pivot(j, k) ;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;cost[i]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;B, &amp;E, &amp;_need[i]) ; <span class="comment">//约束 </span></span><br><span class="line">		<span class="keyword">for</span> (j = B ; j &lt;= E ; ++ j) A[j][i] = <span class="number">1.0</span> ;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(simplex() + <span class="number">0.5</span>)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么说呢，似乎单纯形有好多地方的写法都比较灵活<del>让我不知道背什么样的板子会更好</del></p>
<h1 id="rm-0x02-NOI2008-志愿者招募"><a href="#rm-0x02-NOI2008-志愿者招募" class="headerlink" title="$\rm{0x02}$ [NOI2008] 志愿者招募"></a>$\rm{0x02}$ [NOI2008] 志愿者招募</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3980" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3980</a></p>
<p><del>什么鬼啊这不是上面的那道题吗</del></p>
<p>还是：</p>
<script type="math/tex; mode=display">
\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots m)\\\
\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \geq A_i \quad (i = 1,2,3\cdots n)</script><p>其中$x_j$表示选择的第$j$类志愿者的个数，$w_{i,j}$表示在第$i$天，第$j$类志愿者能否选择。那么还是老样子，对偶过去就可以得到：</p>
<script type="math/tex; mode=display">
\text{最大化} \quad \sum A_ix_i \quad(i = 1,2,3\cdots n)\\\
\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \leq c_i \quad (i = 1,2,3\cdots m)</script><p>怎么说呢……这个一开始的建模比上一个题还是有难度的，因为上一个题的$L_i,R_i$跟约束有关，而这次的$L_i,R_i$则是跟目标函数有关——或许不应该这么说，但是看上去确实不如上面那题跟约束有关系就对了<del>(我在BB一堆什么啊)</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1035</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span> ; <span class="keyword">double</span> res ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> b[MAXM], e[MAXM] ; </span><br><span class="line"><span class="keyword">int</span> N, M, i, j, k ; <span class="keyword">double</span> C[MAXM], _need[MAXM], A[MAXM][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> posN, <span class="keyword">int</span> posC)</span></span>&#123;</span><br><span class="line">	C[posC] /= A[posC][posN] ; <span class="comment">// constraint divided by A_&#123;l,e&#125;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="keyword">if</span> (p != posN) A[posC][p] /= A[posC][posN] ;<span class="comment">//this line Booom</span></span><br><span class="line">	A[posC][posN] = <span class="number">1</span> ;</span><br><span class="line">	<span class="comment">// Pivot is above, taking it back is below</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= M ; ++ p)<span class="comment">//taking back to constraints </span></span><br><span class="line">		<span class="keyword">if</span> (p != posC &amp;&amp; <span class="built_in">fabs</span>(A[p][posN]) &gt; eps)&#123;</span><br><span class="line">			C[p] -= A[p][posN] * C[posC] ;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">				<span class="keyword">if</span> (i != posN) A[p][i] -= A[p][posN] * A[posC][i] ;</span><br><span class="line">			A[p][posN] = <span class="number">0</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	res += _need[posN] * C[posC] ;<span class="comment">//this time results in a better INIT-Sol</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="keyword">if</span> (p != posN) _need[p] -= _need[posN] * A[posC][p] ;</span><br><span class="line">	_need[posN] = - _need[posN] * A[posC][posN] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		j = <span class="number">0</span>, k = <span class="number">0</span> ; <span class="keyword">double</span> MAX = INF ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (_need[j] &gt; eps) <span class="keyword">break</span> ; <span class="comment">/*1*/</span> <span class="keyword">if</span> (j &gt; N) <span class="keyword">return</span> res ; <span class="comment">//make-it-sure if go on</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][j] &gt; eps &amp;&amp; MAX &gt; C[i] / A[i][j]) MAX = C[i] / A[i][j], k = i ; <span class="comment">//find the min_val constraint</span></span><br><span class="line">		<span class="keyword">if</span> (MAX &gt;= INF) <span class="keyword">return</span> INF ; <span class="comment">/* this task is unbounded */</span> Pivot(j, k) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; _need[i] ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;b[i], &amp;e[i], &amp;C[i]) ;</span><br><span class="line">		<span class="keyword">for</span> (j = b[i] ; j &lt;= e[i] ; ++ j) A[i][j] = <span class="number">1</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(simplex()+<span class="number">0.5</span>)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1]$ :$Candy?$的$blog$ <a href="https://www.cnblogs.com/candy99/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
        <tag>线性规划/对偶定理</tag>
      </tags>
  </entry>
  <entry>
    <title>【网络流24题专题】1 · 较简单的费用流</title>
    <url>/2019/03/29/nw-flow-24-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>包括以下可以用费用流解决的问题：</p>
<p><code>loj#6011</code> 运输问题，<code>loj#6012</code> 分配问题 、 <code>loj#6024</code> 深海机器人问题 以及  <code>loj#6025</code> 火星运输问题。</p>
<a id="more"></a>
<h1 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a>运输问题</h1><blockquote>
<p>给定一个二分图。一开始每个点有点权，对于一条边所连接的 $a_i,b_j$ ，可以让 $a_i\text{+=}\Delta,b_j\text{-=}\Delta$ 或者反过来，代价均为 $c_{i,j}\times \Delta$。现在需要让 $\sum a_i=\sum b_i$ ，最小化代价和。</p>
</blockquote>
<p>看了 $40\%$ ?</p>
<p>其实就是</p>
<script type="math/tex; mode=display">
\rm S\stackrel{f = a_i,c = 0}{\longrightarrow}i \stackrel{f = + \infty,c = c_{i,j}}{\longrightarrow}j \stackrel{f = b_j,c=0}{\longrightarrow}T</script><p>其中$i$代表仓库的编号，$j$代表商店的编号，建完图跑费用流即可。</p>
<p>由于SPFA死了，所以就一直用$dijk$做费用流，只不过难背一点……然后第二问的话就把权值取负重新做一下费用流就好。</p>
<p>总结一下，这个题似乎是比较裸的费用流的题了？一般费用流大概都是用来求解最优化问题的吧qwq……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next, f, c ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> S, T, N, M, dist[MAXN], i, j, k, t[MAXN], x ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dist, num ;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp; now) <span class="keyword">const</span>&#123;<span class="keyword">return</span> dist &gt; now.dist ; &#125;</span><br><span class="line">&#125;; priority_queue&lt;node&gt; q ; <span class="keyword">bool</span> vis[MAXN] ; <span class="keyword">int</span> Last[MAXN], F[MAXN], H[MAXN], Pre[MAXN], MAX_C ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].c = c, t[cnt] = f ;</span><br><span class="line">	E[cnt].f = f, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, E[cnt].c = -c, t[cnt] = <span class="number">0</span> ;</span><br><span class="line">	E[cnt].f = <span class="number">0</span>, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>, S&#125;) ; vis[S] = dist[S] = <span class="number">0</span>, F[<span class="number">0</span>] = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i) dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		node now = q.top() ; q.pop() ;</span><br><span class="line">		<span class="keyword">int</span> fr = now.num, sec = now.dist ; <span class="keyword">if</span> (vis[fr]) <span class="keyword">continue</span> ;</span><br><span class="line">		<span class="keyword">for</span> (vis[fr] = <span class="number">1</span>, k = head[fr] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line">			<span class="keyword">int</span> nowc = sec + E[k].c + H[fr] - H[to(k)] ;</span><br><span class="line">			<span class="keyword">if</span> (E[k].f &gt; <span class="number">0</span> &amp;&amp; !vis[to(k)] &amp;&amp; dist[to(k)] &gt; nowc)&#123;</span><br><span class="line">				dist[to(k)] = nowc, q.push((node)&#123;dist[to(k)], to(k)&#125;) ;</span><br><span class="line">				F[to(k)] = min(F[fr], E[k].f), Pre[to(k)] = fr, Last[to(k)] = k ; </span><br><span class="line">			&#125;<span class="comment">//!!!!!</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dist[T] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> _Ed ; MAX_C = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (dijkstra())&#123;</span><br><span class="line">		_Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line">		<span class="keyword">while</span>(_Ed != S)	E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ <span class="number">1</span>].f += F[T], _Ed = Pre[_Ed] ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] += dist[i] ; <span class="comment">/*	cout &lt;&lt; MAX_C &lt;&lt; endl ;  */</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; MAX_C * qwq &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, S = <span class="number">0</span> ; </span><br><span class="line">	T = N + M + <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(S, i, x, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(i, T, x, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)	</span><br><span class="line">		<span class="keyword">for</span> (j = N + <span class="number">1</span> ; j &lt;= N + M ; ++ j)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(i, j, Inf, x) ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt;= cnt ; ++ i) printf("%d %d %d\n", E[i].to + 1, E[i].f, E[i].c) ;</span></span><br><span class="line">	MCMF(<span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i], E[i].c = -E[i].c ; MCMF(<span class="number">-1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分配问题"><a href="#分配问题" class="headerlink" title="分配问题"></a>分配问题</h1><blockquote>
<p>两个部均为 $n$ 个点的最大权二分图完美匹配匹配问题。</p>
</blockquote>
<p>可能会存在一个神奇的KM算法。但是自己不会x</p>
<p>发现此题中不仅需要最大权，也需要完美匹配。所以直接跑最小费用/最大费用最大流即可。</p>
<p>细节的话，考虑直接在二分图匹配的流图基础上，加上 $c_{i,j}$ 的费用就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">此处是dijkstra……</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> _Ed ; MAX_C = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">while</span> (dijkstra())&#123;</span><br><span class="line">		_Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line">		<span class="keyword">while</span>(_Ed != S)	</span><br><span class="line">      E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ <span class="number">1</span>].f += F[T], _Ed = Pre[_Ed] ;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] += dist[i] ; <span class="comment">/*	cout &lt;&lt; MAX_C &lt;&lt; endl ;  */</span></span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; MAX_C * qwq &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + N ; ++ i) Add(i, T, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="keyword">for</span> (j = N + <span class="number">1</span> ; j &lt;= N + N ; ++ j)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; x, Add(i, j, Inf, x) ;</span><br><span class="line">	MCMF(<span class="number">1</span>) ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">    E[i].c = -E[i].c, E[i].f = t[i] ;</span><br><span class="line">  MCMF(<span class="number">-1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="火星探险问题"><a href="#火星探险问题" class="headerlink" title="火星探险问题"></a>火星探险问题</h1><blockquote>
<p>火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。探测车在移动中还必须采集岩石标本，每一块岩石标本由最先遇到它的探测车完成采集，每块岩石标本只能被采集一次。岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。探测车不能通过有障碍的地面。</p>
<p>本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。</p>
<p>用一个 $\text{P}\times \text{Q}$ 网格表示登陆舱与传送器之间的位置。登陆舱的位置在 $(X_1,Y_1)$ 处，传送器 的位置在 $(X_P,Y_Q)$ 处。 给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多， 而且探测车采集到的岩石标本的数量最多。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://www.oj.swust.edu.cn/upload/image/problem/1758.png" alt="233"> </p>
</blockquote>
<p>发现每个点虽然可能有至多 $1$ 个石块，但是可以重复经过。于是自然想到把每个点拆成俩，之间连 $f=1,c=-1$ 的边。对于一个点 $x$ 和他直接连通的点 $y$ ，将 $x,x’$ 和 $y,y’$ 这 $2*2=4$ 个点对分别连 $f=\infty,c=0$ 的普通边，代表着走还是不走。当然这个地方还有另一个处理方法，就是直接拿 $x’$ 去跟 $y$ 连，然后每个 $x$ 再和 $x’$ 连一个 $f=\infty,c=0$ 的边。可以知道这样是本质相同的。</p>
<p>最后 $dfs$ 输出方案。这里 $dfs$ 的方式对我自己而言是有启发的。本来想的是逐渐增加 $\rm S$ 的初始流量，然后去 $dfs$ 找哪些边已经满流了。但这样没法去记录哪些是这一层增广的，哪些是之前增广的。所以考虑一开始全部流一下，然后边 $dfs$ 边模拟流的过程。<strong>判断每条边是否应该被流，直接看反向边的流量即可。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num ;</span><br><span class="line"><span class="keyword">int</span> tot ;</span><br><span class="line"><span class="keyword">int</span> fl[M] ;</span><br><span class="line"><span class="keyword">int</span> ans[M] ;</span><br><span class="line"><span class="keyword">int</span> Id[N][N] ;</span><br><span class="line"><span class="keyword">int</span> base[N][N] ;</span><br><span class="line"><span class="keyword">int</span> _n, _m, _k ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dodo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">if</span> (x == _n &amp;&amp; y == _m)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; len ; ++ i)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">" "</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = Id[x][y] ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (fl[k] &gt;= fw(k ^ <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">continue</span> ; <span class="keyword">else</span> fl[k] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == Id[x + <span class="number">1</span>][y])</span><br><span class="line">            &#123; ans[len] = <span class="number">0</span> ; dodo(x + <span class="number">1</span>, y, len + <span class="number">1</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == Id[x][y + <span class="number">1</span>])</span><br><span class="line">            &#123; ans[len] = <span class="number">1</span> ; dodo(x, y + <span class="number">1</span>, len + <span class="number">1</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == Id[x + <span class="number">1</span>][y] + tot)</span><br><span class="line">            &#123; ans[len] = <span class="number">0</span> ; dodo(x + <span class="number">1</span>, y, len + <span class="number">1</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == Id[x][y + <span class="number">1</span>] + tot)</span><br><span class="line">            &#123; ans[len] = <span class="number">1</span> ; dodo(x, y + <span class="number">1</span>, len + <span class="number">1</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	now += tot ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; ~k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (fl[k] &gt;= fw(k ^ <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">continue</span> ; <span class="keyword">else</span> fl[k] ++ ;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == Id[x + <span class="number">1</span>][y])</span><br><span class="line">            &#123; ans[len] = <span class="number">0</span> ; dodo(x + <span class="number">1</span>, y, len + <span class="number">1</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == Id[x][y + <span class="number">1</span>])</span><br><span class="line">			&#123; ans[len] = <span class="number">1</span> ; dodo(x, y + <span class="number">1</span>, len + <span class="number">1</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == Id[x + <span class="number">1</span>][y] + tot)</span><br><span class="line">            &#123; ans[len] = <span class="number">0</span> ; dodo(x + <span class="number">1</span>, y, len + <span class="number">1</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == Id[x][y + <span class="number">1</span>] + tot)</span><br><span class="line">            &#123; ans[len] = <span class="number">1</span> ; dodo(x, y + <span class="number">1</span>, len + <span class="number">1</span>) ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; _k &gt;&gt; _m &gt;&gt; _n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= _n + <span class="number">1</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= _m + <span class="number">1</span> ; ++ j)</span><br><span class="line">            base[i][j] = <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= _m ; ++ j)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; base[i][j], Id[i][j] = ++ tot ;</span><br><span class="line">    n = <span class="keyword">_t</span> = tot * <span class="number">2</span> + <span class="number">1</span> ; _s = <span class="number">0</span> ;</span><br><span class="line">    add(_s, <span class="number">1</span>, _k, <span class="number">0</span>) ; </span><br><span class="line">	<span class="comment">//add(_s, tot + 1, _k, 0) ;</span></span><br><span class="line">    <span class="comment">//add(Id[_n][_m], _t, _k, 0) ; </span></span><br><span class="line">	add(Id[_n][_m] + tot, <span class="keyword">_t</span>, _k, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= _m ; ++ j)&#123;</span><br><span class="line">			<span class="keyword">if</span> (base[i][j] == <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (base[i + <span class="number">1</span>][j] != <span class="number">1</span>)&#123;</span><br><span class="line">                add(Id[i][j], Id[i + <span class="number">1</span>][j], I, <span class="number">0</span>) ;</span><br><span class="line">                add(Id[i][j], Id[i + <span class="number">1</span>][j] + tot, I, <span class="number">0</span>) ;</span><br><span class="line">                add(Id[i][j] + tot, Id[i + <span class="number">1</span>][j], I, <span class="number">0</span>) ;</span><br><span class="line">                add(Id[i][j] + tot, Id[i + <span class="number">1</span>][j] + tot, I, <span class="number">0</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (base[i][j + <span class="number">1</span>] != <span class="number">1</span>)&#123;</span><br><span class="line">                add(Id[i][j], Id[i][j + <span class="number">1</span>], I, <span class="number">0</span>) ;</span><br><span class="line">                add(Id[i][j], Id[i][j + <span class="number">1</span>] + tot, I, <span class="number">0</span>) ;</span><br><span class="line">                add(Id[i][j] + tot, Id[i][j + <span class="number">1</span>], I, <span class="number">0</span>) ;</span><br><span class="line">                add(Id[i][j] + tot, Id[i][j + <span class="number">1</span>] + tot, I, <span class="number">0</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (base[i][j] == <span class="number">2</span>)</span><br><span class="line">                add(Id[i][j], Id[i][j] + tot, <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">        	<span class="comment">//add(Id[i][j], Id[i][j] + tot, I, 0) ;</span></span><br><span class="line">		&#125;</span><br><span class="line">    ek() ; <span class="comment">//cout &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= _k ; ++ i)</span><br><span class="line">        num = i, dodo(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="深海机器人问题"><a href="#深海机器人问题" class="headerlink" title="深海机器人问题"></a>深海机器人问题</h1><blockquote>
<p>深海资源考察探险队的潜艇将到达深海的海底进行科学考察。潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。</p>
<p>本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。用一个 $\text{P} \times \text{Q}$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$ ，东北角的坐标为 $(Q,P)$ 。</p>
<p>给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://www.oj.swust.edu.cn/upload/image/problem/1755.png" alt="233"></p>
</blockquote>
<p>发现…似乎和上一道题差不多？唯一的区别就是权放到边上了，大概是24题里最简单的题之一了吧？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; _n &gt;&gt; _m ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= _m ; ++ j)</span><br><span class="line">            Id[i][j] = ++ tot ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; _m ; ++ j)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c, add(Id[i][j], Id[i][j + <span class="number">1</span>], <span class="number">1</span>, -c) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= _m ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; _n ; ++ j)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; d, add(Id[j][i], Id[j + <span class="number">1</span>][i], <span class="number">1</span>, -d) ;</span><br><span class="line">    n = <span class="keyword">_t</span> = tot + <span class="number">1</span> ; _s = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= _n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= _m ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; _n) add(Id[i][j], Id[i + <span class="number">1</span>][j], I, <span class="number">0</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; _m) add(Id[i][j], Id[i][j + <span class="number">1</span>], I, <span class="number">0</span>) ;</span><br><span class="line">           &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= a ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; _k &gt;&gt; c &gt;&gt; d, add(_s, Id[c][d], _k, <span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= b ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; _k &gt;&gt; c &gt;&gt; d, add(Id[c][d], <span class="keyword">_t</span>, _k, <span class="number">0</span>) ;</span><br><span class="line">    ek() ; <span class="built_in">cout</span> &lt;&lt; -res &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后谷的讨论区快笑死我了：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="fmf.png" alt=""></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>网络流24题</tag>
        <tag>网络流/费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>随想七 · 言葉の庭</title>
    <url>/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>​    Hello darkness my old friend. 黯淡如旧，今时重逢。<br>​    I’ve come to talk with you again. 阔别久日，可赴低叙？<br>​    Because a vision softly creeping. 如梦如幻，于我心萦。<br>​    Left its seeds while I was sleeping. 遗之入梦，齐我心同。<br>​    And the vision that was planted in my brain. 不知归处，不知归处。<br>​    Still remains with the sound of silence. 行舟如风，遣舟迟暮。<br>​    In restless dreams I walk alone. 吾心独行，兰皋止息。<br>​    Narrow streets of cobble stone. 越陌度阡，可有一醉？<br>​    Beneath the hallo of a street lamp’, 如光化影，于我心寂。<br>​    I turned my collar to the cold and damp. 浊寒入襟，刺我心底。<br>​    When my eyes were stabbled. 所见皆幻，所见皆明。<br>​    By the flash of a neon light. 万物皆虚，万物皆允。<br>​    That split the night. 不知归处，不知归处。<br>​    And touched the sound of silence 星瀚灿漫，行人慢走。</p>
<p>​    ——『$\rm{The ~Sound~of~Silence}$』寂静之声</p>
</blockquote>
<p>随想系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<p>这次大概会写的时间线很跳跃，但我真的是被这个故事叩击了心脏最深处的地方。</p>
<hr>
<h1 id="rm-Part-1"><a href="#rm-Part-1" class="headerlink" title="$\rm{Part~1}$"></a>$\rm{Part~1}$</h1><p>月考结束了。我终于有时间把这本书读完。</p>
<p>之前是一次周末，固定的奥赛时间。中途课件去学校的书店逛——一个不错的书吧，书墨香透着小资情调。</p>
<p>我在不起眼的地方，偶然发现了一本《言叶之庭》——看起来是最后一本了，想都没想就买了。38元，不便宜，薄薄的一本，但是封面却是一片令人赏心悦目的浓绿——是用油彩画的树叶，很漂亮——遂觉得不算物不抵价。</p>
<p>但买回来才发现，不是新海诚的写的，而是他的一个“好基友”加纳新太，站在秋月孝雄的立场写的。剧情大体上跟我一年之前看过的46分钟的短片差不多，“就当买了收藏吧”我想。</p>
<p>《言叶之庭》是我去年刚来实验部的时候接触的新鲜东西之一——初中时只懵懂地看过《你的名字》，被里面超越时空的爱情吸引的不要不要的。当时看完确实觉得是部好片，因为剧情很吸引人——当然，大多数都是我的主观感情在起作用，因为当时懵懂的我正好迫切地渴望一次说走就走的爱情。</p>
<p>那本薄薄的书又带我回想起了第一次看《言叶之庭》时的满足和愉悦，于是便决定买新海诚的原版来看。我并不认为新海诚的原版会比加版或动画版好多少，毕竟故事就是那么个故事，无非是视角不一样罢了。</p>
<p>并且我也觉得，似乎加版和电影版刻画的人物都太单薄了？反正我在看完加版之后，又重看了一遍电影版，发现不光人物好几处画崩了，有些东西写的似乎太少——不只是意犹未尽了，更像是连说都没说完。所以我一直期待着能够赶紧月考完，好让我在老师忙于讲题+阅卷、没空布置作业的时候，有空看一下新海诚的原版——原版是月考前的大休来的货，书封的主色调是白色的，封1是一张动画电影里的截图——一只睡莲，躺在下着雨的河里。</p>
<p>或许那时我还不知道，我将会看到一个怎样完整、优秀、细腻的故事——电影和加版，和原版比起来，简直贻笑大方。</p>
<h1 id="rm-Part-2"><a href="#rm-Part-2" class="headerlink" title="$\rm{Part~2}$"></a>$\rm{Part~2}$</h1><p>感动，满足，幸福，美好……都是我看完的第一想法；独步天下，绝无仅有……则是第二想法。</p>
<p>连续两个中午未眠，再加上考完试的轻松，让我在$3$月$28$日中午读完了这本书。还有二十分钟才吹起床哨，遂决定小眠片刻，谁知梦里朦胧的，全是言叶里面的内容，全是雪野和孝雄，全是棉花糖一样柔软香甜的梦幻，在我的脑海里欺负、沉淀、卷缩、舒张——那真是我有生以来经历过的最单纯而又美好的时光之一。</p>
<p>我更加坚定地认为，这种只属于梦幻的东西，这种“天上语”，“天籁之音”，都应该留在那个梦幻的世界里——大抵上就是要把“现实”和“梦幻”割裂开来吧。我认为，把这种“此曲只应天上有，人间难得几回闻”的美好，带到这个现实的、令人失望的世界，是一种对它的侮辱。</p>
<p>所以，我不打算去看知乎的评论，不愿去看书评，不愿去与别人聊起这部小说——我只想把这种最单纯的梦幻，留给最纯粹的世界，精心地呵护。</p>
<p>……</p>
<p>说起原因，大抵上有很多。比如电影里剧情的淡薄，在这部小说里得到了很好的充实，让我满足得很；比如雪野和孝雄之间未曾言明，但是却无比真挚、无比纯粹、无比坚固的爱情——那是最美好的爱情了吧，厮守，陪伴大概是最长情的告白；比如书中每个人的心理活动，细腻，真切，读起来一气呵成；比如……</p>
<p>但是我总感觉，这些其中的某个，或者是他们的并集，从客观上讲，都不能成为让我如此动容的理由。</p>
<p>现在想来，上一次如此感动至深，还是在看真人电影版的《我想吃掉你的胰脏》的时候。我自认为像这种具有强大感染力的文艺作品，用动画去表现实在是太单薄了——或许需要好的演员，或许需要好的文字，总之，小说和真人电影，都要有更好的效果——当时哭的稀里哗啦的。我也不知道到底为何而哭，明明男女主之间都没有令人羡慕的爱情，明明女主最后都已经在劝男主忘掉她，明明情节就是那么的简单俗套……</p>
<p>我不知道为什么。</p>
<p>总之，很美就对了。我大概需要再过好多好多天才能缓过来吧。现在的状态大概是一闲下来就会想起言叶里面的内容，每当独自一个人时，脑子里便全是$1.$百香里和孝雄之间如潺潺不绝的流水一样的真挚感情$2.$百香里是如何一个人扛过那些岁月的$3.$他们最后相遇以后会怎样，在一起之后会怎样的快乐……感觉自己仿佛变成了一个多情细腻的小姑娘，重复回想着书中的一幕幕。“如果站在新海诚的作家立场上看，他这本书对我这个读者来说，已经是极为成功的了吧”我心想。</p>
<p>我甚至会幻想世界上真有一个百香里，一个孝雄，他们在某个时间点相遇、相伴、相携、相知、相爱……那该是多美好的童话啊。或许百香里经历的一切，其背后的原因都是那么的无厘头、甚至是荒谬——毕竟是青春期的孩子一首酿成的错误——但或许老天是为了有个利用奖赏给她一份完美的、童话般的爱情，才会先让她经历一些痛苦吧。毕竟如果雪野不经历这些，或许他跟孝雄就会是永远陌生人了……</p>
<p>突然感觉自己真的…居然都开始相信主观唯心主义了…真是不可救药地沉浸在这本书里了啊。</p>
<p>这绝对是我读过的最美的故事了。</p>
<h1 id="rm-Part3"><a href="#rm-Part3" class="headerlink" title="$\rm{Part3}$"></a>$\rm{Part3}$</h1><p>现在是$3.27$的中午，我躺在寂静的宿舍里，看着《言叶之庭》——大概，“三分之一是读完了吧?”我想。</p>
<p>“这本书大抵上是新海诚在拍《言叶之庭》之前写的吧，”我想，“所以或许会跟很无聊，毕竟情节是都知道的”。确实，看完加版、重温完电影版之后，如果是相同的内容，对我来说确实是有点枯燥。</p>
<p>但是当我现在看到主角为“秋月翔太”这一章时，似乎感到了什么奇怪的事情发生了——书中对男主哥哥的描写得如此详细，甚至绝大部分情节都是原作里面没有的。虽然前面几节里面也有或多或少的情节没在电影里出现，但是一整章的内容全部掐掉，也未免太狠心了吧。</p>
<p>我突然开始着迷起来，开始觉得新海诚是个小天才了——其情节设置的是如此的合理，让我越来越感到满足。原本困倦的我似乎来了精神，“一定要赶紧读完”，我心想。</p>
<p>……</p>
<p>读完之后，后记里面新海诚是这么描述的：</p>
<blockquote>
<p>我一直单恋着小说。<br>不只是小说，我觉得自己也一直单恋着漫画、电影、动画与现实中的风景。也就是说，这是一<br>种「我喜欢对方，对方却对我没什么兴趣」的状态。我也知道自己是四十几岁的成年人了，不该再<br>想这些没有意义的事，但我却怎么样也摆脱不了这种情绪。</p>
<p>……</p>
<p>写小说是很愉快的，我能够尽情写出动画表达不出来的情节，或是很难的内容。例如，写到<br>「她的脸上浮现迷途孩子般的微笑」，我就会（对身为动画导演的自己）示威：「怎样！」怎样？<br>这句话很难用影像表现吧！演员能恰如其分诠释出「迷途孩子般的表情」吗？动画师能画出每个人<br>一看就知道是「迷途孩子」的脸吗？不可能！不安的表情或许可以办到，但是「迷途孩子般的」这<br>种简洁明白的形容，很难利用影像呈现。又或是当我写到：「门外的喧闹声，宛如从耳机里外溢的<br>声音……」，我就会狞笑心想：「这个你（影像）也做不到吧？」观众无法从教室的环境音联想到<br>耳机声音外溢云云。<br>我透过写作切身感受到，小说的乐趣就在于文字的连结。我注意到自己利用写后记的方式来回<br>顾那段时光时，就会独自感到雀跃不已，总之就是非常地幸福。</p>
<p>……</p>
<p>写完一本书最大收获，反而是更加深了我对于小说和动画的单恋情怀。反正我本来就不期待两<br>情相悦。我有时会想到，孝雄对雪野的感情，是否也有相似的东西？若这么说来，本书里的角色多<br>多少少都在单恋。我重新体悟到自己想写的，就是人们的这种心情——孤单渴望某个人、某项事物<br>的心编织出这个世界。而本书想要描述的就是这点。<br>在「爱」以前，这是段「孤独希求」的故事。<br>这句话是电影版的宣传文案。想必现代也有不少人对于远在一千三百年前的万叶时代，将「恋<br>爱」这个字，写作「孤悲（孤寂悲伤）」深表同感。</p>
</blockquote>
<p>我想，这大概也是这部小说迷人的因素之一吧——原本就已经很完整的情节，加上妙笔的勾勒，瞬间活灵活现起来。</p>
<h1 id="rm-Part-4"><a href="#rm-Part-4" class="headerlink" title="$\rm{Part~4}$"></a>$\rm{Part~4}$</h1><p>选了几段放到这里，留作纪念。</p>
<p>首先是最后，孝雄和雪野重逢的情景：</p>
<blockquote>
<p>走过日本庭园的木桥，雨声又起了些微变化。树叶摇曳的声音，胜过雨滴敲打水面的声音。自<br>制的雕花皮鞋，缓缓踏在土壤上的脚步声，伴着绿绣眼清脆的鸣啭。越过日本黑松所见到的水面、<br>杜鹃花倒映在水面上的粉红色、千头赤松树皮的红色，以及枫叶的灿绿色。<br>孝雄的后背包里装着为那个人打造的鞋子。那是一双约五公分高的小巧尖头高跟鞋，鞋尖是浅<br>粉红色，鞋身是近乎白色的浅肤色，脚踵处是仿佛阳光照耀的柠檬黄色，缠绕在脚踝上的长脚踝带<br>上缝着枫叶的形状。<br>这双鞋是为了那个人打造，一定可以走得更长更远。<br>不知从何处传来老乌鸦强有力的鸣叫，远方的天空隐约响起了雷鸣声。<br>——隐约雷鸣。<br>孝雄脱口而出这句话。<br>一股预感充满全身。<br>已经可以看到浸湿枫叶后侧的凉亭，那里坐着一个人。<br>孝雄吸入雨水的气味，克制住自己的心情，继续走向凉亭，穿过层层树叶后，整座凉亭映入眼<br>帘。<br>那是一位穿着浅绿色裙子的女人。<br>孝雄停下脚步。<br>有着一头剪至齐肩柔软短发的女人，正把咖啡举到嘴边，她轻轻瞥了他一眼。<br>看着雪野从快要哭出来的紧绷表情，逐渐绽开笑容。<br>孝雄心想，雨好像停了。</p>
</blockquote>
<p>然后是孝雄表白完、雪野拒绝后，雪野的心声：</p>
<blockquote>
<p>「可是你的衣服还没干……」雪野望着他远去的背影，不由得大叫。<br>不对，这样正好。雪野逼自己收回视线，低头看着手中的咖啡杯，隐约听见他关上更衣间的<br>门。雪野把还没喝上一口的咖啡杯举到嘴边，袅袅升起的热气微微沾湿了睫毛。她想要喝咖啡，却<br>觉得杯子沉重异常，只得把它放回桌上。雪野体内有一团像刺猬般带刺的情绪，笨拙地四处乱闯。<br>这情绪似乎是后悔和内疚，正一阵阵刺痛雪野的心并沉默地责怪她。<br>不然我该怎么做？雪野几乎就要哭出来了。我从一开始就没有选择的余地。我明明那么真诚地<br>对待每一个人，明明想成为像阳菜子老师那样温柔体贴的大人，明明努力回应任何一个需要我的<br>人。雪野看着逐渐稀薄的咖啡热气。我不要待在世界的外围，我想进到世界的里面，我想成为这个<br>耀眼世界的一部分。我以为只要长大，一切就会顺利；我以为照这样下去，就能和大家一样正常生<br>活。可是，却发现自己被卷入那些像淋雨般避不掉的灾难里。先是伊藤老师出现，然后牧野同学出<br>现，最后相泽同学也出现，我的生活变得一团糟。好不容易来到屋檐下可以躲躲雨，这回秋月出现<br>了。每个人都在扰乱我的心，我想要静静地待着。但我一个人就连只是站着，都如此勉强，每天光<br>是不让自己蹲下，就必须耗费莫大的力气。<br>听见脚步声慢慢移近，雪野抬起头。他站在浅浅的青绿色影子里，身上已经换上应该还是半干<br>的制服。<br>「那个，我要走了。各方面来说，非常感谢你。」他静静说完，深深一鞠躬，不等雪野回应便<br>朝着玄关走去。<br>「啊！」<br>雪野不自觉离座起身。等等，多待一会儿吧。你没有带伞，对吧？等雨停再走吧？——不对，<br>不是这样，不可以这样说。雪野默然不语，又一次慢慢坐回椅子上。他的脚步声愈来愈远，穿鞋的<br>声音，转开门把的声音。然后——</p>
<p>啪嗒。关门的声音。<br>那一瞬间，雪野突然感到很气愤。<br>「笨蛋！」<br>她大吼一声，抓起坐着的椅子作势要扔出去，可是，她怒视的前方已经没有半个人在。她顿时<br>泄气地慢慢放下椅子，再次坐了下来。<br>「……笨蛋。」她小声地又说了一次。<br>秋月那个笨蛋。<br>一副单方面被甩的受害者表情、一副自己没做错任何事的表情，你根本不知道你没来凉亭的暑<br>假里，我是怀抱着什么样的心情度过。你的高一暑假一定过得很欢乐吧！你可以每天和家人一起吃<br>饭，可以和班上女同学去喝茶，你根本完全无法想像大你十二岁的女人过着什么样的生活。<br>一阵鼻酸，热气堵住喉咙，胸口苦闷难受，眼眶渗出泪水，她以手掌紧紧按住双眼阻止这一<br>切，湿眼皮内侧浮现犹如细窄迷宫般的白色纹路。始终搁在桌上的那杯咖啡，仍在无声无息地持续<br>冷却着。<br>——结束这段时光的人，是你啊！<br>雪野不禁有些埋怨。你果真还是个孩子。如果你不说那种话，我们说不定还能一起吃饭、交换<br>连络方式，或是你会在我要回老家那天来送我，说不定我们还能够以温和平静、痛苦最少的方式，<br>静静地结束我们的关系。<br>其实我一直在忍耐。<br>其实我一直没有说出口。<br>其实我一直没有说出来过——</p>
<p>我喜欢你。</p>
</blockquote>
<p>还有两段段很有名的摘录下来：</p>
<blockquote>
<p>二十七岁的我，丝毫不比十五岁时候的我聪明。<br>雪野望着阳光愈来愈炫目、影子逐渐加深的庭园，带着有人在为自己打分数的心情，如此想<br>着。</p>
</blockquote>
<p>还有孝雄的情感爆发：</p>
<blockquote>
<p>孝雄故意打断她的话，什么也不想听，「雪野姐，请你忘了我刚才说的话。」<br>仿佛事先背好的台词，孝雄很自然、干脆地说出这句话。他直直望着雪野，说出必须说的话，<br>说出他觉得为了她应该要这么说的话：「我其实很讨厌你。」<br>吹进来的雨滴打在脸颊上。雪野十分哀伤地眯着眼。孝雄真的觉得自己非常厌恶事到如今才<br>露出这副表情的她。<br>「我一开始就觉得你这个人……有够讨厌，一大早就在公园里喝啤酒，还留下莫名其妙的和<br>歌。」孝雄说着。<br>过去因为这个雨女而尝到的困惑、焦躁、嫉妒、憧憬、期盼、祈求、希望、绝望等所有情绪，逐渐化为怒意。他再也管不住自己的嘴巴。<br>「你从来不说自己的事，却老是探听我的事。你早就知道我是你的学生吧？你这种做法有够卑<br>鄙！」<br>讨厌！我讨厌这个女人。一副受到伤害的表情，现在又一副要哭的样子，我最讨厌她了！<br>「如果知道你是老师，我绝对不会告诉你鞋子的事。反正你会觉得那是做不到，也不可能实现<br>的梦想，对吧？你为什么不那样说？还是你觉得这只是小孩子讲的话，随便应付一下就好？」<br>讨厌！我讨厌自己像孩子一样，为这种事情嚷嚷。<br>「你一开始就知道我向往什么、憧憬谁，也知道那个人不会接受、目标永远不会实现。你都知<br>道！」<br>我讨厌自己在女人面前哭得这么难看，我一直一直努力当个大人，你却把我变成这副模样。我<br>讨厌你！<br>「……既然如此，你应该一开始就对我说啊！说我碍事！说臭小子快去上学！说你讨厌我！」<br>但如果不这么做，我会一辈子都爱着你。好喜欢好喜欢好喜欢，就连现在的每一分每一秒也更<br>加喜欢你。<br>「你就一直那样……」<br>——开什么玩笑，怎么连你也哭了？<br>「你就一直那样，摆出若无其事的表情……」<br>秋月的泪水滴滴答答滑落，大吼着。<br>「——一直孤单一人，度过一生吧！」</p>
</blockquote>
<p>……</p>
<p>今天是三月二十九日，我突然好像明白了自己如此着迷与这个故事的原因。</p>
<p>孤独。</p>
<p>对，就是这个词，孤独。</p>
<p>无论是《我想吃掉你的胰脏》真人电影也好，《言叶之庭》也好，男主一直是孤独的——只不过他们自己不觉得孤独，但是却有一种呼之欲出的孤独感；紧接着他们分别遇到了女主，从此开始不再孤独——孝雄可以每逢雨天去亭子里和雪野相见，春树也可以每天有樱良为伴——虽然不清楚春树到底喜不喜欢这样。</p>
<p>总之，本来单调的生活，突然就多彩了起来：眼前是未曾见过的亮丽景色。一切仿佛是命中注定，有种天赐的使命感让你爱她，而她也让你的生活看起来没有那么无聊——“每个不曾起舞的日子。都是对生命的辜负”，她或许就是你生命中的领舞者。总之，心中如同拨云见日了一样，有着明快的节奏和爽朗的旋律。</p>
<p>或许新海诚已经说出来了，他想营造的就是“孤独”的气氛，而这冰凉冰凉的孤独如同一把有着水蜜桃香气的箭，穿过我胸腔前薄薄的几层肌肤，直戳我内心最柔软的地方——我好孤独啊。</p>
<p>或许一旦我忙起来，我就不再对《言叶》有这么深厚的感情了；或许一旦我有了可以让我的生活热闹起来的人，我就不再对《言叶》有这么深层次的共鸣了；或许……</p>
<p>但我没有啊，哈。</p>
<p>但是我因此而悲伤吗？或许吧。但我更庆幸可以有这个机会，想未谙世事的小女孩一样肆意幻想这个世界上最美好的东西。这对我来说，或许已经足够了。</p>
<p>天边是一抹飘逸的鱼肚白，点缀着一只金黄色的太阳，随卷舒的云在碧蓝的天空中摇曳，有着别致的美感。</p>
<h1 id="rm-Part-5-Ending"><a href="#rm-Part-5-Ending" class="headerlink" title="$\rm{Part~5/Ending}$"></a>$\rm{Part~5/Ending}$</h1><p>今天是$3$月$31$日，我终于可以直面一些东西了。比如我在听到言叶的主题曲时，不在感到孤独和压抑，更多的则是对新生活的盼望。</p>
<p>我一直在想，这本书到底能带给我什么。</p>
<p>是如何小心地呵护一个人吗？是为了一个目标（比如孝雄对制鞋）要不断披荆斩棘吗？是要坚强吗？是要珍惜身边每一个人吗？是……？……</p>
<p>我不知道，但我觉得我列举的每个目的都太肤浅。</p>
<p>或许读书，读一个令人感动的故事，真的不会带来什么特别的东西。但那会化成血与肉，填充进我的身体；会化成一缕青烟，迷蒙在我的脑海里，最终沉积下来，到它应该到的地方去。</p>
<p>说的太模糊了，“到它应该到的地方去”，究竟是到哪去呢？是沉积到脑袋里，沉积在心里，还是沉积在我身体上随便哪个器官上？又或许它根本不会停留，于我而言只是一个过客，可以突然从我身上蒸发走呢……？</p>
<p>我不会知道——毕竟，我连自己的路都仍不知要如何去走，我连自己的去处都仍不知该何处寻觅，这种事情我也更不会知道了吧。</p>
<p>$\mathfrak{Orchidany, 3,31,2019}$</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】线性规划对偶定理</title>
    <url>/2019/03/19/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p>
<h1 id="rm-Preface-About-Duality-Theorm"><a href="#rm-Preface-About-Duality-Theorm" class="headerlink" title="$\rm{Preface:} About~Duality~Theorm$"></a>$\rm{Preface:} About~Duality~Theorm$</h1><p><strong>线性规划对偶定理</strong>：我们朴素的线性规划大致如下：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\
\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)</script><p>那么我们称它的<strong>对偶</strong>为形如下的线性规划：</p>
<script type="math/tex; mode=display">
\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\
\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)</script><a id="more"></a>
<p>换做矩阵表示就会是这样：</p>
<script type="math/tex; mode=display">
\text{最小化}\quad \boldsymbol{b^Ty} \\
\text{满足约束} \quad A^T\boldsymbol{y\geq c} \\\
\it{\qquad \qquad \quad} \boldsymbol {y} \geq 0</script><p>那其实比较显然的是，我们原来线性规划中的约束向量与目标函数里的系数向量交换，目标函数的最大化变成了最小化。现在我们思考对偶的意义。</p>
<p>首先假设我们有这么一个线性规划：</p>
<script type="math/tex; mode=display">
\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\
\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)</script><p><del>其实就是上面那个</del></p>
<p>我们的目的其实等价于确定目标函数的下界。我们观察每一组约束，假设有一组约束是</p>
<script type="math/tex; mode=display">
\quad \sum \limits_{j=1}^{m} a_{p,j}y_{j} \geq c_p\quad (i = 1,2,3\cdots n)</script><p>并且我们保证有：</p>
<script type="math/tex; mode=display">
\forall a_{p,j} \in \boldsymbol{a_p},\forall b_i \in{\boldsymbol{b}},\quad i=j \Longrightarrow b_i\geq a_{p,j}</script><p>好像写的很不规矩……意思就是对应项的系数，目标函数都比这个约束里的大。</p>
<p>那么因为$\forall x\geq 0$，所以我们可以保证目标函数的最小值一定会是$c_p$。这个结论是显然的。</p>
<p>更进一步，那么我们最后确定的下界一定会是这样的（此处一点也不严谨地使用了$\Omega$符号）：</p>
<script type="math/tex; mode=display">
\Omega(\rm{Aim}) = \it{\sum \limits_{j = 1}^{n}t_j\cdot\sum\limits_{i=1}^{n}\sum \limits_{k=1}^{m}a_{i,k}y_k}\\\
\forall t_j \geq 0</script><p>而因为我们对于原来的约束有</p>
<script type="math/tex; mode=display">
\quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n)</script><p>所以我们将其代回我们画好的式子里面：</p>
<script type="math/tex; mode=display">
\Omega(\rm{Aim}) \geq \it{\sum\limits_{j=1}^{n}t_jc_j}</script><p>那么……目标函数的下界就变成了一个和式的上界——又变成了一个求解目标函数最大值的问题。</p>
<p>那么这或许感性证明了对偶定理的正确性？</p>
<h1 id="rm-Afterword-Some-Typical-Problem"><a href="#rm-Afterword-Some-Typical-Problem" class="headerlink" title="$\rm{Afterword:}Some~Typical~Problem$"></a>$\rm{Afterword:}Some~Typical~Problem$</h1><p><del>没见过吧，一篇文章只有前言和总结</del></p>
<p><del>其实博主就是在疯狂划水/摸鱼</del></p>
<p>其实常见的对偶问题有很多，博主功力不够，于是只能整理一个比较形式化的结论：</p>
<h2 id="最大流问题"><a href="#最大流问题" class="headerlink" title="$~$最大流问题"></a>$~$最大流问题</h2><p>形式化的最大流问题的线性规划如下：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \quad \quad ~f_{s\to t} \quad ~ \quad \quad \quad \quad \quad \quad \\
\text{满足约束} \quad \quad f_{u\to v} \leq L_{u \to v}\qquad (u,v) \in E \\\ 
\qquad \quad \quad ~\sum\limits_{u}f_{u \to v} = \sum\limits_{v}f_{v \to u}\qquad u\in V
 \\\ \qquad \qquad \qquad ~~\quad f_{u\to v} \geq 0 \qquad (u,v) \in E ~\cup \text{e(s,t)}</script><p>其中$e(u,v)$表示链接$u,v$的路径集合，$f$表示流量，$L$表示容量(Limit)。</p>
<p>其对偶过去就会是：</p>
<script type="math/tex; mode=display">
\text{最小化}\quad \quad \quad \sum_{(u,v)\in E}L_{u\to v}d_{u \to v} \quad ~ \quad \quad \quad \\
\begin{aligned}
\text{满足约束} \quad \quad d_{u\to v}-p_u+p_v &\geq 0\qquad (u,v) \in E \\\ 
\qquad \quad \quad \quad \quad \quad ~~p_s - p_t & \geq 1\qquad u\in V
 \\\ \qquad \qquad \qquad \quad  p_i,d_{i\to j} & \in \{0,1\} ~\qquad
\end{aligned}</script><p>里面$d_{i\to j}$表示$i \to j$这条边有没有被割，同时假设我们割完之后，原来的图分成了两部分$S$和$T$,那么会有$p_i = [i \in S]$。这个限制是为了保证割的逻辑性——所有的割边都连接着$S,T$两个集合，且源点和汇点在不同的集合。</p>
<p>emmm我实在不想再整理了(写式子太麻烦)，等什么时候我退完役闲下来再说吧233</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1]$ :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线性规划</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
        <tag>线性规划/对偶定理</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】NTT和任意模数NTT</title>
    <url>/2019/03/17/NTT1-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0x01-quad-rm-Preface"><a href="#0x01-quad-rm-Preface" class="headerlink" title="$0x01\quad \rm{Preface}$"></a>$0x01\quad \rm{Preface}$</h1><p>无特别说明，本文不区分$n$和$N$两种符号，均表示形式为$2^j(j \in \mathbb{N+})$的多项式长度（或者，次数）。</p>
<p>我们知道，对于$FFT$而言，其得以优化成$\log$的根本原因是找到了单位复根这个东西，可以方便处理+计算。而另一种方法则是在模意义下，利用原根的美妙性质，进行多项式卷积。</p>
<p>$\boldsymbol{NTT~\text{(Fast Number-Theoreti Transform)}}$，<strong>快速数论变换</strong>。在分析$NTT$是如何利用原根之前，需要先分析$FFT$是如何利用的单位复根$^{[1]}$：</p>
<ul>
<li><p>$\omega_n^n = 1$。</p>
</li>
<li><p>$\omega_n^1,\omega_n^2, \omega_n^3\cdots\omega_n^{n-1}$是互不相同的，这样带入计算才能保证插出一个完整的$n$次多项式。</p>
</li>
<li><p>{$\omega_n^2$} = {$\omega_{\frac{n}{2}}^{2}$}，这使得问题规模可以在计算的时候减半。</p>
</li>
<li><script type="math/tex; mode=display">
\sum \limits _{k=0}^{n-1} (\omega_n^{j-i})^k = 
 \begin{cases} 0 \quad i \neq j \newline n \quad i = j \newline \end{cases}</script></li>
</ul>
<p>这样可以保证我们能够使用相同的方法进行逆变换。</p>
<hr>
<p>首先，原根的基本定义：设$g$为$p$的一个原根，则满足：</p>
<script type="math/tex; mode=display">
𝑔^{𝑝−1}  \equiv 1(\mod p) \\
∀1≤𝑘<𝑝−1, 𝑔^𝑘 \not \equiv 1(\mod p)</script><p>换句话说$g^0,g^1,g^2\cdots,g^{p-2} \quad (\bmod p)$ 是互不相同的数，满足性质二。</p>
<p>同时如果我们令$p-2$作为这个群的阶，那么$g^{p-1}$和$\omega_n^n$，其实就是等价的，只不过</p>
<script type="math/tex; mode=display">
g^{p-1} \equiv1(\bmod~p) \\ \omega_n^n=1</script><p>而已。于是就满足性质一。</p>
<p>  而对于性质三，我们先考虑一个转化。我们如果要将$g$作为单位根的替代的话，就需要用到$g^{\frac{p-1}{N}}$。换句话说，$N | (p-1)$。那么我们便可以令$g_n^k \equiv g^{\frac{k(p-1)}{N}} (\bmod~p)$，得到一个和单位根相似的形式。</p>
<p>  那么接下来，因为$p$是素数，所以在$g_n^n\equiv g^{\frac{N(p-1)}{N}}\equiv g^{p-1} \equiv 1 (\bmod ~p)$的基础上，我们可以得到$g_{2n}^{n} \equiv1\quad\text{or}\quad \text{-1} (\bmod~ p)$，那么平方之后性质三便显而易见；或者考虑另一种思路，我们根据刚才得出的、跟二次剩余有些相似的式子，可以得到以下结论：</p>
<script type="math/tex; mode=display">
  g_n^{\frac{n}{2}+k}=-g_n^k (\bmod~p)</script><p>  再结合<del>显而易证的</del>消去引理$g_n^k \equiv g_{jn}^{jk}$，我们可以很自然像$FFT$证明单位复根的折半性一样，证出这个结论。</p>
<p>  至于性质四，证明的大体相似于单位单位复根。即：</p>
<script type="math/tex; mode=display">
  \sum\limits_{j =0}^{n-1}{(g_n^k)^j} \equiv \frac{(g_n^k)^n -1}{g_n^k -1} \Longrightarrow  \frac{(g_n^n)^k -1}{g_n^k -1} \equiv  \frac{(1)^k -1}{g_n^k -1} = 0</script><p>  而对于$n=k$的情况，不适用于普通的几何级数求和，所以直接就是$\sum 1 =n$ 。</p>
<h1 id="0x02-quad-rm-Codes"><a href="#0x02-quad-rm-Codes" class="headerlink" title="$0x02\quad \rm{Codes}$"></a>$0x02\quad \rm{Codes}$</h1><p>呃，于是NTT就完了。注意因为要保证$N | (p-1)$，且 $N$ 是 $2$ 的幂次，所以素数 $p$ 一定要是 $k\cdot 2^j+1$ 的形式。</p>
<p>至于求原根，不是本界探讨的内容。普通的NTT模数，原根可以背过；其余情况暴力求+验证即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N, M, K, qaq ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000010</span> ;</span><br><span class="line">LL A[MAXN], B[MAXN], Inv ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>) ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span> ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    	<span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    	<span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    	<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   		<span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    	<span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    	<span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    	*++now_w=<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= P ;</span><br><span class="line">        (a *= a) %= P, b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    	LL Gn = expow(flag == <span class="number">1</span> ? G : Gi, (P - <span class="number">1</span>) / (j &lt;&lt; <span class="number">1</span>)) ;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">        	LL g = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j ; l ++, g = (g * Gn) % P)&#123;</span><br><span class="line">                LL Nx = J[k + l], Ny = g * J[k + j + l] % P ;</span><br><span class="line">                J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); </span><br><span class="line">    N = read(), M = read() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i] = (read() + P) % P ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i] = (read() + P) % P ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    NTT(A, <span class="number">1</span>), NTT(B, <span class="number">1</span>);</span><br><span class="line">  	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = (A[i] * B[i]) % P ; Inv = expow(Lim, P - <span class="number">2</span>) ;</span><br><span class="line">    NTT(A, <span class="number">-1</span>) ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++) write((<span class="keyword">long</span> <span class="keyword">long</span>) (A[i] * Inv + P) % P) ; 	 					fwrite(ch, <span class="number">1</span>, now_w - ch, <span class="built_in">stdout</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Gi</code>表示$998244353$的原根的逆元。</p>
<h1 id="0x03-quad-rm-Extending"><a href="#0x03-quad-rm-Extending" class="headerlink" title="$0x03\quad \rm{Extending}$"></a>$0x03\quad \rm{Extending}$</h1><p>接上节内容，$NTT$本质上是只能处理“$NTT$模数（$p=\omega\cdot 2^k+1$）”。但是当我们需要对其进行任意模数取模时，就需要我们用$CRT$合并。</p>
<p>然后…我也不知道从哪找到了一张比较浅显的图：<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""> </p>
<p>但是这个地方仍然会存在不少问题，巨佬<code>KsCla</code>如此解释：</p>
<blockquote>
<p>具体做法是这样：先选取三个乘积在$10^{23 }$以上的便于使用NTT的模数。在这里我选的是$m_1=998244353=2^{23}∗119+1$，$m_2=1004535809=2^{21}∗479+1$，$m_3=469762049=2^{26}∗7+1$。选这三个模数的好处在于它们的原根都是3。<br>然后用这三个模数做NTT，可以得到以下三条式子：</p>
<script type="math/tex; mode=display">
~ans≡c_1~(\bmod m_1)\\\
ans≡c_2~(\bmod m_2)\\\
ans≡c_3~(\bmod m_3)</script><p>虽然这三条式子可以在$10^{23}$以内唯一固定$ans$的值，但问题也随之而来：$m_1∗m_2∗m_3$很大，无法直接用<code>long long</code>存下，而用<code>long double</code>之类的则会丢失精度，所以无法用普通的$CRT$。难道要写高精度？</p>
<p>不，有一种很妙的方法可以解决这个问题。<br>首先注意到这里只有三个模数，而且两个模数乘起来是不会爆<code>long long</code>的，所以可以先合并前两条式子。根据CRT，有：</p>
<script type="math/tex; mode=display">
ans≡(c_1m_2Inv(m_2,m_1)+c_2m_1Inv(m_1,m_2))(\bmod m_1m_2)</script><p>其中$Inv(x,y)$表示x关于y的逆元。<br>这条式子涉及到两个很大的数相乘然后再取模，而直接相乘会爆long long。可以用$O(\log(m_1m_2))$的快速乘，或者$O(1)$转double后相乘。<br>为了方便，把上式化成这样的形式：</p>
<script type="math/tex; mode=display">
ans≡C(\bmod M)</script><p>然后设：</p>
<script type="math/tex; mode=display">
ans=xM+C=ym_3+c_3</script><p>接下来的部分才是精髓。我们求出$x$在$\bmod m_3$意义下的值：</p>
<script type="math/tex; mode=display">
xM≡c_3−C(\bmod m_3)</script><p>在$\bmod m_3$意义下，$ym_3$被消掉了。</p>
<p>然后有：</p>
<script type="math/tex; mode=display">
x≡(c_3−C)M−1(\bmod m_3)</script><p>算出右半部分的值为$q$，则可令$x=km_3+qx=km_3+q$。将其代入$ans=xM+C$：</p>
<script type="math/tex; mode=display">
ans=(km_3+q)M+C=km_3M+qM+C</script><p>也就是说：</p>
<script type="math/tex; mode=display">ans=km_1m_2m_3+qM+C</script><p>而由于$ans∈[0,m_1m_2m_3)$，所以$k$必为0。也就是说$ans$就是$qM+C$！直接把这条式子对题面要求的模数取模即可.</p>
</blockquote>
<p>嗝……其实我就是加了一遍mkd，但是也算是复习了一遍吧XD。</p>
<p>有一点是需要注意的：</p>
<ul>
<li>为什么要选三个乘积大于$10^{23}$的质数作为模数？<ul>
<li>为了是最后的结果可以<strong>不取模</strong></li>
</ul>
</li>
</ul>
<p>嗯，然后就是板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, qaq ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">600010</span> ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="keyword">int</span> Mod, P, pr[] = &#123;<span class="number">469762049</span>, <span class="number">998244353</span>, <span class="number">1004535809</span>&#125; ;</span><br><span class="line">LL Ans[<span class="number">4</span>][MAXN], A[MAXN], B[MAXN], Inv, A1[MAXN], B1[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL k = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span> ;c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span> ,c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(LL *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    	LL Gn = expow(G, (P - <span class="number">1</span>) / (j &lt;&lt; <span class="number">1</span>), P) ;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">        	LL g = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j ; l ++, g = (g * Gn) % P)&#123;</span><br><span class="line">                LL Nx = J[k + l], Ny = g * J[k + j + l] % P ;</span><br><span class="line">                J[k + l] = (Nx + Ny) % P, J[k + j + l] = (Nx - Ny + P) % P ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &gt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> Inv = expow(Lim, P - <span class="number">2</span>, P) ; reverse(J + <span class="number">1</span>, J + Lim) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= Lim ; ++ i) J[i] = <span class="number">1l</span>l * J[i] * Inv % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(LL *J, LL *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; Lim ; ++ i) J[i] = L[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">egg</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a,LL b,LL p)</span></span>&#123;</span><br><span class="line">    LL re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>,a = (a + a) % p)</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) re = (re + a) % p;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T_NTT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= <span class="number">2</span> ; ++ i)&#123;</span><br><span class="line">        P = pr[i] ; i ? clear(A1, B1) : egg() ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= N ; ++ j) A1[j] = A[j] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j) B1[j] = B[j] ;</span><br><span class="line">        NTT(A1, <span class="number">1</span>), NTT(B1, <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; Lim ; ++ j) A1[j] = A1[j] * B1[j] % P ;</span><br><span class="line">        NTT(A1, <span class="number">-1</span>) ; <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= Lim ; ++ j) Ans[i + <span class="number">1</span>][j] = A1[j] ; </span><br><span class="line">    &#125;</span><br><span class="line">    rr LL Mo = <span class="number">1l</span>l * pr[<span class="number">1</span>] * pr[<span class="number">0</span>], k1, k2, a, b, c, mod = Mod ;</span><br><span class="line">    LL inv1 = expow(pr[<span class="number">1</span>] % pr[<span class="number">0</span>], pr[<span class="number">0</span>] - <span class="number">2</span>, pr[<span class="number">0</span>]), inv0 = expow(pr[<span class="number">0</span>] % pr[<span class="number">1</span>], pr[<span class="number">1</span>] - <span class="number">2</span>, pr[<span class="number">1</span>]), inv3 = expow(Mo % pr[<span class="number">2</span>], pr[<span class="number">2</span>] - <span class="number">2</span>, pr[<span class="number">2</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N + M ; ++ i)&#123;</span><br><span class="line">        a = Ans[<span class="number">1</span>][i], b = Ans[<span class="number">2</span>][i], c = Ans[<span class="number">3</span>][i] ;</span><br><span class="line">        k1 = (mul(a * pr[<span class="number">1</span>] % Mo, inv1, Mo) + mul(b * pr[<span class="number">0</span>] % Mo, inv0, Mo)) % Mo ;</span><br><span class="line">        k2 = ((c - k1 % pr[<span class="number">2</span>]) % pr[<span class="number">2</span>] + pr[<span class="number">2</span>]) % pr[<span class="number">2</span>] * inv3 % pr[<span class="number">2</span>], Ans[<span class="number">0</span>][i] = ((k2 % mod) * (Mo % mod) % mod + k1 % mod) % mod;</span><br><span class="line">    &#125;<span class="comment">/*</span></span><br><span class="line"><span class="comment">    LL a,b,c,t,k,M = 1ll * pr[0] * pr[1];</span></span><br><span class="line"><span class="comment">    LL inv1 = inv(pr[1],pr[0]),inv0 = inv(pr[0],pr[1]),inv3 = inv(M % pr[2],pr[2]);</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt;= deg; i++)&#123;</span></span><br><span class="line"><span class="comment">        a = fft[0].A[i],b = fft[1].A[i],c = fft[2].A[i];</span></span><br><span class="line"><span class="comment">        t = (mul(a * pr[1] % M,inv1,M) + mul(b * pr[0] % M,inv0,M)) % M;</span></span><br><span class="line"><span class="comment">        k = ((c - t % pr[2]) % pr[2] + pr[2]) % pr[2] * inv3 % pr[2];</span></span><br><span class="line"><span class="comment">        ans[i] = ((k % md) * (M % md) % md + t % md) % md;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ;</span><br><span class="line">    N = qr(), M = qr(), Mod = qr() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i] = qr() % Mod ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i] = qr() % Mod ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    T_NTT() ; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[<span class="number">0</span>][i])  ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是这玩意儿进行了9遍NTT，那是真的慢。。。</p>
<h1 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h1><ul>
<li><code>KsCla</code>的$blog$ <a href="https://blog.csdn.net/kscla/article/details/79547242" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】有趣的数学题</title>
    <url>/2019/03/17/Math1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>两道小清新数学题，分别是 [NOI2002]Savage 和 [Violet · 5]樱花 。</p>
<a id="more"></a>
<h1 id="NOI2002-Savage"><a href="#NOI2002-Savage" class="headerlink" title="[NOI2002] Savage"></a>[NOI2002] Savage</h1><blockquote>
<p>克里特岛以野人群居而著称。岛上有排列成环行的 $M$ 个山洞。这些山洞顺时针编号为 $1,2,\dots,M$。岛上住着 $n$ 个野人，一开始依次住在山洞 $C_1,C_2,\dots,C_n$ 中。以后每年，第 $i$ 个野人会沿顺时针向前走 $P_i$ 个洞住下来。每个野人i有一个寿命值 $L_i$，即生存的年数。</p>
<p>奇怪的是，虽然野人有很多，但没有任何两个野人在有生之年处在同一个山洞中，使得小岛一直保持和平与宁静，这让科学家们很是惊奇。他们想知道，至少有多少个山洞，才能维持岛上的和平呢？数据保证有解，$M$ 的值不大于 $10^6$。</p>
<p>数据范围：$1\le n\le 15$，$1\le C_i,P_i\le 100$，$0\le L_i\le 10^6$</p>
</blockquote>
<p>不算特别难…其实就是求让对于任意一组关于 $(i,j)$ 方程</p>
<script type="math/tex; mode=display">
C_{i}+P_{i}x \equiv C_j+P_jx \pmod M</script><p>均不存在一个解使得</p>
<script type="math/tex; mode=display">
x \leq min(L_i,L_j)</script><p>时，$M$ 的最小值。然后因为题目中的数据，$M\leq 10^6$ 于是考虑直接枚举 $M$, 然后 check。</p>
<p>由于最多共有 $15$ 个野人，且单次 <code>exgcd</code> 是 $\log n $ 级别的，所以复杂度上限是 $O (Mn^2 \log C_{\max}) &lt; \Omega(10^8)$。如果不是精心构造数据的话，可以直接艹过去。</p>
<p>喜闻乐见的是……我的exgcd似乎一开始有问题？我一开始是这么写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = P[i] - P[j], b = M, x, y, w = C[j] - C[i] ;</span><br><span class="line">            <span class="keyword">int</span> qwq = exgcd(x, y, a, b) ; <span class="keyword">if</span> (w % qwq) <span class="keyword">continue</span> ;</span><br><span class="line">            x = x * w / qwq ; <span class="keyword">while</span> (x &lt;= <span class="number">0</span>) x += M ; </span><br><span class="line">          	<span class="keyword">if</span> (x &lt;= min(L[i], L[j])) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后觉得一点问题都没有，$40pts$ 之后愣了大半天。</p>
<p>而事实上这个地方$x$应该是一个特解，而不是最小解。换句话说我为了求出准确的 $x$，应该不断取模$\frac{b}{\gcd(a,b)}$。</p>
<p>为什么？至于为什么，一开始我也懵的很。直到我翻出来很久之前我的一篇题解：</p>
<blockquote>
<p>_这是上面这个式子为什么可以这么做的证明：_</p>
<p>若有 $ax+by=c$ 且 $a_0x+b_0y=c$ 。</p>
<p>那么便有 $a(x-x_0)+b(y-y_0)=0$ 。</p>
<p>两边同时除以 $\gcd(a,b)$ 可得：</p>
<script type="math/tex; mode=display">
\frac{a}{\gcd(a,b)}(x-x_0)=-\frac{b}{\gcd(a,b)}(y-y_0) \quad(1)</script><p>而因为</p>
<script type="math/tex; mode=display">
(\frac{a}{\gcd(a,b)},\frac{b}{\gcd(a,b)})=1</script><p>所以由 $(1)$ 可得$\frac{b}{\gcd(a,b)}$ 整除 $(x-x_0)$ 。</p>
<p>所以很显然有$\frac{b}{\gcd(a,b)}\times{t}={(x-x_0)},t \in \mathbb Z$ 。</p>
<p>那么就有对于任意一个 $x_i$，有</p>
<p>$ x_i=x_0+\frac{b}{\gcd(a,b)} \times{t} $</p>
</blockquote>
<p>我特么…智商已经回退到上个世纪了吧 qaq，自闭了。</p>
<p>这就是我整理这道题的原因…还有，上面 $P_i-P_j$ 似乎需要取模并使其变成正的，因为好像我的 $exgcd$ 里面限制了$A&gt;0$ 的缘故。</p>
<p>哦，对哈，如果 A 和 B 其中任意一个 $&lt;0$ 都会出现对负数取模的情况…咱也不知道对负数取模会怎么样.jpg</p>
<p>心得：我退役吧嘤。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, N, M, C[MAXN], P[MAXN], L[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!B) &#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> A ;&#125;</span><br><span class="line">    <span class="keyword">int</span> t = exgcd(y, x, B, A % B) ; y -= A / B * x ; <span class="keyword">return</span> t ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = (P[i] - P[j] + M) % M + M, b = M, x, y, w = C[j] - C[i], qwq = exgcd(x, y, a, b) ; <span class="keyword">if</span> (w % qwq) <span class="keyword">continue</span> ; </span><br><span class="line">            x = x * w / qwq ; x = (x % (M / qwq) + (M / qwq)) % (M / qwq) ; <span class="keyword">if</span> (!x) x += (M / qwq) ; <span class="keyword">if</span> (x &lt;= min(L[i], L[j])) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;C[i], &amp;P[i], &amp;L[i]), M = max(M, C[i]) ;</span><br><span class="line">    <span class="keyword">for</span> ( M ; ; ++ M) <span class="keyword">if</span> (check()) &#123; <span class="built_in">cout</span> &lt;&lt; M &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Violet～5-樱花"><a href="#Violet～5-樱花" class="headerlink" title="[Violet～5] 樱花"></a>[Violet～5] 樱花</h1><p>好久之前做的一道题，突然被我发现了。大概就是</p>
<blockquote>
<p>求方程<script type="math/tex">\frac{1}{x}+\frac{1}{y} = \frac{1}{n!}\quad (n \leq 10^6)</script>的解的组数。</p>
</blockquote>
<p>不想思考系列问题，我这么懒还是退役吧。(sigh)</p>
<p>我们将柿子变个形：</p>
<script type="math/tex; mode=display">
\frac{x+y}{xy} = \frac{1}{n!} \\
n!x + n!y = xy</script><p><del>然后我就不会了，此题完结</del></p>
<p>然后有一步很妙的是两边同时 $+(n!)^2$ 得到：</p>
<script type="math/tex; mode=display">
(n!)^2 + n!(x+y) -n!(xy) = (n!)^2\\
(n!-x)(n!-y)=(n!)^2</script><p>然后就会发现我们只需要找出 $(n!)^2$ 的因子个数就好了…</p>
<p>好像我从来没有写过求 $\tau(x)$的样子，既然这样我就顺便记一个算因子个数的公式吧（其实就是乘法原理啦）</p>
<script type="math/tex; mode=display">
x = \prod p_ix^{a_i} \longleftrightarrow\tau(x) = \prod (a_i+1)</script><p><del>其实就是为了水字数</del></p>
<p>$\rm upd ~on ~2019.6.13$ : 我发现自己似乎之前听过这个题的”另解”，以前自己整理过：</p>
<blockquote>
<p>思考一个比较显然的问题，就是一定会有 $y&gt;n!$。那窝萌不妨设 $y = n!+T$，带回到原式里面就会有</p>
<script type="math/tex; mode=display">
\frac{1}{x} + \frac{1}{n!+T} = \frac{1}{n!}</script><p>继而有</p>
<script type="math/tex; mode=display">
x = \frac{n!^2}{T}+n!</script><p>那么其实一共就有 $\tau(n!^2)$ 个合法答案，所以我们转而求 $n!^2$ 的约数数量。</p>
<p>但是显然的是我们并不可以直接求解，当然我不知道高精度之后会怎么样，估计 $n\log n$ 一下还是有可能过的。但是考虑到常数巨大，所以卡过 $10^6$ 基本上是痴人说梦。所以我们思考一种清新脱俗<del>我根本想不出来</del>的做法。</p>
<p>窝萌考虑筛出所有的 $1-n$ 素数来，然后对于一个素数而言，由于窝萌要判断的对象是 $n!$，他有一个奇妙的性质就是 </p>
<script type="math/tex; mode=display">
n!=\prod \limits_{i=1}^{n}{i}</script><p>那么也就是说我们只需要判断对于一个当前给定的素数 $p$，在 $1-n$ 的所有数里面，$p$ 作为因子出现了多少次即可。那么也就是这个式子：</p>
<script type="math/tex; mode=display">
Ans = \prod \limits _{p \in prime }^{p \leq n}\sum_{i \geq 1}^{p^i \leq n}\left( \lfloor \frac{n}{p^i} \rfloor +1 \right)</script><p>我们每次遍历一遍，保证只加一次，譬如质数$3$，三的倍数的个数产生的贡献是一，三的平方的倍数产生的贡献是二，但是我们从前往后扫的话，每次就只要增长一个贡献即可（类似于去重操作$233$）</p>
</blockquote>
<p>嗯，我算一下蛤，法 2 的复杂度大概是 $O(\frac{n}{\ln n}\times \log n)=O(n)$ 。</p>
<p>然后是法 1 的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Prime[MAXN] ;</span><br><span class="line"><span class="built_in">std</span> :: <span class="built_in">bitset</span> &lt;MAXN&gt; vis ; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> N, i, j, cnt, Ans, Cnt[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ego</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>] = vis[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) Prime[++ cnt] = i ;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= cnt ; ++ j)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i * Prime[j] &gt; N) <span class="keyword">break</span> ;</span><br><span class="line">			vis[i * Prime[j]] = <span class="number">1</span> ;</span><br><span class="line">			<span class="keyword">if</span> (!(i % Prime[j])) <span class="keyword">break</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i)</span><br><span class="line">	    <span class="keyword">for</span> (j = Prime[i] ; j &lt;= N ; j *= Prime[i])</span><br><span class="line">	        ( Cnt[i] += (N / j) ) %= Mod ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; N ; Ans = <span class="number">1l</span>l, Ego() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= cnt ; ++ i) </span><br><span class="line">        (Ans *= (Cnt[i] &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>) %= Mod ;</span><br><span class="line">    <span class="built_in">std</span> :: <span class="built_in">cout</span> &lt;&lt; Ans % Mod &lt;&lt; <span class="built_in">std</span> :: <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数学/扩展欧几里德</tag>
        <tag>数学/素数/素数筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>【探究向】一类线段树的转移</title>
    <url>/2019/03/17/Segment-Tree1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>奇奇怪怪的线段树散发着奇奇怪怪的香气（</p>
<a id="more"></a>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p>
<p>最近大概是泛做了线段树相关题目，但是这些线段树大概都需要比较强的思维和比较长的代码……$2333$</p>
<h1 id="子段和"><a href="#子段和" class="headerlink" title="子段和"></a>子段和</h1><p>其实这个算是比较简单的了，毕竟 $qyf$ 曾经给我们讲过，当时我就觉得十分的……麻烦233.</p>
<p>那么例题其实就是 $\rm{SPOJ}$ 的 $GSS$ 系列——的前三道题<del>(后几道题都不会做)</del></p>
<h2 id="GSS1​-区间求最大子段和-不带修"><a href="#GSS1​-区间求最大子段和-不带修" class="headerlink" title="GSS1​ 区间求最大子段和(不带修)"></a>GSS1​ 区间求最大子段和(不带修)</h2><p>应该算是比较简单的了。我们对于每个区间维护一个<strong>区间和</strong>，维护一个<strong>从最左端开始且必须包含最左端元素的最大子段和</strong>，再维护一个<strong>从最右端开始且必须包含最右端元素的最大子段和</strong>，最后维护一个<strong>区间最大子段和</strong>。</p>
<p>那么转移(<code>push_up</code>)时就显得十分方便。我们的父区间的 <code>Lmax</code> 只取决于左子区间的 <code>Lmax</code> 和 <strong>当左区间的 <code>Sum</code> 等于 <code>Max</code> 时(即左区间全部都要纳入到其最大子段和中时)</strong>，左区间的 <code>Sum</code> 与右区间的 <code>Lmax</code> 的和。那么对于区间的 <code>Rsum</code>，也是一个道理。最终对于该区间的最大子段和，我们<strong>不考虑</strong>从已经转移来的 <code>Lmax/Rmax</code>，而是考虑从左右区间的 <code>Max</code> 以及左右区间的和来转移。大体代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">	Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">	Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">	Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有值得注意的一点：在询问的时候，它比较膈应…就是由于是连续的，所以你不能直接像普通的线段树一样询问然后加起来…所以所就要类似于边询问，边 <code>push_up​</code> 这种感觉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> T[rt] ; </span><br><span class="line">	Tree res, A, B ;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">	A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">	res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; </span><br><span class="line">  <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后总代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">my_Fuckmax</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A &amp; ((B - A) &gt;&gt; <span class="number">63</span>) | B &amp; ((~(B - A)) &gt;&gt; <span class="number">63</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">	Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">	Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">	Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		T[rt].Lsum = T[rt].Rsum = </span><br><span class="line">		T[rt].S = T[rt].Sum = base[l] ; <span class="keyword">return</span>  ;</span><br><span class="line">	&#125; build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) </span><br><span class="line">		<span class="keyword">return</span> T[rt] ; </span><br><span class="line">	Tree res, A, B ;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">	A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">	res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">while</span> (M --) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GSS3-区间求最大子段和-带修"><a href="#GSS3-区间求最大子段和-带修" class="headerlink" title="GSS3 区间求最大子段和(带修)"></a>GSS3 区间求最大子段和(带修)</h2><p><a href="https://www.luogu.org/problemnew/show/SP1716" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<p>…其实吧，这个带修不带修……好像影响并不大？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">my_Fuckmax</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A &amp; ((B - A) &gt;&gt; <span class="number">63</span>) | B &amp; ((~(B - A)) &gt;&gt; <span class="number">63</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	S(rt) = S(ls(rt)) + S(rs(rt)) ;</span><br><span class="line">	Lsum(rt) = max(Lsum(ls(rt)), S(ls(rt)) + Lsum(rs(rt))) ;</span><br><span class="line">	Rsum(rt) = max(Rsum(rs(rt)), S(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">	Sum(rt) = max(max(Sum(ls(rt)), Sum(rs(rt))), Lsum(rs(rt)) + Rsum(ls(rt))) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		T[rt].Lsum = T[rt].Rsum = </span><br><span class="line">		T[rt].S = T[rt].Sum = base[l] ; <span class="keyword">return</span>  ;</span><br><span class="line">	&#125; build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) </span><br><span class="line">		<span class="keyword">return</span> T[rt] ; </span><br><span class="line">	Tree res, A, B ;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ; </span><br><span class="line">	A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">	res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == l &amp;&amp; L == r)&#123;</span><br><span class="line">		T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = k ; <span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= mid) change(ls(rt), l, mid, k) ;</span><br><span class="line">	<span class="keyword">else</span> change(rs(rt), mid + <span class="number">1</span>, r, k ) ; P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">while</span> (M --) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;MArk, &amp;L, &amp;R) ;</span><br><span class="line">		<span class="keyword">if</span> (!MArk) change(<span class="number">1</span>, <span class="number">1</span>, N, R) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GSS4-区间开根问题"><a href="#GSS4-区间开根问题" class="headerlink" title="GSS4 区间开根问题"></a>GSS4 区间开根问题</h2><p><a href="https://www.luogu.org/problemnew/show/SP2713" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<p>这个和子段和一点儿关系都没有，顺便整一下233.</p>
<p>就是让你区间开根（向下取整）+查询……这个东西大概就是对于一个 $2^{63}$ 内的数值$N$，我们假设其开根 $k$ 次可以得到 $N &lt; 2$  —— 只要 $N &lt; 2$ ，之后的计算就会集中在一个紧确的范围 $(1,2)$ 内，向下取整之后永远都会是$1$，所以我们不需要再去考虑。</p>
<p>那么现在问题就在于 $k$ 的大小。首先，$\sqrt n$ 在 $[0,+\infty]$ 是单调递增的，同理三次方根也是，四次方根也是…所以我们不妨取最大值，考虑 $N=2^{63}$ 时，$k$ 值的大小。而很显然，此时的 $k$ 应该为 $\log _263+1 ≈ 6.978$ 。</p>
<p>总之，我们得出，似乎运算次数的上界就是 $k≈7$，所以说我们直接暴力除就好了，聚合分析一下，复杂度的上界似乎是 $O(n)$ 的样子，无非就是多几个常数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll N, M, K, i, L, R ; </span><br><span class="line">ll base[MAXN], T[MAXN], tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">p_u</span><span class="params">(ll rt)</span></span>&#123; ;&#125;</span><br><span class="line"><span class="keyword">void</span> _Build(ll rt, ll l, ll r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;T[rt] = base[l] ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    _Build(ls(rt), l, mid) ;</span><br><span class="line">    _Build(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> ll _query(ll rt, ll l, ll r, ll sl, ll sr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= sl &amp;&amp; r &lt;= sr) <span class="keyword">return</span> T[rt] ;</span><br><span class="line">    ll ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= sl) ret += _query(ls(rt), l, mid, sl, sr) ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; sr) ret += _query(rs(rt), mid + <span class="number">1</span>, r, sl, sr) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Sqrt(ll rt, ll l, ll r, ll sl, ll sr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= sl &amp;&amp; r &lt;= sr)&#123;</span><br><span class="line">        <span class="keyword">if</span> (T[rt] &lt;= (r - l + <span class="number">1</span>)) <span class="keyword">return</span> ; </span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">                T[rt] = (<span class="keyword">int</span>)(<span class="built_in">pow</span>((<span class="keyword">double</span>)T[rt], <span class="number">0.5</span>)) ;</span><br><span class="line">            	<span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= sl) _Sqrt(ls(rt), l, mid, sl, sr), </span><br><span class="line">				   T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; sr) _Sqrt(rs(rt), mid + <span class="number">1</span>, r, sl, sr), </span><br><span class="line">				   T[rt] = T[ls(rt)] + T[rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">    	++ tot, <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>, tot) ;</span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    	_Build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    	    K = qr(), L = qr(), R = qr() ;</span><br><span class="line">    	    <span class="keyword">if</span> (L &gt; R) swap(L, R) ;</span><br><span class="line">   		    <span class="keyword">if</span> (K)&#123;</span><br><span class="line">    	        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, _query(<span class="number">1</span>, <span class="number">1</span>, N, L, R)) ;</span><br><span class="line">    	        <span class="keyword">continue</span> ;</span><br><span class="line">    	    &#125;</span><br><span class="line">    	    _Sqrt(<span class="number">1</span>, <span class="number">1</span>, N, L, R) ;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长连续问题"><a href="#最长连续问题" class="headerlink" title="最长连续问题"></a>最长连续问题</h1><p>这个东西其实应该跟最大子段和差不多——要求的都是连续的东西。对于所有包括<strong>连续</strong>字样的东西，基本的思路大概都是维护一个从左端开始的，维护一个从右端开始的，然后从下向上不断 <code>push_up</code> 即可。</p>
<p>emmm​ 在这边整理几道思路不错的题吧：</p>
<h2 id="rm-USACO-酒店-hotel"><a href="#rm-USACO-酒店-hotel" class="headerlink" title="$\rm{USACO}$ 酒店($hotel$)"></a>$\rm{USACO}$ 酒店($hotel$)</h2><p><a href="https://www.luogu.org/problemnew/show/P2894" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<blockquote>
<p>初始的一个全零的序列，我们对它准确来说有以下三个操作：</p>
<ul>
<li>1、区间置 $0$ 。</li>
<li>2、区间置 $1$ 。</li>
<li>3、询问是否有一段长度为 $k$ 的连续的零区间，如果有的话，选取最靠左的，输出其左端点并执行操作②</li>
</ul>
</blockquote>
<hr>
<p>这个题在我看来，应该算是一个思维题。对于最后一个操作，我十分地懵逼——因为我压根不知道该怎么维护。</p>
<p>但事实上…这就是学数据结构学傻了的后果…毕竟数据结构只会是一个辅助而已。仔细想来，好像除了权值线段树能够维 护$\rm{DP}$之外，没做过什么数据结构的好题，都是一些数据结构的裸题……大概这就是学傻了吧，只会专一的一门学科，或者说只会专精一种东西——还是十分蠢笨迟钝地“专精”。</p>
<p>唉，大概检验一个人学没学过数据结构，不是通过他会不会做类似于 $NOI2005$ 维护数列那样的毒瘤裸题，而是看他到底可不可以和其他的东西结合在一起。学习大抵也是同样的道理，不可以把学的东西迁移到其他地方，照样是白学吧。</p>
<p>诶，好像扯了什么奇怪的东西……</p>
<p>回到正题，我们不考虑直接维护这个东西，而是<strong>通过维护区间内的最长连续 $0$ 的个数，达到辅助查找区间的目的</strong>。那么我们查找区间的时候，就直接选择最左边的区间优先，并 $check$ 其是否有足够的 $0$ 。</p>
<p>对于查询，我们先查询左区间，再查询中间（左区间的右边与右区间的并集），最后查询右区间。</p>
<p>哦，才知道这个东西就叫做线段树上二分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> Sum, Len, Lsum, Rsum, tag ; </span><br><span class="line">&#125;T[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> A, B, N, M, MArk, i, t ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T[rt].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T[rt].tag == <span class="number">0</span>)&#123;</span><br><span class="line">		T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">0</span> ;</span><br><span class="line">		T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = <span class="number">0</span> ;</span><br><span class="line">		T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">1</span> ;</span><br><span class="line">		T[ls(rt)].Lsum = T[ls(rt)].Sum = T[ls(rt)].Rsum = T[ls(rt)].Len ;</span><br><span class="line">		T[rs(rt)].Lsum = T[rs(rt)].Sum = T[rs(rt)].Rsum = T[rs(rt)].Len ;	</span><br><span class="line">	&#125;</span><br><span class="line">	T[rt].tag = <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T[ls(rt)].Sum == T[ls(rt)].Len) </span><br><span class="line">		T[rt].Lsum = T[ls(rt)].Len + T[rs(rt)].Lsum ;</span><br><span class="line">	<span class="keyword">else</span> T[rt].Lsum = T[ls(rt)].Lsum ;</span><br><span class="line">	<span class="keyword">if</span> (T[rs(rt)].Sum == T[rs(rt)].Len) </span><br><span class="line">		T[rt].Rsum = T[rs(rt)].Len + T[ls(rt)].Rsum ;</span><br><span class="line">	<span class="keyword">else</span> T[rt].Rsum = T[rs(rt)].Rsum ;</span><br><span class="line">	T[rt].Sum = max(T[ls(rt)].Sum, T[rs(rt)].Sum), </span><br><span class="line">	T[rt].Sum = max(T[rt].Sum, T[ls(rt)].Rsum + T[rs(rt)].Lsum) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	T[rt].tag = <span class="number">-1</span>,</span><br><span class="line">	T[rt].Len = T[rt].Lsum = </span><br><span class="line">	T[rt].Rsum = T[rt].Sum = r - l + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= l &amp;&amp; ur &gt;= r)&#123;</span><br><span class="line">		T[rt].tag = k ;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) T[rt].Lsum = T[rt].Rsum = T[rt].Sum = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">else</span> T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].Len ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	push_down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (ul &lt;= mid) update(ls(rt), l, mid, ul, ur, k) ;</span><br><span class="line">	<span class="keyword">if</span> (ur &gt; mid) update(rs(rt), mid + <span class="number">1</span>, r, ul, ur, k) ;</span><br><span class="line">	push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	push_down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ;</span><br><span class="line">	<span class="keyword">if</span> (T[ls(rt)].Sum &gt;= A) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T[ls(rt)].Rsum + T[rs(rt)].Lsum &gt;= A) <span class="keyword">return</span> mid - T[ls(rt)].Rsum + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">	<span class="keyword">while</span>(M --)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;MArk) ;</span><br><span class="line">		<span class="keyword">if</span> (MArk == <span class="number">2</span>)  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), update(<span class="number">1</span>, <span class="number">1</span>, N, A, A + B - <span class="number">1</span>, <span class="number">1</span>) ;	</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A) ;</span><br><span class="line">			<span class="keyword">if</span> (T[<span class="number">1</span>].Sum &gt;= A)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t = query(<span class="number">1</span>, <span class="number">1</span>, N)), update(<span class="number">1</span>, <span class="number">1</span>, N, t, t + A - <span class="number">1</span>, <span class="number">0</span>)  ;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">'0'</span>), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;  <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$emmm$这个题码量其实不大，思维含量也不高，但是成功地把做数据结构题做傻了的我拉回了正途。</p>
<h2 id="rm-SCOI-序列操作"><a href="#rm-SCOI-序列操作" class="headerlink" title="$\rm{SCOI}$ 序列操作"></a>$\rm{SCOI}$ 序列操作</h2><p><a href="https://www.luogu.org/problemnew/show/P2572" target="_blank" rel="noopener">$\color{violet}{Link}$</a></p>
<p>对于一个$01$序列，大体是这几种操作：</p>
<blockquote>
<ul>
<li>1、区间清零 。</li>
<li>2、区间置为$1$ 。</li>
<li>3、区间全部取反。</li>
<li>4、区间查询$1$的个数。</li>
<li>5、区间查询最长连续的$1$的长度。</li>
</ul>
</blockquote>
<p>好的，这道题被我秒了，爽啊…不过秒是秒了，对拍调，调了好久$233$。</p>
<p>其实对于 $1,2,4,5$ 都好说，只是第$3$个操作，需要再另维护区间最长连续的 $0$ 的长度，如果存在取非标记生效，就交换一下就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> OS, OL, OR ;</span><br><span class="line">	<span class="keyword">int</span> Sum, Lsum, Len, Rsum, S, tag, t ;</span><br><span class="line">	<span class="comment">//tag = 1 -&gt; 1,tag = 0 -&gt; 0, tag = 2 -&gt; xor</span></span><br><span class="line">&#125;T[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, MArk, L, R, base[MAX], i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">	T[rt].S = T[ls(rt)].S + T[rs(rt)].S ;</span><br><span class="line">	<span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span> (T[ls(rt)].S == T[ls(rt)].Len) </span><br><span class="line">		  T[rt].Lsum = max(T[ls(rt)].Lsum, T[ls(rt)].Len + T[rs(rt)].Lsum) ;</span><br><span class="line">	<span class="keyword">else</span>  T[rt].Lsum = T[ls(rt)].Lsum ;</span><br><span class="line">	<span class="keyword">if</span> (T[rs(rt)].S == T[rs(rt)].Len) </span><br><span class="line">		  T[rt].Rsum = max(T[rs(rt)].Rsum, T[rs(rt)].Len + T[ls(rt)].Rsum) ;</span><br><span class="line">	<span class="keyword">else</span>  T[rt].Rsum = T[rs(rt)].Rsum ;</span><br><span class="line">	T[rt].Sum = max(T[ls(rt)].Rsum + T[rs(rt)].Lsum, max(T[ls(rt)].Sum, T[rs(rt)].Sum)) ;</span><br><span class="line">	<span class="comment">//0</span></span><br><span class="line">	<span class="keyword">if</span> (!T[ls(rt)].S) </span><br><span class="line">		  T[rt].OL = max(T[ls(rt)].OL, T[ls(rt)].Len + T[rs(rt)].OL) ;</span><br><span class="line">	<span class="keyword">else</span>  T[rt].OL = T[ls(rt)].OL ;</span><br><span class="line">	<span class="keyword">if</span> (!T[rs(rt)].S) </span><br><span class="line">		  T[rt].OR = max(T[rs(rt)].OR, T[rs(rt)].Len + T[ls(rt)].OR) ;</span><br><span class="line">	<span class="keyword">else</span>  T[rt].OR = T[rs(rt)].OR ;</span><br><span class="line">	T[rt].OS = max(T[ls(rt)].OR + T[rs(rt)].OL, max(T[ls(rt)].OS, T[rs(rt)].OS)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (T[rt].tag == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (T[rt].t == <span class="number">1</span>)&#123;</span><br><span class="line">		T[ls(rt)].tag ^= <span class="number">1</span>, T[rs(rt)].tag ^= <span class="number">1</span> ;</span><br><span class="line">		T[ls(rt)].S = T[ls(rt)].Len - T[ls(rt)].S ;</span><br><span class="line">		T[rs(rt)].S = T[rs(rt)].Len - T[rs(rt)].S ;</span><br><span class="line">		<span class="comment">//l</span></span><br><span class="line">		T[ls(rt)].Sum ^= T[ls(rt)].OS ^= T[ls(rt)].Sum ^= T[ls(rt)].OS ;</span><br><span class="line">		T[ls(rt)].Lsum ^= T[ls(rt)].OL ^= T[ls(rt)].Lsum ^= T[ls(rt)].OL ;</span><br><span class="line">		T[ls(rt)].Rsum ^= T[ls(rt)].OR ^= T[ls(rt)].Rsum ^= T[ls(rt)].OR ;</span><br><span class="line">		<span class="comment">//r</span></span><br><span class="line">		T[rs(rt)].Sum ^= T[rs(rt)].OS ^= T[rs(rt)].Sum ^= T[rs(rt)].OS ;</span><br><span class="line">		T[rs(rt)].Lsum ^= T[rs(rt)].OL ^= T[rs(rt)].Lsum ^= T[rs(rt)].OL ;</span><br><span class="line">		T[rs(rt)].Rsum ^= T[rs(rt)].OR ^= T[rs(rt)].Rsum ^= T[rs(rt)].OR ;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[rt].tag == <span class="number">0</span>)&#123;</span><br><span class="line">		T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">0</span> ;</span><br><span class="line">		T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = T[ls(rt)].Len ;</span><br><span class="line">		T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = T[rs(rt)].Len ;</span><br><span class="line">		T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = <span class="number">0</span> ;</span><br><span class="line">		T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T[rt].tag == <span class="number">1</span>)&#123;</span><br><span class="line">		T[ls(rt)].tag = T[rs(rt)].tag = <span class="number">1</span> ;</span><br><span class="line">		T[ls(rt)].OL = T[ls(rt)].OR = T[ls(rt)].OS = <span class="number">0</span> ;</span><br><span class="line">		T[rs(rt)].OL = T[rs(rt)].OR = T[rs(rt)].OS = <span class="number">0</span> ;</span><br><span class="line">		T[ls(rt)].Lsum = T[ls(rt)].Rsum = T[ls(rt)].Sum = T[ls(rt)].S = T[ls(rt)].Len ;</span><br><span class="line">		T[rs(rt)].Lsum = T[rs(rt)].Rsum = T[rs(rt)].Sum = T[rs(rt)].S = T[rs(rt)].Len ;</span><br><span class="line">	&#125;</span><br><span class="line">	T[rt].tag = <span class="number">-1</span>, T[rt].t = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">		T[rt].tag = k ;</span><br><span class="line">		<span class="keyword">if</span> (!k)	</span><br><span class="line">			T[rt].OL = T[rt].OR = T[rt].OS = T[rt].Len, </span><br><span class="line">			T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = <span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">else</span>  T[rt].OL = T[rt].OR = T[rt].OS = <span class="number">0</span>, </span><br><span class="line">			  T[rt].Lsum = T[rt].Rsum = T[rt].Sum = T[rt].S = T[rt].Len ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= mid) _change(ls(rt), l, mid, k) ;</span><br><span class="line">	<span class="keyword">if</span> (R &gt; mid) _change(rs(rt), mid + <span class="number">1</span>, r, k) ;</span><br><span class="line">	up(rt) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _reverse(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">		T[rt].t = <span class="number">1</span> ;</span><br><span class="line">		T[rt].Sum ^= T[rt].OS ^= T[rt].Sum ^= T[rt].OS ;</span><br><span class="line">		T[rt].Lsum ^= T[rt].OL ^= T[rt].Lsum ^= T[rt].OL ;</span><br><span class="line">		T[rt].Rsum ^= T[rt].OR ^= T[rt].Rsum ^= T[rt].OR ;	</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	down(rt) ;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= mid) _reverse(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (R &gt; mid) _reverse(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	up(rt) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> T[rt].S ;</span><br><span class="line">	down(rt) ; <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= mid) res += Sum(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (R &gt; mid) res += Sum(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">	T[rt].tag = <span class="number">-1</span> ;</span><br><span class="line">	T[rt].Len = r - l + <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!base[l]) T[rt].OL = T[rt].OR = T[rt].OS = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">else</span>  T[rt].Sum = T[rt].Lsum = T[rt].Rsum = T[rt].S = <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	build(ls(rt), l, mid), build(rs(rt), mid + <span class="number">1</span>, r), up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Tree <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &lt;= l &amp;&amp; R &gt;= r) <span class="keyword">return</span> T[rt] ;</span><br><span class="line">	Tree res, A, B ;	</span><br><span class="line">	<span class="keyword">if</span> (mid &gt;= R) <span class="keyword">return</span> query(ls(rt), l, mid) ;</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; L) <span class="keyword">return</span> query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    A = query(ls(rt), l, mid), B = query(rs(rt), mid + <span class="number">1</span>, r) ;</span><br><span class="line">    res.Lsum = max(A.Lsum, A.S + B.Lsum) ; res.Rsum = max(B.Rsum, B.S + A.Rsum) ;</span><br><span class="line">    res.Sum = max(max(A.Sum, B.Sum), A.Rsum + B.Lsum) ; res.S = A.S + B.S ; </span><br><span class="line">	<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">	<span class="keyword">while</span> (M --)&#123;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; M &lt;&lt; " " &lt;&lt; "qwerweafasdfsdf" &lt;&lt; endl ;</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;MArk, &amp;L, &amp;R),</span><br><span class="line">		++ L, ++ R ;</span><br><span class="line">		<span class="keyword">if</span> (MArk == <span class="number">0</span>) _change(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">0</span>) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">1</span>) _change(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">2</span>) _reverse(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (MArk == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Sum(<span class="number">1</span>, <span class="number">1</span>, N)) ;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, query(<span class="number">1</span>, <span class="number">1</span>, N).Sum), <span class="built_in">putchar</span>(<span class="string">'\n'</span>) ;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; " qwerweafasdfsdf " &lt;&lt; endl ;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>push_up</code> 真长啊 $233$ 。</p>
<p>艹完这个题是真的爽啊~</p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>其实这东西和 $DP$ 某种程度上有共通之处。你只需要确定你想要维护什么(等价于确定状态)，然后明确父子区间如何向上维护(等价于状态之间如何转移)。</p>
<p>嗯，万物相同。</p>
<blockquote>
<p>野马也，尘埃也，生物之以息向吹也。天之苍苍，其正色耶？其远而无所至极耶？</p>
</blockquote>
<p>不知为什么，突然想到了这句话。</p>
<h1 id="mathscr-The-End"><a href="#mathscr-The-End" class="headerlink" title="$\mathscr{The~End}$"></a>$\mathscr{The~End}$</h1>]]></content>
      <categories>
        <category>题解</category>
        <category>SPOJ</category>
      </categories>
      <tags>
        <tag>奇怪的技巧</tag>
        <tag>数据结构/线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】自适应Simpson法入门</title>
    <url>/2019/03/17/Simpson1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一种很可爱的积分近似法，学的时候顺便看了好多论文qaq</p>
<a id="more"></a>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先阐明一点，<strong>自适应辛普森算法($\rm{Adaptive ~Simpson’s~ Algorithm}$ )</strong>是一类近似算法，主要用于求较难反导的函数的积分。大概在信息计算的时候中很常用？</p>
<p>其思想是利用二次函数来不断 <strong>拟合($\rm{Overfitting}$)</strong> 所求曲线，而所谓的 <strong>$\rm Adapative$(自适应)</strong> 则是用于优化时间复杂度的方法。</p>
<p>嗝…总之…比较简单？</p>
<p>表示看了两篇外国学者的论文，感觉好像思路已经比较清晰的样子。</p>
<h1 id="辛普森公式"><a href="#辛普森公式" class="headerlink" title="辛普森公式"></a>辛普森公式</h1><p>稍等，这个跟算法的关系不大，主要是公式：</p>
<script type="math/tex; mode=display">
{\int _{l}^{r} f(x) \mathrm{dx}\approx (r-l)\times \frac{f(r) +f(l)+ 4 \cdot f(m)}{6}}</script><p>事实上吧，求积分的话，大多数都是直接套辛普森公式的。并且这个公式是广泛适用的……只不过误差有点儿人大 $233$ 。</p>
<p>这其实是我们用二次函数不断拟合的结果，推导过程大致如下$^{[1]}$：</p>
<blockquote>
<p>因为 $g(x)$ 是用来拟合 $f(x)$ 的，所以有：</p>
<script type="math/tex; mode=display">
\int\limits_L^Rf(x)dx\approx \int\limits_L^Rax^2+bx+c\space dx</script><p>求 $g(x)$ 的不定积分为：</p>
<script type="math/tex; mode=display">
\int g(x)dx=\frac13ax^3+\frac12bx^2+cx+C</script><p>然后再带入 R 和 L ：</p>
<script type="math/tex; mode=display">
\int\limits_L^Rf(x)dx=\frac13a(R^3-L^3)+\frac12b(R^2-L^2)+c(R-L)</script><p>然后提公因式，原式为：</p>
<script type="math/tex; mode=display">
\frac{R-L}{6}(2a(R^2+LR+L^2)+3b(R+L)+6c)6R−L(2a(R2+LR+L2)+3b(R+L)+6c)</script><p>把里面展开来：</p>
<script type="math/tex; mode=display">
\frac{R-L}{6}(2aR^2+2aLR+2aL^2+3bR+3bL+6c)</script><p>重新整理一下式子：</p>
<script type="math/tex; mode=display">
\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+aR^2+aL^2+2aLR+2bR+2bL+4c)</script><p>再整理：</p>
<script type="math/tex; mode=display">
\frac{R-L}{6}((aR^2+bR+c)+(aL^2+bL+c)+4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c))</script><p>代换可得：</p>
<script type="math/tex; mode=display">
aR^2+bR+c\approx f(R)\\\
aL^2+bL+c\approx f(L)\\\
4(a(\frac{R+L}{2})^2+b(\frac{R+L}{2})+c)\approx 4f(\frac{R+L}{2})</script><p>把这三个式子带回去， 最后我们就得到了$\rm{Simpson}$ 积分公式：</p>
<script type="math/tex; mode=display">
\int\limits_L^Rf(x)dx \approx \frac{R-L}{6}(f(L)+4f(\frac{L+R}{2})+f(R)))</script></blockquote>
<p>于是我们就得到了所谓的 $\rm{Simpson~Fomula}$。但事实上，对于一段“跌宕起伏”的函数，我们还是无法准确地去用一个二次函数的拟合来刻画。于是——</p>
<h1 id="自适应辛普森法"><a href="#自适应辛普森法" class="headerlink" title="自适应辛普森法"></a>自适应辛普森法</h1><p>我们考虑，如果把区间们稍微划分地更细一点，那是不是会好呢？答案是一定的。那么我们可以考虑<strong>定向二分</strong>。但是……定向二分始终存在一个问题，就是它太笨了，笨到如果$[l_1,r_1]$已经满足精度要求了，我们却还要一直分；笨到$[l_2,r_2]$分的次数根本不够用——但我们并不可以得到反馈。</p>
<p>于是考虑<strong>自适应</strong>。</p>
<p>所谓<strong>自适应</strong>，说的直白点，无非就是<strong>需要多分治几次的地方，多分治几次；不需要的则可以少分治几次</strong> 。</p>
<p>你会发现，其实他节约的就是一个点——<strong>时间效率</strong>。</p>
<p>举个栗子$^{[2]}$：</p>
<p>比如有这么个函数</p>
<script type="math/tex; mode=display">
{f (x) = 13(x − x^2)e^{\frac{−3x}{2}} }</script><p>我们要求</p>
<script type="math/tex; mode=display">
\int_{0}^{4}f(x) \rm{~dx}</script><p>并要求精度误差在 $1e-5$ 以内。而我们有两种方法去解决：</p>
<ul>
<li>以固定的比例去二分。</li>
<li>运用自适应策略分配。</li>
</ul>
<p>那么我们首先要知道他真正的$value:$</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="3.png" alt=""></p>
<p>看起来好像海星？然后我们用两种方法都试一试：</p>
<p>首先是自适应法，我们发现最后只需要求 $20$ 段区间。</p>
<p>表中的 $a_k,b_k$ 表示区间左右端点，$S(l,r)$ 表示$[l,r]$ 内运用辛普森公式计算的结果，$\rm{Error~Bound}$ 表示误差界，$\rm{Tolerance}$ 表示计算时 <strong>可以忍受的误差</strong>。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="4.png" alt=""></p>
<p>那么最后算出来的值是 $ −1.54878823413$ ，与真实值误差为 $0.00000013840 $，一共调用了 $79$ 次<strong>函数估值</strong>（留个坑，后文会讲）。</p>
<p>那么绘制出来的函数图像大概长这样：<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="5.png" alt=""></p>
<p>好像很流畅？$233$</p>
<p>那么第二种方法是定值分段。我们考虑分成区间 $[0,4]$ 分为长度为 $0.03125$ 的 $128$ 段，分段应用辛普森共识，最后得出的结果为<br>$−1.54878844029$，误差为 $0.00000006776$ 。</p>
<p>好像是第一个误差的二分之一？看起来好像误差小了，但是却需要 $257$ 次函数估值的调用…相比之下，我们可以获得更优越的性能，而那误差也是不需要考虑的啦。</p>
<p>比起 $1e-5$ 精度来说…这波稳赚啊。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>首先是<a href="https://www.luogu.org/problemnew/show/P4525" target="_blank" rel="noopener">$LuoguP4525$</a>的暴力解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">5e-8</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Ans, A, B, C, D, L, R ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (C * x + D) / (A * x + B) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) / <span class="number">6</span> * (F(l) + F(r) + <span class="number">4</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, v, t ;</span><br><span class="line">    v = Simp_calc(l, r) ;</span><br><span class="line">    Lv = Simp_calc(l, mid) ;</span><br><span class="line">    Rv = Simp_calc(mid, r) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= Eps) <span class="keyword">return</span> Lv + Rv ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> do_divide(l, mid)  +  do_divide(mid, r) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf%lf%lf"</span>, &amp;A, &amp;B, &amp;C, &amp;D, &amp;L, &amp;R) ;</span><br><span class="line">    Ans = do_divide(L, R) ; <span class="built_in">printf</span>(<span class="string">"%.6lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这…严格意义上讲，不能算是自适应辛普森法——更准确地说，四不像，或者“东施效颦”之类的，都挺合适。这是我在初学这一块儿内容时的写法，他不严格正确，但是…他对的很？</p>
<p>Upd on 2020.4.16 放一个比较对的写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">db L, R ;</span><br><span class="line">db a, b, c, d ;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">f</span><span class="params">(db x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (c * x + d) / (a * x + b) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">simpson</span><span class="params">(db l, db r)</span></span>&#123;</span><br><span class="line">	db mid = (l + r) * <span class="number">0.5</span> ; </span><br><span class="line">	<span class="keyword">return</span> (r - l) * (<span class="number">4.0</span> * f(mid) + f(l) + f(r)) * <span class="number">0.1666666666</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">db <span class="title">solve</span><span class="params">(db l, db r, db e)</span></span>&#123; </span><br><span class="line">    db mid = (l + r) * <span class="number">0.5</span> ; </span><br><span class="line">	db val = simpson(l, r) ;</span><br><span class="line">	db lval = simpson(l, mid) ; </span><br><span class="line">	db rval = simpson(mid, r) ;<span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(val - lval - rval) &lt;= <span class="number">15.0</span> * e) </span><br><span class="line">		<span class="keyword">return</span> lval + rval + <span class="built_in">fabs</span>(val - lval - rval) / <span class="number">15</span> ; <span class="comment">//2</span></span><br><span class="line">	<span class="keyword">return</span> solve(l, mid, e * <span class="number">0.5</span>) + solve(mid, r, e * <span class="number">0.5</span>) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; L &gt;&gt; R ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, solve(L, R, eps)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于进化版<a href="https://www.luogu.org/problemnew/show/P4526" target="_blank" rel="noopener">LuoguP4526​</a>，也是完全可以violently艹过去的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) / 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">5e-8</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, B, C, D, L, R ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, A / x - x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) / <span class="number">6</span> * (F(l) + F(r) + <span class="number">4</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> Lans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, v, t ; Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r), v = Lans ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= Eps) <span class="keyword">return</span> Lv + Rv ; <span class="keyword">return</span> do_divide(l, mid, Lv) + do_divide(mid, r, Rv) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A) ; L = Eps, R = <span class="number">23.3</span> ;</span><br><span class="line">    <span class="keyword">if</span> (A &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"orz"</span>), <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">    Ans = do_divide(L, R, Simp_calc(L, R)) ; <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，真正的实现应该是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v Lans</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hps eps * 0.5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r) * 0.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">double</span> Ans, A, L, R ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Liu = <span class="number">1.0</span> / <span class="number">6</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">F</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(x, A / x - x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Simp_calc</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (r - l) * Liu * (F(l) + F(r) + <span class="number">4.0</span> * F(mid)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">do_divide</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> Lans, <span class="keyword">double</span> eps)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Lv, Rv, t ; </span><br><span class="line">    Lv = Simp_calc(l, mid), Rv = Simp_calc(mid, r) ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= eps * <span class="number">15</span>) <span class="keyword">return</span> Lv + Rv + t / <span class="number">15</span> ; </span><br><span class="line">    <span class="keyword">return</span> do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ; <span class="comment">//据说eps×15来自于Wiki……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A) ; L = Eps, R = <span class="number">30</span> ; </span><br><span class="line">    <span class="keyword">if</span> (A &lt; <span class="number">0</span>) &#123; <span class="built_in">puts</span>(<span class="string">"orz"</span>), <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;&#125;</span><br><span class="line">    Ans = do_divide(L, R, Simp_calc(L, R), Eps) ; <span class="built_in">printf</span>(<span class="string">"%.5lf"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们发现这就可以跟文章上面的例子呼应了：每次分治时计算两次，总共分治了 $39$ 次，最终一共计算了 $78+1=79$ 次，而分治做时，则会形成一棵有 $128$ 个叶子节点的递归树，总共计算了 $256 +1=257$ 次。    </p>
<p>好的，终于要扯正题了。算法的实现其实简单，我们用拟合性算法不断check\&amp;calc​；而 check 的方式也很简单，只需要判断一下两段子区间的函数值之和，与整个区间的函数值之和的差值，是否在精度要求范围之内.如果满足精度误差就直接 <code>return</code>，否则对于这段区间继续递归下去。</p>
<p>而这个地方有个要求，就是对于 $eps$，你需要不断 $half$ 他，原因很简单，对于一整段区间 $U$，要求他的返回值的 $|eps(U)| \leq k$ 的话，那么对于其作为子集两个连续区间 $A,B$，当 $A \bigcup B = U$ 时，必须要满足$|eps(A)| \leq \frac{k}{2}, |eps(B)| \leq  \frac{k}{2}$，才能保证 $|eps(U) = eps(A) + eps(B)| \leq k$，所以要：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hps eps * 0.5</span></span><br><span class="line">....................</span><br><span class="line"><span class="keyword">return</span> do_divide(l, mid, Lv, hps) + do_divide(mid, r, Rv, hps) ;</span><br></pre></td></tr></table></figure>
<p>好了，唯一的问题在于有句话迷的很：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(t = (Lv + Rv - v)) &lt;= eps * <span class="number">15</span>) <span class="keyword">return</span> Lv + Rv + t / <span class="number">15</span> ;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="nky.jpg" alt=""></p>
<p>这个 $\leq 15 \cdot eps$ 是什么意思？</p>
<p>好吧，笔者也不清楚，但是有个结论是长这样的：<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<p>什么？你说推什么倒？小小年纪整天想着推倒<del>学姐</del>可不好啊$233$</p>
<p>什么？你还想看推倒的过程？啧啧啧，左转知乎感情专区蟹蟹～</p>
<hr>
<p>好的，以上两段是瞎扯的，推导过程十分诡异，大家自己食用好了……</p>
<p>于是结束，撒花花！</p>
<h1 id="rm-Referance"><a href="#rm-Referance" class="headerlink" title="$\rm{Referance}$"></a>$\rm{Referance}$</h1><ul>
<li><p>$[1]$ : <code>NaCly_Fish</code> 的$blog$ <a href="https://www.luogu.org/blog/NaCly-Fish-blog/SimpsonIntegral" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></p>
</li>
<li><p>$[2]$ : 某篇论文 <a href="https://files.cnblogs.com/files/pks-t/AdaptiveQuadProof.pdf" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a></p>
</li>
</ul>
<p>对于第二篇 $refer$，借鉴的比较多（读书人的事…咳咳…），但是改了一个数据，就是$81 \to 79$，因为代码需要 $233$ 。</p>
<p>$Ps:$史上最不正经的 $reference$ 从此诞生了……</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学/积分/积分近似</tag>
        <tag>计算几何/Simpson积分</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】线性规划入门</title>
    <url>/2019/03/15/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p>
<p>许久之前开始学的算法了…今天终于学完了。主要参考的材料是董克凡的 $ 2016 $ 集训队论文和 $ \rm{Candy?} $ 的代码整理，在此处致以敬意。</p>
<hr>
<h1 id="rm-0x01-Preface"><a href="#rm-0x01-Preface" class="headerlink" title="$ \rm{0x01~ Preface} $"></a>$ \rm{0x01~ Preface} $</h1><p>线性规划主要解决的问题是：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\
\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)</script><p>不失一般性的，我们定义最大化的函数为<strong>目标函数( $ \rm{Aim-Func} $ )</strong> ，定义约束函数的集合为<strong>约束函数集( $ \rm{Constraint-Set} $ )</strong>。那么朴素的线性规划可以看求一组向量{ $ x_1,x_2\cdots x_n $ }，使之既可以做约束函数的因变量，又满足其目标函数的值为 $ max $ 。</p>
<p>同时，规定所有的 $ x $ 均满足 $ x&gt;0 $ 。</p>
<a id="more"></a>
<p>当然，存在一种更加赏心悦目的矩阵表示方式：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \boldsymbol{c^Tx} \\
\text{满足约束} \quad A\boldsymbol{x\leq b} \\\
\it{\qquad \qquad \quad} \boldsymbol {x} \geq 0</script><p>其中 $ \boldsymbol{c,x,b} $ 均为一维向量， $ A $ 为系数矩阵。</p>
<p>那么我们在高中数学必修五里面运用的智障做法是，通过每个约束确定一个凸包，再用目标函数不断平移以求得与凸包的切点/切线来达到最大值，但是这样的做法通常不具有一般性。所以需要引入一种更常用的方法来解决这类问题。</p>
<h1 id="rm-0x02-松弛型矩阵与-rm-Pivot-操作"><a href="#rm-0x02-松弛型矩阵与-rm-Pivot-操作" class="headerlink" title="$ \rm{0x02} $  松弛型矩阵与 $ \rm{Pivot} $ 操作"></a>$ \rm{0x02} $  松弛型矩阵与 $ \rm{Pivot} $ 操作</h1><p>我们考虑一种更加友好的线性规划方式——<strong>松弛型矩阵</strong>，即将原来的矩阵添加几个无实际作用的新变量 $ x_i $ ，使之换一个样子：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\
\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} \quad (i = 1,2,3\cdots m) \\\ \qquad\quad  x_j \geq 0\quad (j=1,2,3\cdots n+m)</script><p>两种表示是等价的，但是我们更倾向于松弛型这种简洁的表述方式。</p>
<p>同时我们规定以下：</p>
<p> $ 1. $ 基变量：在松弛型约束中，等式左边的变量。</p>
<p> $ 2. $ 非基变量：在松弛型约束中，等式右边的变量。</p>
<p>那我们定义一次<strong>转轴操作 $ (pivot) $ </strong>为<strong>将一个基变量换进等式右边，换出一个非基变量的过程</strong>。</p>
<p>假设我们在第 $ i $ 组约束中，有一个变量 $ x_k~(k&gt;n) $ 是基变量，我们要换出一个非基变量 $ x_p~(1\leq p\leq n) $ ，那么就会由：</p>
<script type="math/tex; mode=display">
x_k= b_i -\sum \limits_{j=1}^{n} a_{i,j}x_{j}</script><p>变成</p>
<script type="math/tex; mode=display">
x_p = \frac{b_i - \sum \limits_{j\neq p}a_{i,j}x_j -x_k}{a_{i,p}}</script><p>而单纯性做法的本质就是通过不断转轴，实现目标函数不断变大。</p>
<p>看上去似乎比较抽象？我们考虑对一次转轴操作，我们需要在转轴之后将原来目标函数里的非基变量代入，即用 $ (b_i - \sum _{j\neq p}a_{i,j}x_j -x_k)/a_{i,p} $ 这个东西去替换掉 $ x_p $ ，那么其中的常数项 $ \frac{b_i}{a_{i,p}} $ 就可以作为目标函数中的一个常数值，当 $ x_i~(i=1,2,3\cdots n) $ 均为 $ 0 $ 时，目标函数的值即为此。那么转轴操作就是通过这样的操作使得目标函数里的常数值不断增大，达到最优解。</p>
<p>注意，转轴之后的得到的 $ x_p $ 的表达式，不仅要代入目标函数，也要代入其余的约束。</p>
<h1 id="rm-0x03-rm-Simplex"><a href="#rm-0x03-rm-Simplex" class="headerlink" title="$ \rm{0x03}~ \rm{Simplex} $"></a>$ \rm{0x03}~ \rm{Simplex} $</h1><p>那么接下来，我们考虑单纯性做法的完整过程。</p>
<p>不失一般性的，我们假设所有 $ b_i\geq 0 $ </p>
<p>首先，我们对于转轴操作结束，回代一次之后，会发现目标函数中肯定会有至少一项系数变为负值，即转进来的前·基变量 $ x_k $ ，那么增大 $ x_k $ 一定会让结果目标函数变小。所以我们可以断言，<strong>当目标函数里的所有变量系数均为负值时，目标函数的最优值就会是现在目标函数中的常数值</strong>——因为我们在前文已经假定 $ x_i\geq 0 $ 了。</p>
<p>同样，我们每次转轴操作需要保持原来线性规划的不变性，换句话说就是我们每次转轴时<strong>都需要找一个对与某个非基变量限制最紧的约束，将其换出</strong>。原因是我们考虑目标函数中的 $ x_i $ ，当其系数 $ \geq 0 $ 时， $ \rm{Aim  }\propto x_i $ ，所以我们需要找一个最紧的约束<strong>遏止</strong> $ x_i $ 的增长(即使我们不想)。</p>
<p>那么伪代码如下， $ A,\boldsymbol{b,c} $ 的定义一开始已给出：</p>
<hr>
<p>Simplex(A, b, c){<br> $ \qquad $  initialization(A,b,c)  ;<br> $ \qquad $  while  $ ∃e $  that  $ c_e&gt;0 $ {<br> $ \qquad  \qquad $ find the index  $ l $  that  $ A_{l,e} $   $ &gt; 0 $  and minimizes  $ b_l/A_{l,e} $<br> $ \qquad \qquad $ if  $ ∀l, A_{l,e} ≤ 0 $<br> $ \qquad \qquad \qquad $ return Unbounded ;<br> $ \qquad \qquad $ else<br> $ \qquad \qquad \qquad $ pivot(A, b, c, l, e)；<br>}</p>
<hr>
<p>值得注意的是，如果在寻找完最紧约束后，存在一个 $ A_{l,e} \leq 0 $ ，那么我们在这组约束里无论怎么增大 $ x_e $ 都会使得目标函数增大，所以直接<code>return Unbounded</code>。</p>
<p>此时我们还需要进行额外的操作，即初始化。因为我们转轴操作的目的是使目标函数增大，所以我们需要保证所有的 $ b_i\geq 0 $ ，但一开始给定的 $ b_i $ 很可能不满足这一约束，所以我们需要进行一次初始化。那么对于初始化，我们的思想是做另一次线性规划。<del>鬼知道那些发明这玩意儿的神仙怎么构造出的这个线性规划。</del></p>
<p>我们考虑一个这样的线性规划：</p>
<script type="math/tex; mode=display">
\text{最大化}\quad -x_0 \\
\text{满足约束} \quad x_{n+i} = b_i - \sum \limits_{j=1}^{n} a_{i,j}x_{j} +x_0\quad (i = 1,2,3\cdots m)\\
\it{\qquad \qquad \qquad \quad x_j} \geq 0\quad (j=0,1,2,3\cdots n)</script><p>首先，无论怎样，先思考他会不会对原来的线性规划产生什么影响——答案是：不会。因为我们考虑当 $ -x_0 $ 最大时，一定是 $ x_0=0 $ 的时候。所以对于约束中的 $ x_{n+i} $ ，大小不会变化。</p>
<p>那么我们考虑这种初始化方式的正确性。我们考虑每次都将 $ x_0 $ 作为换入变量(即我们一开始将 $ x_0 $ 视作非基变量)，那么 $ pivot $ 之后就会有</p>
<script type="math/tex; mode=display">
x_0 = -b_i+x_{i+n}+\sum\limits_{j=1}^{n}a_{i,j}x_j</script><p>由于我们一定找的时限制最小的，那么 $b_i\lt 0\Longrightarrow-b_i\gt 0$ ，这组约束合法。</p>
<p>对于其余的约束，我们考虑代入之后，会有：</p>
<script type="math/tex; mode=display">
x_{n+k}= b_k-b_i+\sum\limits_{j=1}^{n}(a_{k,j}-a_{i,j})x_j+x_{i+n}</script><p>由于 $ b_i $ 最小，那么 $ b_k\geq b_i \Longrightarrow b_k-b_i\geq 0 $ 。任务完成。</p>
<p>那么就可以愉快地上代码辣(≧▽≦)/！题目来自于<a href="http://uoj.ac/problem/179" target="_blank" rel="noopener"> $ \rm{UOJ179} $ </a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e15</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, T, Id[MAXN], i, j ; <span class="keyword">double</span> A[MAXN][MAXN], Get[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    swap(Id[N + l], Id[e]) ;<span class="comment">//交换两个变量</span></span><br><span class="line">    <span class="keyword">double</span> t = A[l][e] ; A[l][e] = <span class="number">1.0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= N ; ++ i) A[l][i] /= t ;<span class="comment">//类似于高斯消元的第一步，把这一项挪到等式右边，所以要先都除以系数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt;= M ; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(i != l &amp;&amp; <span class="built_in">fabs</span>(A[i][e]) &gt; eps)</span><br><span class="line">            <span class="keyword">for</span>(t = A[i][e], A[i][e] = j = <span class="number">0</span> ; j &lt;= N ; ++ j) </span><br><span class="line">              A[i][j] -= A[l][j] * t ;<span class="comment">//此处则是代换。而由于代数式中肯定不会出现我们的A_&#123;i,e&#125;(毕竟是换到了等式右边)，所以对于这一项的系数要特殊处理成0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>, l = <span class="number">0</span> ; <span class="keyword">double</span> t = -eps ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][<span class="number">0</span>] &lt; t) l = i, t = A[i][<span class="number">0</span>] ; <span class="keyword">if</span>(!l) <span class="keyword">return</span> <span class="number">1</span> ;<span class="comment">//找系数最小的负值项</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (A[l][j] &lt; -eps &amp;&amp; (!e || (rand() &amp; <span class="number">1</span>))) e = j ;</span><br><span class="line">        <span class="keyword">if</span> (!e) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Infeasible"</span>), <span class="literal">false</span> ;  Pivot(l, e) ;</span><br><span class="line">    &#125;<span class="comment">//不合法的线性规划，因为我们假设全部的系数都为正，且我们前面已经假定了全部x_i为正，那么不可能满足标准型里面的小于b_l——此时b_l为负值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, e = <span class="number">0</span> ; <span class="keyword">double</span> MAX = INF ;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (A[<span class="number">0</span>][j] &gt; eps) &#123; e = j ; <span class="keyword">break</span> ; &#125; <span class="keyword">if</span>(!e) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][e] &gt; eps &amp;&amp; A[i][<span class="number">0</span>] / A[i][e] &lt; MAX) MAX = A[i][<span class="number">0</span>] / A[i][e], l = i ;<span class="comment">//选个最紧的约束</span></span><br><span class="line">        <span class="keyword">if</span> (!l) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Unbounded"</span>), <span class="literal">false</span> ; Pivot(l,e) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; T ; srand(<span class="number">19260817</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Id[i] = i ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; A[<span class="number">0</span>][i] ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; <span class="built_in">cin</span> &gt;&gt; A[i ++][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="built_in">cin</span> &gt;&gt; A[i][j] ; </span><br><span class="line">    <span class="keyword">if</span> (!(Init() &amp;&amp; Simplex())) <span class="keyword">return</span> <span class="number">0</span> ; <span class="built_in">printf</span>(<span class="string">"%.8lf\n"</span>, -A[<span class="number">0</span>][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= M ; ++ i) Get[Id[N + i]] = A[i][<span class="number">0</span>] ; </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%.8lf "</span>,Get[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然鹅事实上这份代码只有 $ 97pts $ …好像剩下3分就几乎没有人得过，除了kcz和std……</p>
<p>至于中间的<code>srand</code>，是由于我们随便 $ pivot $ 一个 $ e $ 就好，于是就<del>听长者的</del>。</p>
<h1 id="rm-0x04-Afterwords"><a href="#rm-0x04-Afterwords" class="headerlink" title="$ \rm{0x04}~ Afterwords $"></a>$ \rm{0x04}~ Afterwords $</h1><p>一直想学，一直没有机会学。</p>
<p>说起来确实有点儿小激动。第一次写单纯型的代码是前不久的一次周末，早上点起来之后头昏脑涨地扑向Candy?的博客，学了起来。在那之后才发现原来线性规划并不常考，甚至说，不考。但是我挺喜欢这种感觉，<del>感觉自己仿佛比出题人会的还多</del></p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$ \rm{Reference} $"></a>$ \rm{Reference} $</h2><ul>
<li>$ [1] $  : $ Candy? $ 的 $ blog $  <a href="https://www.cnblogs.com/candy99/" target="_blank" rel="noopener"> $ ^{^{[\nearrow ]}} $ </a></li>
<li>$ [2] $  :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener"> $ ^{^{[\nearrow]}} $ </a> 提取码：vua4</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>线性规划</category>
      </categories>
      <tags>
        <tag>线性规划/单纯形法</tag>
        <tag>目测用不到的算法系列</tag>
      </tags>
  </entry>
  <entry>
    <title>随想六 · 难</title>
    <url>/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近心绪颇不宁静。</p>
<a id="more"></a>
<p>《随想》系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">$Link$</a></p>
<h2 id="text-Part0"><a href="#text-Part0" class="headerlink" title="$\text{Part0}$"></a>$\text{Part0}$</h2><p>不知道为什么，最近的心绪颇不宁静。</p>
<p>那是一种说不出来的痛苦与寂寞，或许夹杂着一些爽快。省选将近，我不知道自己会有什么样的下场。我只知道自己码力依旧很弱、脑子依旧很笨。比起几个月之前退役之后萎靡不振的自己，没有什么长进。</p>
<p>我更是知道，我原本的想法是多么的幼稚。或许我一直在骗自己吧，骗自己“省选之前的一两个月，拼一拼、挤一挤时间，或许就能怎样怎样”——原来$\rm{NOIP}$爆锤我的人，不止比我聪明，还比我勤奋，还比我认真，还比我努力。我有什么资本去同台竞技呢？到最后，省选对我来说，也不过只是个笑话吧。</p>
<p>这些天我一直觉得自己已经足够努力了，但是发现永远都是“远远不够”。就好比我想要触及$\infin$，而我每天就算是以$100$、$1000$、$10000$…… 的速率增长，也永远没有抵达的那一天。</p>
<p>毕竟啊，上苍的笔下，早已经写下了规则：无论$1$后面多少个$0$，都至多是一个十分大的常数而已。</p>
<p>就好像我自己，无论多么努力，努力到感动自己，也至多是一个笑话而已。</p>
<h2 id="text-Part1-cdot-Her"><a href="#text-Part1-cdot-Her" class="headerlink" title="$\text{Part1}\cdot Her$"></a>$\text{Part1}\cdot Her$</h2><p>“她”是谁？</p>
<p>我曾在$qq$空间中发过一篇说说，调侃我们奥赛生不能放假，但是主体部分却是与假期毫无关系：</p>
<blockquote>
<p>头一次清晨在无人的校园里闲逛，<br>耳畔是青鸟在歌唱着礼赞，以及夹杂在清风中的徐徐回音，<br>眼前是澄碧色的天空，远处仿佛降下一道若隐若现的天上虹。<br>一切都慢下来了，我可以看到流云在舒张、卷缩，又舒张，我可以听到渺茫的歌声，我甚至可以想到你的模样——那在暖阳下熠熠闪光的细框眼镜和清亮的眸子，以及如桃花一样绯红的面颊。<br>好像整个世界都停下来了，只有我和在烟雾中幻化出神形的你，和身旁枝梢上的青鸟，以及指尖流掠的清风与阳光——</p>
</blockquote>
<p>最后一句本来是<code>但是这TM跟我只能待在学校不能回家并且你们在家里嗨没有任何关系</code>，毕竟是为了逗乐，我也不想被当成什么为感情烦恼的愣头青。但是在我看来，主体部分应该是上面引用框里的内容。</p>
<p>我曾经觉得只要奥赛拿了耀眼的成绩，就可以十分骄傲地去追求我想要的。但就现在的情况而言，不是很乐观。</p>
<p>我不想让她知道这件事，因为这世界上无疾而终的事情太多了，或许这就是下一件。但其实思来想去，似乎这份薄薄的感情并不那么重要，因为比起这事儿来，我需要担心的东西还有太多太多——明天跑操会不会很累？文化课会不会继续跪？文化课跪完班主任是否会丧失对我的最后一点信任？我的OI终点到底是什么？……</p>
<p>以前从没觉得做人这么难。但我并不想说“我成长了”这种自我满足式的话语，我更想对我自己说：</p>
<blockquote>
<p>大概是只有弱者才会觉得人生艰难吧。你看你灰暗的眼眸中的对岸，正有个青年，眼里全是山水诗画。可惜那个青年，不是你。</p>
</blockquote>
<p>她学习成绩很好，毕竟不学奥赛，有大把的时间去搞文化课。而我或许只是班级角落里一个喜欢标新立异的弱者吧。</p>
<h2 id="rm-Part3"><a href="#rm-Part3" class="headerlink" title="$\rm{Part3}$"></a>$\rm{Part3}$</h2><p>我很烦。</p>
<p>机房里去年省一的小伙伴们似乎并不是多在意省选，就只有我在拼得头昏脑胀。</p>
<p>我好不爽啊，凭什么我如此珍视的东西，他们可以胡乱蹂躏、浪费、玷污——况且迄今为止这个机会对于去年<code>NOIP</code>考挂的我，还不一定有这个机会去省选。这就好像我的女神不属于我，但是却被另一个人又杀又剐——我怎能不生气+寒心呢？</p>
<p>好在这个精神状态持续了两天就好转了——主要原因是我得知$SD$的省选政策，只是限制了基准线而已——或许还有机会？我不知道，因为我的智商在所有的$Oier$里面，大概算是个中下，所以我即使拼尽全力也不能保证强过谁——况且我根本不可以拼尽全力啊…</p>
<p>最近一直在翘考试、翘美术音乐课……各种翘，我估计班主任马上就要通过对我的不信任案了……</p>
<h2 id="rm-Part4"><a href="#rm-Part4" class="headerlink" title="$\rm{Part4}$"></a>$\rm{Part4}$</h2><p>不得不说这篇随想比之前的随想水多了……于是糊一篇我在知乎上的回答吧。当时有个题主问，如果从高一下学期左右开始，每天学奥赛几个小时，能不能拿金牌。</p>
<p>其实本来是无所谓的——于我而言无所谓。因为他志向宏大是一件好事，至于能否成真，我也没有评论的权利。但是我确乎是发现，他心里一直是觉得“我还有两把刷子的”，“只是时运不济罢了”。不知怎的，突然我就有了想多说两句的欲望：</p>
<blockquote>
<p>我给你讲，目标跟眼界和实力有关。眼界越大、实力越强，目标越小。</p>
<p>同时，我可以很负责任的跟你讲：你绝对不知道的接下来你面临的是什么。</p>
<p>如果说你准备提高组的考试之前，有什么题不会看题解，理解起来的痛苦程度是1的话，那么你想继续向上走、想去省选、想去NOI，理解起来的痛苦程度将会是1e5以上。</p>
<p>没错，10万倍——如果你想自学的话。相信我，NOIP级别的考试，只是考代码素质/程序设计能力，根本不考察理解能力。</p>
<p>保送——是的，这是奥赛的终极目标之一。但是向来不会有人主动谈起这件事，即使他再NB。你现在还可以提出这个问题，只是说明你还不了解行情。抱歉，如果你现在觉得你自己很有天分，你觉得你现在可以拿“啊…我当时只是因为某些跟我自己没有关系的原因失败了”这种幼儿园智商的理由来骗自己——我只能跟你说，你不知道其它人有多厉害，说得难听些，就是井底之蛙——</p>
<p>你知道全中国有无穷无尽的智商可以吊打你的人，他们每天可以有大半天的时间学OI吗？</p>
<p>你知道每年有多少初中生在NOIp中碾压高中生吗？</p>
<p>你不知道。</p>
<p>每天几个小时？</p>
<p>做学问最需要的是谦卑，给自己找理由、沉浸在“我应该多么多么厉害”的幻想里终究会失败。</p>
<p>你相信我，我说的都是切实的体会。你体会不到是因为你不知道你所在四川到底有多么恐怖——基本是成都七中制霸；NOIP全省前40人均460+，全省前90人均400+。</p>
<p>我知道我没有很厉害，所以我的话你不会信多少。但是如果说奥赛给了我什么，最大的收获就是在学术上面的虔诚——做学问就好好做学问，不去追求附加价值，以及在学术上永远谦卑的态度。</p>
</blockquote>
<p>看起来似乎我很刚的样子，但是这样做不是毫无缘由的——我其实，也是在对自己说吧。</p>
<p>为什么会这么难呢？我不知道啊。</p>
<p>我只知道我的机会确乎是不多了。</p>
<p>今年省选还有没有戏呢？我也不知道。</p>
<p>我只知道我的时间不多了。</p>
<p>不知怎的，眼前仿佛有一条宽阔的大河，浩荡无际。我无论做什么，都只能在上面溅起一圈窄窄的波纹而已。我在小小的沙洲上伫立着，远望是另一个小小的沙丘，上面站着她。我无法丈量出我们彼此之间的距离，好像很近，近到我能看清她的一颦一簇，可以看清她眉上新添的露珠；好像也很远，因为我不知道她在想什么、她要做什么。</p>
<p>呵，才记起来曾经有一部时下较火的剧里，称“暗恋”或者“单相思”，是最省钱的恋爱。我确乎是记住这一点了。但是我更想说，它不仅是最省钱的，也是最美的、最富有变化的、最梦幻的。</p>
<p>这是一片无垠的朦胧，夜幕中遥遥的，仿佛闪着两颗摇曳的星。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随想四 · 故人故事</title>
    <url>/2019/03/01/%E9%9A%8F%E6%83%B3%E5%9B%9B%C2%B7%E6%95%85%E4%BA%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我一直在想，这篇到底该怎么写，到底该写什么。</p>
<p>但才发现，想要回忆的太多了啊。</p>
<p>但既然是讲故人故事的，那就讲好了。</p>
<p>这是段什么故事呢？这是段我不想讲也不会讲的故事吧。</p>
<a id="more"></a>
<h1 id="0"><a href="#0" class="headerlink" title="$0$"></a>$0$</h1><p>说实在的，这篇文章我写了好多好多不同的版本，但都是写了一两段不想写了，感觉越写越智障。今天是 <code>11/1/2020</code> ，不知道为啥突然就啥都不想干了，于是就来补一下。</p>
<p>我们这一级，应该是最特殊的吧？我们来的前一年9月实验部成立，来的第一年10月因为高三太菜了，实验部解散；我们的学长是rqy，这份奇怪的缘分奇怪在，我们些人连续参加了 $4$ 年的 $noip$，每次都和 $rqy$ 一起参加——就算是和他同级的人也没有这种缘分。同样，我们也是老校最后一批初三，新校第一批高一</p>
<p>总之呢，这让我想起一句话：</p>
<blockquote>
<p>过去与未来的交叉点就是当下,而我正站在这个点上。 ——梭罗《瓦尔登湖》</p>
</blockquote>
<h1 id="1-老校-·-衔接班-·-光明"><a href="#1-老校-·-衔接班-·-光明" class="headerlink" title="$1$ 老校 · 衔接班 · 光明"></a>$1$ 老校 · 衔接班 · 光明</h1><p>还在老校的时候，每天最烦的就是考试，因为我老是垫底。</p>
<p>我 $2019$ 年一月份来的实验部，直到现在也一直觉得自己是混上来的，因为我觉得我考的很差，可能只是因为初三提高组写了个小凯的疑惑水到了省三而被潜规则上来的。当时刚来的时候十分愉快，每天 $5:30$ 起，太新奇了。高中部四处都是新鲜的环境，种类繁多的小卖部，再加上我初三一直很稳地霸占着全班第一，觉得自己人生到达了一个小顶点。</p>
<p>刚来的时候，是 $12$ 个人。我在其中的实力不算高。只记得刚来的时候，由于大家初中是就挺熟，所以也了解彼此的八卦。在阿淳帮獴哥给他的大番薯女神用qq表（机）完白（惨）之后（至于为什么叫大番薯…我承认这是我起的绰号，因为他女神和《老夫子》里面的大番薯一样可爱233），獴哥被无情拒绝，之后这就变成了我们机房初来实验班的第一个梗。</p>
<p>嗯，其实我并没有多老实，因为接下来两天，我在机房外放了两天的《好日子》来庆祝獴哥表白失败，233.</p>
<p>（说句题外话，当时最开始我们甚至可以中午不去吃饭，用午饭时间打「死神VS火影」。后来被教练抓包了就不能了）</p>
<p>不过之后可能是遭报应了，由于在高中部食堂吃了一碗烤鸡心，肠胃发炎在学校高烧了两天——当时我说什么都不会请假的。所以现在我在打出「烤鸡心」这三个字的任意一个组合或者某个后缀的时候都会感到恶心。</p>
<p>之后呢？之后我不知道为什么就被选成了队长。然后大家就开始在高中部吹水，每天去洛谷做题，从上到下挨着刷，不过我大多数都是在抄题解。</p>
<p>渐渐地，我的缺点终于暴露了——我很偏执。这就直接导致了我的领导十分「黑暗」、「独裁」，也可能是因为大家都太有个性了，初中的时候都是班里叱咤风云的人物，所以都不是很服。当然了，矛盾啥的最后也都不了了之，大多数时候大家还是很和睦的。</p>
<p>衔接班，也就是实验班被选出来提前在高中部学习的那半年，挺快乐的。但就是考试自己老是不会，然而自己当时唯一找出的原因就是「别人经验丰富」。</p>
<p>期间经历过什么呢？经历过最难忘的一次培训，那是在二月。年前刚来实验部的愉悦加上马上过年的期盼，每天和lzr&amp;qcr吃鸡吃到凌晨三四点，四点多开始写博客，8点多起床直奔讲课地点也来不及吃早饭，于是饭票几乎就没用过；自我感觉是收获比较多的一次培训。因为在那之后，经过一位HB巨佬的指正（事实上是EA），我学会了线段树（之后才发现原来跟线段没有关系），再之后我就写出了洛谷上「线段树」的题解——当时的洛谷还不是这么热闹。</p>
<p>现在回想起来，真幸福啊。</p>
<p>比较悲伤的几件事，就是来的前几天就被主任给抓了晚上在宿舍说话（8个人有7个在闲扯），被罚干一学期的值日并且挂名「物业公司」；四月底又因为在奥赛室里开qq群吹水+换了一张sexy Miku的高清图做桌面而被赶回家过了个黄金周……</p>
<p>然后就是无止尽的失恋，如果我可以这么说的话。因为毕竟妹子都没喜欢过我qaq。</p>
<p>记得当时的大家：</p>
<p>dyz作为我们之中唯一的女选手，很要强很认真，会自己申请不放假留校学习；</p>
<p>ljp每天和wx黏在一起，并伙同我们一起给wx起名为「王强」，毕竟wx确实很强；</p>
<p>yjk由于每次考试都rank1，深受金牌教练喜爱，被我们称为金牌教练的「干儿子」，是个看起来老实的骚包；</p>
<p>lwy做题速度总是很快，ID是「影流殿殿主」，然而我也不知道「影流殿」是个什么梗（一直到去年年底「影流之主」的爆火我才知道）；</p>
<p>wxl一直被我们怂恿去跟他暗恋的妹子表白，直到拍毕业照那天他才真敢去表白；</p>
<p>獴哥一直很稳，由于和别人水群被组cp，同时由于我们的宿舍和初三宿舍以及买学习用品的小卖部面对面，导致每次他的「大番薯女神」经过旁边的商店都被我们起哄；</p>
<p>qcr给自己起了个Id叫做「邱城锐大神」，在明白OI的生存法则之后感到失去梦想，然而他经常因为看小说被抓，因此也掌握了各种「装作自己不在看小说但实际上就是在看」的看小说方法（比如复制进luogu的剪贴板）；</p>
<p>lzr十分颓，经常和qcr被成对抓包，但他主要是在搓游戏；由于初中的时候同班，所以我有什么事儿都会先同他讲——他也很仗义，在我们的水群被抓包、我要被赶回家的时候，他站出来跟主任解释不全是我的锅（虽然最后还是因为我身为队长也在水群被赶回去黄金周了）；</p>
<p>阿淳作为唯一有女票的，被我们整天起哄——我们用「大河」代指他的女票，你没猜错这也是我起的绰号（文学带师.jpg）；同时后期的他也是html（读作『喝特么了』）带师，博客园美化小能手，甚至真的拿了奥赛室的一本html教材开始学orz；</p>
<p>ZZH一度是我们中做题做的最多的，也是八卦八的很频繁的：他自诩为钢铁直男（虽然，indeed），同时一直暗恋着一个妹子但是一直不表白（因为那个妹子也来了实验班，不过不是我们班的233）——还有，我自诩为全奥赛模仿ZZH模仿的最像的，我把他回答问题/说话时的「慢<del>~</del><del>~</del>~~条斯理」模仿的淋漓尽致。</p>
<p>嗯，那我呢？似乎因为我写的博客都很详细，所以获得了一堆赞，自己也很开心；至于组织学习方面，我组织大家每个人都去学不同的新算法然后互相教给对方，学了一堆比如网络流、splay、莫队、treap之类的新奇东西，也补了一下dp、搜索之类的基本功。</p>
<p>关于这个活动…评价几点吧：</p>
<ul>
<li>我主张的学splay——当时仿佛大家都觉得splay，名字简短但是总感觉蕴含着复杂有趣的道理，于是决定wx讲二叉搜索木和treap，我讲splay.</li>
<li>…如果说我们这一级到底出了什么问题，那可能就是基础不扎实吧。作为始作俑者，我自裁qaq</li>
</ul>
<p>还有学长啊。一直在骑砍（233）的邱神、不熟的学长hmr，mzq、一开始不熟但慢慢熟得很的zay（虽然现在已经变成了我的同学），还有rqy。</p>
<p>老校的天，总是变得很慢很慢；老校的日子，也总是过的很慢很慢。和lzr、qcr一起打乒乓球，当时的我为什么会觉得，这一球一球、来回翻飞之间，时光会流的这么慢呢？走在吃饭的路上、为了不迟到奔跑在凌晨五点的操场上、在月光下慢悠悠地走在回宿舍的路上，为什么，为什么这时光总是过得这么慢呢？</p>
<p>慢啊，慢到我都忘记了，忘记了这一切，总是会有个尽头的。</p>
<h1 id="2-新校-·-高一-·-总是离别"><a href="#2-新校-·-高一-·-总是离别" class="headerlink" title="$2$ 新校 · 高一 · 总是离别"></a>$2$ 新校 · 高一 · 总是离别</h1><p>终于，獴哥因为忍受不了主任的精英论调，去了友校。</p>
<p>终于，唯一的女生dyz由于文化课的繁重，在马上要联赛的时候退出了奥赛。</p>
<p>终于，联赛之后，zzh走了。我一直在想，他决心要走的时候，内心会有多不舍呢？可能再也没有答案了。</p>
<p>终于，阿淳也不学了，只剩了8个人。</p>
<p>离别，不只是人离别。我离别了自己初中时的快乐，开始变得阴郁，变得更加偏执。但不知道为什么，我就是难以放下奥赛。啊，可能美其名曰是执念吧。但是我可能只是，在那些个时间还会慢慢流淌日子里，已经幻想出自己取得好成绩会去怎样地庆祝——如同驾驶着一匹难以驾驭的马，要我停下，我也很难去放手。</p>
<p>我不得不承认，其实这段时光过的才是最漫长的——有着一眼望不到头的文化课、做着一眼望不到头的不会的习题、接受着一眼望不到头的失败。天分不够，努力更不够。在广袤的天地间，我又算什么呢？</p>
<p>但其实站在现在的角度，我会感恩这段时光，感恩这段碌碌无为的时光。它告诉了我，最差劲、最迷茫、最没有希望的一段日子该怎么走。这期间我翘课去准备省选，但就是在玩；这期间我用「努力」欺骗了自己，实际上根本没有多努力；这期间我用「菜是原罪，有bb、感叹人生的时间，不如多做点题来提升你那本来就微不足道的实力」来说服自己，结果发现这根本就是不是适合我的心态。</p>
<p>总之呢，在老庄(班主任)的关照下，我待在自己的舒适区里，安静地睡着。</p>
<p>直到暑假的到来。</p>
<h1 id="3-暑假-·-外出培训-·-Simon"><a href="#3-暑假-·-外出培训-·-Simon" class="headerlink" title="$3$ 暑假 · 外出培训 · Simon"></a>$3$ 暑假 · 外出培训 · Simon</h1><p>高一升高二的暑假，一开始我只是安静地颓，期间rqy在NOI摘了金，我们都为他感到十分自豪。</p>
<p>之后，大概已经是七月末了，我就去了浙江参加正睿的培训。</p>
<p>培训的过程嘛，那当然是全线自闭。报了一个不适合自己实力的班，再加上我外出培训一定会上课走神犯困，所以听课效果很不好，模拟赛也是全线自闭，只会暴力。对同宿舍的ldl也十分暴躁……总之，回忆不算很美好。</p>
<p>但是为什么我还会对这段仅仅长达半个多月的培训记忆犹新呢？我在当时正在播的《中国好声音》发现了一首歌：Simon.</p>
<blockquote>
<p>从来不曾怀疑过/我见过/最高的山峰/最温暖的手</p>
<p>从前我不假思索/大胆蹉跎/以为我会永垂不朽</p>
<p>才发现/当我终于张开眼/看见他们早就紧紧闭上</p>
<p>Simon, I just don’t know</p>
<p>该往哪里走/盲目还麻木的走</p>
<p>Simon 我还不明白</p>
<p>为什么命运捉弄我/降落在这个错误的星球</p>
<p>自命不凡的赌徒/一掷孤注/明知不能再输/却一直下注</p>
<p>早已什么都没有/我还不断频频回头</p>
<p>等待那些我曾经失去/和那些我即将要失去的</p>
<p>是我太常哭红眼睛/还是他们已经不会悲伤</p>
<p>Simon I just don’t know</p>
<p>该往哪里走/盲目还麻木的走</p>
<p>Dear simon 我还不明白</p>
<p>什么时候我们才能够/逃离这星球/我们能吗</p>
<p>我一直记得/你说你永远相信我</p>
<p>现在我很难过/恐怕我找不回那个自我——</p>
<p>I just don’t know</p>
<p>该往哪里走/我才算真的活过</p>
<p>Simon 我还不明白</p>
<p>还能按照我们原来的期待/去证明我们的未来吗</p>
<p>……</p>
</blockquote>
<p>很丧的歌词，但是并不是像某些口水歌在空谈悲伤，其中包含着沧桑的生命力量；这首歌不是在那种一个人的孤独的悲叹「唉，我太难了」，而是在朝着命运大吼着「老子为什么这么难！这个世界就真的不适合我吗」？振聋发聩的歌词，让我感到我真真切切地活着，每一句都那么的与我相像。</p>
<p>单凭歌词很难想象，这看上去像是失败者的默默絮语，真正去听的时候才会发现，其实是苟活在平凡中、却有着不凡梦的人心底最真实的呐喊。</p>
<p>其实我个人十分反感「好想爱这个世界，为啥这个世界不爱我啊」这种论调，因为本身一整个高一下学期我都这种心态，之后跳脱出来才发现，这个世界根本不欠我什么，也没人欠我什么，这个世界不会因为我爱与不爱它而变化多少，在抱怨多少也没有用。这个世界有时就是残酷而不可理喻的，这一点无可置疑。所以与其纠结「为什么生活这么艹蛋的世界」，不如直接「F**k the crule world」来的实在。</p>
<p>总之呢，这首歌总会让我想到，那些黄昏里金华街头漫步的光景；那些个宾馆里的晚上，昏暗的台灯，耳机里循环着「Simon」时自己的模样；那些麦当劳里的午后，那些小吃店外等待叫号的夜晚…</p>
<p>其实呢，这首歌也并没有教会我怎么面对生活。但这首歌确乎是把我内心中最纠结挣扎的东西喊了出来，有时候，可能让囿于心的情感喷薄而出，也是疗愈的好方法吧。</p>
<h1 id="4-高二上学期-·-分班-·-未卜"><a href="#4-高二上学期-·-分班-·-未卜" class="headerlink" title="$4$ 高二上学期 · 分班 · 未卜"></a>$4$ 高二上学期 · 分班 · 未卜</h1><p>&gt;</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】exBSGS</title>
    <url>/2019/02/22/exBSGS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>众所周知，朴素的 BSGS 并不可以解决 $(a,p) &gt;1$ 的情况。然后 exBSGS 大概就是魔改一下 BSGS。</p>
<a id="more"></a>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>严格来讲，这东西不应该被算到一个模板里面。因为在我看来<strong>模板</strong>是人构造出来的，但是这个算法应该是一个解决问题的process…更像是在解一道数学题，如果 BSGS 是定理的话，exBSGS 更像是一个不断转化的过程233（手动@lxa并且溜</p>
<h1 id="Algorithm-Process"><a href="#Algorithm-Process" class="headerlink" title="Algorithm~Process"></a>Algorithm~Process</h1><p>今天才发现原来$\rm{BSGS}$有两种写法…（PS on 2020.4.16 : 明明有好多好多种写法）</p>
<p>其实本质上，当 $p$ 不为素数时，我们无法进行朴素BSGS 的原因是我们的欧拉定理 $a^{\varphi(p)} \equiv b(\bmod p)$ 只能处理 $(a,p)=1$ 的情况。那么朴素的 $\rm{BSGS}$ 关键在于，可以保证最小解是有界的—— $x$ 一定在 $[1,\varphi(p)]$ 中。所以最后 $\rm BSGS$ 的复杂度才会是 $\Theta(\sqrt{\varphi(p)})$ 的——比如说比较常见的 $p$ 是素数的情况下，时间复杂度为 $\Theta(\sqrt p)$ 。</p>
<p>那么也就是说，我们只需要进行一些操作，保证$(a,p)=1 $即可$^{[1]}$。</p>
<p>对于同余式 $a^x\equiv b \pmod p$ 而言，先假定 $(a,p)&gt;1 $。而此时如果有 $((a,p), b)=1$，那么说明此式只有可能在 $x=0,b=1$ 的时候有解——这个结论是平凡的。因为假设我们把它展开成 $a\cdot a^{x-1} +kp=b $ 的形式，必须要有$(a,p)  |  b$ 的情况下，才能保证 $a^{x-1}$ 和 $k$ 都是整数。</p>
<p>那么对于 $(a,p)&gt;1$ 且 $(a,p)  |  b $，将原式变成</p>
<script type="math/tex; mode=display">
a^{x-1}\cdot \frac{a}{(a,p)} \equiv \frac{b}{(a,p)} \pmod{\frac{p}{(a,p)}}</script><p>的样子，如果此时 $(a^{x-1},\frac{p}{(a,p)})=1$ 的话，就直接解</p>
<script type="math/tex; mode=display">
a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }\pmod{\frac{p}{(a,p)}}</script><p>这个方程即可。否则我们继续分解直至 $(p’,a)=1$。</p>
<p>那么此时有个问题需要注意，就是如果在解这个方程时，出现了</p>
<script type="math/tex; mode=display">
\left(a, \frac{p}{(a,p)}\right)\nmid \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} }</script><p>的情况，那我们需要特判并 <code>return -1</code> ，因为此时 $(a^{x-2},\frac{p}{(a,p)})$ 不存在整数解。</p>
<p>另一种情况，如果我们出现了</p>
<script type="math/tex; mode=display">
a^{x-1}\equiv \frac{\frac{b}{(a,p)}} {\frac{a}{(a,p)} } \equiv1\pmod {\frac{p}{(a,p)}}</script><p>的情况，也需要特判并输出此 $k$（此时同余式左边是 $a^{x-k}$，因为 $a^{x-k}\equiv1 \pmod p$ 所以直接输出 $k$ ），不过也有可能不需要，完全看你写的 BSGS 能不能判断 $x=0$ 的情况…一般情况下不能。</p>
<p>此时<strong>由于 $\boldsymbol{p}$ 不再是素数，所以不能用费马小定理，需要我们用 <code>exgcd</code> 的方法求逆元，包括但不限于 $\frac{b}{(a,p)}$ 的逆元和 $a^{-im}$</strong> 。</p>
<p>以下是完整版代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ll, <span class="keyword">int</span>&gt; H ;</span><br><span class="line"><span class="keyword">int</span> N, M, P, ans ; <span class="comment">// N ^x = M (mod P)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a ;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">expow</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b) res = ((b &amp; <span class="number">1</span>)?res * a % mod : res), a = a * a % mod, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">exgcd</span><span class="params">(ll &amp;x, ll &amp;y, ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123; x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ; &#125;</span><br><span class="line"> 	ll t = exgcd(y, x, b, a % b) ; y -= x * (a / b) ; <span class="keyword">return</span> t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll mod, ll qaq)</span></span>&#123;</span><br><span class="line">    H.clear() ; ll Q, p = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(mod)), x, y ; </span><br><span class="line">    exgcd(x, y, qaq, mod), b = (b * x % mod + mod) % mod, </span><br><span class="line">    Q = expow(a, p, mod), exgcd(x, y, Q, mod), Q = (x % mod + mod) % mod ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * a % mod)  <span class="keyword">if</span> (!H.count(i)) H[i] = j ;</span><br><span class="line">    <span class="keyword">for</span> (ll i = b, j = <span class="number">0</span> ; j &lt;= p ; ++ j, i = i * Q % mod)  <span class="keyword">if</span> (H[i]) <span class="keyword">return</span> j * p + H[i] ; <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">exBSGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll qaq = <span class="number">1</span> ;</span><br><span class="line">    ll k = <span class="number">0</span>, qwq = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">if</span> (M == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">while</span> ((qwq = gcd(N, P)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (M % qwq) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        ++ k, M /= qwq, P /= qwq, qaq = qaq * (N / qwq) % P ;</span><br><span class="line">        <span class="keyword">if</span> (qaq == M) <span class="keyword">return</span> k ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (qwq = BSGS(N, M, P, qaq)) == <span class="number">-1</span> ? <span class="number">-1</span> : qwq + k ;</span><br><span class="line">&#125;                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;P, &amp;M); </span><br><span class="line">      	<span class="keyword">if</span> (!N &amp;&amp; !M &amp;&amp; !P) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        N %= P, M %= P, ans = exBSGS() ; </span><br><span class="line">      	<span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"No Solution"</span>) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 2020.4.16 我又重写了一遍，似乎是比原来快了…但是还是比 yyb 慢得多啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fuck_out puts(<span class="meta-string">"No Solution"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> exBSGS&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; f ;</span><br><span class="line">    <span class="function">il <span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; m) a -= m ;</span><br><span class="line">        <span class="keyword">while</span> (b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                ret = <span class="number">1l</span>l * ret * a % m ;</span><br><span class="line">            a = <span class="number">1l</span>l * a * a % m ; b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">bool</span> <span class="title">chk_ans</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        a %= m ;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= m) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!a &amp;&amp; b) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!y) <span class="keyword">return</span> x ;</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">sqrt</span>(x), ret = x ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= y ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">                ret = <span class="number">1l</span>l * ret * (i - <span class="number">1</span>) / i ;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i  ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">            ret = <span class="number">1l</span>l * ret * (x - <span class="number">1</span>) / x ;</span><br><span class="line">        <span class="keyword">return</span> ret ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">            x = <span class="number">1</span> ;</span><br><span class="line">            y = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">return</span> a ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = exgcd(y, x, b, a % b) ;</span><br><span class="line">        y = y - (ll)x * (a / b) ; <span class="keyword">return</span> ret ;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        exgcd(x, y, b, a % b) ;</span></span><br><span class="line"><span class="comment">        int t = y ; y = x ;</span></span><br><span class="line"><span class="comment">        x = x - (ll)y * a / b ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">   	<span class="function">il <span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">sqrt</span>(m) + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> bl ; <span class="keyword">int</span> t = - p ;</span><br><span class="line">        <span class="keyword">while</span> (t &lt; <span class="number">0</span>) t += (m - <span class="number">1</span>) ;</span><br><span class="line">        bl = expow(a, t, m) ; f.clear() ;</span><br><span class="line">        <span class="keyword">if</span> (chk_ans(a, b, m)) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span> ; i &lt; p ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!f.count(j)) f[j] = i ; j = (ll)j * a % m ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = b ; i &lt;= p ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (f.count(j)) <span class="keyword">return</span> f[j] + i * p ; j = (ll)j * bl % m ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b1, <span class="keyword">int</span> m, <span class="keyword">int</span> b2)</span></span>&#123;</span><br><span class="line">        f.clear() ;</span><br><span class="line">        <span class="keyword">int</span> x, y, p, bl ;</span><br><span class="line">        exgcd(x, y, b2, m) ;</span><br><span class="line">        b1 = ((ll)b1 * x % m + m) % m ;</span><br><span class="line">        <span class="keyword">if</span> (chk_ans(a, b1, m)) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        exgcd(x, y, a, m) ; (x %= m) += m ;</span><br><span class="line">        p = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(phi(m))) ; bl = expow(x, p, m) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span> ; i &lt; p ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!f.count(j)) f[j] = i ; j = (ll)j * a % m ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = b1 ; i &lt;= m / p ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (f.count(j)) <span class="keyword">return</span> f[j] + i * p ; j = (ll)j * bl % m ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">il <span class="keyword">int</span> <span class="title">exbsgs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">        <span class="keyword">int</span> g, ans = <span class="number">0</span>, res, inv = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> ((g = gcd(a, m)) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b % g != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">            b /= g ; m /= g ; ans += <span class="number">1</span> ;</span><br><span class="line">            inv = <span class="number">1l</span>l * inv * (a / g) % m ;</span><br><span class="line">            <span class="keyword">if</span> (inv == m) <span class="keyword">return</span> ans ;</span><br><span class="line">        &#125;</span><br><span class="line">        res = bsgs(a, b, m, inv) ;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span> ; <span class="keyword">return</span> res + ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> exBSGS ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;m) ; </span><br><span class="line">        <span class="keyword">if</span> (!(n + k + m)) <span class="keyword">return</span> <span class="number">0</span> ; ans = exbsgs(n, m, k) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) fuck_out ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Afterword"><a href="#Afterword" class="headerlink" title="Afterword"></a>Afterword</h1><p>今天才知道原来 BSGS 有两种写法qaq</p>
<p>$zyf2000$ 好像和我写的 BSGS 对“大步”和“小步”的定义不是很一样…但其实正着做或者反着做复杂度都是对的。</p>
<p>于是最后还是自己$\rm{yy}$的233</p>
<p>不过整体来看其实不是很难。因为本质上 exBSGS 就是 BSGS 和「同余」那一节里面的一个小定理结合了一下而已。</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1]$ :$zyf2000$的$blog$ <a href="https://blog.csdn.net/clove_unique/article/details/51227328" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>BSGS</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
        <tag>数学/扩展欧几里德</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】拆系数FFT</title>
    <url>/2019/02/19/FFT2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89-darkviolet.svg" alt=""></p>
<p>上一篇多项式：<a href="http://www.orchidany.cf/2019/02/19/FFT1/" target="_blank" rel="noopener">多项式1·普通的FFT</a></p>
<hr>
<h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$\rm{0x01\quad Preface}$"></a>$\rm{0x01\quad Preface}$</h1><p>今天是$Feb.19^{th}$，开学前一天，现在是北京时间下午$10:05$，我还剩除了英语物理的所有作业没做 … 耶，真开心。</p>
<p>由于特殊原因嘛，我暂时不会写的特别详细——毕竟还有作业没有做<del>抄</del>完，所以就先整理地仓促一点。</p>
<p>首先，为什么要拆系数？这是一个问题——直接$FFT$之后判个精度再取模不就得了？很喜闻乐见的是，这个题中的$value_{max}$到达了$1e9\cdot1e9 \cdot 1e5 = 1e23$的级别，不可以直接<code>long long</code>爆艹。</p>
<h1 id="rm-0x02-Normal-Coefficient-Spliting-FFT"><a href="#rm-0x02-Normal-Coefficient-Spliting-FFT" class="headerlink" title="$\rm{0x02~Normal-Coefficient-Spliting~FFT}$"></a>$\rm{0x02~Normal-Coefficient-Spliting~FFT}$</h1><p>首先是最朴素的拆系数法。其原理简单得很，就是选择一个$M$，把$A(x)$和$B(x)$的各项系数表示成</p>
<script type="math/tex; mode=display">
A_i = a_iM+b_i~(0\leq b_i <a_i) \\
B_i = c_iM+d_i~(0\leq d_i <c_i)</script><p>的形式。然后我们做乘法的话，会有</p>
<script type="math/tex; mode=display">
A_i\cdot B_i = a_ic_iM^2+(a_id_i+c_ib_i)M+b_id_i</script><p>那么我们考虑，对于第一部分$a_ic_iM^2$我们可以通过一次$DFT$、一次$IDFT$算出来，；对于第二部分$(a_id_i+c_ib_i)M$ 我们可以通过两次$DFT$分别算出$a_id_i$、$c_ib_i$然后合并，之后一次$IDFT$求出来；对于最后一部分则只需要一次$DFT$、一次$IDFT$求出。所以算法流程一共$7$次$FFT$。</p>
<p>那我们考虑估计一下范围，此处不甚严谨地使用$\Theta$作为同阶的符号$^{[1]}$</p>
<script type="math/tex; mode=display">b_i\cdot d_i \approx \Theta(M^2)</script><script type="math/tex; mode=display">a_i\cdot c_i =\lfloor \frac{P}{M}\rfloor \cdot \lfloor \frac{P}{M}\rfloor = \Theta(\lfloor \frac{P^2}{M^2}\rfloor)</script><script type="math/tex; mode=display">(a_id_i + c_ib_i)\cdot M =\Theta( M \cdot \lfloor \frac{P}{M}\rfloor)</script><p>那么我们取$M = \Theta(\sqrt P)$级别的，可以保证三个值的阶为$\Theta(P)$，大概是$1e9 \cdot 1e5 = 1e14$级别的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 423333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="keyword">int</span> R[MAXN], L, x ; <span class="keyword">long</span> <span class="keyword">long</span> Ans[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">long</span> <span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN], C[MAXN], D[MAXN], F[MAXN], G[MAXN] ;</span><br><span class="line">node H1[MAXN], H2[MAXN], H3[MAXN] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123; <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y); &#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123; <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y); &#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123; <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;</span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ;</span><br><span class="line">                J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; <span class="number">0</span>) <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) J[i].x = J[i].x / N + <span class="number">0.5</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; </span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; </span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; </span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, t ; <span class="built_in">cin</span> &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P, M = <span class="number">32767</span> ; N = <span class="number">1</span>, t = L1 + L2 ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) x = qr(), A[i].x = x / M, B[i].x = x % M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) x = qr(), C[i].x = x / M, D[i].x = x % M ; </span><br><span class="line">    <span class="keyword">while</span>(N &lt;= t) N &lt;&lt;= <span class="number">1</span>, ++ L ; rep(i, <span class="number">0</span>, N) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>), FFT(C, <span class="number">1</span>), FFT(D, <span class="number">1</span>) ;</span><br><span class="line">    rep(i, <span class="number">0</span>, N) H1[i] = A[i] * C[i], H2[i] = B[i] * D[i], H3[i] = A[i] * D[i]+ C[i] * B[i] ; </span><br><span class="line">    FFT(H1, <span class="number">-1</span>), FFT(H2, <span class="number">-1</span>), FFT(H3, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        Ans[i] = ((<span class="keyword">long</span> <span class="keyword">long</span>)H1[i].x * M % P * M % P + (<span class="keyword">long</span> <span class="keyword">long</span>)H2[i].x % P + (<span class="keyword">long</span> <span class="keyword">long</span>)H3[i].x * M % P) % P ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 + L2 ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以最终的复杂度是$\boldsymbol{O(7\cdot P(n) \cdot n \log n)}$，其中$P(n)$是$FFT$自带的、大到不可忽略的常量因子。</p>
<p>但是……好像这个常数有点大诶，算上常数的话已经是$O(n \log^2n)$的级别了，于是——</p>
<h1 id="rm-0x03-Conjugate-Optimization"><a href="#rm-0x03-Conjugate-Optimization" class="headerlink" title="$\rm{0x03~Conjugate~Optimization}$"></a>$\rm{0x03~Conjugate~Optimization}$</h1><p>源自毛啸的《再探快速傅立叶变换》。</p>
<p>我们思考这样两个多项式$\boldsymbol{P, Q} \in \mathbb{C}$</p>
<script type="math/tex; mode=display">
\rm{P(x) = A(x) + iB(x)} \\
\rm{Q(x) = A(x) - iB(x)}</script><p>我们不妨令$P’[k]$和$Q’[k]$为其$\text{DFT}$之后的序列，即$P’[k] =P(\omega_n^k),Q’[k] =Q(\omega_n^k) $。</p>
<p>同时，令$\text{conj(x)}$表示对$x$取共轭。</p>
<p>那么会有$^{[5]}$：</p>
<script type="math/tex; mode=display">
\begin{align}
P'[k] &= A(\omega_{n}^{k}) + i B(\omega_{n}^{k}) \\
& = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} + i B_{j} \omega_{n}^{jk} \\
& = \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\
& =  \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{kj}
\\
Q'[k] &= A(\omega_{n}^{k}) - i B(\omega_{n}^{k}) \\
& = \sum_{j=0}^{n-1} A_{j} \omega_{n}^{jk} - i B_{j} \omega_{n}^{jk} \\
& = \sum_{j=0}^{n-1} (A_{j} - i B_{j}) \left(\cos \left(\frac{2 \pi jk}{n}\right) + i \sin \left(\frac{2 \pi jk}{n}\right)\right) \\
& = \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{2 \pi jk}{n}\right) + B_{j} \sin \left(\frac{2 \pi jk}{n}\right)\right) - i \left(A_{j} \sin \left(\frac{2 \pi jk}{n}\right) - B_{j} \cos \left(\frac{2 \pi jk}{n}\right)\right) \right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} \left(A_{j} \cos \left(\frac{-2 \pi jk}{n}\right) - B_{j} \sin \left(\frac{-2 \pi jk}{n}\right)\right) + i \left(A_{j} \sin \left(\frac{-2 \pi jk}{n}\right) + B_{j} \cos \left(\frac{-2 \pi jk}{n}\right)\right) \right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \left(\cos \left(\frac{-2 \pi jk}{n}\right) + i \sin \left(\frac{-2 \pi jk}{n}\right)\right)\right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{-jk} \right) \\
& = \text{conj} \left( \sum_{j=0}^{n-1} (A_{j} + i B_{j}) \omega_{n}^{(n-k)j} \right) \\
& = \text{conj} \left( P'[n-k] \right)
\end{align}</script><p>好吧我承认这段推导过程的代码甚是壮观，于是并不是我自己写的qwq。</p>
<p>那么我们发现其中$A(x)$和$B(x)$可以通过$P,Q$推出来：</p>
<script type="math/tex; mode=display">
A'[k] = \frac{P'[k] + Q'[k]}{2} \\
B'[k] = \frac{P'[k] - Q'[k]}{2i}</script><p>哦，对了，当$k=0$时，由于不存在这一项，所以我们需要特判一下。并且由于我们的$P(x)$和$Q(x)$的实部和虚部都可以利用，所以我们对于七次$DFT$可以优化到$4$次$DFT$.</p>
<p>以下是共轭优化$FFT$的初号机：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 423333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> R[MAXN], Len, x, Ans[MAXN] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> r, i ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">node</span> <span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">double</span> yy = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        r = xx, i = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node <span class="title">Conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node(r, -i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN], w[MAXN], t1[MAXN], t2[MAXN] ;</span><br><span class="line">node H1[MAXN], H2[MAXN], H3[MAXN] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123; <span class="keyword">return</span> node(J.r + Q.r , J.i + Q.i); &#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123; <span class="keyword">return</span> node(J.r - Q.r , J.i - Q.i); &#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123; <span class="keyword">return</span> node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; </span><br><span class="line">    rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; ++ l)&#123;</span><br><span class="line">                node T = w[N / j * l] ; T.i *= flag ;</span><br><span class="line">                node Nx = J[k + l], Ny = T * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> L)</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; <span class="keyword">while</span> (N &lt;= L) N &lt;&lt;= <span class="number">1</span>, ++ Len ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) A[i] = node(f[i] &amp; <span class="number">32767</span>, f[i] &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) B[i] = node(g[i] &amp; <span class="number">32767</span>, g[i] &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) w[i] = node(<span class="built_in">cos</span>(Pi * i / N), <span class="built_in">sin</span>(Pi * i / N)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (Len - <span class="number">1</span>)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MTT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node ia, ib, a1, a2, b1, b2 ;</span><br><span class="line">    rr <span class="keyword">int</span> i, k, t = L1 + L2, q1, q2, q3 ; Init(t) ;</span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        k = (N - i) &amp; (N - <span class="number">1</span>), ia = A[k].Conj(), ib = B[k].Conj() ;<span class="comment">//(ia,ib) = Q</span></span><br><span class="line">        a1 = (ia + A[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), a2 = (A[i] - ia) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        b1 = (ib + B[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), b2 = (B[i] - ib) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(<span class="number">0</span>, <span class="number">1</span>), t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  FFT(t1, <span class="number">-1</span>), FFT(t2, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; w[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; A[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">// for (i = 0 ; i &lt;= N ; ++ i) cout &lt;&lt; B[i].r &lt;&lt; " "; cout &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        q1 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].r / N + <span class="number">0.5</span>) % P, q2 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t1[i].i / N + <span class="number">0.5</span>) % P ;</span><br><span class="line">        q3 = (<span class="keyword">long</span> <span class="keyword">long</span>)(t2[i].r / N + <span class="number">0.5</span>) % P, Ans[i] = ((((<span class="keyword">long</span> <span class="keyword">long</span>)q3 &lt;&lt; <span class="number">30</span>) % P + ((<span class="keyword">long</span> <span class="keyword">long</span>)q2 &lt;&lt; <span class="number">15</span>) % P + q1) % P + P) % P ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i ; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L1 &gt;&gt; L2 &gt;&gt; P ; N = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) f[i] = qr() % P ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) g[i] = qr() % P ; MTT() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 + L2 ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x04-quad-拼命卡常"><a href="#rm-0x04-quad-拼命卡常" class="headerlink" title="$\rm{0x04\quad}$拼命卡常"></a>$\rm{0x04\quad}$拼命卡常</h1><p>好的，首先我们可以欣赏一下最初的版本（用小号交的拆系数$FFT$ + $O2$）</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<p>然后是大号的共轭优化$FFT$（不加$O2$，即上方代码）：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png" alt=""></p>
<p>特别的，以下是无共轭优化的拆系数$FFT$，不开$O2$:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="3.png" alt=""></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="4.png" alt=""></p>
<p>好吧，他看起来没有快多少。毕竟都是同阶的复杂度，好像后者的常数更大那么一点……</p>
<p>于是考虑对共轭优化的进行大力卡常：</p>
<ul>
<li>多次使用的非全局变量。使用<code>register</code>修饰符。</li>
<li>将$double$转换成为$long~double$ 。</li>
<li>减少取模次数。</li>
<li>从yjk那里偷来的$\rm{fread/fwrite}$</li>
</ul>
<p>一番操作之后，我们成功地卡到了第五页上……</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="5.png" alt=""></p>
<p>最后奉上最快的代码qwq：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 102333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 272333</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> IO&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ch_top=<span class="number">4e7</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">char</span> ch[ch_top],*now_r=ch<span class="number">-1</span>,*now_w=ch<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(*++now_r&lt;<span class="string">'0'</span>);</span><br><span class="line">    	<span class="keyword">register</span> <span class="keyword">int</span> x=*now_r-<span class="string">'0'</span>;</span><br><span class="line">    	<span class="keyword">while</span>(*++now_r&gt;=<span class="string">'0'</span>)x=x*<span class="number">10</span>+*now_r-<span class="string">'0'</span>;</span><br><span class="line">    	<span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   		<span class="keyword">static</span> <span class="keyword">char</span> st[<span class="number">20</span>];<span class="keyword">static</span> <span class="keyword">int</span> top;</span><br><span class="line">    	<span class="keyword">while</span>(st[++top]=<span class="string">'0'</span>+x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">    	<span class="keyword">while</span>(*++now_w=st[top],--top);</span><br><span class="line">    	*++now_w=<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R[MAXM], Len, x, Ans[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r, i ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> node <span class="title">Conj</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node(r, -i); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">node</span> <span class="params">(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        r = xx, i = yy ;</span><br><span class="line">    &#125;<span class="comment">//定义的Complex型是用来进行复数运算的 </span></span><br><span class="line">&#125;A[MAXM], B[MAXM], w[MAXM], t1[MAXM], t2[MAXM] ; <span class="keyword">int</span> L1, L2, P, N, M ;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> + (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r + Q.r , J.i + Q.i); &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> - (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r - Q.r , J.i - Q.i); &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> <span class="keyword">double</span> &amp;Q) &#123; <span class="keyword">return</span> (node) &#123;J.r * Q, J.i * Q&#125; ; &#125;</span><br><span class="line"><span class="keyword">inline</span> node <span class="keyword">operator</span> * (<span class="keyword">const</span> node &amp;J, <span class="keyword">const</span> node &amp;Q) &#123; <span class="keyword">return</span> node(J.r * Q.r - J.i * Q.i , J.r * Q.i + J.i * Q.r) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J)</span></span>&#123;</span><br><span class="line">    rr node t ;</span><br><span class="line">    rr <span class="keyword">int</span> i, j, k, l ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) t = J[i], J[i] = J[R[i]], J[R[i]] = t ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; N; k += (j &lt;&lt; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; ++ l)&#123;</span><br><span class="line">                rr node T = w[N / j * l] ;</span><br><span class="line">            	rr node Nx = J[k + l], Ny = T * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny, J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFFT</span><span class="params">(node *J)</span></span>&#123;</span><br><span class="line">    reverse(J + <span class="number">1</span>, J + N), FFT(J) ; </span><br><span class="line">    rr <span class="keyword">int</span> i ; rr <span class="keyword">double</span> qwq = <span class="number">1.0</span> / N ; </span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) J[i] = J[i] * qwq ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fread(ch,<span class="number">1</span>,ch_top,<span class="built_in">stdin</span>); </span><br><span class="line">    rr <span class="keyword">int</span> i, k, t ; rr node ia, ib, a1, a2, b1, b2 ; </span><br><span class="line">    t = ((L1 = read()) + (L2 = read())), P = read(), N = <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">while</span> (N &lt;= t) N &lt;&lt;= <span class="number">1</span>, ++ Len ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L1 ; ++ i) x = read(), A[i] = node(x &amp; <span class="number">32767</span>, x &gt;&gt; <span class="number">15</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= L2 ; ++ i) x = read(), B[i] = node(x &amp; <span class="number">32767</span>, x &gt;&gt; <span class="number">15</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) w[i] = node(<span class="built_in">cos</span>(Pi * i / N), <span class="built_in">sin</span>(Pi * i / N)), R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (Len - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A), FFT(B) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        k = (N - i) &amp; (N - <span class="number">1</span>), ia = A[k].Conj(), ib = B[k].Conj() ;<span class="comment">//(ia,ib) = Q</span></span><br><span class="line">        a1 = (ia + A[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), a2 = (A[i] - ia) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        b1 = (ib + B[i]) * node(<span class="number">0.5</span>, <span class="number">0</span>), b2 = (B[i] - ib) * node(<span class="number">0</span>, <span class="number">-0.5</span>) ;</span><br><span class="line">        t1[i] = a1 * b1 + (a1 * b2 + b1 * a2) * node(<span class="number">0</span>, <span class="number">1</span>), t2[i] = a2 * b2 ;</span><br><span class="line">    &#125;  </span><br><span class="line">    IFFT(t1), IFFT(t2) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= t ; ++ i)</span><br><span class="line">        write(((ll)(t1[i].r + <span class="number">0.5</span>) + ((ll)(t1[i].i + <span class="number">0.5</span>) % P &lt;&lt; <span class="number">15</span>) + ((ll)(t2[i].r + <span class="number">0.5</span>) % P &lt;&lt; <span class="number">30</span>)) % P) ;</span><br><span class="line">    fwrite(ch,<span class="number">1</span>,now_w-ch,<span class="built_in">stdout</span>); <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实践证明，以上代码不加任何优化（不开$\rm{O2/3/fast}$）甚至可以快$4ms$！<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="6.png" alt=""></p>
<h1 id="rm-0x00-quad-Afterword"><a href="#rm-0x00-quad-Afterword" class="headerlink" title="$\rm{0x00\quad Afterword}$"></a>$\rm{0x00\quad Afterword}$</h1><p>嗯，其实按道理来讲，不是特别难。但是这跟$HLPP$一样，都是打死都不会考的算法，所以学这些只是为了娱乐……听起来挺苍凉？</p>
<p>但似乎，从一开始就不应该把应付考点作为OI的初衷吧，虽然如果没有获利，没有多少人会去学，但是不沾染功利的OI，似乎可爱了那么几分呢……</p>
<p>并且在学的过程中顺便认识了一个巨佬<code>CMXRYNP</code>，嘿嘿，也算不亏啦。</p>
<p>本篇文章真实完稿时间是$2019/3/17$，因为太懒+太忙，鸽了一个月$\rm{qaq}$.</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1]$ :$lvzelong2014$的$blog$ <a href="https://blog.csdn.net/lvzelong2014/article/details/80156989" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[2]$:<code>无梦之梦</code>的$blog$ <a href="https://www.cnblogs.com/DreamlessDreams/p/10241267.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[3]$:$Cyhlnj$的$blog$ <a href="https://www.cnblogs.com/cjoieryl/p/10114614.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[4]$:$litble$的$blog$ <a href="https://blog.csdn.net/litble/article/details/84864516" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[5]$:$CMXRYNP$的$blog$ <a href="https://cmxrynp.github.io/2019/01/07/fft-optimization/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
<li>$[6]$ :2016国家集训队论文《再探快速傅里叶变换》毛啸· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】从单位根到FFT</title>
    <url>/2019/02/19/FFT1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p>
<h1 id="rm-0x01-quad-Preface"><a href="#rm-0x01-quad-Preface" class="headerlink" title="$ \rm{0x01\quad Preface} $"></a>$ \rm{0x01\quad Preface} $</h1><p>这篇文章初写于 $ 7/1/2018 $ ，是在陪同好友 $ yjk $ 与 $ wx $ 以及学长 $ rqy $ 一起去参加省队集训时写的。今天突然来了兴致，打算重新复习一遍 $ FFT $ 并且写 $ MTT $ ，于是便有了这篇文章。</p>
<p>其实一开始我是不情愿把这篇文章搬到这儿来的——这好像是一个时代的缩影，那个时代的<code>orchidany</code>特别喜欢扮演老师，每天仿佛来到奥赛室只是为了“为人师”的：心性浮躁，学习功利。但现在我则是想沉下心来，认真做学问。</p>
<p>但无论如何，我希望这篇原本冗杂繁长的文章可以更短、更新颖、从更高的角度审视一些问题。</p>
<h1 id="rm-0x02-quad-Convolution"><a href="#rm-0x02-quad-Convolution" class="headerlink" title="$ \rm{0x02\quad Convolution} $"></a>$ \rm{0x02\quad Convolution} $</h1><p><strong>卷积 $ \boldsymbol{(Convolution)} $ </strong>，准确来说是一种<strong>通过两个函数 $ \boldsymbol f $  和 $ \boldsymbol g $  生成第三个函数的一种数学算子.</strong></p>
<p>而广义上其定义为： <script type="math/tex">\boldsymbol{h(x) = \int _{- \infty} ^{\infty}g(\tau) \cdot f(x - \tau)} \rm{d\tau}</script> </p>
<p>我们称 $ h(x) $ 是 $ g(x) $ 与 $ f(x) $ 的<strong>卷积</strong>。</p>
<p>而此处我们讨论的是整次多项式域，那么就把其定义划归进多项式，得到</p>
<script type="math/tex; mode=display">A(x) \cdot B(x) =\sum\limits_{i = 0}^{n} \sum\limits_{j=0}^{i}{a_jb_{i-j}}</script><p>其中 $ A(x) $ 和 $ B(x) $ 均为 $ N-1 $ 次多项式<br>比较显然的是，在我们合并同类项的情况下，最终卷出来的结果应该有 $ 2n+1 $ 项。</p>
<h1 id="rm-0x03-quad-Dot-Method"><a href="#rm-0x03-quad-Dot-Method" class="headerlink" title="$ \rm{0x03\quad Dot~Method} $"></a>$ \rm{0x03\quad Dot~Method} $</h1><p>我们知道，原本的多项式是系数表示法，现在我们将其转化为<strong>点值表示法 $ (\boldsymbol{dot~method} ) $ </strong>。即我们可以把多项式 $ F(x) $ 转化为多项式函数 $ f(x) $ ，那么这个 $ n $ 阶函数就可以由 $ n+1 $ 个点唯一确定。即 <script type="math/tex">f(x)\Longleftrightarrow{(x_0,y_0),(x_1,y_1),(x_2,y_2)....(x_n,y_n)}</script> 那么 <script type="math/tex">\forall k,y_k = f(x_k)</script> 这是很显然的，并且这 $ n+ $ 个点是随意选取的——只要求它们相异即可。</p>
<ul>
<li><h2 id="rm-Advanced-Trick-Point-color-red-1-rm-Multiplication"><a href="#rm-Advanced-Trick-Point-color-red-1-rm-Multiplication" class="headerlink" title="$ \rm{Advanced~Trick~Point} $   $ \color{red}{1} $   $ \rm{Multiplication} $"></a>$ \rm{Advanced~Trick~Point} $   $ \color{red}{1} $   $ \rm{Multiplication} $</h2></li>
</ul>
<p>假设我们有两个关于 $ x $ 的 $ n+1 $ 次多项式 $ A(x) $ 和 $ B(x) $ ，我们要对它的点值表达式进行乘法操作。由于结果有 $ 2n+1 $ 项，我们考虑补上一堆项，并对 <script type="math/tex">A(x) = {(x_0,y_0),(x_1,y_1)....(x_{2n},y_{2n})}</script>   <script type="math/tex">B(x) = {(x_0,y_0'),(x_1,y_1')....(x_{2n},y_{2n})}</script>  做乘法可得  <script type="math/tex">A(x)B(x) = {(x_0,y_0y_0'),(x_1,y_1y_1')(x_{2n},y_{2n}y_{2n}')}</script>   </p>
<p>我们观察点乘法，它的时间复杂度达到了 $ \Theta(n) $ ，完全可以接受。那么不妨先看一下算法的大体思路：</p>
<blockquote>
<p>对于每个因子多项式，选取 $ n+1 $ 个点，得出点值表达式（复杂度 $ \Theta(n^2) $ ）  $ \longrightarrow $ 点乘法(时间复杂度 $ \Theta(n) $ )——&gt;将得出来的 $ C(x) $ 的点值表达式再转换成系数表达式(复杂度 $ \Theta(n^2) $ )</p>
</blockquote>
<p>这就是 $ FFT $ 的大体流程。<del>转化之后怎么没多快常数还大了</del></p>
<p>虽然其余部分的时间复杂度还是很麻烦的 $ O(n^2) $ ，但是都是可以优化成 $ O(nlogn) $ 的。</p>
<hr>
<p>本质上的 $ FFT $ 包含<strong> $ \boldsymbol{DFT} $ （离散傅立叶变换）</strong>和<strong> $ \boldsymbol{IDFT} $ （逆离散傅立叶变换）</strong>实际上，<strong> $ DFT $ </strong>对应着的就是<strong>把系数表达式映射到点值表达式</strong>的过程，<strong> $ IDFT $ </strong>对应着的就是我们<strong>把点值表达式映射到系数表达式</strong>的过程。</p>
<h1 id="rm-0x04-Base-of-Optimization"><a href="#rm-0x04-Base-of-Optimization" class="headerlink" title="$ \rm{0x04~Base ~of~Optimization} $"></a>$ \rm{0x04~Base ~of~Optimization} $</h1><p>因为实际上，我们的第一步——求值（系数转点值）和我们的第三步（点值转系数）都是可以做到 $ nlogn $ 的，那么总的时间复杂度，渐进意义下就是 $ O(nlogn) $ 的。</p>
<p>下面就让我们来看看如何优化：</p>
<ul>
<li><h2 id="rm-Advanced-Trick-Point-color-red-2-rm-Unit-Complex-Root"><a href="#rm-Advanced-Trick-Point-color-red-2-rm-Unit-Complex-Root" class="headerlink" title="$ \rm{Advanced~Trick~Point} $   $ \color{red}{2} $   $ \rm{Unit ~Complex ~Root} $"></a>$ \rm{Advanced~Trick~Point} $   $ \color{red}{2} $   $ \rm{Unit ~Complex ~Root} $</h2><p>$ n $ 次单位复根是满足 $ \omega^n = 1 $  的复数 $ \omega $ ，其中我们可以由复数的运算法则（辐角相加，模相乘）很简单地得出<strong> $ n $ 次单位根有 $ n $ 个</strong>这个结论——亦或者是用代数基本定理证，都可以。而又因为复数 $ \omega^n $ 在复数平面上的模都是一，所以相乘之后还会是一，那么所有的 $ \omega_i,1 \leq i \leq n $ 就会均匀分布在单位圆上，类似当 $ n = 8 $ 时它是这样的：</p>
</li>
</ul>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="1.png" alt=""></p>
<p>我们考虑欧拉公式：</p>
<script type="math/tex; mode=display">e^{ix} = cosx + isinx</script><p>我们取 $ x =2\pi $ ，可以得到如下关系式： <script type="math/tex">e^{2 \pi i} = 1 = \omega^n \Longleftrightarrow \omega = e^{\frac{2\pi i}{n}}</script> </p>
<p>们把此时的单位根称之为<strong>主次单位根</strong>，记作 <script type="math/tex">\omega_n = e^{\frac{2\pi i}{n}}</script> </p>
<p>那么对于其他的单位根，记作 <script type="math/tex">\omega_n^k=e^{\frac{2\pi ik}{n}},0 \leq k < n</script> 都是主次单位根的整次幂，也就是上图中的一圈。</p>
<hr>
<p>诶，这个有啥用啊 $ QAQ $ ?</p>
<p>那是因为单位根们有一堆特别好用的性质，让我们可以将数据规模不断折半，使得其达到 $ nlogn $ 的复杂度……</p>
<p>那么我们先来看其支持其规模减半的引理：</p>
<ul>
<li><h3 id="frak-Elimination-Lemma-quad-消去引理"><a href="#frak-Elimination-Lemma-quad-消去引理" class="headerlink" title="$ \frak{Elimination ~Lemma\quad} $ 消去引理"></a>$ \frak{Elimination ~Lemma\quad} $ 消去引理</h3></li>
</ul>
<hr>
<blockquote>
<p><strong>引理：对任何整数 $ n \geq 0,k \geq 0,d &gt;0 $ ,有 <script type="math/tex">\omega_{dn}^{dk} = \omega_n^k</script> </strong></p>
</blockquote>
<p> $ \mathcal{Proof.} $ </p>
<p>这个好像很好证的样子……代入定义可以获得 <script type="math/tex">\omega_{dn}^{dk} = \omega^{\frac{2\pi dk}{dn}} = e^{\frac{2\pi ik}{n}} = \omega_n^k</script><br> $ \mathcal{Q.E.D.} $ </p>
<hr>
<ul>
<li><h3 id="frak-Binary-Lemma-quad-折半引理"><a href="#frak-Binary-Lemma-quad-折半引理" class="headerlink" title="$ \frak{Binary~Lemma\quad} $  折半引理"></a>$ \frak{Binary~Lemma\quad} $  折半引理</h3></li>
</ul>
<hr>
<blockquote>
<p><strong>引理：对于任何大于 $ 0 $ 的偶数 $ n $ ，都有 $ n $ 个 $ n $ 次单位复根的平方的集合，等于 $ \frac{n}{2} $ 个 $ \frac{n}{2} $ 次单位复根的集合。</strong></p>
</blockquote>
<p> $ \mathcal{Proof.} $ </p>
<p>我们可以由消去引理得到 <script type="math/tex">(\omega _n^k)^2 = \omega^{2k}_n=\omega_{n/2}^k</script> 那么</p>
<script type="math/tex; mode=display">(\omega_n^{k + \frac{n}{2}})^2 = \omega_n^{2k + n} \Longrightarrow \omega_n^{2k} \cdot \omega_n^n \Longrightarrow \omega_n^{2k} = (\omega_n^k)^2</script><p> $ \mathcal{Q.E.D.} $ </p>
<hr>
<p>那么接下来，如果对所有的 $ n $ 次单位跟平方一下，我们会发现 $ \frac{n}{2} $ 次单位根每个都恰好出现了两次——也就是说，在 $ n $ 个 $ n $ 此单位复数根的集合（朴素的集合，即不可重集）里，只有 $ \frac{n}{2} $ 个元素。我们参考上面那张图，它的意义就在于方向相对的两只向量，其平方相等。</p>
<p>那么把所有 $ n $ 单位根的平方画到一个数列上就是这样。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="2.png" alt=""></p>
<p>这个引理直接保证了我们求值的复杂度为 $ \Theta(n \log n) $ </p>
<p>而我们在代码实现中，<strong>不能直接得到 $ e $ 或者虚数 $ i $ </strong>，所以这个时候求单位根的任务就交给了我们上文中提到过的<strong>欧拉公式</strong>。</p>
<ul>
<li><h3 id="frak-Sum-Lemma-quad-求和引理"><a href="#frak-Sum-Lemma-quad-求和引理" class="headerlink" title="$ \frak{Sum~Lemma\quad} $ 求和引理"></a>$ \frak{Sum~Lemma\quad} $ 求和引理</h3></li>
</ul>
<hr>
<blockquote>
<p><strong>引理：对于任意 $ n&gt;0 $ 且 $ k $ 不能整除 $ n $ ，我们都有 <script type="math/tex">\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = 0</script> </strong></p>
</blockquote>
<p> $ Proof. $ </p>
<p>由几何级数的求和公式（等比数列求和公式) <script type="math/tex">\sum\limits_{j = 0}^{n}{x^j} = \frac{x^{j +1} -1}{x -1}</script> 可得 <script type="math/tex">\sum\limits_{j =0}^{n-1}{(\omega_n^k)^j} = \frac{(\omega_n^k)^n -1}{\omega_n^k -1} \Longrightarrow  \frac{(\omega_n^n)^k -1}{\omega_n^k -1} =  \frac{(1)^k -1}{\omega_n^k -1}</script> 由于保证了 $ k $ 不可整除 $ n $ 所以分母一定不为 $ 0. $ </p>
<p> $ \mathcal{Q.E.D} $ </p>
<hr>
<h1 id="rm-0x05-quad-DFT-to-FFT"><a href="#rm-0x05-quad-DFT-to-FFT" class="headerlink" title="$ \rm{0x05\quad DFT \to FFT} $"></a>$ \rm{0x05\quad DFT \to FFT} $</h1><p>那么我们在了解完单位复数根之后，便可以正式地对 $ DFT $ 给出定义与操作方案了。</p>
<ul>
<li><h2 id="DFT"><a href="#DFT" class="headerlink" title="$ DFT $"></a>$ DFT $</h2></li>
</ul>
<p>对于我们已知的一个多项式 <script type="math/tex">A(x) = \sum\limits_{i =0}^{n - 1}{a_ix^i}</script> 在 $ \omega_n^0,\omega_n^1,\omega_n^2 \cdots \omega_n^{n-1} $ 处的取值，我们可以假定 $ n $ 是 $ 2 $ 的幂，因为即使它本身不是 $ 2 $ 的幂，我们也可以通过向高次幂补值为 $ 0 $ 的项来解决这个问题。而补足 $ 2 $ 的幂的目的，就是为了在 $ FFT $ 分治的过程中，使之可以一直分治下去且每次分治得出的两半可以进行运算。</p>
<p>那我们现在会有一个 $ A $ 的向量组 $ \vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}} $ ，对于 $ k = 0, 1, 2, \cdots n -1 $ ，定义 $ y_k $ 如下： <script type="math/tex">y_k = A(\omega_n^k)=\sum\limits_{j =0}^{n -1}{a_j \cdot \omega_n^{kj}}</script> ，那么向量 <script type="math/tex">\vec{y} = {y_0, y_1, y_2 \cdots y_{n-1}}</script> 就称作系数向量 $ \vec{a} = {a_1, a_2, a_3 \cdots a_{n-1}} $ 的<strong>离散型傅立叶变换（ $ \boldsymbol{Discrete   Fourier   Transformation} $ ）</strong>。</p>
<p>嗯，这个<strong>离散型</strong>我们可以由点乘法联想意会一下：本来 $ A(x) $ 是一个优美的多项式，转变成函数之后是一条优美的曲线（优美只是定语……不是重要内容 $ qwq $ ），结果你突然把它拆成了一堆离散的点，把它用点值法表示，故称之曰：“离散型” 。</p>
<ul>
<li><h2 id="FFT-优化-DFT"><a href="#FFT-优化-DFT" class="headerlink" title="$ FFT $ 优化 $ DFT $"></a>$ FFT $ 优化 $ DFT $</h2></li>
</ul>
<p>在上文中我们分析过，将系数表达式转化为点值表达式需要的时间复杂度为 $ O(n^2) $ ，这是朴素算法。而我们只需要用一种被称作<strong>快速傅立叶变换（ $ \boldsymbol{Fast   Fourier   Transformation} $ ）</strong>的方式，就可以将其时间复杂度压缩成 $ O(nlogn) $ 。而在这里我们就用到了刚才证明的引理——<strong>折半引理</strong>。</p>
<p>我们考虑将原来的多项式 <script type="math/tex">A(x) = a_0+a_1x+ a_2x^2 \cdots +a_{n-1}x^{n-1}</script> 重定义成两个次数为 $ \frac{n}{2} $ 的小多项式 $ A^{[0]}(x) $ 和 $ A^{[1]}(x) $ ： </p>
<script type="math/tex; mode=display">A^{[0]}(x) = a_0 + a_2x+a_4x^2 \cdots +a_{n-2}x^{\frac{n}{2} - 1} $$   $$  A^{[1]}(x) = a_1 + a_3x+a_5x^2 \cdots +a_{n-1}x^{\frac{n}{2} - 1} $$     那么也就是说， $ A^{[0]}(x) $ 存储的是所有偶数位（二进制位最后一位是 $ 0 $ ），而 $ A^{[1]}(x) $ 存储的是所有的奇数位（二进制位最后一位是 $ 1 $ ），那么有下式： $$ A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2) $$ 那我们求 $ A(x) $ 在单位根们 $ \omega_n^0,\omega_n^1,\omega_n^2 \cdots ,\omega_n^{n-1} $ 处的值，就变成了先求出 $ A^{[0]}(x^2) $ 和 $ A^{[1]}(x^2) $ 的值，然后根据上式进行合并即可。

而显然的是，根据折半引理，我们根本不需要 $ O(n) $ 求，而是通过数据规模不断减小使之成为 $ O(\log n) $ 。于是，我们成功通过 $ FFT $ 优化了求值的复杂度。

那么同时对于另一边，我们可以根据

 $$ A(\omega_n^{k+\frac{n}{2}}) = A^{[0]}(\omega_n^{2k+n})+\omega_n^{k+\frac{n}{2}}A^{[1]}(\omega_n^{2k+n}) \Longrightarrow A^{[0]}(\omega_n^{2k}\cdot \omega_n^{n})-\omega_n^{k}A^{[1]}(\omega_n^{2k}\cdot \omega_n^{n})</script><p>得到</p>
<script type="math/tex; mode=display">A(\omega_n^{k+\frac{n}{2}})=A^{[0]}(\omega_n^{2k})-\omega_n^{k}A^{[1]}(\omega_n^{2k})</script><p>从而有伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> Lim = <span class="number">1</span>, N, M ;</span><br><span class="line"><span class="function">function <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> lenth, <span class="keyword">complex</span> *A, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    IF (Lim == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">complex</span> A0[lenth &gt;&gt; <span class="number">1</span>], A1[lenth &gt;&gt; <span class="number">1</span>] ;<span class="comment">//分成两部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j : <span class="number">0</span> to lenth by_grow <span class="number">2</span>) A0[j &gt;&gt; <span class="number">1</span>] = A[j], A1[j &gt;&gt; <span class="number">1</span>] = A[j + <span class="number">1</span>] ;</span><br><span class="line">    FFT(lenth &gt;&gt; <span class="number">1</span>, A0, flag) ;</span><br><span class="line">    FFT(lenth &gt;&gt; <span class="number">1</span>, A1, flag) ;</span><br><span class="line">    <span class="keyword">complex</span> Wn = unit(,) , w = (<span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//Wn是单位根，w用来枚举幂，即我们令主次单位根不变，由于其余单位根都是其整次幂，所以可以用一个w来记录到第几次幂</span></span><br><span class="line">        <span class="comment">/*此处求单位根的时候会用到我们的参数flag……嗯没错就用这一次，并且flag的值域为(-1, 1)……是的，只会有两个值*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j : <span class="number">0</span> to (lenth &gt;&gt; <span class="number">1</span>) by_grow <span class="number">1</span> with w = w * Wn)&#123;</span><br><span class="line">        A[i] = A0[i] + A1[i] * w ;<span class="comment">//应用公式，下同 </span></span><br><span class="line">        A[i + (lenth &gt;&gt; <span class="number">1</span>)] = A0[i] - A1[i] * w ; <span class="comment">//顺便求出另一半，由折半引理可显然。 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">function Main&#123;</span><br><span class="line">    input(N), input(M) ;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">0</span> to N by_grow <span class="number">1</span>) =&gt; input(A) ;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">0</span> to M by_grow <span class="number">1</span>) =&gt; input(B) ; </span><br><span class="line">    <span class="keyword">while</span>(Lim &lt; N + M) Lim &lt;&lt;= <span class="number">1</span> ;<span class="comment">//Lim为结果多项式的长度（暂时），化为2的幂的便于分治（二分）</span></span><br><span class="line">    FFT(Lim, A, <span class="number">1</span>) ;<span class="comment">//两遍FFT表示从系数化为点值 </span></span><br><span class="line">    FFT(Lim, B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i : <span class="number">0</span> to Lim by_grow <span class="number">2</span>) =&gt; A[i] *= B[i] ;<span class="comment">//点乘法，此处需要重定义乘号，因为每一项现在表示的是一个点，有x和y两个属性qwq </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是基于 $ pks $ 标准下的伪代码<del>你可以试试在c++标准下运行</del>，其中 $ for $ 循环部分， $ grow $ 表示当前循环变量的<strong>单次增量</strong>，之后带有 $ with $ 表示每次循环结束都会进行的运算（下同</p>
<p>嗯，这就是求值的方法，好像很 $ nice $ 地达到了 $ O(n \log n) $ </p>
<ul>
<li><h2 id="FFT-优化-IDFT"><a href="#FFT-优化-IDFT" class="headerlink" title="$ FFT $ 优化 $ IDFT $"></a>$ FFT $ 优化 $ IDFT $</h2></li>
</ul>
<p>上文中我们曾经提及过的<strong>范德蒙德矩阵</strong>可以放到这儿用：</p>
<p> $ \begin{vmatrix}  1         &amp;  1  &amp; 1   &amp; \cdots &amp; 1      \newline 1         &amp;  \omega_n  &amp; \omega_n^2   &amp; \cdots &amp; w_n^{n-1}      \\newline1         &amp;  \omega_n^2  &amp; \omega_n^4   &amp; \cdots &amp; \omega_n^{2(n-1)}      \newline \vdots  &amp; \vdots &amp; \vdots  &amp;  \ddots &amp; \vdots \newline 1    &amp;  \omega_n^{n-1}  &amp; \omega_n^{2(n-1)}   &amp; \cdots &amp; \omega_n^{(n-1)(n-1)}        \newline  \end{vmatrix} $    $ \begin{vmatrix}  a_0  \newline a_1 \newline a_2 \newline \vdots \newline a_{n-1} \end{vmatrix} $  =  $ \begin{vmatrix}  y_0  \newline y_1 \newline y_2 \newline \vdots \newline y_{n-1} \end{vmatrix} $ </p>
<p>那为了求出我们的 $ \vec{a} = {a_0, a_1 \cdots ,a_{n-1}} $ 我们应该让刚刚求值算出的 $ \vec{y} $ 乘上我们 $ \vec{V}^{~-1} $ （ $ \vec{V} $ 的逆矩阵）即可。但是桥豆麻袋~~~不需要用什么高消啊…余子式啊…我们只需要以下：</p>
<hr>
<blockquote>
<p><strong>推论</strong>：对于 $ j,k = 0,1, 2 \cdots n-1,V_n^{-1} $ 的 $ (j, k) $ 处的值为 $ \omega_n^{-kj}/n $ </p>
</blockquote>
<p> $ Proof. $ </p>
<p>我们考虑反向证明，已知 $ V_n’ $ 是一个 $ (j,k) $ 处值为 $ \omega_n^{-kj}/n $ 的、与 $ V $ 形态相同的矩阵，那我们只需要证明 $ V’ \cdot V = I_n $ 即可，其中 $ I_n $ 是 $ n $ 阶单位矩阵，即主对角线都是 $ 1 $ ，其余位置上是 $ 0 $ 的矩阵。</p>
<p>那么我们考察 $ V’ V $ 中的元素 $ (i, j) $ ，有如下的式子 <script type="math/tex">V'V = \sum\limits^ {n-1}_{k=0}{(\omega_n^{-ki}/n)} \cdot {\omega_n^{kj}} = \frac{1}{n} \sum\limits^ {n-1}_{k=0}{\omega_n^{k(j-i)}}</script> </p>
<p>由<strong>求和引理</strong>当且仅当 $ i=j $ 时其值为一，其余的时刻均为零，所以有 $ V’V = I_n $ </p>
<p> $ \mathcal{Q.E.D} $ </p>
<hr>
<p>那么我们把我们刚刚求出来的逆矩阵 $ V^{-1} $ 美化一下，提出每一项所除的 $ n $ ，可以得到 $ IDFT $ 可以如此计算： <script type="math/tex">IDFT_n(y) = \frac{1}{n}\sum\limits_{k = 0}^{n-1}{y_k\omega_n^{-kj}},j\in [0,n-1]</script> 诶，这个好像……跟我们求值时的公式差不多？没错，除了带个负号，其余的都差不多。所以我们可以考虑打个标记：当 $ flag=1 $ 时，他是正向 $ DFT $ ；当它等于 $ -1 $ 时，它是逆向的 $  IDFT $ 。这可以让我们通过这一个函数解决两个过程。我们只需要用 $ y $ 替换 $ a $ ，用 $ \omega_n^{-1} $ 替换 $ \omega_n $ ，其余的没什么差别，于是……时间复杂度还是 $ O(n \log n) $ 的!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> Lim,<span class="keyword">complex</span> *A,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Lim == <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">complex</span> A0[Lim &gt;&gt; <span class="number">1</span>], A1[Lim &gt;&gt; <span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Lim ; i += <span class="number">2</span>)</span><br><span class="line">        A0[i &gt;&gt; <span class="number">1</span>] = A[i], A1[i &gt;&gt; <span class="number">1</span>] = A[i+<span class="number">1</span>] ;</span><br><span class="line">    FFT(Lim &gt;&gt; <span class="number">1</span>, A0, flag) ;</span><br><span class="line">    FFT(Lim &gt;&gt; <span class="number">1</span>, A1, flag) ;</span><br><span class="line">    <span class="keyword">complex</span> unit = (<span class="keyword">complex</span>)&#123;<span class="built_in">cos</span>(<span class="number">2.0</span> * Pi / Lim) , flag * <span class="built_in">sin</span>(<span class="number">2.0</span> * Pi / Lim)&#125;, w = <span class="keyword">complex</span>(<span class="number">1</span>, <span class="number">0</span>) ;<span class="comment">//欧拉公式 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">        A[i] = A0[i] + w * A1[i] ;</span><br><span class="line">        A[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - w*A1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">......................</span><br><span class="line">FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;</span><br><span class="line">FFT(A, <span class="number">-1</span>) ;</span><br><span class="line">......................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，现在嘛……可以考虑撒花花啦！因为我们的 $ FFT $ 实际上已经结束了！ $ But $ ，这个递归版本的 $ FFT $ 由于牵扯到 $ sin/cos $ 的运算、 $ double $ 、递归时的入栈出栈（底层），所以常数特别的大 $ emmmmm $ ，那么——</p>
<h1 id="rm-0x06-Iterative-Optimization"><a href="#rm-0x06-Iterative-Optimization" class="headerlink" title="$ \rm{0x06~Iterative~ Optimization} $"></a>$ \rm{0x06~Iterative~ Optimization} $</h1><p>我们现在要引出的就是迭代版的 $ FFTqwq $ </p>
<h2 id="·-rm-Advanced-Trick-Point-color-red-3-rm-The-Butterfly-Operation"><a href="#·-rm-Advanced-Trick-Point-color-red-3-rm-The-Butterfly-Operation" class="headerlink" title="·  $ \rm{Advanced~Trick~Point} $   $ \color{red}{3} $   $ \rm{The~Butterfly ~Operation} $"></a>·  $ \rm{Advanced~Trick~Point} $   $ \color{red}{3} $   $ \rm{The~Butterfly ~Operation} $</h2><p> $ emmm $ 先上一个不是特别卡常数的优化。我们观察之前的代码中，有这么一步：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">        a[i] = A0[i] + w * A1[i] ;</span><br><span class="line">        a[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - w*A1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们会发现…… $ \omega \cdot A^{[1]}[i] $ 被执行了两次，所以我们不妨用个变量记录它：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (Lim &gt;&gt; <span class="number">1</span>) ; i ++, w = w * unit) &#123;</span><br><span class="line">     <span class="keyword">int</span> temp = w * A1[i] ;</span><br><span class="line">     a[i] = A0[i] + t ;</span><br><span class="line">     a[i + (Lim&gt;&gt;<span class="number">1</span>)] = A0[i] - t ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><del>嗯，这就是全部的优化啦！那么，FFT，完！</del></p>
<p> $ qwq $ 这分明是骗小孩子的啦……如果单单这一步就可以卡常数的话，那这个世界该多么美好 $ \mathcal{QAQ} $ 。好吧，说这个的原因，只是为了引出我们关于<strong>蝴蝶操作</strong>的定义：</p>
<blockquote>
<p>我们定义 $ \omega_n^k $ 为<strong>旋转因子</strong>，那么每一次我们先将 $ y_k^{[1]} $ 与旋转因子的乘积存储在一个变量 $ t $ 里，并在 $ y_k^{[0]} $ 增加、减去 $ t $ 的操作称为一次蝴蝶操作。</p>
</blockquote>
<p>说白了，蝴蝶操作是一次 $ O(2) $ 的求出 $ A^{[0]}_k $ 与 $ A^{[1]}_k $ 的操作。</p>
<hr>
<p>我们首先考虑按照递归的思路，将 $ FFT $ 的分治流程刻画一下：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="3.png" alt=""></p>
<p>我们会发现，其实我们是可以对它进行反向迭代的。以上面的迭代树为例，我们的步骤大体如下：</p>
<blockquote>
<p>$ step   1 $   成对地取出儿子节点，用蝴蝶操作计算出其 $ DFT $ 。<br>$ step   2 $   用这一步的 $ DFT $ 替换之前的；<br>$ step   3 $   直到我们迭代到根节点为止，否则返回 $ step   1 $ </p>
</blockquote>
<p>而反向迭代似乎有规律可循。我们发现只要我们用迭代的过程模拟出回溯的过程即可。那么思路便有了：三层 $ for $ ，先枚举区间长度（1，2，4，8……），第二层枚举长度为 $ j*2 $ 的每个区间的起点——意图为同时枚举两个相邻区间，便于相邻区间之间 $ DFT $ 的合并，第三层负责遍历每段区间，运用蝴蝶操作逐个合并：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;<span class="comment">//枚举区间长度，从小区间到大区间依次合并。</span></span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;<span class="comment">//两段区间两段区间的枚举，用于合并</span></span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;<span class="comment">//枚举k所枚举的两个区间内的值，并进行蝴蝶操作。</span></span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ; J[k + j + l] = Nx - Ny ;<span class="comment">//一次蝴蝶操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>嗯，好像……海星？哈，思维不严谨的我们漏了一个地方：我们在 $ DFT $ 的时候，为了保证时间复杂度是 $ \Theta(\log n) $ ，我们曾经进行过一次 $ A(x) = A^{[0]}(x^2)+xA^{[1]}(x^2) $ 的操作，所以我们需要自动调整顺序。通俗一点，就是我们原来的序列顺序是 $ 0,1,2,3,4,5,6,7 $ ，但是迭代版的 $ FFT $ 却需要的顺序应该跟叶子结点的顺序吻合，即 $ 0, 4, 2, 6, 1, 5,3,7 $ 。所以——</p>
<ul>
<li><h2 id="·-rm-Trick-Point-color-red-4-rm-The-Butterfly-Law"><a href="#·-rm-Trick-Point-color-red-4-rm-The-Butterfly-Law" class="headerlink" title="·  $ \rm{Trick~Point} $   $ \color{red}{4} $   $ \rm{The~Butterfly ~Law} $"></a>·  $ \rm{Trick~Point} $   $ \color{red}{4} $   $ \rm{The~Butterfly ~Law} $</h2></li>
</ul>
<p>这个嘛……我们可以选择打个表观察：<br>原来的序号  $ 0        1        2        3        4        5        6         7 $<br>现在的序号  $ 0        4        2        6        1        5        3        7 $<br>原来的二进制表示  $ 000        001        010        011        100        101        110        111 $<br>现在的二进制表示  $ 000        100        010        110        100        101        011        111 $ </p>
<p>诶，二进制好像是反序的嗷~~这便是我们的最后一个 $ trick $ ，蝴蝶定理。而因为我们观察到的蝴蝶定理是满足一一对应性的，所以我们在 $ FFT $ 之前 $ swap $ 一遍即可。</p>
<p>嗯，然后我们可以将这个反序存在一个数组里面。类似这样求出来：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br></pre></td></tr></table></figure><br>呃，这个二进制计算自己推一下就好。</p>
<p>那么我们可以看到，这就简化了很多冗余的步骤，并让我们脱离递归的大常数。<del>真开森啊</del></p>
<p>最后附迭代版的代码(我写的常数好像有点儿大 $ QAQ $ )</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, K ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">3000100</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>) ;</span><br><span class="line"><span class="keyword">int</span> i, j, k, l, Lim = <span class="number">1</span>, L, R[MAXN] ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y ;</span><br><span class="line">    node (<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>)&#123;</span><br><span class="line">        x = xx, y = yy ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;A[MAXN], B[MAXN] ;</span><br><span class="line">node <span class="keyword">operator</span> * (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x * Q.x - J.y * Q.y , J.x * Q.y + J.y * Q.x);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> + (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x + Q.x , J.y + Q.y);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span> - (node J, node Q)&#123;</span><br><span class="line">    <span class="keyword">return</span> node(J.x - Q.x , J.y - Q.y );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span> ;c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span> ,c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(node *J, <span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; R[i]) swap(J[i], J[R[i]]) ;<span class="comment">//前面的if保证只换一次</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; Lim; j &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">T</span><span class="params">(<span class="built_in">cos</span>(Pi / j), flag * <span class="built_in">sin</span>(Pi / j))</span> </span>;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; Lim; k += (j &lt;&lt; <span class="number">1</span>) )&#123;</span><br><span class="line">            <span class="function">node <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span> </span>;</span><br><span class="line">            <span class="keyword">for</span>(l = <span class="number">0</span> ; l &lt; j; l ++, t = t * T)&#123;</span><br><span class="line">                node Nx = J[k + l], Ny = t * J[k + j + l] ;</span><br><span class="line">                J[k + l] = Nx + Ny ;</span><br><span class="line">                J[k + j + l] = Nx - Ny ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr(), M = qr() ; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N; i ++) A[i].x = qr() ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= M; i ++) B[i].x = qr() ;</span><br><span class="line">    <span class="keyword">while</span>(Lim &lt;= N + M) Lim &lt;&lt;= <span class="number">1</span>, L ++ ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; Lim; i ++ ) R[i] = (R[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>)) ;</span><br><span class="line">    FFT(A, <span class="number">1</span>), FFT(B, <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= Lim; i ++) A[i] = A[i] * B[i] ;</span><br><span class="line">    FFT(A, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= N + M; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, (<span class="keyword">int</span>)(A[i].x / Lim + <span class="number">0.5</span>)) ;<span class="comment">//我们推过的公式里面有一个1/n这一项，最后输出的时候添上即可 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>啊……那就撒花花吧！！</p>
<h1 id="rm-0x00-quad-Afterword"><a href="#rm-0x00-quad-Afterword" class="headerlink" title="$ \rm{0x00\quad Afterword} $"></a>$ \rm{0x00\quad Afterword} $</h1><p>以下是原尾语，保留了下来：</p>
<blockquote>
<p>嗯……怎么说呢，现在看这个算法，真是简单的一匹啊……代码这么短<del>这么容易背过</del>。但是当时理解起来却花了很大心思呢！这篇博客我写了整整三天 $ qwq $ ，由于要培训和考试，所以拖拖沓沓地写了三天，一边写一边感叹自己理解的简直太浅显了。每一个证明、每一个引理、甚至每一个符号，我都需要去和其他 $ DALAO $ 比对审核、或者缠着 $ rqy $ 问个没完；每次一讲到原理，我都发现自己原来并不理解那些，于是不得不推倒重来。这篇博客会持续更新，补充语意不明、证明难以理解的地方。</p>
<p>以下是温馨提示：</p>
<ul>
<li>好多自己当初不理解的地方在代码里就只有半行qaq</li>
<li>三个引理中，只有消去引理跟算法的实现没有关系——消去引理主要是用来证明其他引理的</li>
</ul>
</blockquote>
<p>真 · 结束语：</p>
<p>其实没什么好说的，今天重新复习了一遍，发现自己以前有好多内容虽然如原尾语所言，看上去<code>现在看这个算法，真是简单的一匹啊</code>，但实际上忽略了好多东西。我想大概只有一遍一遍地钻研才能了解完全一件事情吧。</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$ \rm{Reference} $"></a>$ \rm{Reference} $</h2><ul>
<li>$ [1] $  : $ rvalue $ 的 $ blog $  <a href="https://www.cnblogs.com/rvalue/p/7351400.html" target="_blank" rel="noopener"> $ ^{^{[\nearrow ]}} $ </a></li>
<li>$ [2] $  :算法导论 <a href="https://pan.baidu.com/s/13PRy8pPn__zGj3UfOTX8Ew" target="_blank" rel="noopener"> $ ^{^{[\nearrow]}} $ </a> 提取码: txs2 </li>
<li>[3]*：鸣谢rqy</li>
</ul>
<h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$ \mathfrak{writter:pks} $"></a>$ \mathfrak{writter:pks} $</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>随想五 · 手中没有红玫瑰</title>
    <url>/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<hr>
<p>今天下了一天的雪。</p>
<p>我是隔着窗户望的，直到现在我还没有真正触摸到久违的雪花。一年多了？或许吧。我轻度近视，但是白天在窗边的书桌旁习作时，不戴眼镜的，还是能看到纷飞的白絮——虽然有些模糊。它们经常想我挥手致意，我也满足了。</p>
<p>“情人节呢…”我想着。当然，人类在思考一件事的时候不可避免的要联想，我联想到的是什么呢？是我没写完也压根不想写的作业，是如果有了恋人之后老师们的竭力反对、在同学中显得鹤立鸡群以及在学业与处理恋爱关系的漩涡交叉中抽不开身——大抵就是这些吧。我不敢想了，因为我想到一桩美好的事情，仿佛就会联想到十件、上百件令人不寒而栗的事情——这让我感到恐惧。</p>
<p>雪真美啊。</p>
<hr>
<p>早恋？</p>
<p>“严打！”， “好孩子不早恋！”， “早恋肯定没戏，好好学习吧”，“什么年龄就该干什么年龄该干的事儿”……</p>
<p>说真的，我很难启齿，哪怕是在要好的朋友面前——当我说出我对哪个女孩子有好感的时候，我都是怯怯的。</p>
<p>直到刚刚看到了这样一篇文章，是一个网络作家苏见祈写的，挺早的一篇文章了：</p>
<blockquote>
<p>小学五年级的时候，我喜欢班上的一个女孩子。<br>那时候想的很多。<br>比如有一天看电视剧，男主扑过来替女主挡了一枪，挂了。<br>那天我辗转反侧了一夜，质问自己如果有人用枪指着我喜欢的小女孩，我敢不敢扑过去赴死。<br>这犹豫让12岁的我非常羞愧。我觉得这样自私的我，不配喜欢她。<br>我开始质疑自己，我自以为的喜欢是不是真的像大人说的那样，只是不懂事的小孩闹着玩。</p>
<p>如今我知道这自责毫无必要。在感情里闹着玩，这事儿在大人的世界里要流行的多。</p>
<p>我想得多还体现在了别的方面。比如老师说好好学习，可我一直不明白为什么。<br>他们的那些理由，比如找个好工作啊，出人头地啊，听起来就很无聊，何必呢。</p>
<p>于是从初一开始，原本三好学生的我成绩一落千丈，勉强只能上个末流高中。<br>家长老师全都急死了，或威逼利诱，或苦口婆心，我一概油盐不进。当然现在的我知道了读书的理由，可是叛逆期的少年什么也不想听。</p>
<p>后来初三开学，我收到了一封信。<br>来自那个小学时候喜欢的女孩子。<br>信的末尾有一句话：我准备报考X中，你要不要一起？</p>
<p>我的手不受控制地颤抖。<br>烈焰在灵魂的深处燃起，灼人的热浪席卷了全身每一个细胞。</p>
<p>为什么要读书呢？<br>16岁的我获得了唯一的答案——为了和喜欢的人在一起。<br>我开始疯了一样地复习，恶补这两年落下的知识点。书桌边上放了一盆水，困了就用水泼自己的脸。<br>对于我一夜之间的剧变，大人们一个个喜笑颜开，说孩子终于懂事了。<br>是啦，他们总以为自己很懂。</p>
<p>很多人说，小孩子不要谈感情，因为反正不会有结果。<br>是，的确不会有结果。<br>就像哪怕后来我如愿考上了X中，这依然不是柯景腾沈佳宜那样的故事。从始至终，我都没能在女孩的人生里扮演过哪怕一个配角。</p>
<p>可是如今我站在时间的彼端回望，如果那个十几岁的孩子没有爱上过什么人，那么他之后的人生，将无法挽回地滑入深渊。<br>爱过一个人，是我少年时最大的幸运。</p>
<p>所以，当所有大人视早恋为洪水猛兽的时候，我完全不敢苟同。而当他们言之凿凿地说“谈恋爱影响学习”的时候，我更只能报以白眼。<br>是，谈恋爱影响学习。只是很多时候，这“影响”可以被称为“激励”。</p>
<p>有可能影响学习的东西很多，电视剧可以，小说可以，糟糕的老师和不合格的父母更加可以。而在所有的因子里，恋爱最有可能把叛逆的少年变成更好的人。<br>结果所有的大人，偏偏用尽所有力气，揪着这柄双刃剑纠缠不清。</p>
<p>我甚至怀疑，比起那些高大上的“为你好”，他们只是恐惧另一个人成为自己孩子的精神寄托，恐惧孩子脱离自己的掌控——和婆婆刁难媳妇的心理相同。</p>
<p>他们轻蔑地说，小孩子懂什么恋爱。<br>好，那我们来看看大人们有多么懂爱情。<br>相亲的男女将各自的筹码摆上天平，房，车，行业，家庭，收入，像一场等价交换的生意。<br>夜场里乐声震耳欲聋，男人在刚认识半小时的女人耳边大喊，明天上午我送你回学校好吗。<br>夫妻二人坐在沙发的两端玩着各自的手机，一晚上都懒得抬头看对方一眼。</p>
<p>所以我一直无法理解，成年人在孩子的爱情面前，那份优越感到底从何而来。他们趾高气扬地说着“小孩懂什么恋爱”，却不拿镜子照照自己的一地鸡毛。<br>难道以上这些画面，比穿着校服的女孩假装路过球场，只为偷看一眼喜欢的男生打球，更能称为爱情？</p>
<p>还有一种比较温和的反对，说起来语重心长：“你们还年轻，别着急，谈恋爱以后有的是机会。”<br>仔细回想，这种过来人现身说法的方式，对孩子的确很有说服力。孩子总是相信美好的，相信久别重逢，相信姻缘一线，相信十年之后我们至少还是朋友。</p>
<p>可是，请如今已经长大的大家问问自己，当年魂牵梦萦的那个人，如今还在吗？<br>你们是真的有的是以后，还是早已离散在人海？<br>而后来遇到的那些人，真能模糊了十六岁留在心里的眉眼吗？</p>
<p>很久以后我们终于知道，大人都在说谎。<br>少年的错过是一生的求不得，是哪怕功成名就和富可敌国都无法挽回的遗憾。或许未来的你风光无限，可你永远无法逆转时间。没有什么“有的是机会”，错过此刻，就是错过一生。</p>
<p>如果有还在上学的读者看到这里，请记住，人生没有那么多以后。<br>有喜欢的人就去追，你不追上ta，分离就会追上你，没有例外。当然啦，为了你们的手能牵得久一些，成绩一定不能落下。</p>
<p>至于那些义正辞严棒打鸳鸯的长辈……相信我，十年后他们不会理会你的遗憾和怅惘，他们会催你随便找个人结婚，并且丝毫不觉得在打自己的脸。</p>
<p>我有个有点儿丧的朋友，叫小怪。关于少年的爱恋他说过一段话，我觉得我不能说得更好了，借花献佛送给大家。</p>
<p>” 很多人即使只见过一面，已经算见过了最后一面。“</p>
<p>十八岁前不早恋，这辈子都来不及早恋。<br>你的人生看起来很长，每一秒都无法挽回。</p>
</blockquote>
<p>虽然不排除有“站着说话不腰疼”的嫌疑，但是我觉得这或许提醒了我什么。</p>
<p>我今天在这里可以开诚布公地跟各位讲我所谓的”感情经历“，”心路历程“。</p>
<p>当然，也是给我自己讲。</p>
<p>关于这件事，我一直纠结的很。因为身旁或许有了喜欢的女生，但是或因为她有男朋友了，或因为别的什么原因，我不能很顺利地实现。是坚持呢，还是不坚持呢？我不知道。以前在初中，遇到一个女孩就痴痴地觉得可以携手一生，但最后却是连牵手的机会都没有。</p>
<p>现在不一样了吧，一生，多长啊。</p>
<p>我是在担心这个吗？我也不知道。大概是从来没有什么人支持过我，包括我自己，也从来没有支持过我自己。</p>
<p>没提起这件事，遇见她，总会感觉内心无比纠结，会因为她一颦一簇心里翻腾好久，也会因为其他的原因感到略略压抑。好像我已经把她当成了什么洪水猛兽。因而我也常常纠结不已。</p>
<p>等会儿，难道每天纠结的要死就是我想要的吗？理性分析一下，我想要她成为我的恋人是我喜欢她的必然结果，但是这两种状态我真的可以权衡的很好吗？换句话说，我关于她的的喜怒哀乐还是因为我喜欢她吗？</p>
<p>不，我觉得不是。</p>
<p>我是在亵渎一种感情，是在侮辱一个人。</p>
<p>爱从来都是无私地付出，而不是拼命的占有啊。</p>
<p>我仿佛把她当做了一种商品，一种十分想得到手的商品。我现在会展现给自己、也展现给其他人一副十分渴求、十分真诚的面孔，或许也不过是希望得到她的一种手段。当我们真正属于彼此后，我不能保证在那层皮撕开之后，我还会一如既往地珍惜这份情愫，你也不能保证，同样，她也不能保证。</p>
<p>你看，就这么点儿事情我纠结了这么长的篇幅。什么纠结啊，占有啊，真爱啊，一生啊，</p>
<p>都不过是拼命地想被爱而已。</p>
<hr>
<p>不知道现在看到这儿的你是否和我一样孤独？孤独并不是每个人都有的情感，有些人，很多人从来都不会感到孤独——我多羡慕他们啊……</p>
<p>孤独，或许也是另一种程度上的纯粹。我至今仍觉得我有着最纯粹的感情，是少年一样的感情，不是向垂暮老人一样的、只可独自怀念的情感。这种感情是热切的、生动的。</p>
<p>我很喜欢一首合唱曲目，叫做”我喜欢“。歌词十分动人，旋律优美动听，松弛恰到好处。</p>
<p>下面是歌词：</p>
<blockquote>
<p>我喜欢暖冬的太阳<br>我喜欢初春的青草<br>我喜欢午后的庭院和一旁发呆的秋千<br>我喜欢仲夏的冰沙<br>我喜欢清秋的明月<br>良宵的夜空 漫天星辰<br>我喜欢雨后的青蛙<br>我喜欢山前的杏<br>我喜欢周三的傍晚被霞光亲吻的水族馆<br>我喜欢成群的野<br>我喜欢凌乱的书架<br>清风的露台远处的灯海<br>我喜欢 走在无人的九十六号公路<br>我喜欢 木村拓哉长长的头发<br>我喜欢 无尽田野上奔跑的麋鹿<br>我喜欢 外婆门前的榕树<br>我喜欢母亲的便当<br>喜欢父亲的胡渣<br>我喜欢八月的夜晚还在营业的游乐场<br>我喜欢放学的铃铛<br>我喜欢停电的夜晚<br>点一对蜡烛 在幽静的玄关<br>我喜欢 城市尽头那远远的青山<br>我喜欢 热气球飞上西边的天空<br>我喜欢 清晨的石板路<br>雾腾腾的早餐店 阿公的桂花糕<br>我喜欢 每一朵暮云 每一株绿树<br>我喜欢你，你应该，也知道<br>我喜欢你，你应该，也知道</p>
</blockquote>
<p>优美的旋律，配上最后两句甜甜的告白。或许我们开来，似乎有点扭捏——扯这么多只为了表达最后两句——</p>
<blockquote>
<p>我喜欢你，你应该，也知道.</p>
<p>我喜欢你，你应该，也知道。</p>
</blockquote>
<p>很平常？确实很平常。但是我认为这两句恰到好处。前面大段大段的铺垫，叙述了许许多多美好、恬静的事物，但是这一切或许都比不过你。</p>
<p>你可以想象，在一片动人的夕阳下，天空中是大片大片的奶茶红，一个憨憨的大男孩，突然叫住你，红着脸跑到你面前，拿着皱皱巴巴的稿子，颤颤地朗诵着这些——他实在太动情了，念着念着突然声调放高，声音变大——他是打心眼里喜欢你，越读越有感情，越读他越自信——但是突然他又畏缩起来，声音低低地向你说出了最后一句最动人的话：”我喜欢你，你应该，也知道“。</p>
<p>有可能你没有什么特殊的感觉，但在我心里，这就是最纯粹的东西——是不奢求的朴实的爱，是不考虑物质只拿捏感情的爱，是无语凝噎但心中重复千千万万次的爱，是真挚的爱——这是属于我们这个年纪最美好的东西，虽然有学业繁忙等诸多因素阻挠，无法完整地得到——但或许只是一片、两片这样的有着亮暖色调的枫叶，就可以点亮一整片枯败的枫林。</p>
<p>我大概在听这首歌之前，从来没有真正知道原来”喜欢“这个已经烂大街的词、这个现如今可以随便说出口又可以随便忘记的词、这个在我上过的所有学校里从来没有人敢光明正大说出来的词、这个现在在芸芸众生中已经被玷污的、被人们认为还没有一块钱来的实在的词，竟然如此的可爱，竟然如此的值得人们尊敬，竟然可以在冰冷的寒夜散发出如此耀眼的光芒。</p>
<p>我喜欢你，你应该，也知道。</p>

        <div id="aplayer-mhRVIMPD" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-mhRVIMPD"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "我喜欢",
              author: "彩虹合唱团",
              url: "我喜欢.flac",
              pic: "/2019/02/14/随想五·情人节/wxh.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<hr>
<p>心在流浪的人啊，在这华灯遍街的情人节，你是否也跟我一样，跟自己的灵魂形影相吊呢？</p>
<p>如果你已经有了心上人，我祝福你；如果你已经有了打算携手一生的人，我也祝福你。唯有那些都市里最角落的孤独者，我们的邂逅或许是一种缘分吧，或许我们素未谋面，或许我们并不熟识，但在这流光掠影的漆黑夜空下，我希望你能跨过一切，跨过时间——看这篇文章时的你，伸出你的右手，或许就可以跟在这一晚伏案沉思写下这篇文章的我，轻轻击掌，感受对方的体温与灵魂。</p>
<p>我伸出手了啊，你呢？嗯…抱歉啦，我手中今天没有红玫瑰可以送你。这翩飞的雪花，就当做是我送你最好的礼物吧。</p>
<p>相信我，这个世界上绝对有人偷偷地爱着你，即使你觉得自己很不堪。比如你班里的某个人，比如你对门，比如你同事，比如你的后桌，比如，我。</p>
<p>$19/2/14$ </p>
<hr>
<p>本来打算这篇水文就这么结束，留下一个温馨鸡汤结尾，挺好的。但突然想了想，自古以来能给人留下印象的从来不是喜剧结尾，短暂的欢愉会让人忘记。</p>
<p>那么就补一个深沉一点的结尾吧。</p>
<p>我一直不知道我现在有好感的那个人，究竟是自己意识流强加的，还是真的发自内心的喜欢。我纠结。我无法知道将来是否会遇到一见钟情的人——我希望这样，而不是为了捕获爱情而去捕获得来的感情。我惶恐。</p>
<p>但其实没准所谓一见钟情+修成正果一直是文学作品里面用来抓读者眼球的工具而已，大家或许都不可能找到自己的“最爱”，只能找到一个“差不多”，进而不断地磨合，直至磨成“最爱”。但这样的情节，说什么都不会让人满意吧……</p>
<p>路在哪呢？彼岸又在哪呢？我已经受够一个人形影相吊的孤独生活了，但在这浩如烟海的求学之旅中，似乎接受孤独、体味孤独、并最终热爱孤独才是最好的法子吧。</p>
<p>可是面对着无奈的明天的我，什么都不能做。</p>
<hr>
<p>雪，终于停了啊。现在已经午夜了，街上一个人都没有，天空在积雪的映照下，是让人着迷的紫红色。</p>

        <div id="aplayer-HBMKMXDo" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-HBMKMXDo"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "遇见",
              author: "孙燕姿",
              url: "遇见.flac",
              pic: "/2019/02/14/随想五·情人节/yj.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随想三 · NOIP2018游记</title>
    <url>/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我不想退役。</p>
<a id="more"></a>
<p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<hr>
<p>他看着眼前的屏幕，静静地发呆。</p>
<p>他不知道迎接他的将会是什么，后天的 $\rm{NOIp}$ 终究是个谜。</p>
<p>刚刚给机房里其他人讲完期望的他，打心底觉得自己没有讲好，但效果似乎还可以。</p>
<p>“希望别考期望吧，嘿嘿……” 他心里这么想着。</p>
<p>晚上，他一直在补他出的题的锅。鸽了这么久，也该写一写题解了啊。</p>
<p>他不知道是否该向身旁的同僚们一样继续打板子——上午打的板子让他很满意，虽然都是很简单的东西，但是他却觉得自己写的很精彩，都是一遍 AC​。大概这样，他觉得似乎没什么问题。</p>
<p>从下午就开始有空调暖风了，这倒是让他十分欣喜。前几天，或者说昨天，在机房穿着厚厚的羽绒服，手颤抖着，脑袋十分昏沉地打代码时候的模样……他不愿意再回想起这些。</p>
<hr>
<p>早上十分着急地买了早饭，之前吃学校里的羊汤都吃的是羊杂汤，今天决定尝试一下贵三块钱的羊肉汤的他感到很失望——羊肉又肥又腻又膻腥。他一点没吃，买了一块脆香米就走出了食堂。去奥赛室收拾了一下东西，本来还想离线下来几集最近在追的番剧，才发现原来 Bilibili 不支持 MacOS，连硕鼠也不能用了，便只得作罢。</p>
<p>终于要走了。踏上去昌邑一中的车的前一刻，他回头看了一眼学校。他记得那个开朗的、但是实际上并不是很熟的女孩在听课之前为他助威的场景；他记得他自己计划的是，NOIP​ 好好考，参加完冬令营，签一个清北约，带着还算不错的成绩迎接寒假，然后在寒假里去找他的女神——高中新认识的、一个爱笑的、努力的、可爱的女生，撩她出去玩儿，最好是能在一起吧——但是学校规则是不会允许的吧。不过他认为，只要彼此都在学校里数一数二，只要彼此都能比较轻松地上清北，学校或许会睁一只眼闭一只眼。他似乎对将来他们一起努力的场景充满了信心。</p>
<p>“大概只需要400分，或者以上？总之不是特别难吧。”他这么想着，眼里发出晶蓝色的光，或许是反射的太阳光吧。</p>
<p>看了看天空，他上了大巴车。</p>
<hr>
<p>”昌邑一中真大啊“这是他到这儿后的第一想法。</p>
<p>到达昌邑一中已经是中午。饭菜比较可口，在他心里大概比日照一中的饭菜$better$几倍。下午原本想出去找同僚们蹭一下网，把板子打完，但谁知道一睡就睡到了四点。匆匆忙忙地看完考场位置，在路上遇到了同僚和前同僚。瞎侃了几句之后发现到饭点儿了，于是就只能选择去吃晚饭了。晚饭给他的感觉似乎没有午饭那么惊艳，“或许是太累了吧”，他这么想。吃饭的时候和$rqy$瞎侃，感觉海星。</p>
<p>宿管说$6$点以后来电，结果咕咕咕。我们于是就用空调插头接上插排凑活了一晚上。</p>
<p>他十二点左右才睡下——虽然他知道这么晚睡不行，但是没有办法，板子没打完的话，心中像是有什么负担一样——当初他执着于补一晚上自己的锅而不是去打板子大概也是这个缘由。他想放心地进入考场，这是他考试的习惯。</p>
<hr>
<h2 id="Day-1​"><a href="#Day-1​" class="headerlink" title="Day 1​"></a>Day 1​</h2><p>突然不让坐电梯，六楼让他气喘吁吁。”该减肥了……不过现在或许不是想这个的时候”。</p>
<p>考场在六楼，昨晚试机的时候，他写了一个 dijkstra，写了个 ST 表，又写了个暴力 $n^2 ~\rm{RMQ}$ ，并写了个对拍。都是一次成功。让他感觉很好。</p>
<p>入场了，他带了两块橡皮糖，两小块脆香米，都是早先从学校买好的。</p>
<p>T1 他觉得似曾相识，大概是什么积木大赛还是积木大会啥的，他记不清了。考场的时候他一走神就会不自觉地去想最后一个字到底是什么，但就是想不起来。最后他写了一个复杂度 $n\log^2n$ 的线段树和一个 $n\log n$ 的ST 表，又写了个 gen 啥的让他俩拍，此时已经 9:15 了。</p>
<p>T2​ 他从第一眼开始就已经输了。他觉得应该是什么数学题或者结论题，花了 10min​ 写了个暴力，过不了大样例的最后一个点，又想了 10min 他才发现原来不止可以由两个推出新的，可能是三个或者更多。DP 这个想法在他脑子里一闪而过，他没有选择捕捉。最终他居然只写了一个暴力+骗分。</p>
<p>T3 大概只会求直径——但是他只记得是什么两遍 dfs 或者 bfs，因为他从没做过求直径的题。考试之前 qbxt 的时候，他甚至让别人给他推荐几道直径的题，但终究是没来得及做。他很后悔。最终写了一个暴力骗分。</p>
<p>期望得分 $100pts + random(0,100)+random(10,20) $ 。</p>
<p>Luogu​ 数据 $100pts + 65pts + 15pts = 180pts$ 。</p>
<p>听说今天三道题都是原题，他很愤懑，希望没准可以让 CCF​ 重考一下之类的。但是这根本是无稽之谈。</p>
<p>下午他和同僚去逛了逛昌邑一中，并且买了三本东野圭吾的书，店主对他不错，给他打了七折。</p>
<p>考挂了，他想到。</p>
<p>这世界上似乎就他一个不会 T2 的人。</p>
<p>他对好多人的言行感到厌烦：有人说 “完了，大众分160”，接着便有人回驳他 “明明大众分220”，但接着又有人大声地说 “大众分明明255好吧” 。</p>
<p>虽然大家平常都互%，但是总感觉那些弱小的人是多么的无助啊——他们只会感到虚伪、无助、绝望。像我一样。</p>
<p>或许他期望着明天能翻盘？</p>
<p>晚上他彻底颓废了，要求熄灯后，他用同学的热点看了《青春期猪头少年XXXX》的最新三集，感到海星。依旧睡得不早。11：30​ 左右吧。</p>
<hr>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>今天他没有带什么吃的。</p>
<p>T1​ 只会 $60$ 分，转眼去看 T2</p>
<p>写了好长时间的暴力并且调了好久，在考试结束前 30min 他写好了爆搜，找出了规律，$65pts$ 左右。</p>
<p>T3 连想的时间都没有。</p>
<p>退役了。</p>
<hr>
<p>他很伤心。</p>
<p>回家之后他和其他省市的 Oier​ 交流之后发现大概都挂了。无奈的世界。</p>
<p>他本来不想期中考试，但是却又想不出什么理由来不去考试。毕竟刚考完 NOIp ​的其他人都照常期中考试。</p>
<p>他觉得自己语文发挥的一般，物理发挥的正常，除了物理的某个傻狗填空题让保留一位小数自己眼瞎了而已。</p>
<p>其余的都考炸了。</p>
<p>初回文化课，班里的人并不陌生。语文老师似乎对他的这个语文课代表的回归感到很高兴。</p>
<p>他一开始也并不怎样，没啥感觉。</p>
<p>直到那天下午。</p>
<hr>
<p>他兴高采烈地去奥赛室看民间测试数据的成绩。中午高二的某个学长告诉他的，他考了全校第四，接近$400$分。虽然可信度不高，毕竟自己什么逼数他自己心里清楚。不过还是期待了一下午。</p>
<p>兴奋的他去奥赛室看成绩。</p>
<p>学长看错了。</p>
<p>他的两个同僚都是 370/380+​ 的样子。</p>
<p>只有他不到.</p>
<p>其他人的分数也比他高。</p>
<p>他大概全校第十几吧。</p>
<p>他感到了绝望。</p>
<p>本来以为的三人行（三个人一起参加过两届省队集训），其实是不包括他的两人行。</p>
<p>他注定是失败者。</p>
<p>他伤心极了。</p>
<hr>
<p>他开始愈发消沉，晚自习看了一晚上的文学素材荟萃那种东西，都是些鸡汤之类的蠢文章。但他什么都不想干。他想在学校读那几本从昌邑买回来的书，但是怕被抓只好作罢。</p>
<p>他觉得一年来，他一事无成。</p>
<p>或许进实验部只是个错误。但他是不会退出的。即使是为了面子也不会。</p>
<p>他原本计划好的一切都没有成功。现在最后一次机会，他依旧失败了。人生输家，大抵就是这样。他不愿意去面对他的奥赛同僚们。他大概就像是 EDG​ ——国内赛如同战神一般，一到国际比赛就死。</p>
<p>他的女神越开心，他越寒心。倒不是因为别的，只是他的女神越可爱，他越觉得曾经做白日梦的自己是个不曾认清现实的傻 B​，他越发感到落差的不可逾越。他绝望了。</p>
<p>期中考试成绩发下来了，他从停课之前的班里第五，年级第二十滑到了班里第四十，年级第 289​。这次他们班考得很好。年级前四，他的班里有三个；年级前 20 有 10 个，年级前 400 有 46 个。年级共有 1640 左右的人。</p>
<p>这似乎是实验部该有的成绩。可是跟他没有关系。</p>
<p>特别的，他的女神考了年级 28，班里第 13。他比她差十倍。虽然停课了一段时间没上好像是个不错的理由，但他依旧觉得，自己太失败了。</p>
<p>太失败了。</p>
<p>太失败了。</p>
<hr>
<p>大休回家，现在是 11.17 晚，我用第三人称说完了这个故事，感觉……并没有什么感觉。</p>
<p>我发现我现在心情虽然很沉重，但是同样很放松。我大概不会再参加什么 OI 了吧——这让我感到轻松无比。不需要面对其他很强的人而有心理负担，不必面对教练主任去承受他们的“高目标”，不必每次 fake 时还会纠结我自己到底强不强，不必再去争强好胜。虽然最终免不了被当做反面教材说给 OI 的学弟们，虽然免不了是要主任被批一顿并且让你总结个什么傻逼错因或者感悟并让你声泪俱下地去反省并且保证以后好好学 OI，但，我轻松的很。</p>
<p>这真是从未有过的轻松的感觉。</p>
<p>或许我本来没有什么天赋，只是在靠个人素质硬刚而已。也许信竞给我的终究是除了成功之外的一切，比如毅力，比如做人。</p>
<p>我感到无比的轻松。</p>
<p>以后大概不会学信竞了吧。毕竟压根没有什么转机。路的话，边走边想吧。</p>
<p>我现在十分地想学 CNAO​，之前由于要准备 NOIP，从图书馆借来的书没来得及看。现在终于有时间了。</p>
<p>嗯，大概天文才是我真正喜欢的吧。以前每次为了 OI​ 奋斗的时候总要想想自己到底是不是真正喜欢 OI，其实说不上喜欢吧，毕竟没有真的从骨子里喜欢这东西。</p>
<p>但是其实山东没有开展 AO​ 的，不过我想当这个第一人。</p>
<p>我突然很感激这一切，感激曾经的失败与成功、收获与感动。君与我之恩，毕生难忘。</p>
<p>到了说再见的时候了，哈，我的作业还没写呢。我可要学好文化课，做的滴水不漏才能去学$AO$啊，虽然这是一段未知的旅程，但是我乐意去闯。</p>
<hr>
<p>在成绩单上看到了好多山东的巨佬…曾经在我看来与我水平差不多的人，大概都以压倒性的优势击败了我吧。</p>
<p>没准学 OI​ 的时候，如果我一直是为了功名利禄而学，为了获得进入某两所大学的机会而学，终究是肯定不会成功的吧——到不是说一定要去喜欢这门奥赛，只是在奋斗的时候，还是只为了奋斗而奋斗比较好吧。</p>
<p>我该说什么？强大的理解能力或者推理能力，终是不是OI的核心素养——创造力才是。当然啦，数学有够好+强大的理解能力=rqy这个等式也是成立的。</p>
<p>当然，不属于我啦。</p>
<p>虽然现在很不甘……但是没有办法，大概这就是人生吧。</p>
<p>如果说……退役后的几天感觉怎么样……还好吧，没我想象的痛苦。只不过之前一直憧憬的所谓“妹子”也好，“女神”也好，原来一直有男朋友只不过我不知道；只不过干起什么事情来都力不从心而已；只不过重新燃起的希望之火又被浇灭了而已吧，也没有什么必要去为之伤心——这才是人生吧。</p>
<p>听说你谷有个 OIer 要自杀…不知道这个传闻是真是假，毕竟也没法去确认。我只是为此感到伤心而已——无论到底有没有自杀，我只想用那句话来评论“实力如果强到独步天下，想怎么学就怎么学；否则只能毫无保留地、纯粹地去努力，而不是为了去获得功名、封佛封神 —— 不忘初心在什么时候都是最重要的。”所以，心无旁骛，什么时候都是最重要的。</p>
<p>总之呢，我把这篇文章称之为“启示录”，只是希望后来的Oier或可以从我的这一些杂悟里获得些什么：</p>
<blockquote>
<p>做什么事情，都要先从自己的灵魂出发，而不是从利益出发。</p>
</blockquote>
<p>之类的吧。</p>
<p>我想引用一句（段）话，来自《本杰明巴顿奇事》：</p>
<blockquote>
<p>有些人，注定可以于河边闲坐。<br>有些人被闪电击中过七次。<br>有些人对音乐有着非凡的天赋。<br>有些人是艺术家。<br>有些人是游泳健将。<br>有些人懂得制作纽扣。<br>有些人懂莎士比亚。<br>有些人是妈妈。<br>还有些人，是舞者。<br>我们注定要失去我们所爱的人，<br>要不然我们怎么知道他们对我们有多么的重要。</p>
</blockquote>
<p>后会有期。</p>
<script type="math/tex; mode=display">
\mathscr{THE\quad END....?}</script>]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>【赛题整理】CF#536Div2の题解(E&amp;F)</title>
    <url>/2019/02/08/CF-536Div2%E3%81%AE%E9%A2%98%E8%A7%A3-E-F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>春节前的一场 CNRound～名字很 nice 的说～</p>
<p>⑧说别的啦，新年好那个新年好qwq !</p>
<a id="more"></a>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89--%2F%E7%9C%81%E9%80%89-blueviolet.svg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>emmm​这次 CF 本身打的很顺畅，但是居然unrated了……咕咕咕咕</p>
<p>这是头一次CF有比赛我全部题目都做了……可喜可贺可喜可贺233</p>
<p>简单总结一下前面四道题 <a href="http://codeforces.com/contest/1106" target="_blank" rel="noopener">Link</a>：</p>
<ul>
<li><p>A题：sb题，$O(n^2)$ 枚举，但是我 check 的时候太粗心WA了一次<del>身败名裂XD</del></p>
</li>
<li><p>B题：sb题，一个模拟，需要一个可以处理优先级的数据结构（其实就是堆但是我一开始想的是线段树）</p>
</li>
<li>C题：sb题，一个贪心（其实是数学上可proof的数学题但被我当贪心题做了XD），大概就是你胡乱排个序之后胡搞一下就好。（画外音：现在是来自 0202 年的复盘，其实这题的原理是排序不等式）。</li>
<li>D题：水题，思考一下可得，我们只需要写一个BFS+一个优先队列即可，因为无向图+随便走=胡搞八搞。本质上是考察的字典序的贪心本质。</li>
</ul>
<p>下面两道题就好像不是那么水了qaq</p>
<h1 id="E-Lunar-New-Year-and-Red-Envelopes"><a href="#E-Lunar-New-Year-and-Red-Envelopes" class="headerlink" title="E Lunar New Year and Red Envelopes"></a>E Lunar New Year and Red Envelopes</h1><blockquote>
<p>给 $k$ 个区间，每个区间一个左端点 $s$ 一个右端点 $e$，同时还有一个蜜汁 · 右端点 $t$。顺着时间线$1\sim n$，可以从 $s_i$ 到 $e_i$ 的时间内获得 $w_i$ 的收益，但同时下次的选择必须在 $t_i$ 之后。</p>
<p>最大化收益的思路下，有 $m$  次机会让选择者在某个时间点啥都不干。求最小的收益。</p>
</blockquote>
<p>呃，其实比较容易的发现就是个时间线 dp 。根据 <code>n 不大就dp n</code> 的是指导思想（瞎扯的），我们应该按时间 $dp$。</p>
<p>那么第一步就是把每个区间的信息映射到时间线上去。这个时候有一个比较妙的 $idea$。首先我们给每个区间的 $s$ 和 $e+1$ 在时间线上分别打上不同的标记，之后我们考虑沿时间线从前向后扫描每一段区间，每当遇到一个区间的 $s$  时就丢到一个 <code>multiset</code> 里面，反之遇到 e+1 时就 <code>erase</code>。然后这样我们只顺便乱搞一下就可以得出每个时间点最优的方案。</p>
<p>之后？之后就直接$O(nm)$的 dp 啊，毕竟 $nm$ 只有 $2\times 10^6$ 。</p>
<p>Ps: 由于STL中 multiset 一删删一串的zz性质，改用map了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 233</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mark, d, w ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> time_node &amp;T) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> w &gt; T.w || (w == T.w &amp;&amp; d &gt; T.d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; base[MAXN] ;</span><br><span class="line"><span class="built_in">map</span> &lt;time_node, <span class="keyword">int</span>&gt; M_set ;</span><br><span class="line"><span class="built_in">vector</span>&lt;time_node&gt;Time[MAXN] ; <span class="keyword">long</span> <span class="keyword">long</span> Ans ;</span><br><span class="line"><span class="keyword">int</span> N, M, K, A, B, C, D, i, j ; <span class="keyword">long</span> <span class="keyword">long</span> dp[MAXN][MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;A, &amp;B, &amp;C, &amp;D),</span><br><span class="line">        Time[A].push_back((time_node)&#123;<span class="number">1</span>, C, D&#125;) ;</span><br><span class="line">        Time[B + <span class="number">1</span>].push_back((time_node)&#123;<span class="number">2</span>, C, D&#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> tot = Time[i].size() ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; tot ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (Time[i][j].mark == <span class="number">1</span>) ++ M_set[Time[i][j]] ;</span><br><span class="line">            <span class="keyword">else</span> M_set[Time[i][j]] &gt; <span class="number">1</span> ?</span><br><span class="line">                 M_set[Time[i][j]] -- : M_set.erase(Time[i][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (M_set.size())</span><br><span class="line">            base[i] = (*M_set.begin()).first ;</span><br><span class="line">        <span class="keyword">else</span> base[i] = (time_node)&#123;<span class="number">0</span>, i, <span class="number">0</span>&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    Ans = dp[<span class="number">1</span>][<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">            j &gt; <span class="number">0</span> ? dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j]) : <span class="number">1</span> ;</span><br><span class="line">            dp[base[i].d][j] = min(dp[base[i].d][j], dp[i - <span class="number">1</span>][j] + base[i].w) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        Ans = min(Ans, dp[N][i]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="string">'\n'</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-Lunar-New-Year-and-a-Recursive-Sequence"><a href="#F-Lunar-New-Year-and-a-Recursive-Sequence" class="headerlink" title="F Lunar New Year and a Recursive Sequence"></a>F Lunar New Year and a Recursive Sequence</h1><blockquote>
<p>给你一个序列 $F$ 的 $k$ 项的递推法则（幂次/积式递推），在认定前 $k-1$ 项都满足 $F_x=1$ 的基础上给定 $F_n$，让你倒推出 $F_k$ 来。</p>
</blockquote>
<p>恕我直言…这道题我考场上是不可能会的…（已扑街</p>
<p>首先我们观察一般形式：</p>
<script type="math/tex; mode=display">
F_x = \begin{cases}1 \ , & (x<k) \newline ? \ , & (x = k) \newline \prod\limits_{j=1}^kF_{x-j}^{b_j}  ,  & (x>k)\end{cases} \  \pmod {998,244,353}</script><p>大体上这个式子是没法做的，因为毕竟是乘积+幂次方递推的形式。但是这个地方有个<del>我没想出来、想出来也不会用的</del>  Idea​，就是我们既然要把乘积转化成求和的形式，那就只能在指数上乱搞。换句话说，我们可以考虑把它的每一项都写成同一个数的幂次，那么递推的时候只需要做加法就可以了。</p>
<p>我们选择 $998,244,353$ 的<strong>原根</strong>作为底数。因为原根有一个很优美的性质，就是 <strong>$p$ 的原根的幂次可以遍历 $p$ 的简化剩余系</strong>。</p>
<p>而由 NTT 得到的经验可知，这个模数的最小原根是 3。</p>
<hr>
<p>原根的基本定义：设 $g$ 为 $p$ 的一个原根，则满足：</p>
<script type="math/tex; mode=display">
g^{𝑝−1}  \equiv 1 \pmod p\\
∀1≤k<p−1, g^k \not \equiv 1 \pmod p</script><hr>
<p>由于原根的优秀性质，所以可以将这个式子转化成如下形式：</p>
<script type="math/tex; mode=display">
g^{l_x} \equiv \prod \limits_{i=1}^{k}g^{b_il_{x-i}} \pmod p</script><p>此处是因为 $998244353$ 是一个质数，所以任何 $F$ 在 $\bmod 998244353$ 的意义下都可以被其原根的幂次表示出来。</p>
<p>同时由于指数上的 $l_x$ 满足 </p>
<script type="math/tex; mode=display">
l_x \equiv \sum\limits_{i=1}^{k}b_il_{x-i} \pmod {p-1}</script><p>这就是一个线性递推的形式了，根据扩展欧拉定理可知应该对 $p-1$ 取模 。</p>
<p>另一方面， $l_n$ 是可以通过解</p>
<script type="math/tex; mode=display">
g^{l_n}\equiv F_n\pmod{p}</script><p>得到。这就是一个离散对数的形式。用 BSGS 求解即可。</p>
<p>那么在知道 $l_n$ 之后，虽然很难知道 $l_k$，但由于递推方式一致，很容易通过矩乘得到 $l_k\to l_n$ 是怎么变化的。同时观察题目性质可知</p>
<script type="math/tex; mode=display">
l_n = \pi_n l_k \pmod{p-1}</script><p>其中的 $\pi_n$ 是一个关于 $n$ 的常量因子。因为 $F_1,F_2,F_3\cdots,F_{k-1}$ 都为 $1$，所以 $l_i=0~(1 \leq i &lt;k)$ ，所以之后的项也只会跟 $l_k$ 有关。</p>
<p>那么现在就是</p>
<script type="math/tex; mode=display">
l_k\pi_n = l_n \pmod {p-1}</script><p>移个项可以得到</p>
<script type="math/tex; mode=display">
l_k \pi_n + t(p-1)= l_n</script><p>由于原题让求的是最小的正整数解，所以用一下 $exgcd$ 判一下是否有解就解决了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; Hash ;</span><br><span class="line"><span class="keyword">int</span> N, T, base[MAXN] ;</span><br><span class="line">LL Ft, Hn, Xs, Ans, X, Y, G  ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">    LL M[MAXN][MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(M, <span class="number">0</span>, <span class="keyword">sizeof</span>(M)) ;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) M[i][i] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">friend</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix&amp;A, <span class="keyword">const</span> Matrix &amp;B)&#123;</span><br><span class="line">        Matrix Ans ; Ans.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= N; ++ k)</span><br><span class="line">                    Ans.M[i][j] = (Ans.M[i][j] + A.M[i][k] * B.M[k][j]) % (Mod - <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> Ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">expow</span><span class="params">(Matrix T, LL P)</span></span>&#123;</span><br><span class="line">    Matrix Ans ; Ans.reset() ;</span><br><span class="line">    <span class="keyword">while</span> (P)&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &amp; <span class="number">1</span>) Ans = Ans * T ;</span><br><span class="line">        T = T * T, P &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    LL P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p - <span class="number">1</span>)) ;</span><br><span class="line">  	LL Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt;= P ; ++ j, (i *= x) %= p)</span><br><span class="line">      <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ;</span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p)</span><br><span class="line">      <span class="keyword">if</span> (Hash.count(i)) <span class="keyword">return</span> Hash[i] + j * P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123;x = <span class="number">1</span>, y = <span class="number">0</span> ; <span class="keyword">return</span> a ;&#125;</span><br><span class="line">    LL t = exgcd(b, a % b, y, x) ;  y -=  a / b * x ; <span class="keyword">return</span> t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL k = <span class="number">0</span>, p = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123; c = getchar() ; <span class="keyword">if</span> (c == <span class="string">'-'</span>) p = <span class="number">-1</span> ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">register</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) base[i] = qr() ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; Ft ;  Matrix lab ;  lab.clear() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) lab.M[i][i - <span class="number">1</span>] = <span class="number">1l</span>l  ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) lab.M[i][N] = <span class="number">1l</span>l * base[N -i + <span class="number">1</span>] ;</span><br><span class="line">    lab = expow(lab, T - N), Hn = bsgs(<span class="number">3</span>, Ft, Mod), Xs = lab.M[N][N] ;</span><br><span class="line">    G = exgcd(Xs, Mod - <span class="number">1</span>, X, Y) ; <span class="keyword">if</span> (Hn % G)  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">    X = (X % (Mod - <span class="number">1</span>) * (Hn / G) % (Mod - <span class="number">1</span>) + Mod - <span class="number">1</span>) % (Mod - <span class="number">1</span>) ;</span><br><span class="line">    Ans = expow(<span class="number">3</span>, X, Mod) ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>说实话，这是第一次做整套 CF 的题目…确实，千里挑一的题目就是比你谷上随便找几道题做来劲。$A\sim E$ 都还好，但是 F 实在是…看题解都要想半天的那种…尤其是这个解离散方根的东西…</p>
<p>rqy说 F 题是省选一轮的难度——虽然没说是 D几T几，但我感觉他的语气不像是在说一道很难的题……</p>
<p>完了，要跪了。</p>
<blockquote>
<p>奥赛文化课两爆炸，省选进队进你ma，指望着将来没学上，还不如收拾好铺盖早回家 。</p>
<p>​                                                    ——（pks《春日绝句》）</p>
</blockquote>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>BSGS/exBSGS</tag>
        <tag>动态规划/普通DP</tag>
        <tag>数学/线性代数/矩阵</tag>
        <tag>数学/阶与原根</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】拉格朗日插值法</title>
    <url>/2019/02/07/Lagrange-Formula/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好像初三的时候看选修4-6的课本看的一脸懵，这东西似乎是为数不多印象深刻的233</p>
<a id="more"></a>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98---9cf.svg" alt=""></p>
<h2 id="rm-0x01-Preface"><a href="#rm-0x01-Preface" class="headerlink" title="$\rm{0x01~~} Preface$"></a>$\rm{0x01~~} Preface$</h2><p><strong>插值($\rm Interpolaton$)</strong> 在多项式域中可以看做是<strong>求值$(\rm Evaluation)$</strong>的逆运算。插值基于代数基本定理：</p>
<blockquote>
<p>给定 $n+1$ 组确定的、本质不同的二元组$(x_i, y_i)$，满足 $F(x_i) = y_i$，可以逆向求出原 $n$ 次多项式 $F$。</p>
</blockquote>
<p>而其实，拉格朗日插值公式本身是标准的 $\Theta(n^2)$ 算法：</p>
<script type="math/tex; mode=display">
</script><p>或者不能称其为算法，是 $\Theta(n^2)$ 的运算过程或许会更准确一些。实际上该公式是构造出来的，所以没有多么繁琐的证明——</p>
<h2 id="rm-0x02-rm-Proof"><a href="#rm-0x02-rm-Proof" class="headerlink" title="$\rm{0x02}~~\rm{Proof}$"></a>$\rm{0x02}~~\rm{Proof}$</h2><h3 id="rm-Proof-of-Existence"><a href="#rm-Proof-of-Existence" class="headerlink" title="$\rm Proof ~of~Existence$"></a>$\rm Proof ~of~Existence$</h3><p>我们定义 $F(x)$ 为一在实数域上的 $n-1$ 次多项式。</p>
<p>首先我们需要构造一个对于第 $i$ 个二元组的特殊多项式 $L_i(x)$，满足</p>
<script type="math/tex; mode=display">
L_i(x_j) = \begin{cases}1, &\rm{i=j} \newline 0, & \rm{i \neq j}\end{cases}</script><p>那么我们所求的多项式 $F(x)$ 就可以这么计算出来：</p>
<script type="math/tex; mode=display">
F(x)  = \sum L_i(x_i)\cdot y_i</script><p>这个式子保证了我们对应的 $n$ 个二元组，$F(x)=y$ 恒成立。</p>
<p>那么对于$L_i(x)$，我们考虑由我们对$L_i(x)$的定义可以得出<script type="math/tex">L_i(x) = k_i(x-x_1)(x-x_2)\cdots(x-x_n)</script>其中不包含$x-x_i$这一因式。而由$L_i(x_i)=1$可知我们的比例系数</p>
<script type="math/tex; mode=display">
k_i=\frac{1}{(x_i-x_1)(x_i-x_2)\cdots(x_i - x_{i-1})(x_i - x_{i+1})\cdots(x_i-x_n)}</script><p>那么</p>
<script type="math/tex; mode=display">
L_i(x) = \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}</script><p>从而</p>
<script type="math/tex; mode=display">
F(x)=\sum L_i(x)\cdot y_i(x) = \sum y_i \cdot \prod\limits_{i=1, i \neq j}^{n}\frac{x - x_j}{x_i-x_j}</script><hr>
<h3 id="rm-Proof-of-Uniqueness-1"><a href="#rm-Proof-of-Uniqueness-1" class="headerlink" title="$\rm Proof~of~Uniqueness^{[1]}$"></a>$\rm Proof~of~Uniqueness^{[1]}$</h3><p>接下来要证明的是多项式 $L_i(x)$  的唯一性</p>
<p>假设同时有两个实数域上的 $n-1$ 次多项式 $L_1(x),L_2(x)$ 满足 </p>
<script type="math/tex; mode=display">
L_i(x_j) = \begin{cases}1, &\rm{i=j} \\ 0, & \rm{i \neq j}\end{cases}</script><p>那么我们由作差法可以得出多项式 $L_{\Delta} = L_1 - L_2$ 在取所有的 $x_i$ 时，其值均为 $0$ 。那么一定会有多项式</p>
<script type="math/tex; mode=display">
L'(x) = \prod\limits_{i=1}^{n}(x - x_i)</script><p>满足</p>
<script type="math/tex; mode=display">
L'|L_{\Delta}</script><p>其中 $|$ 表示多项式整除。但是我们知道，对于 $L’$ 这个多项式，其次数为 $n$ ；而对于我们所定义的 $L_i(x)$ ，均为 $n-1$ 次的，从而 $L_{\Delta}$ 也是 $n-1$ 次多项式。所以我们可以得出</p>
<script type="math/tex; mode=display">
L_{\Delta} = 0</script><p>从而有</p>
<script type="math/tex; mode=display">
L_1=L_2</script><h2 id="rm-0x03-color-red-C-color-cyan-o-color-gold-d-color-green-e"><a href="#rm-0x03-color-red-C-color-cyan-o-color-gold-d-color-green-e" class="headerlink" title="$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$"></a>$\rm{0x03~\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}}$</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题号：Luogu4781</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; LL Ans, xs ;</span><br><span class="line"><span class="keyword">int</span> N, i, j ; LL T, t, xv[MAXN], yv[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (B)&#123;</span><br><span class="line">        <span class="keyword">if</span> (B &amp; <span class="number">1</span>) (res *= A) %= Mod ; </span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>, (A *= A) %= Mod ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;xv[i], &amp;yv[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        t = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">            (t *= (xv[i] - xv[j] + Mod)) %= Mod ;</span><br><span class="line">        &#125;</span><br><span class="line">        t = expow(t, Mod - <span class="number">2</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span> ;</span><br><span class="line">            (t *= (T - xv[j] + Mod)) %= Mod ;</span><br><span class="line">        &#125;</span><br><span class="line">        (t *= yv[i]) %= Mod, (Ans += t) %= Mod ;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; Ans &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04-一道水题"><a href="#0x04-一道水题" class="headerlink" title="$0x04$ 一道水题"></a>$0x04$ 一道水题</h2><p>题意大概就是给出连续的一段 $x_0$ 和 $y_0$ ，算出多项式 $F(x)$ 在一个特定值 $x_0’$ 时的值。</p>
<p>注意到 $40 \%$ 的数据可以直接高消，列出 $n+1$ 个方程。同时还可以用朴素的拉格朗日插值法插出 $80pts$ 的好成绩。而对于 $100 \%$ 的数据，$n$ 是 $1e5$ 级别的，所以考虑预处理出一些东西。</p>
<p>观察拉格朗日插值公式的一般形式：</p>
<script type="math/tex; mode=display">
F(x) = \sum \limits _{i=0}^{N} y_i \cdot \prod \limits_{i \neq j} \frac{x -x_j}{x_i-x_j}</script><p>我们发现首先分子可以 $O(n)$ 预处理，而分母由于 $x_j$ 是连续的，所以</p>
<script type="math/tex; mode=display">
{\prod \limits _{i \neq j} (x_i  - x_j)}= \rm fac(i) \cdot fac(n-i) \cdot evenmark(n-i)</script><p>其中$\rm fac$表示求阶乘，$\rm{evenmark}(x)$ 是符号函数，当 $x$ 是偶数时返回 $1$，否则返回 $-1$ 。</p>
<p>于是我们就可以得出一个式子：</p>
<script type="math/tex; mode=display">
F(x) = \sum \limits_{i=0}^{n}{y_i \cdot}\frac{\frac{Pre}{x-x_i}}{\rm fac(i) \cdot fac(n-i) \cdot evenmark(n-i)}</script><p>其中 $\frac{Pre}{x-x_i}$ 的缘由是分母上没有 $x-x_i$ 这一项。</p>
<p>取模啥的就小费马搞一搞即可，最终复杂度 $\Theta(n \log n)$ .</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL A, LL B)</span></span>&#123;</span><br><span class="line">	LL res = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">while</span> (B)&#123;</span><br><span class="line">		<span class="keyword">if</span> (B &amp; <span class="number">1</span>) (res *= A) %= Mod ; </span><br><span class="line">		B &gt;&gt;= <span class="number">1</span>, (A *= A) %= Mod ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">get_symbol</span><span class="params">(LL x)</span></span>&#123; <span class="keyword">return</span> (!x ? <span class="number">1</span> : Mod - <span class="number">1</span>) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ; Fac[<span class="number">0</span>] = qwq = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]), (Fac[i + <span class="number">1</span>] = Fac[i] * (i + <span class="number">1</span>)) %= Mod ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ; Ans = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (T &lt;= N) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, base[T]) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) (qwq *= (T - i + Mod)) %= Mod ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">		M = (N - i) &amp; <span class="number">1</span>, _qwq = qwq * expow((T - i), Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line">		t = expow(Fac[i] * Fac[N - i] % Mod, Mod - <span class="number">2</span>) % Mod ; </span><br><span class="line">		t = t * (get_symbol(M) * _qwq % Mod) % Mod, t = (t * base[i]) % Mod ;</span><br><span class="line">		(Ans += t)  %= Mod ;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; Ans &lt;&lt; endl ;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul>
<li>$[1] $:Angel_Kitty的$blog$《拉格朗日插值法》 <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>多项式基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】BSGS算法初探</title>
    <url>/2019/02/06/BSGS-junior/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一类 $a^x\equiv b\pmod p$，且 $p$ 为素数时的同余式解法。</p>
<a id="more"></a>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98---9cf.svg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>BSGS(Baby Step Giant Step), 大步小步法</strong>。也被叫做<strong>拔山盖世</strong>、<strong>北上广深</strong>算法……咳，这并不重要。形式化地讲， $\rm{BSGS}$算法主要用来解决以下问题 :</p>
<blockquote>
<p>给定质数 $p$ ， 整数 $a, b$, $(a, p)=1$. 求最小的非负整数 $x$, 使得 $a^x≡ b\pmod p$。</p>
</blockquote>
<p>由欧拉定理可知 $a ^{\varphi(p)} ≡ 1 \pmod p$，并且还有 $a^0≡1 \pmod p$，所以我们可以得出一个断言：</p>
<blockquote>
<p> 如果方程 $a^x≡ b \pmod p$ 有最小非负整数解，那么该解一定在 $[0, \varphi(p))$ 中。 $\qquad (1) $</p>
</blockquote>
<p>此处肉眼可以看出其循环节为 $\varphi(p)$，不再证明。</p>
<p>之后我们将以此为基础进行类似分块的操作：</p>
<h1 id="Baby-Step-Giant-Step"><a href="#Baby-Step-Giant-Step" class="headerlink" title="Baby Step Giant Step"></a>Baby Step Giant Step</h1><p>首先我们记 $n=\sqrt {\varphi(p)}$，那么 $\forall x \in [0, \varphi(p)), x = i\times m+j$ 有</p>
<script type="math/tex; mode=display">
i \leq  \lfloor \frac{\varphi(p)-m}{m} \rfloor,~~ 0≤j <m</script><p>那么对于原方程，我们可以把其改为</p>
<script type="math/tex; mode=display">
a^{i\cdot n+j}≡ b\pmod p</script><p>移一下项就可以变成</p>
<script type="math/tex; mode=display">
a^j ≡b \cdot a^{-i\cdot n} \pmod p</script><p>那么现在我们的策略是算出所有 $a^j$ 来，在$\bmod p$  意义下观察是否有一个 $i$ 可以使得 </p>
<script type="math/tex; mode=display">
a^j ≡ b \cdot a^{-i\cdot n} \pmod p</script><p>我们称左边枚举 $a^j$ 叫做 <strong>小步 (Baby Step)​</strong>，称右边枚举 $b \cdot a^{-i\cdot n}$ 叫做 <strong>大步(Giant Step)</strong> 。</p>
<p>那么其实算法流程很明晰了，我们只需要循环两次。第一次记录的 $a^j$ 用哈希表(STL 的 <code>unordered_ map</code>)记录一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), Hash.clear(), Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="comment">//a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ;</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; P ; ++ j, (i *= x) %= p) </span><br><span class="line">        <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ; <span class="comment">// Push them into hash_table</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p) </span><br><span class="line">        <span class="keyword">if</span> (Hash.count(i))&#123; <span class="built_in">cout</span> &lt;&lt; Hash[i] + j * P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中细节还是有的：</p>
<ul>
<li><p>计算 <code>sqrt</code> 时要上<strong>取整</strong>。</p>
</li>
<li><p>在求 $a^{-i\cdot n}$ 时用的底变量需要由费马小定理求快速幂得出。但是此时指数上可能为负数，所以我们选择加上一个模数，不影响结果。</p>
</li>
<li>两次循环枚举的边界要注意有的是 $\leq$ 有的是 $&lt;$ 。</li>
<li>算法还没开始时，要判断本身 $a$ 是否可以被 $P$ 整除。如果不特判这种情况的话，我们上面代码中的 <code>Q</code> 就会<code>= 0</code>，从而在下面的第二个循环处出错——我们的 <code>hash[i]</code> 和 <code>j</code> 不能同时为 $0$ ，从而输出错误的答案。</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="LG-P4028"><a href="#LG-P4028" class="headerlink" title="LG P4028"></a><a href="https://www.luogu.org/problemnew/show/P4028" target="_blank" rel="noopener">LG P4028</a></h2><p>裸题，但是有很多坑……或者说上面列举的细节都涵盖了qaq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tr1 ; <span class="keyword">int</span> T ;</span><br><span class="line">LL A, B, M, P, Q ; <span class="built_in">unordered_map</span> &lt;LL, LL&gt; Hash ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">expow</span><span class="params">(LL a, LL b, LL p)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            (res *= a) %= p ;</span><br><span class="line">        (a *= a) %= p, b &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bsgs</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    P = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), Hash.clear(), Q = expow(x, -P + <span class="number">2</span> *(p - <span class="number">1</span>), p) ;</span><br><span class="line">    <span class="comment">//a ^ (p-1) = 1 (mod p) =&gt; Q = a^(-P) = a ^(-P + p -1) ;</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span>, j = <span class="number">0</span> ; j &lt; P ; ++ j, (i *= x) %= p) </span><br><span class="line">        <span class="keyword">if</span> (!Hash.count(i)) Hash[i] = j ; <span class="comment">// Push them into hash_table</span></span><br><span class="line">    <span class="keyword">for</span> (LL i = y, j = <span class="number">0</span>  ; j &lt;= P ; ++ j, (i *= Q) %= p) </span><br><span class="line">        <span class="keyword">if</span> (Hash.count(i))&#123; <span class="built_in">cout</span> &lt;&lt; Hash[i] + j * P &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't Produce!"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        M = qr(), A = qr(), B = qr() ;</span><br><span class="line">        <span class="keyword">if</span> (!(A % M == <span class="number">0</span> &amp;&amp; B)) bsgs(A, B, M) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Couldn't Produce!"</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TJOI2007-CutePrime​"><a href="#TJOI2007-CutePrime​" class="headerlink" title="[TJOI2007] CutePrime​"></a><a href="https://www.luogu.org/problemnew/show/P3846" target="_blank" rel="noopener">[TJOI2007] CutePrime​</a></h2><p>最裸最裸的、无特判的题……可以水一下双倍经验。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这可能是我来培训第一个听的比较懂的算法了，撒花~</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>BSGS</category>
      </categories>
      <tags>
        <tag>技巧/分块</tag>
        <tag>BSGS/exBSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】LCT初步</title>
    <url>/2019/02/04/LCT-s-Junior-Intro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一种以 $ \rm Splay $ 作为辅助树的、动态维护森林连通性的算法。</p>
<a id="more"></a>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt=""></p>
<h1 id="rm-0x01-闲话-·-rm-LCT-的用途以及具体思路"><a href="#rm-0x01-闲话-·-rm-LCT-的用途以及具体思路" class="headerlink" title="$ \rm{0x01} $  闲话 ·  $\rm LCT$ 的用途以及具体思路"></a>$ \rm{0x01} $  闲话 ·  $\rm LCT$ 的用途以及具体思路</h1><p>咳，其实在我最近只是浅浅地学了一部分的基础上，窝觉得 $\rm LCT$ 其实就是一个用来维护<strong>森林连通性</strong>的。</p>
<p>嗯……因为其独特的性质所以也可以顺便维护好多东西，什么链上的最大值啊，链上的权值和啊……都可以维护——或者说，$\rm LCT$ 是更加全能的树剖。</p>
<p>但其实吧…… $ \rm LCT $ 打板子是很简单的，但是真正理解却一点儿也不简单。因为本身 $\rm splay$ 就很麻烦了，况且 $\rm splay$ 之前一直用于维护数列。要知道，此处的 $\rm splay$ 可是作为<strong>辅助树</strong>，维护一整个森林，并且可以支持序列中几乎全部操作——这就大大增高了理解难度。举个例子，你曾经认为已经难以理解、或者说不可以做的、比较复杂的区间翻转<a href="https://www.luogu.org/problemnew/show/P3391" target="_blank" rel="noopener"> $\rm Luogu3391 $ </a>，在 $\rm LCT$ 里面有十分全面的涉及，但是被精简到了只有两行是用来描述这个内容的。显而易见的是， $\rm LCT $ 虽然常数十分的大，但代码十分的短，比一棵完整的平衡树短了不少（实测50+行），与 $ \rm FFT $ 一样具有着华丽的可观赏性，但是隐藏在之后的思维难度同样不可小觑。</p>
<p>也就是说我们是不是学的太草率、太浮躁了呢？快餐式地学完 $\rm LCT$ ，网上的每一篇博客都包教包会。但是我今天要整理的，是对于 $ \rm LCT $ 真正的理解。希望各位看到这篇拙作的人可以获得一些什么。</p>
<h1 id="rm-0x02-闲话-·-关于-rm-splay"><a href="#rm-0x02-闲话-·-关于-rm-splay" class="headerlink" title="$ \rm{0x02} $  闲话 · 关于 $ \rm{splay} $"></a>$ \rm{0x02} $  闲话 · 关于 $ \rm{splay} $</h1><p>道理我都懂，要想动态拆删一些东西，辅助树的形态可以改变是先决条件。看上去平衡树好像是个不错的选择，但是，选哪个作为辅助树呢？<del>后宫佳丽三千我该翻谁的牌子呢</del></p>
<p>历史的重任最后落到了 $ \rm{splay} $ 的身上。然后 $ \rm{splay} $ 他居然：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="t1.jpg" alt=""></p>
<p>他甚至还：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="t2.png" alt=""></p>
<p>……</p>
<p>好吧，由于某些<del>rqy也不知道的</del>原因，如果不用 $ \rm{splay} $ 的话，复杂度是均摊 $ \Theta(\rm{nlog^2n}) $ , 而用 $ \rm{splay} $ 就可以做到均摊 $ \Theta(\rm{nlogn}) $  ……但事实上，splay确实有他独特的性质，比如旋转到根啊之类的，比起其他种类的平衡树而言，更加适合 $\rm LCT$ </p>
<h1 id="rm-0x03-rm-LCT-的思路和基础操作"><a href="#rm-0x03-rm-LCT-的思路和基础操作" class="headerlink" title="$ \rm{0x03} $     $\rm LCT$ 的思路和基础操作"></a>$ \rm{0x03} $     $\rm LCT$ 的思路和基础操作</h1><h2 id="一-主要思路"><a href="#一-主要思路" class="headerlink" title="一 主要思路"></a>一 主要思路</h2><p>主要思路嘛……大概是基于<strong>实链剖分</strong>的操作。</p>
<p><strong>朴素的树剖是重链剖分</strong>，大体上就是将整棵树的链划分为轻边和重链，运用巧妙的性质做到 $ log $ 级别。而遗憾的是 $\rm LCT$ 维护的是森林的连通性，所以只能采用实链剖分。</p>
<p>而实链剖分大体上就是把边分为<strong>虚边</strong>和<strong>实边</strong>。其中实边串联起一个联通块，同一组实边存在、且仅存在于一棵 $ \rm{splay} $ 中。 $ \rm{splay} $ 和 $ \rm{splay} $ 之间由虚边相连。</p>
<p>实链剖分的好处呢？在于<strong>实链剖分是一种动态剖分</strong>，他可以<strong>随意改变边的虚实属性</strong>。而显然，重链剖分由于有着足够的理论依据和逻辑推演，所以轻重链是难以更改，或者说，不可更改的。So，实链剖分为动态树的动态打下了基础。</p>
<p>那么接下来我们来看一个 $\rm LCT$ 是如何定义的:</p>
<ul>
<li><p>0、本质上， $\rm LCT$  是一堆树，正如它的全称「$\rm Link-Cut~Trees$」，里面充斥着实边和虚边。每一棵单独的 $\rm Link-Cut ~Tree$ 用来维护一个连通块（原图中连通）。</p>
</li>
<li><p>1、首先，一棵  $\rm LCT$  管控的是一堆分散的点，点以几棵分散的 $\rm splay$ 的形式聚集。起初整棵 $\rm LCT$ 是没有任何联系的，各自为战，各自为根。接下来看到的 $ access $ 、 $ makeroot $ 等操作，都是在自己的联通块儿内部进行的操作。换句话讲， $\rm LCT$ 维护的是有根森林，即组成森林的每个联通块都有其唯一的根。</p>
</li>
<li><p>2、实边串联起一个联通块，同一组实边存在、且仅存在于一棵 $ \rm{splay} $ 中。 $ \rm{splay} $ 和 $ \rm{splay} $ 之间由虚边相连。只有实边是有效的，虚边可以被认为不存在。<strong>但是两种边都没有用到显式存储</strong>，都是通过splay中的 $ Son $ 数组和 $ Fa $ 数组访问的。但虚边和实边的存储有区别：</p>
</li>
<li><p>3、虚边是认父不认子，即如果 $ Fa[x]==y $ ，那么 $ y $ 不存 $ x $ 这个儿子，但是 $ x $ 存 $ y $ 这个父亲。这样做是为了可以 $ Access $ ——因为其实在 $ Access $ 的子函数 $\rm splay$ 里，发挥作用的实际上是 $ Fa $ 指针。</p>
</li>
<li><p>4、实边是完整的双向存储。</p>
</li>
<li><p>5、显然的是， $ \rm{splay} $ 中维护的是一条从上到下按在原树中深度严格递增的路径，且中序遍历 $ \rm{splay} $ 得到的每个点的深度序列严格递增。换句话讲，一个 $ \rm{splay} $ 里面不会出现在原联通块儿（树）中深度相同的两个点。在一棵 $ \rm{splay} $ 中，键值就是原树中的深度。</p>
</li>
<li><p>6、如果  $ x $  是它所在  $\rm splay$  的最左边的点，那么它在原森林里的父亲是  $ x $  所在  $\rm splay$  的根的  $ fa $ , 否则就是  $ x $  在  $\rm splay$  上的前驱。</p>
</li>
</ul>
<h2 id="二-基础操作"><a href="#二-基础操作" class="headerlink" title="二 基础操作"></a>二 基础操作</h2><p> $ emm $ 所谓基础操作大概就是每个用到 $\rm LCT$ 的题几乎都要用到的操作。我们把  $ n $  以实边相连的儿子记作实儿子，否则记为虚儿子。</p>
<p>同时值得注意的是，$\rm Access$、$\rm Make~Root$ 、$\rm Find~Root$ 和 $\rm Merge$ 操作都是针对<strong>一棵</strong> $lct$ 的操作，而 $\rm Link$ 和 $\rm Cut$ 则是针对一整片 $lct$ 森林，可以看做“分裂/合并两个 $\rm LCT$”。    </p>
<p>至于连通块的根，可以看做是给无根树强行钦定的一个根，即原图里的根（似乎可以结合并查集理解？</p>
<ul>
<li><h2 id="rm-1-rm-Access"><a href="#rm-1-rm-Access" class="headerlink" title="$ \rm{1} $ $\rm Access $"></a>$ \rm{1} $ $\rm Access $</h2></li>
</ul>
<p>这个操作有着很迷的性质，其时间复杂度是均摊  $ \log n $  的。而这个操作的目的是 <strong>$ Access(n) $  表示从  $ root $  向  $ n $  打通一条实链，并以  $ n $  点为最深度最大的点、 $ root $  为深度最小的点形成一棵 $ \rm{splay} $ </strong>。</p>
<p>不难看出，这个操作其实就是把原来  $\rm splay$  的割据给改变了。</p>
<p>我们思考，如果此时我们  $ Access $  完点  $ n $  之后，理论上来讲， $ n $  点应该不再有实儿子了——显然，如果有实儿子的话， $\rm splay$  中是应该包含这个实儿子的——而这就不符合  $ n $  是  $ \rm{splay} $  中深度最大的点的性质了。而因为在  $ \rm splay $  中，点是以深度为键值的，所以我们要每次砍掉 $ \rm{splay} $ 中的右儿子——即砍掉原来的实儿子，并把刚刚诞生的  $ \rm{splay} $  连上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> qwq = <span class="number">0</span> ; x ; x = T[qwq = x].F) </span><br><span class="line">		splay(x), rc = qwq, update(x) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这就是 $\rm Access $ 了。</p>
<ul>
<li><h2 id="rm-2-Make-Root"><a href="#rm-2-Make-Root" class="headerlink" title="$\rm 2 ~Make~ Root~ $"></a>$\rm 2 ~Make~ Root~ $</h2></li>
</ul>
<p>这个操作的目的是把一个节点变成  $ lct$  的根节点。</p>
<p>先从  $ root $  向  $ n $  打通一条路径，然后  $\rm splay$  上去，最后  $ reverse $  一下。此处由于一开始  $ n $  的深度最大， $\rm splay$  之后深度依旧最大，但此时  $ n $  是  $\rm splay$  的根，所以  $ reverse(n) $  就相当于翻转了整条树上的链，那么翻转之后， $ n $  的深度就变成了最小，于是就是这个联通块儿的根节点了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> F, Son[<span class="number">2</span>], R, S ;</span><br><span class="line">&#125;T[MAXN] ; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; lc ^= rc ^= lc ^= rc, T[x].R ^= <span class="number">1</span> ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">if</span> (!T[x].R) <span class="keyword">return</span> ; T[x].R = <span class="number">0</span> ; <span class="keyword">if</span> (lc) reverse(lc) ; <span class="keyword">if</span> (rc) reverse(rc) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rooten</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Access(x), splay(x), reverse(x) ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> qwq = x ; stk.push(qwq) ;</span><br><span class="line">	<span class="keyword">while</span>(check(qwq)) qwq = T[qwq].F, stk.push(qwq) ;</span><br><span class="line">	<span class="keyword">while</span>(!stk.empty()) push_down(stk.top()), stk.pop() ;</span><br><span class="line">	<span class="keyword">while</span>(check(x))&#123;</span><br><span class="line">	<span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F ;</span><br><span class="line">	<span class="keyword">if</span> (check(fa)) rotate((T[g_fa].Son[<span class="number">1</span>] == fa) == (T[fa].Son[<span class="number">1</span>] == x) ? fa : x) ; rotate(x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处 $\rm splay$ 中由于<strong>要下放标记，需要保证树的形态是正确</strong>的，所以我们用一个 $ stack $ 存一下，顺序下放标记。</p>
<ul>
<li><h2 id="rm-3-Merge"><a href="#rm-3-Merge" class="headerlink" title="$\rm 3 ~Merge~ $"></a>$\rm 3 ~Merge~ $</h2></li>
</ul>
<p>此处的 $\rm Merge(x, y) $ 的意义是，拉起 $ x,y $ 中间的链，形成一个 $\rm splay$ 。这里就直接 $ Mkroot $ 一遍，然后 $ Access $ 即可。让哪个点当根应该都可以，只不过多 $\rm splay$ 几次可以保证优（毒）秀（瘤）的复（大）杂（常）度（数）。</p>
<p>upd：此处 $\rm splay$ 还有深层次的意图，就是可以保证现在 $ x $ 和 $ y $ 是相邻的，这样在cut的时候就会很方便了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; Rooten(x), Access(y), splay(y) ; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h2 id="rm-4-Link-amp-Cut"><a href="#rm-4-Link-amp-Cut" class="headerlink" title="$\rm 4~Link~\&amp;~Cut $"></a>$\rm 4~Link~\&amp;~Cut $</h2></li>
</ul>
<p>如果保证 $ \rm Link $ 和 $ \rm Cut $ 都是合法的操作的话， $ \rm Link $ 直接连， $ \rm Cut $ 直接删即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Merge(x, y) ; T[x].F = T[y].Son[<span class="number">0</span>] = <span class="number">0</span> ;&#125;</span><br></pre></td></tr></table></figure>
<p>此处 $\rm Link$ 必须先 $ \rm Mkroot $ 一下，否则树链就断了。连的是虚边（因为连实边就会改变原来 $\rm splay$ 的割据）； $ \rm Cut $ 必须先 $\rm Merge$ 一下，保证两个点之间在同一棵 $\rm splay$ 中，加之我们的 $ Merge $ 操作中，一开始把 $ x $ 给 $ mkroot $ 了，再把 $ y $ 点 $\rm splay$ 上去，直接导致了现在 $ x $ 应该是 $ y $ 的孩子——于是就很开心的，可以直接 $\rm Cut$ 了。       </p>
<p>但事实上，天不遂人意……有时候这条边并不存在，盲目删除的话会导致 $ GG $ ，盲目连边的话也会导致树的形态爆炸，所以我们要进行一波操作……</p>
<ul>
<li>1、 $\text{ New-Link }$  </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; Rooten(x) ; <span class="keyword">if</span>(Find(y) != x) T[x].F = y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; Access(x), splay(x) ; <span class="keyword">while</span>(lc) push_down(x), x = lc ; splay(x) ; <span class="keyword">return</span> x ;&#125;</span><br></pre></td></tr></table></figure>
<p>此处的意义在于，如果我们发现两个点在一个子树里面，连接它们就破坏了树的性质。 $ \rm Find $ 则是找到这个 $lct$ 维护的连通块内的根。 </p>
<p>但要注意啊， $ Find $ 找的是原树中的根，不是 $\rm splay$ 。由于原树中根的深度一定最小，所以应该是 $\rm splay$ 中最靠左的点……所以不断找左儿子。</p>
<p>多 $ BB $ 一句，这个地方一定注意啊！ $ Find $ 只改变了 $\rm splay$ 的形态， $ mkroot $ 改变的是原树中的根</p>
<ul>
<li>2、 $\text{New-Cut}$ </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123; </span><br><span class="line">	Rooten(x) ; </span><br><span class="line">	<span class="keyword">if</span> (Find(y) != x || T[y].Son[<span class="number">0</span>] || T[y].F != x) <span class="keyword">return</span> ; </span><br><span class="line">	T[y].F = T[x].Son[<span class="number">1</span>] = <span class="number">0</span>, update(x) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处首先我们要判一下这两个点是不是直接相连。是否直接相连……在一棵 $\rm splay$ 中的体现，要克服两个问题，第一是要判断是否连通，还是 $ Find $ 操作。</p>
<p>之后我们需要判断是否满足恰好相隔一条边——注意，首先因为代码中的 $ x $ 比 $ y $ 在原树位置靠上（ $ Rooten $ 了 $ x $ ），在 $\rm splay$ 中靠左，那么如果 $ y $ 有左儿子的话，说明一定有</p>
<script type="math/tex; mode=display">
\rm Depth(x) < Depth(y\text{的左儿子们})  < Depth(y)</script><p>其中 $\rm depth$ 表示原树深度。那么此时原树中 $ x $ 和 $ y $ 之间，一定隔着一些节点。考虑树的性质，两点之间有且仅有一条简单路径——所以当 $\rm T[y].son[0] $ 不指向 $ Null $ 时， $ x $ 和 $ y $ 之间没有一条边，不能直接 $\rm Cut$ 。</p>
<p>剩下的就很简单了， $\rm T[y].F $ 应该是 $ x $ ，否则也不是直接相连。</p>
<ul>
<li><h2 id="5-rm-Rotate-中的坑点"><a href="#5-rm-Rotate-中的坑点" class="headerlink" title="5  $\rm ~Rotate $ 中的坑点"></a>5  $\rm ~Rotate $ 中的坑点</h2></li>
</ul>
<p>呃……其实就一处而已。就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> T[T[x].F].Son[<span class="number">0</span>] == x || T[T[x].F].Son[<span class="number">1</span>] == x ;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fa = T[x].F, g_fa = T[fa].F, W = x == T[fa].Son[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">if</span> (check(fa)) T[g_fa].Son[T[g_fa].Son[<span class="number">1</span>] == fa] = x ; T[x].F = g_fa ;</span><br><span class="line">	T[fa].Son[W] = T[x].Son[W ^ <span class="number">1</span>], T[T[x].Son[W ^ <span class="number">1</span>]].F = fa, T[fa].F = x</span><br><span class="line">  T[x].Son[W ^ <span class="number">1</span>] = fa, update(fa), update(x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方 $\rm splay$ 双旋判断祖父的时候，不再用 $ \rm{if(g\text{_}fa)} $ ，而是用 $ \rm{if(check(fa))} $ 。原因很简单，我们的虚边也是有指向父亲的指针的，但是连接两个不同的 $\rm splay$ </p>
<p>剩下的……大概就没了吧……</p>
<p>于是——</p>
<h1 id="color-red-C-color-cyan-o-color-gold-d-color-green-e"><a href="#color-red-C-color-cyan-o-color-gold-d-color-green-e" class="headerlink" title="$ \color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e} $"></a>$ \color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e} $</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目名称：UOJ#3 「NOI2014」魔法森林</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gcr getchar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr(k) E[k].fr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va(k) E[k].va</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vb(k) E[k].vb</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fa(x) t[x].fa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rv(x) t[x].rev</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) t[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) t[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">400010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1000000008</span> ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCT</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa ;</span><br><span class="line">    <span class="keyword">bool</span> rev ;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] ;</span><br><span class="line">&#125;t[N] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> va, vb ;</span><br><span class="line">    <span class="keyword">int</span> fr, to ;</span><br><span class="line">&#125;E[M] ;</span><br><span class="line"><span class="keyword">int</span> ans ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"><span class="keyword">int</span> f[N] ;</span><br><span class="line"><span class="keyword">int</span> sz[N] ;</span><br><span class="line"><span class="keyword">int</span> val[N] ;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge a, Edge b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.va &lt; b.va ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">bool</span> <span class="title">notroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (lc(fa(x)) == x) || (rc(fa(x)) == x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    rv(x) ^= <span class="number">1</span> ; swap(lc(x), rc(x)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    val[x] = x ;</span><br><span class="line">    <span class="keyword">if</span> (vb(val[x]) &lt; vb(val[lc(x)])) val[x] = val[lc(x)] ;</span><br><span class="line">    <span class="keyword">if</span> (vb(val[x]) &lt; vb(val[rc(x)])) val[x] = val[rc(x)] ;</span><br><span class="line">&#125;</span><br><span class="line">il <span class="keyword">void</span> _down(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">if</span> (rv(x))&#123;</span><br><span class="line">        rv(x) = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span> (lc(x)) reverse(lc(x)) ;</span><br><span class="line">        <span class="keyword">if</span> (rc(x)) reverse(rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = x == rc(fa(x)) ;</span><br><span class="line">    <span class="keyword">int</span> f1 = fa(x), f2 = fa(f1) ;</span><br><span class="line">    <span class="keyword">if</span> (notroot(f1))</span><br><span class="line">        t[f2].son[f1 == rc(f2)] = x ;</span><br><span class="line">    fa(x) = f2 ; fa(f1) = x ;</span><br><span class="line">    fa(t[x].son[w ^ <span class="number">1</span>]) = f1 ;</span><br><span class="line">    t[f1].son[w] = t[x].son[w ^ <span class="number">1</span>] ;</span><br><span class="line">    t[x].son[w ^ <span class="number">1</span>] = f1 ;</span><br><span class="line">    update(f1), update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y ;</span><br><span class="line">    stk[++ tp] = y = x ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(y))</span><br><span class="line">        y = fa(y), stk[++ tp] = y ;</span><br><span class="line">    <span class="keyword">while</span> (tp) _down(stk[tp --]) ;</span><br><span class="line">    <span class="keyword">while</span> (notroot(x))&#123;</span><br><span class="line">        <span class="keyword">int</span> f1 = fa(x) ;</span><br><span class="line">        <span class="keyword">int</span> f2 = fa(f1) ;</span><br><span class="line">        <span class="keyword">if</span> (notroot(f1))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((f1 == rc(f2)) == (rc(f1) == x))</span><br><span class="line">                rotate(f1) ; <span class="keyword">else</span> rotate(x) ;</span><br><span class="line">        &#125;</span><br><span class="line">        rotate(x) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">qr</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span> ; <span class="keyword">char</span> c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="string">'9'</span> || c &lt; <span class="string">'0'</span>) c = gcr() ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="number">48</span>, c = gcr() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> ( ; x ; x = fa(y = x))</span><br><span class="line">        splay(x), rc(x) = y, update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ; splay(x) ;</span><br><span class="line">    <span class="keyword">while</span> (lc(x)) x = lc(x) ;</span><br><span class="line">    <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x) ;</span><br><span class="line">    splay(x) ; reverse(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    make_root(x) ;</span><br><span class="line">    <span class="keyword">if</span> (find_root(y) != x)</span><br><span class="line">        <span class="keyword">return</span> fa(x) = y, <span class="keyword">void</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    make_root(x) ;</span><br><span class="line">    access(y) ; splay(y) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(to(x)) ; splay(x) ;</span><br><span class="line">    lc(x) = rc(x) = fa(lc(x)) = fa(rc(x)) = <span class="number">0</span> ;</span><br><span class="line">    update(x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = find(f[x]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; ans = MAX ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)</span><br><span class="line">        qr(fr(i)), qr(to(i)), qr(va(i)), qr(vb(i)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i) fr(i) += m, to(i) += m ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n + m + <span class="number">1</span> ; ++ i) f[i] = i ;</span><br><span class="line">    sort(E + <span class="number">1</span>, E + m + <span class="number">1</span>, comp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; ++ i)&#123;</span><br><span class="line">        rg <span class="keyword">int</span> f1, f2 ;</span><br><span class="line">        rg <span class="keyword">int</span> u = fr(i), v = to(i) ;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; val[i] &lt;&lt; endl ;</span></span><br><span class="line">        split(v, u) ;</span><br><span class="line">        f1 = find(u), f2 = find(v) ;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; f1 &lt;&lt; " " &lt;&lt; f2 &lt;&lt; endl ;</span></span><br><span class="line">        <span class="keyword">if</span> (f1 != f2)&#123;</span><br><span class="line">            link(u, i), link(v, i) ;</span><br><span class="line">            <span class="keyword">if</span> (sz[f1] &lt; sz[f2])</span><br><span class="line">                f[f1] = f2, sz[f2] += sz[f1] ;</span><br><span class="line">            <span class="keyword">else</span> f[f2] = f1, sz[f1] += sz[f2] ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vb(i) &lt; vb(val[u]))</span><br><span class="line">            cut(val[u]), link(u, i), link(v, i) ;</span><br><span class="line">        <span class="keyword">if</span> (find(m + <span class="number">1</span>) == find(m + n))</span><br><span class="line">            split(m + <span class="number">1</span>, n + m),</span><br><span class="line">            ans = Min(ans, va(i) + vb(val[n + m]) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans == MAX ? <span class="number">-1</span> : ans) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm-0x00-后记和参考"><a href="#rm-0x00-后记和参考" class="headerlink" title="$ \rm{0x00} $    后记和参考"></a>$ \rm{0x00} $    后记和参考</h1><p>可写完了……嗝……<del>打个肥宅嗝犒劳犒劳自己</del></p>
<p>怎么说呢，自从我开始学 $\rm LCT$ 到我写完这篇 $ blog $ 为止，是我十分难熬的时间，总时长接近一周。一开始看别人写的 $\rm LCT$ ，想当然地、草率地理解了理解，就开始打板子，对 $\rm LCT$ 一直是极为肤浅的认识。直到开始写，才发现自己哪个地方都不会，理解的半生不熟，总之很惨……</p>
<p>写博客真是一个陶冶情操的过程啊……<del>包括做表情包</del></p>
<p>加油吧， $ pks $ ！</p>
<h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$ \rm{Reference} $"></a>$ \rm{Reference} $</h2><ul>
<li>$ [1] $  : $\rm Flash\text{_}Hu $ 的 $ blog $  <a href="http://www.cnblogs.com/flashhu/p/8324551.html" target="_blank" rel="noopener"> $ ^{^{[\nearrow ]}} $ </a></li>
<li>$ [2] $  :某篇论文，结合食用效果显著 <a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb.html" target="_blank" rel="noopener"> $ ^{^{[\nearrow]}} $ </a></li>
</ul>
<h2 id="mathfrak-writter-pks"><a href="#mathfrak-writter-pks" class="headerlink" title="$ \mathfrak{writter:pks} $"></a>$ \mathfrak{writter:pks} $</h2>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Link-Cut Trees</category>
      </categories>
      <tags>
        <tag>数据结构/平衡树/splay</tag>
        <tag>数据结构/LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】左偏树</title>
    <url>/2019/01/27/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>只会写不会用系列.jpeg</p>
<a id="more"></a>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98-skyblue.svg" alt=""></p>
<p>嗯…就当作是复习了233…时隔好几个月（其实就两个月）才想起来要整理。</p>
<h1 id="关于左偏树"><a href="#关于左偏树" class="headerlink" title="关于左偏树"></a>关于左偏树</h1><p>首先是整理自己想出来的几个梗</p>
<ul>
<li>$\mathcal{To~be~(left) ~or~not ~to~be~(left), this~is ~a~question}$ 左偏还是右偏，这是个问题(哈姆雷特梗)。</li>
<li>Hell ! Where is my Left Leaning Tree? 该死，我的左偏树向右偏了。</li>
<li>左偏树是1个log，右偏树也是1个log，那我左右都偏是不是就会更快！(恭喜你建出了一棵满二叉树)</li>
<li>讲个鬼故事：每棵树都是下偏树。</li>
<li>其实，左耳离心脏更近，所以甜言蜜语麻烦合并到左偏树里吧。（《左耳》梗）</li>
</ul>
<p><del>好吧我承认不是很好笑</del></p>
<p>呐，下面进入正题。左偏树，一种<strong>可以合并的堆状结构</strong>，支持 <code>insert/remove/merge</code> 等操作。稳定的时间复杂度在 $\Theta(\log n)$ 的级别。对于一个左偏树中的节点，需要维护的值有 <code>dist</code> 和 <code>value</code>。其中 <code>value</code> 不必多说，<code>dist</code> 记录这个节点到它子树里面最近的叶子节点的距离，叶子节点距离为 0。</p>
<p>首先，他有以下几个喜闻乐见的性质：</p>
<blockquote>
<p>一个节点的 <code>value</code> 必定(或小于)左右儿子的 <code>value</code> <strong>（堆性质）</strong><br>一个节点的左儿子的 <code>dist</code> 不小于右儿子的 <code>dist</code> <strong>（左偏性质）</strong><br>一个节点的距离始终等于右儿子 +1 。</p>
</blockquote>
<p>那么这就可以推出以下性质：</p>
<blockquote>
<p>推论：任何时候，节点数为 $n$ 的左偏树，距离最大为 $\log (n+1)-1$ .</p>
</blockquote>
<script type="math/tex; mode=display">
\mathcal{Proof.}</script><p>对于一棵距离为定值 $k$ 的树，点数最少时，一定是一棵满二叉树。这是显然的。因为对于每个节点，如果想要有最少的儿子，那么起码要做到左儿子的数量等于右儿子的数量。那么对于他的逆命题也是成立的—— “若一棵左偏树的距离为 $k$，则这棵左偏树至少有 $2^{k+1}-1$ 个节点”。    </p>
<p>所以会有</p>
<script type="math/tex; mode=display">
n \geq 2^{k+1}-1\\\ \log_2{(n+1)} \geq k+1\\\ \log_2{(n+1)}-1 \geq k</script><script type="math/tex; mode=display">
\mathcal{Q.E.D}</script><p>emmm 这可是一个很美妙的性质啊。</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>这是整个左偏树的重头戏，时间复杂度稳定在一个 $\log$，其主要思想就是不断把新的堆合并到新的根节点的右子树中——因为我们的右子树决定“距离”这个变量，而距离又一定保证在 $\log$ 的复杂度内，所以不断向右子树合并。</p>
<p>大体思路(以小根堆为例)，首先我们假设两个节点 $x$ 和 $y$，$x$ 的根节点的权值小于等于 $y$ 的根节点（否则 <code>swap(x,y)</code>），把 $x$ 的根节点作为新树 $\rm Z$ 的根节点，剩下就是合并 $x$ 的右子树和 $y$ 了。</p>
<p>合并了 $x$ 的右子树和 $y$ 之后，当 $x$ 的右子树的距离大于 $x$ 的左子树的距离时，为了维护性质二，我们要交换 $x$ 的右子树和左子树。顺便维护性质三，所以直接 $dist_x = dist_{rson(x)}+1$ .</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ;</span><br><span class="line">    <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">	rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ;</span><br><span class="line">    S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们观察，我们是不断交替拆分右子树，由推论可得我们的距离不会大于</p>
<script type="math/tex; mode=display">
\Theta(\log(n_x+1))+\Theta(\log(n_y+1))-2 =O(\log n_x+ \log n_y)</script><p>这个地方比较喜闻乐见的是需要存$root$，即需要路径压缩。不路径压缩的话，寻一次$rt$就是$\Theta(n)$的了，复杂度是不对的 <del>但似乎Luogu的模板，不路径压缩会更快</del></p>
<h2 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h2><p>……$pop$的话，乱搞就好了$233$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; </span><br><span class="line">  S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到删除操作其实是把当前应该被删除的 $rt$ 当做了一个虚点，加入了新的没有 $rt$ 的子树内，这样就可以使得那些原来连在 $rt$ 上的点，再找一次 fa 的时候就会被路径压缩到新的根上。</p>
<p>然后就是总代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dis, val, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;S[MAXN] ; <span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">	rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		S[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line">		<span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line">			<span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">			<span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; <span class="keyword">if</span> (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一点问题"><a href="#一点问题" class="headerlink" title="一点问题"></a>一点问题</h1><p>问题大概就是路径压缩……</p>
<p><a href="https://www.luogu.org/problemnew/show/P3377" target="_blank" rel="noopener">$LuoguP3377$</a>很不负责任地处了数据，导致以下这份代码可以过：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, val, F, Son[<span class="number">2</span>] ;</span><br><span class="line">&#125;S[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">while</span>(S[x].F) x = S[x].F ; <span class="keyword">return</span> x ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].F = S[rs].F = <span class="number">0</span>, Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">    rs = Merge(rs, y), S[rs].F = x ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line">            <span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span> || B == C) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; Merge(f1, f2) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切都很正常，但问题在于他复杂度不对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">while</span>(S[x].F) x = S[x].F ; <span class="keyword">return</span> x ; &#125;</span><br></pre></td></tr></table></figure>
<p>这显然是个上界为$O(n)$的函数……不寒而栗……</p>
<p>所以他是不对的，<a href="https://www.luogu.org/discuss/show/96561" target="_blank" rel="noopener">这组数据</a>可以很好的卡掉（由巨佬小粉兔制作）。</p>
<p>所以应该用一个并查集维护。而我们在路径压缩之后，必须要在 $pop$ 后，给 $pop$ 掉的点一个指针指向新的根，所以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br></pre></td></tr></table></figure>
<p>于是最后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 150010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap my_swap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls S[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs S[x].Son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dis, val, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;S[MAXN] ; <span class="keyword">int</span> N, T, A, B, C, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123; x ^= y ^= x ^= y ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> S[x].rt == x ? x : S[x].rt = Get(S[x].rt) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; S[x].val = <span class="number">-1</span>, S[ls].rt = ls, S[rs].rt = rs, S[x].rt = Merge(ls, rs) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ; <span class="keyword">if</span> (S[x].val &gt; S[y].val || (S[x].val == S[y].val &amp;&amp; x &gt; y)) swap(x, y) ;</span><br><span class="line">	rs = Merge(rs, y) ; <span class="keyword">if</span> (S[ls].dis &lt; S[rs].dis) swap(ls, rs) ; S[ls].rt = S[rs].rt = S[x].rt = x, S[x].dis = S[rs].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; T ; S[<span class="number">0</span>].dis = <span class="number">-1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">		S[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;S[i].val) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ;</span><br><span class="line">		<span class="keyword">if</span> (A == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C) ;</span><br><span class="line">			<span class="keyword">if</span> (S[B].val == <span class="number">-1</span> || S[C].val == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">			<span class="keyword">int</span> f1 = Get(B), f2 = Get(C) ; <span class="keyword">if</span> (f1 != f2) S[f1].rt = S[f2].rt = Merge(f1, f2) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(S[B].val == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S[Get(B)].val), Pop(Get(B)) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一道水题"><a href="#一道水题" class="headerlink" title="一道水题"></a>一道水题</h1><p>无论怎么说，单独用一篇博客来整理板子题实在是太 Low 了（尤其是显得笔者很没品位），于是就直接拼到一起吧qwq</p>
<p><strong>[LuoguP1456]Monkey King</strong> <a href="https://www.luogu.org/problemnew/show/P1456" target="_blank" rel="noopener">链接</a></p>
<p>这玩意儿真tm水爆啊…直接存个代码证明我做过这道题吧qaq：</p>
<p>等会儿，突然想起来这道题的坑点来。就是原来的板子题，都是维护序列那种感觉，一个元素 pop 掉之后又就不用管它了。但是这道题是一道应用题，所以不应该删完不管，应该清空 qwq。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc T[x].Son[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc T[x].Son[1]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a, i, b) for(i = a ; i &lt;= b ; ++ i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Heap</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val, dis, Son[<span class="number">2</span>], rt ;</span><br><span class="line">&#125;T[MAXN] ; <span class="keyword">int</span> N, M, A, B, i ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == T[x].rt)  <span class="keyword">return</span> x ;</span><br><span class="line">	<span class="keyword">return</span> T[x].rt = get(T[x].rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ;</span><br><span class="line">	<span class="keyword">if</span> (T[x].val &lt; T[y].val) x ^= y ^= x ^= y ;</span><br><span class="line">	rc = Merge(rc, y) ; <span class="keyword">if</span> (T[lc].dis &lt; T[rc].dis) lc ^= rc ^= lc ^= rc ;</span><br><span class="line">	T[lc].rt = T[rc].rt = T[x].rt = x, T[x].dis = T[rc].dis + <span class="number">1</span> ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N))&#123;</span><br><span class="line">		<span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T)) ;</span><br><span class="line">		rep(<span class="number">1</span>, i, N) T[i].rt = i, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T[i].val) ; <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">		rep(<span class="number">1</span>, i, M)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B) ; <span class="keyword">int</span> rt1, rt2 ;</span><br><span class="line">			<span class="keyword">int</span> f1 = get(A), f2 = get(B) ; <span class="keyword">int</span> ff1, ff2 ;  </span><br><span class="line">			<span class="keyword">if</span> (f1 == f2) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">continue</span> ; &#125;</span><br><span class="line">			T[f1].val &gt;&gt;= <span class="number">1</span>, T[f2].val &gt;&gt;= <span class="number">1</span> ;  </span><br><span class="line">			rt1 = Merge(T[f1].Son[<span class="number">0</span>], T[f1].Son[<span class="number">1</span>]) ; </span><br><span class="line">			T[f1].Son[<span class="number">0</span>] = T[f1].Son[<span class="number">1</span>] = T[f1].dis = <span class="number">0</span> ; </span><br><span class="line">			rt2 = Merge(T[f2].Son[<span class="number">0</span>], T[f2].Son[<span class="number">1</span>]) ; </span><br><span class="line">			T[f2].Son[<span class="number">0</span>] = T[f2].Son[<span class="number">1</span>] = T[f2].dis = <span class="number">0</span> ; </span><br><span class="line">			ff1 = Merge(f1, rt1), ff2 = Merge(f2, rt2) ;</span><br><span class="line">			T[ff2].rt = T[ff1].rt = Merge(ff1, ff2) ;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[get(T[ff1].rt)].val) ; 	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>upd: 2020.4.15 重写了一遍，觉得还是这个码风看着比较顺眼。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ltree&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rt(x) s[x].rt</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lc(x) s[x].lc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rc(x) s[x].rc</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ds(x) s[x].dis</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> val(x) s[x].val</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> rt ;</span><br><span class="line">        <span class="keyword">int</span> lc ;</span><br><span class="line">        <span class="keyword">int</span> rc ;</span><br><span class="line">        <span class="keyword">int</span> val ;</span><br><span class="line">        <span class="keyword">int</span> dis ;</span><br><span class="line">    &#125;s[N] ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == rt(x)) <span class="keyword">return</span> x ;</span><br><span class="line">        <span class="keyword">return</span> rt(x) = find(rt(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y ;</span><br><span class="line">        <span class="keyword">if</span> (val(x) &gt; val(y)) swap(x, y) ;</span><br><span class="line">        rc(x) = merge(rc(x), y) ;</span><br><span class="line">        <span class="keyword">if</span> (ds(lc(x)) &lt; ds(rc(x))) swap(lc(x), rc(x)) ;</span><br><span class="line">        rt(lc(x)) = rt(rc(x)) = rt(x) = x ;</span><br><span class="line">        ds(x) = ds(rc(x)) + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">return</span> x ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">		val(x) = <span class="number">-1</span> ;</span><br><span class="line">        rt(lc(x)) = lc(x) ;</span><br><span class="line">        rt(rc(x)) = rc(x) ;</span><br><span class="line">        rt(x) = merge(lc(x), rc(x)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Ltree ;</span><br><span class="line"><span class="keyword">int</span> n, m ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>) ; <span class="built_in">cout</span>.tie(<span class="number">0</span>) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m ; <span class="keyword">int</span> k, x, y ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[s[i].rt = i].val, s[i].lc = s[i].rc = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; x ;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = val(find(x)) ;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; val(4) &lt;&lt; '\n' ;</span></span><br><span class="line">			<span class="keyword">if</span> (val(x) &lt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="string">'\n'</span> ;           </span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>, pop(find(x)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; y ; <span class="keyword">int</span> fx, fy ; </span><br><span class="line">            <span class="keyword">if</span> (!(~val(y))) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!(~val(x))) <span class="keyword">continue</span> ;</span><br><span class="line">			fx = find(x), fy = find(y) ; </span><br><span class="line">            <span class="keyword">if</span> (fx != fy) rt(fx) = rt(fy) = merge(fx, fy) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>左偏树</category>
      </categories>
      <tags>
        <tag>数据结构/左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>【整合向】类树上距离问题泛做</title>
    <url>/2018/11/09/Cal-on-Tree1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt=""></p>
<p>好的，今天整理一类较为简单的树上针对边权的修改、查询、操作题。</p>
<p>问题大概有两类：只有查询 $\&amp;$ 修改查询都有。</p>
<h1 id="普通的静态查询问题"><a href="#普通的静态查询问题" class="headerlink" title="普通的静态查询问题"></a>普通的静态查询问题</h1><p>大概问题就类似于这个典型的 <a href="https://www.luogu.org/problemnew/show/P2420" target="_blank" rel="noopener">$XOR$问题</a> 。</p>
<p>其实说白了，这个题的解法十分简单—— $\rm LCA $。</p>
<p>但其实…我一开始考虑 $\rm LCA$，没有细致考虑，只是觉得如果从 $u,v$ 分别向 $\rm LCA$ 跳，这并不可以提前处理或者提前维护，所以和暴力没有区别，于是就弃疗。</p>
<p>但是这个地方，$\rm LCA$ 的作用十分巧妙——我们试图去拓展这个题。我们定义 $D(\odot,r,u)$ 表示在运算$\odot$下，从根 $r$ 到某一固定点 $u$ 的边权运算结果，其中限定了运算 $\odot$ <strong>必须存在可逆运算</strong>，比如说异或、加法、减法。注意，此时的可逆运算，可以是<strong>自可逆（自己对自己运算是逆运算，比如 $A\operatorname{xor}A = 0$）</strong>或者<strong>他可逆（即存在另一种运算，是这种运算的逆运算，比如加法之于减法）</strong>那么我们就可以很方便地得出它的一般形式</p>
<script type="math/tex; mode=display">
D(\odot,u,v) = D(\odot,r,u) \odot D(\odot,r,v) ~\bigoplus ~(~2 \cdot D(\odot,r,LCA(u,v)~)~)</script><p>其中我们假设运算 $\odot$ 与 $\oplus$ 互逆。树上前缀和大抵上就是这个意思。</p>
<p>那么回到这个题，我们对于每一个点的 $D$，都是十分方便计算的，因为无权时，$D(r,t) = depth[t]$ ；有权时，直接 $dfs$ 一遍即可。每次查询是 $\log$ 级别的，所以时间复杂度的渐进上界就是比较显然的 $O(m \log n)$。</p>
<p>代码大概是这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _build(<span class="keyword">int</span> deep, <span class="keyword">int</span> now, <span class="keyword">int</span> f, <span class="keyword">int</span> _xor)&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = f, dep[now] = deep, XOR[now] = _xor ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = head[now]; k ;k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[k].t == f) <span class="keyword">continue</span> ;</span><br><span class="line">        _build(deep + <span class="number">1</span>, e[k].t, now, _xor ^ e[k].v) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Up = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= Up; i ++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] &lt; dep[v]) swap(u, v) ;</span><br><span class="line">    pre = dep[u] - dep[v] ;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt;= Up; j ++) <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; j) &amp; pre) u = fa[u][j] ;</span><br><span class="line">    <span class="keyword">if</span>(u == v) <span class="keyword">return</span> u ;</span><br><span class="line">    <span class="keyword">for</span>(j = Up; j &gt;= <span class="number">0</span>; j --) <span class="keyword">if</span>(fa[u][j] != fa[v][j]) u = fa[u][j], v = fa[v][j] ;</span><br><span class="line">    <span class="keyword">return</span> fa[v][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr() ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        in1 = qr(), in2 = qr(), in3 = qr();</span><br><span class="line">        add(in1, in2, in3) ;</span><br><span class="line">    &#125;</span><br><span class="line">    M = qr() ;</span><br><span class="line">    _build(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), init( );</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        in1 = qr(), in2 = qr() ;</span><br><span class="line">        f1 = LCA(in1, in2) ;</span><br><span class="line">        <span class="keyword">int</span> t = XOR[in1]^XOR[f1]^XOR[in2]^XOR[f1] ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="带修的查询问题"><a href="#带修的查询问题" class="headerlink" title="带修的查询问题"></a>带修的查询问题</h1><p>之后我们紧接着尝试去探讨一类带有修改边权的树上操作，大概题目就是<a href="https://www.luogu.org/problemnew/show/P1505" target="_blank" rel="noopener">某年国家集训队的板子题</a>和一道经典的<a href="https://www.luogu.org/problemnew/show/P4315" target="_blank" rel="noopener">边权修改启蒙题</a>  。</p>
<p>我们考虑，纷繁的操作，此时好像树剖比较合适些。但无论怎样，树剖是剖点的，不是剖边的。所以我们自然而然地想到要去把边权转移到点权上面。转移到哪儿去呢？显然<strong>只能转移到深度大的点上</strong>，因为在树这种结构里面，一对多决定了每个节点如果想要只保留一个属性（权值），就不能让父节点保留边权——否则父节点就会同时保有许多属性，并且叶子结点会没有属性，导致逻辑关系十分混乱。</p>
<p>所以，我们就应该把边权放到深度大的节点上，对节点进行操作。事实上，此处唯一需要注意的问题就是，我们在操作的时候要<strong>忽略 $LCA(u,v)$</strong>，这是显然的。关于这一点，我们的方法是把之前树剖里面的这一句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u], Id[v]) ;	</span><br><span class="line">_update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u], Id[v], d) ;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;	</span><br><span class="line">_update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>而对于如何边权转点权，我用的总时间复杂度大约 $O(n)$ 的区间赋值函数，好像比较方便：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">    n[i].u = qr(), n[i].v = qr() ;</span><br><span class="line">  	n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">    _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>嗯，题解好啊</del> 。</p>
<p>那么上面两个题就比较简单了：</p>
<p>$\mathscr{T1 ~\text{の} ~code}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c ;</span><br><span class="line">&#125;n[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, to ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ;  </span><br><span class="line"><span class="keyword">int</span> Id[MAX], M, N, tot, A, B, C, i ; <span class="keyword">char</span> STR[<span class="number">50</span>] ;</span><br><span class="line"><span class="keyword">int</span> Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX], head[MAX] ;</span><br><span class="line"><span class="keyword">int</span> Max[MAX &lt;&lt; <span class="number">1</span>], Min[MAX &lt;&lt; <span class="number">1</span>], S[MAX &lt;&lt; <span class="number">1</span>], T[MAX &lt;&lt; <span class="number">1</span>], cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = v ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = u ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    Sum[now] = <span class="number">1</span>, Fa[now] = F, Dep[now] = Dep[F] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == F) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs1(now, e[k].to) ;</span><br><span class="line">        Sum[now] += Sum[e[k].to] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> Tp)</span></span>&#123;</span><br><span class="line">    Id[now] = ++ tot, Top[now] = Tp ;</span><br><span class="line">    <span class="keyword">if</span> (Son[now]) dfs2(Son[now], Tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == Fa[now] || e[k].to == Son[now]) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs2(e[k].to, e[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    Max[rt] = max(Max[Rs(rt)], Max[Ls(rt)]) ;</span><br><span class="line">    Min[rt] = min(Min[Rs(rt)], Min[Ls(rt)]) ;</span><br><span class="line">    S[rt] = S[Ls(rt)] + S[Rs(rt)] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_d</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt])&#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = Max[Ls(rt)], t2 = Max[Rs(rt)] ;</span><br><span class="line">        T[Ls(rt)] ^= <span class="number">1</span>, T[Rs(rt)] ^= <span class="number">1</span> ;</span><br><span class="line">        Max[Ls(rt)] = -Min[Ls(rt)], Max[Rs(rt)] = -Min[Rs(rt)] ;</span><br><span class="line">        Min[Ls(rt)] = -t1, Min[Rs(rt)] = -t2, S[Ls(rt)] = -S[Ls(rt)], S[Rs(rt)] = -S[Rs(rt)] ;</span><br><span class="line">        T[rt] = <span class="number">0</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  _build(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> ;</span><br><span class="line">    _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + <span class="number">1</span>, R) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        S[rt] = Max[rt] = Min[rt] = k, T[rt] = <span class="number">0</span> ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _change(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Max[rt] ;</span><br><span class="line">        Max[rt] = -Min[rt], Min[rt] = -t ; </span><br><span class="line">        T[rt] ^= <span class="number">1</span>, S[rt] = -S[rt] ; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _update(Rs(rt), Mid + <span class="number">1</span>, R, l, r) ;</span><br><span class="line">    P_u(rt) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> Max[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Maxxxxx = -Inf ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Maxxxxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> Min[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Minnnnn = Inf ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Minnnnn = min(Minnnnn, __query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Minnnnn = min(Minnnnn, __query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Minnnnn ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ___query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> S[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Ssssss = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Ssssss += ___query(Ls(rt), L, Mid, l, r) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Ssssss += ___query(Rs(rt), Mid + <span class="number">1</span>, R, l, r) ;</span><br><span class="line">    <span class="keyword">return</span> Ssssss ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Update(<span class="keyword">int</span> u, <span class="keyword">int</span> v)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u]) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -Inf ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Min</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = Inf ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = min(ret, __query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = min(ret, __query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Sum</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret += ___query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u]) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret += ___query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v]) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        n[i].u = qr() + <span class="number">1</span>, n[i].v = qr() + <span class="number">1</span>, n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, STR) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'N'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, _Update(A, B) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'S'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Sum(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'A'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Max(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'I'</span>) A = qr() + <span class="number">1</span>, B = qr() + <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Min(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span>) A = qr(), B = qr(), n[A].c = B, _change(<span class="number">1</span> ,<span class="number">1</span>, N, Id[n[A].v], Id[n[A].v], B) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题有一个取相反数的操作，遇到这种正反都需要考虑的，$tag$ 一定是<strong>异或而不是覆盖</strong> ……是一个坑点。</p>
<p>$\mathscr{T2 ~\text{の} ~code}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, c ;</span><br><span class="line">&#125;n[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, to ; <span class="comment">//0 = Change, 1 = Add .</span></span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">char</span> STR[<span class="number">50</span>] ; <span class="keyword">int</span> A, B, C ;</span><br><span class="line"><span class="keyword">int</span> Rec[MAX], Id[MAX], Aft[MAX] ;<span class="keyword">int</span> N, tot ;</span><br><span class="line"><span class="keyword">int</span> M[MAX &lt;&lt; <span class="number">1</span>], T[MAX &lt;&lt; <span class="number">1</span>][<span class="number">2</span>], head[MAX], cnt, i ;</span><br><span class="line"><span class="keyword">int</span> Top[MAX], Fa[MAX], Sum[MAX], Son[MAX], Dep[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ;&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> res * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)&#123;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = v ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].v = c, e[cnt].to = u ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    Sum[now] = <span class="number">1</span>, Fa[now] = F, Dep[now] = Dep[F] + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == F) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs1(now, e[k].to) ;</span><br><span class="line">        Sum[now] += Sum[e[k].to] ;</span><br><span class="line">        <span class="keyword">if</span> (Sum[e[k].to] &gt; Sum[Son[now]]) Son[now] = e[k].to ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> Tp)</span></span>&#123;</span><br><span class="line">    Id[now] = ++ tot, Top[now] = Tp ;</span><br><span class="line">    <span class="keyword">if</span> (Son[now]) dfs2(Son[now], Tp) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = e[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[k].to == Fa[now] || e[k].to == Son[now]) <span class="keyword">continue</span> ;</span><br><span class="line">        dfs2(e[k].to, e[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">P_u</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;M[rt] = max(M[Rs(rt)], M[Ls(rt)]) ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P_d</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt][<span class="number">0</span>] != <span class="number">-1</span>)&#123;</span><br><span class="line">        M[Ls(rt)] = T[rt][<span class="number">0</span>], M[Rs(rt)] = T[rt][<span class="number">0</span>] ;</span><br><span class="line">        T[Rs(rt)][<span class="number">0</span>] = T[rt][<span class="number">0</span>], T[Ls(rt)][<span class="number">0</span>] = T[rt][<span class="number">0</span>]; </span><br><span class="line">        T[rt][<span class="number">0</span>] = <span class="number">-1</span>, T[Rs(rt)][<span class="number">1</span>] = <span class="number">0</span>, T[Ls(rt)][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[rt][<span class="number">1</span>])&#123;</span><br><span class="line">        M[Ls(rt)] += T[rt][<span class="number">1</span>], M[Rs(rt)] += T[rt][<span class="number">1</span>] ;</span><br><span class="line">        T[Rs(rt)][<span class="number">1</span>] += T[rt][<span class="number">1</span>], T[Ls(rt)][<span class="number">1</span>] += T[rt][<span class="number">1</span>] ; </span><br><span class="line">        T[rt][<span class="number">1</span>] = <span class="number">0</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span>  _build(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)&#123;</span><br><span class="line">    T[rt][<span class="number">0</span>] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;M[rt] = <span class="number">0</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    _build(Ls(rt), L, Mid), _build(Rs(rt), Mid + <span class="number">1</span>, R) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _change(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][<span class="number">0</span>] = M[rt] = k, T[rt][<span class="number">1</span>] = <span class="number">0</span> ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _change(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _change(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _update(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r)&#123;T[rt][<span class="number">1</span>] += k, M[rt] += k ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    P_d(rt, L, R) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) _update(Ls(rt), L, Mid, l, r, k) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) _update(Rs(rt), Mid + <span class="number">1</span>, R, l, r, k) ;</span><br><span class="line">    P_u(rt) ;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _query(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= L &amp;&amp; R &lt;= r) <span class="keyword">return</span> M[rt] ;</span><br><span class="line">    P_d(rt, L, R) ; <span class="keyword">int</span> Maxxxxx = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &gt;= l) Maxxxxx = max(Maxxxxx, _query(Ls(rt), L, Mid, l, r)) ;</span><br><span class="line">    <span class="keyword">if</span> (Mid &lt; r) Maxxxxx = max(Maxxxxx, _query(Rs(rt), Mid + <span class="number">1</span>, R, l, r)) ;</span><br><span class="line">    <span class="keyword">return</span> Maxxxxx ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Update(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u], d) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _update(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Max</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u])) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ret ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    ret = max(ret, _query(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v])) ;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> d)&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[u] != Top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(Dep[Top[u]] &lt; Dep[Top[v]]) swap(u, v) ;</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[Top[u]], Id[u], d) ;</span><br><span class="line">        u = Fa[Top[u]] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Dep[u] &gt; Dep[v]) swap(u, v) ;</span><br><span class="line">    _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[u] + <span class="number">1</span>, Id[v], d) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">        n[i].u = qr(), n[i].v = qr(), n[i].c = qr(), _Add(n[i].u, n[i].v, n[i].c) ;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">1</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), _build(<span class="number">1</span>, <span class="number">1</span>, N) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep[n[i].u] &gt; Dep[n[i].v]) swap(n[i].u,n[i].v);</span><br><span class="line">        _change(<span class="number">1</span>, <span class="number">1</span>, N, Id[n[i].v], Id[n[i].v], n[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; STR ;</span><br><span class="line">    <span class="keyword">while</span>(STR[<span class="number">0</span>] != <span class="string">'S'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'A'</span>) A = qr(), B = qr(), C = qr(), _Update(A, B, C) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'M'</span>) A = qr(), B = qr(), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Get_Max(A, B)) ;</span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'o'</span>) A = qr(), B = qr(), C = qr(), _Cover(A, B, C) ;    </span><br><span class="line">        <span class="keyword">if</span> (STR[<span class="number">0</span>] == <span class="string">'C'</span> &amp;&amp; STR[<span class="number">1</span>] == <span class="string">'h'</span>) A = qr(), B = qr(), n[A].c = B, _change(<span class="number">1</span> ,<span class="number">1</span>, N, Id[n[A].v], Id[n[A].v], B) ;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, STR) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题也有一个坑点，不过我似乎注意到了，就是它实际上有两种需要下传的标记，一种是赋值，一种是加，在算标记的时候注意一下就好了 。</p>
<h1 id="与树形-mathbb-DP-的巧妙结合"><a href="#与树形-mathbb-DP-的巧妙结合" class="headerlink" title="与树形 $\mathbb{DP}$ 的巧妙结合"></a>与树形 $\mathbb{DP}$ 的巧妙结合</h1><p>这个地方其实说的是一类问题…据说也被称作什么换根 dp/ up and down dp 之类的。</p>
<p>比如一道<del>我根本不会的</del>经典题：</p>
<blockquote>
<p> $\rm Description$</p>
<p>一棵带权树，$n$ 个点 $q$ 次询问，每次询问一个点的 $\sum dis_{odd}$ 和 $\sum dis_{even}$ 。</p>
</blockquote>
<a id="more"></a>
<p>其实这个题的题目意思是让我们求：</p>
<blockquote>
<p>对于每个点，到这个点是距离奇数的节点的距离和，与到这个点距离是偶数的节点的距离和。    </p>
</blockquote>
<p>那么我们不妨先从一个比较简单的问题开始考虑：如何求一个点到它子树的距离和呢？</p>
<p>这个东西比较简单，因为我们可以直接 $dfs$ 。</p>
<p>那么如果是求所有点到所有点的距离和呢？</p>
<p>换句话说，我们可以把刚才这个十分简单的问题，升华成为一个稍微困难一些的问题：对于每个点$u$，求所有点与它的距离之和，距离依边权而定。</p>
<p>我首先忽略边权，令边权都是 $1$，那么我们思考，我们根据已知条件，很容易知道的是什么呢？我们可以通过上一个问题知道 <strong>根节点到所有点的距离之和</strong>，同时我们也可以知道每个节点子树内的边权之和，那么如何利用这些呢？</p>
<p>我们会发现，此时我们知道的量，同一般的树形 $DP$ 或者说树形结构不同，我们现在已经知道了<strong>每一个子树的根节点的讯息；</strong>而平常的树形结构，我们知道的则是<strong>子节点的讯息 $or$ 子树的讯息</strong>，这一点提示我们：<strong>反向$DP$</strong> 。</p>
<p>我们不妨设 $dp_u$ 表示 $\sum \limits_{i \in T}{dist(i,u)}$ 。</p>
<p>那么我们思考如何构造相邻两层的状态转移方程：</p>
<p>首先，我们已经决定反向 $DP$，换句话说就是<strong>用父亲推出儿子</strong>；并且我们了解到，对于某一个点 $u$，他的<strong>所有子节点到他的距离要比到他的父亲的距离少 $1$</strong>（假设边权$=1$），同时所有<strong>除其子树之外的所有点到他的距离会多$1$</strong>.那么转移方程旧顺水推舟地：</p>
<script type="math/tex; mode=display">
dp_v = dp_u - subsize_v + (n - subsize_v), v \in son_u</script><p>那么接下来我们思考，当边权不为 $1$ 的时候呢？我们可以稍微魔改一下上式，于是就得到</p>
<script type="math/tex; mode=display">
dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + n\cdot pre_v</script><p>其中 $pre_i$ 表示节点 $i$ 的上行边，即父亲与它相连的那条边。</p>
<p>那么以上简单版本的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAX] ; <span class="keyword">int</span> head[MAX], cnt ; </span><br><span class="line"><span class="keyword">int</span> N, A, B, i, j, dp[MAX], sub[MAX], Pre[MAX] ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v)&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	sub[now] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">		build(to(k), now) ;  </span><br><span class="line">		sub[now] += sub[E[k].to], dp[<span class="number">1</span>] += sub[E[k].to] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwork</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (E[k].to == f) <span class="keyword">continue</span> ;</span><br><span class="line">		dp[E[k].to] = dp[now] - <span class="number">2</span> * sub[E[k].to] + N ;</span><br><span class="line">		fwork(to(k), now) ; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), _Add(A, B) ;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">0</span>) ; fwork(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一值得注意的地方就是其中 $dp_1$ 或者说 $dp_{root}$ 的处理。那么其实这个地方我们只需要不断加 $size$ 即可。</p>
<p>高端版本的问题，代码类似：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;E[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> head[MAX], cnt, i ;</span><br><span class="line"><span class="keyword">int</span> N, Sub[MAX], Pre[MAX], dp[MAX], Sum, A, B, C ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	Sub[now] = <span class="number">1</span> ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">		build(to(k), now) ;  Pre[to(k)] = E[k].v ;</span><br><span class="line">		Sub[now] += Sub[to(k)], dp[<span class="number">1</span>] += Pre[to(k)] * Sub[to(k)] ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp_work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">		<span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">		dp[to(k)] = dp[now] - <span class="number">2</span> * Pre[to(k)] * Sub[to(k)] + N * Pre[to(k)] ; dp_work(to(k), now) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">	E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;A, &amp;B, &amp;C), Add(A, B, C) ;;</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">0</span>) ; dp_work(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cout</span> &lt;&lt; dp[i] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么回归到我们的问题，我们要求的是奇数距离$\&amp;$偶数距离，很简单，再加一维即可。</p>
<p>我们致力于维护这样一个东西：对于每个 $u \in T$， 我们试图确定除 $u$ 及其子树外，到 $u$ 点距离是奇数的点的个数$s_0$ 和距离是偶数的点的个数 $s_1$，以便于状态转移。</p>
<p>那么平均树高下，直接在 $dfs/bfs$ 里面来回赋值即可。但是还是有需要注意的地方——比如说边为奇数的时候，父子节点的两个值需要 <code>swap</code> 一下，并且边权为奇数的时候，是交叉转移的（奇数状态转移给偶数状态）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[to(k)][0] &= dp[now][1] - sub[to(k)][0] * [re[to(k)] \\ 
dp[to(k)][1] &= dp[now][0] - sub[to(k)][1] * pre[to(k)] \\ 
dp[to(k)][0] &+= s0 * pre[to(k)] \\ 
dp[to(k)][1] &+= s1 * pre[to(k)] \\
\end{aligned}</script><p>其中 $to(k) \in son_{now}$ 。</p>
<p>而偶数的时候，显然不是交叉转移的（奇数状态转移给奇数状态）：</p>
<script type="math/tex; mode=display">
\begin{aligned}
dp[to(k)][1] &= dp[now][1] - sub[to(k)][1] * pre[to(k)]\\ dp[to(k)][0] &= dp[now][0] - sub[to(k)][0] * pre[to(k)] \\        dp[to(k)][1] &+= s1 * pre[to(k)]\\         dp[to(k)][0] &+= s0 * pre[to(k)] 
\end{aligned}</script><p>于是就结束了。</p>
<p>其实这个地方转移方式十分的多，但是关键的装套转移方程其实就是一句：</p>
<script type="math/tex; mode=display">
dp_v = dp_u - 2 \cdot pre_v \cdot  subsize_v + Count \cdot pre_v</script><p>其中$Count$表示某种神秘的计数方式…</p>
<p>那么其实这种问题还可以拓展到 “求对于每一个点 $u$，$dist(u,v) \bmod n =k$ 的点的个数，其中 $k \in [0,k-1]$，我感觉做法应该会类似吧 <del>（但是我肯定不会做因为根本不可能调的出来）</del> 。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul>
<li>1、没啥好说的，只觉得第三模块的例题十分难调！十分难调！并且…我一开始没用 $s0$ 或者 $s1$，直接用的根节点的 $sub_0$ 和 $sub_1$，最后才发现根本不合逻辑…但他居然过样例了…</li>
<li>2、转移的时候还是需要有一个清醒的思路再code啊！</li>
<li>3、DP ​好啊！</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
        <category>模型</category>
      </categories>
      <tags>
        <tag>树模型</tag>
        <tag>动态规划/树形DP</tag>
        <tag>数据结构/数据结构方法/轻重链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】HLPP+丧心病狂的优化</title>
    <url>/2018/10/07/HLPP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>嗯，我也不知道我在月考即将爆炸 +  NOIp 即将爆炸之际，学 HLPP 的目的何在QAQ</p>
<a id="more"></a>
<blockquote>
<p>#define  $ u $ 的伴点集合     与 $ u $ 相隔一条边的且 $ u $ 能达到的点的集合 </p>
</blockquote>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>预流推进的大体思路是，对每个点记录<strong>超额流( $ \mathrm{Extra~Flow} $ )</strong> ，即<strong>允许流在非源点暂时存储</strong>，并<strong>伺机将超额流推送出去</strong>。不可推送的，就会流回源点。那么最终答案显然存储在 $\rm Extra[T] $ 里面。</p>
<p>但同时这也有一个问题，就是会出现两个点相互推送不停的情况。为了防止这样，我们采用<strong>最高标号</strong>的策略，给每个点一个高度，对于一个点 $ u $ 以及它的伴点集合 $ \{v\} $ ，当且仅当 $ h_u = h_v + 1 $  时才可以推送流。并且我们对于源点 $\mathrm{S} $ ，设置 $ h_{\rm S} = N $ ，并对于 $\mathrm{S} $ 实行<strong>无限制推送</strong>。那么最后的答案就保存在 $ Extra[T] $ 里面 。</p>
<p>但有时，我们发现有个点是”谷“，即周围点的高度都比它高，但是它有超额流。那么我们此时考虑<strong>拔高它的高度</strong>，即 <strong>重贴标签( $ relabel $ )</strong> 操作。</p>
<h1 id="初步的算法流程"><a href="#初步的算法流程" class="headerlink" title="初步的算法流程"></a>初步的算法流程</h1><p>以下我们用  $ \mathrm{Extra}_u $  表示  $ u $  的超额流， $ h_u $  表示  $ u $  的高度，用  $ f_k $  表示边 $ k $ 的容量。</p>
<ul>
<li>1）首先把所有的 $ h_i $ 都置为零，并把 $ h_s $ 置为 $ N $ （点数）。</li>
<li>2）将 $\mathrm{S} $ 的流推送到每个与 $\mathrm{S} $ 相邻的点，同时把他们加入一个以高度为键值得大根堆，所以每次取出的应该是高度最高的、且超额流不为零的点，并执行推送操作。</li>
<li>3）对于点 $ u $ 推送过程中，如果 $ \mathrm{Extra}_u $ 减到了 $ 0 $ ，就立即退出<strong>（优化一）</strong></li>
<li>4）对于每条出边 $ k $ ，推送的流量 $ F = min(f_k,\mathrm{Extra}_u) $ 并执行两个点（ $ u,v $ ）的超额流增减。<strong>如果 $ v $ 不在堆里面</strong>，要把 $ v $ 放到堆里面。</li>
<li>5）如果推送完毕 $ Extra[u] $ 不为零，那么从他的伴点集合选取一个高度最小的点并记录它的高度 $ h_{min} $ ，则新的 $ h_u = h_{min}+1 $ ，并把 $ u $ 入堆。</li>
</ul>
<p>接下来我们发现，重贴标签的过程似乎与 $\rm ISAP $ 有点点像……所以我们不妨通过一个 $\rm Gap $ 数组来记录”断层情况“。即如果对于一个点 $ u $ 来说，他的伴点集 $ \{v\} $ 已经不存在 $ h_u = h_v + 1 $ 的点了，并且也不存在一个点 $ j $ 使得 $ h_j = h_u $ 那么这个地方就是一个<strong>断层 $ (\rm Gap) $ </strong> ，那么也就是说，对于所有 $ h_i&gt; h_u $ 的点来说，它们把流推送到 $ h_u $ 的高度就不能继续推送了，所以我们直接 $ h_i = N + 1 $ ，让他们回流到源点。<strong>（优化二）</strong></p>
<p>接下来这个优化，亲测可以<strong>提速 $ 4000ms $ </strong>，平均每个测试点提速 $ 700 $  ~  $ 800ms $ ，去掉数据最小的点，每个点平均提速 $ 1000ms $ 。这就是—— $\rm BFS $ ! 不妨一开始就倒着 $ \rm BFS $ 一遍，搜出每个点离汇点的最短距离作为初始高度而不是把零作为初始高度(源点高度还是 $N$) 。</p>
<p>嗯， $\rm Mr_Spade $ 大佬实在太强了 。</p>
<p>对了，代码实现方面，需要好多判断不是源点和汇点的小细节…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num, h ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> state &amp; now) </span><br><span class="line">    <span class="keyword">const</span>&#123;  <span class="keyword">return</span> h &lt; now.h ; &#125;</span><br><span class="line">&#125; ; priority_queue &lt;state&gt; heap ; </span><br><span class="line">BFS init ;</span><br><span class="line"><span class="keyword">int</span> N, M, S, T, cnt = <span class="number">-1</span>, A, B, C, D, t, min_h ;</span><br><span class="line"><span class="keyword">int</span> head[MAXN], Extra[MAXN], H[MAXN], Gap[MAXN], node ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Preflow_Push</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> i, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        <span class="keyword">if</span>(H[i] &lt; Inf) ++ Gap[H[i]] ;</span><br><span class="line">    <span class="keyword">for</span>(k = head[S]; k != <span class="number">-1</span> ; k = E[k].next)</span><br><span class="line">        <span class="keyword">if</span> (t = E[k].f)&#123;</span><br><span class="line">            E[k].f -= t, E[k ^ <span class="number">1</span>].f += t ;</span><br><span class="line">          	Extra[S] -= t, Extra[to(k)] += t ;</span><br><span class="line">            <span class="keyword">if</span>(to(k) != T &amp;&amp; !vis[to(k)])</span><br><span class="line">                heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!heap.empty())&#123;</span><br><span class="line">        vis[node = heap.top().num] = <span class="number">0</span>, min_h = Inf, heap.pop() ;</span><br><span class="line">        <span class="keyword">for</span>(k = head[node] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(E[k].f &amp;&amp; H[node] == H[to(k)] + <span class="number">1</span>)&#123;</span><br><span class="line">                t = min(Extra[node], E[k].f) ;</span><br><span class="line">                E[k].f -= t, E[k ^ <span class="number">1</span>].f += t ;</span><br><span class="line">              	Extra[node] -= t, Extra&#125;[to(k)] += t ;</span><br><span class="line">                <span class="keyword">if</span>(!vis[to(k)] &amp;&amp; to(k) != S &amp;&amp; to(k) != T)</span><br><span class="line">                    heap.push((state)&#123;to(k), H[to(k)]&#125;), vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (E[k].f) min_h = min(min_h, H[to(k)]) ;</span><br><span class="line">            <span class="keyword">if</span> (!Extra[node]) <span class="keyword">break</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Extra[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!-- Gap[H[node]])    </span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N ; ++ i)</span><br><span class="line">                    <span class="keyword">if</span>(i != S &amp;&amp; i != T &amp;&amp; H[i] &gt; H[node] &amp;&amp; H[i] &lt; N + <span class="number">1</span>) H[i] = N + <span class="number">1</span> ;</span><br><span class="line">            H[node] = Inf; H[node] = min_h + <span class="number">1</span> ; </span><br><span class="line">            heap.push((state)&#123;node, H[node]&#125;), vis[node] = <span class="number">1</span>, ++ Gap[H[node]] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;fast;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Input() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">        head[i] = <span class="number">-1</span>, H[i] = Inf ;</span><br><span class="line">    <span class="keyword">while</span>(M --)&#123;Add; &#125;</span><br><span class="line">    q.push(T), H[T] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span>(k = head[now] ; k != <span class="number">-1</span> ; k = E[k].next)</span><br><span class="line">            <span class="keyword">if</span> (H[to(k)] &gt; H[now] + <span class="number">1</span>)</span><br><span class="line">                H[E[k].to] = H[now] + <span class="number">1</span>, q.push(E[k].to) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (H[S] == <span class="number">0</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; &#125; </span><br><span class="line">    H[S] = N, Preflow_Push() ; <span class="built_in">cout</span> &lt;&lt; Extra[T] &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来我们加上下面这一句话的毒瘤卡常就可以有 $ 4000ms $ 左右的好成绩，但事实上，这个速度依旧慢的要死。</p>
<p>注意！这个写法是经典写法，其时间复杂度是 $ \boldsymbol{\Theta(n^2m\log n)} $ 的，也就是说在 $ \boldsymbol{n=1200} $ 时会带一个 $ \boldsymbol{10} $ 倍的长🌲</p>
<p>怎么优化呢——</p>
<h1 id="神奇的优化"><a href="#神奇的优化" class="headerlink" title="神奇的优化"></a>神奇的优化</h1><p>各位，你们将会见到迄今为止OI界最丧心病狂的优化（之一）……</p>
<p>来，我们首先思考思考普通的HLPP到底会慢在哪里：</p>
<ul>
<li><p>1）STL 支持的 <code>heap</code> （比如优先队列）实在是太太太…太慢了！</p>
</li>
<li><p>2）每次 Gap 优化，我们的时间复杂度是<strong>紧确</strong>的 $ \Theta(n) $ 。的这显然不合算，因为假设我当前的 $ \boldsymbol{gap} $ （断层）正好位于倒数第一高的点和倒数第二高的点，那么也就相当于我单次会<strong>浪费 $ \boldsymbol{\Theta(n)} $ 的时间</strong>。</p>
</li>
</ul>
<p>事实上…普通的  $ \rm HLPP $  代码并不长，主要问题就是这两个。</p>
<p>我们考虑，如果不用堆的话怎么做呢？</p>
<p>呃…不用堆的意思并不是我们不从高度最大的点开始推送。这个地方需要一个 $ idea $ ——在 $ HLPP $ 中，<strong>高度函数 $ \boldsymbol{H(x)} $ 和点数集大小 $ \boldsymbol{N(x)} $ 是广义同阶的。</strong> 换句话说，我们可以考虑从高度入手。</p>
<p>换句话说，我们原来是通过节点编号访问节点以及其高度，现在我们如果从高度入手，再去访问节点，我们就可以做到 $ \boldsymbol{O(n)} $ 而不是 $ \boldsymbol{O(n\log n)} $  。 那么由于同一高度的节点或许有很多，直接开一个 $ vector $ 。在这个地方我们用 $ vector $ 而不用二维数组建立二维关系的原因，主要是我们初始化麻烦得很，如果套用 $ memset $ 或者 $ fill $ 的话，常数之大可想而知。</p>
<p>那么这两个问题就顺理成章地解决了。但这个地方还有一个优化，就是虽然 $ vector $ 和 $ list $ 都是线性容器，但是 $ list $ 的本质是双向链表，频繁处理插入删除操作时会具有更优秀的表现。</p>
<p>也就是说，原来的 $ Gap $ 数组我们可以直接用 $ list $ 做，以图更小的常数。那么这时存在一个问题，就是虽然本质上删除是容易的，但是你怎么知道要删同一高度下的哪个元素(=@__@=)？就算你知道， $ list $ 也不知道啊2333</p>
<p>hhh不皮了，其实我们记录一下位置就好，即记录一下每个节点在 $ list $ 中的位置，单独开一个 $ Iterator $ 类型的 $ vector $ 记录即可。</p>
<p>好了，现在我们获得了 $ 10 $ 倍 $ + $ 的常数优势qwq，撒花花…</p>
<p>哦对，还有几点我debug的时候被坑死的点：</p>
<ul>
<li>1、那个 $\rm Iterator $ 类型的 $ vector $ 对象是点的编号不是高度！</li>
<li>2、注意下标！下标！再说一遍，下标！因为STL自带左闭右开的性质<del>wrnm</del>，所以一定要注意，如果你是 $ [1,n] $ 选手，注意你的 <code>assign</code> 函数！</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; List ; </span><br><span class="line"><span class="keyword">int</span> step ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, f, next ;</span><br><span class="line">    Edge(<span class="keyword">int</span> to,<span class="keyword">int</span> f,<span class="keyword">int</span> next):to(to),f(f),next(next)&#123;&#125;<span class="comment">//没有人发现正下方这句注释前半句和后半句都是三个音节的吗qaq</span></span><br><span class="line">&#125; ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; q, H, \mathrm&#123;Extra&#125;, Set[MAXN], cnt ; List Gap[MAXN] ;<span class="comment">//list，就是快（</span></span><br><span class="line"><span class="comment">//q:队列，H:高度，\mathrm&#123;Extra&#125;：每个点的超额流，Set:…就是那个经典版HLPP里的堆，高度做第一维</span></span><br><span class="line"><span class="keyword">int</span> Ans, N, M, S, T, max_H, now_H ; <span class="built_in">vector</span> &lt;Edge&gt; E[MAXN] ; <span class="comment">/*vector存边（据说会快）*/</span><span class="built_in">vector</span>&lt;List::iterator&gt; Era_pos ; <span class="comment">//辅助定位+删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">eggs</span><span class="params">()</span> </span>&#123; ;&#125;<span class="comment">//for free~</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">my_min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &amp; ((a - b) &gt;&gt; <span class="number">31</span>) | b &amp; ( ~ (a - b) &gt;&gt; <span class="number">31</span>) ;&#125;<span class="comment">//黑科技</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> v, <span class="keyword">int</span> u)</span></span>&#123; E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, <span class="number">0</span>, E[u].size() - <span class="number">1</span>)) ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123; rr <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = gc() ; <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = gc() ;<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = gc() ; <span class="keyword">return</span> k ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init_label</span><span class="params">()</span></span>&#123;<span class="comment">//等价于一开始的那个BFS，只执行一次</span></span><br><span class="line">    rr <span class="keyword">int</span> i, h = <span class="number">0</span>, t = <span class="number">0</span> ;q.clear(), q.resize(N) ; </span><br><span class="line">    H.assign(N + <span class="number">1</span>, N + <span class="number">1</span>) ; H[T] = <span class="number">0</span> ; q[t ++] = T ;<span class="comment">//从T（高度小的）向前标号</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; t)&#123;<span class="comment">//队列……BFS……真熟悉啊……嗝……</span></span><br><span class="line">        rr <span class="keyword">int</span> now = q[h] ; ++ h ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span> &lt;Edge&gt; :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k)</span><br><span class="line">            <span class="keyword">if</span> (H[k-&gt;to] == N + <span class="number">1</span> &amp;&amp; E[k-&gt;to][k-&gt;next].f) H[k-&gt;to] = H[now] + <span class="number">1</span>, ++ cnt[H[k-&gt;to]], q[t ++] = k-&gt;to ;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, N + <span class="number">1</span>) Set[i].clear(), Gap[i].clear() ;<span class="comment">//还是清空一下比较好吧</span></span><br><span class="line">    rep(i, <span class="number">0</span>, N) </span><br><span class="line">        <span class="keyword">if</span> (H[i]  &lt;N + <span class="number">1</span>)  </span><br><span class="line">            Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), <span class="comment">//疑似insert函数的返回值是一个指针qaq</span></span><br><span class="line">            (Extra[i]&gt;<span class="number">0</span>) ? Set[H[i]].push_back(i) : eggs() ;<span class="comment">//这个彩蛋（eggs）是因为，三目运算符":"两边类型需要形同…</span></span><br><span class="line">    max_H = now_H = H[q[-- t]] ; <span class="comment">//更新，BFS的性质，最后一个元素一定高度最大（除了源点）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x, Edge &amp;e)</span></span>&#123;<span class="comment">//单独写出来的push函数，好像很方便？</span></span><br><span class="line">    rr <span class="keyword">int</span> now_flow = min(Extra[x], e.f) ;</span><br><span class="line">    Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ;</span><br><span class="line">    <span class="keyword">if</span> (Extra[e.to] &gt; <span class="number">0</span> &amp;&amp; Extra[e.to] &lt;= now_flow) Set[H[e.to]].push_back(e.to) ;  <span class="comment">// push it into "heap"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Push(<span class="keyword">int</span> x)&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, x_h = N, t = H[x] ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span> &lt;Edge&gt; :: Iter k = E[x].BG ; k != E[x].end() ; ++ k)</span><br><span class="line">        <span class="keyword">if</span> (k-&gt;f &gt; <span class="number">0</span>)<span class="comment">//如果可以流</span></span><br><span class="line">            <span class="keyword">if</span> (H[k-&gt;to] == H[x] - <span class="number">1</span>) &#123; Push(x, *k) ; <span class="keyword">if</span> (!Extra[x]) <span class="keyword">return</span> ;&#125; <span class="keyword">else</span> x_h = min(x_h, H[k-&gt;to] + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (cnt[H[x]] &lt;= <span class="number">1</span>)&#123;<span class="comment">//如果出现断层了</span></span><br><span class="line">        <span class="keyword">for</span>(i = t ; i &lt;= max_H ; Gap[i].clear(), ++ i)<span class="comment">//这个gap的for肯定比O(n)优秀</span></span><br><span class="line">            <span class="keyword">for</span>(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; </span><br><span class="line">        max_H = t - <span class="number">1</span> ; <span class="comment">/*断层以上的高度都没用了*/</span><span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; <span class="keyword">if</span> (x_h == N) <span class="keyword">return</span> ; <span class="comment">//重贴标签操作，为当前点删除原来的高度</span></span><br><span class="line">    ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;<span class="comment">//增添新的高度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">HLPP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rr <span class="keyword">int</span> i, now ; H.assign(N, <span class="number">0</span>) ; H[S] = N ; Era_pos.resize(N)  ;</span><br><span class="line">    rep(i, <span class="number">0</span>, N - <span class="number">1</span>) <span class="keyword">if</span> (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; </span><br><span class="line">    cnt.assign(N, <span class="number">0</span>), cnt[<span class="number">0</span>] = N - <span class="number">1</span> ; Extra.assign(N, <span class="number">0</span>), Extra[S] = INF, Extra[T] =- INF ;</span><br><span class="line">    rep(i, <span class="number">0</span>, E[S].size() - <span class="number">1</span>) Push(S, E[S][i]) ;  <span class="comment">//下面源点要单独拿出来推送，因为源点推送时高度差不需要=1.</span></span><br><span class="line">    Init_label() ; <span class="comment">//初始化（BFS）</span></span><br><span class="line">    <span class="keyword">while</span> (now_H &gt;= <span class="number">0</span>) <span class="comment">//正式开始HLPP（泪目）</span></span><br><span class="line">        <span class="keyword">if</span> (Set[now_H].empty()) now_H -- ; <span class="comment">//高度递减，实现一个堆的效果</span></span><br><span class="line">        <span class="keyword">else</span> now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;</span><br><span class="line">    <span class="keyword">return</span> Extra[T] + INF ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    N = qr(),; rr <span class="keyword">int</span> i ;<span class="comment">//下面的++N是为了日后好操作qaq</span></span><br><span class="line">    rep(i, <span class="number">1</span>, M) Add(qr(), qr(), qr()) ; ++ N, Ans = HLPP() ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>撒fa~</strong></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li>1、这道题的经典版本好几个月之前我写了一天…然后今天又翻出来，发现了巨佬 <code>KevinYu</code> 抛了一个玉，我就打算优化一波…毒瘤啊，什么 $ vector $ 存边、 $ list $ 我都是第一次用…</li>
<li>2、不得不说…某些大佬的码风真是不可看啊…都写题解了怎么还这么…这么…（虽然自己的也不咋地qaq） </li>
<li>3、最后，人艰不拆，人艰不拆…</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流/最大流</tag>
        <tag>目测用不到的算法系列</tag>
      </tags>
  </entry>
  <entry>
    <title>【学习笔记】Dinic&amp;费用流</title>
    <url>/2018/08/20/net-work-flow%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>$2333$这是好久之前学的了，不过一直在咕咕咕咕。</p>
<p>一般来讲，正常的网络流笔记一开始都是要给网络流图下定义的。那么我们不妨也来先进行一波这种操作。</p>
<p>那么网络流图，类似于有向图，边上带权，但是这个权值变成了“容量”。定义容量为 $c(u,v) \in E ? c(u,v) : 0$。在整张图中有一个源点和一个汇点，且对于每个点来说有 $\sum f_{in} = \sum f_{out}$ 。并且我们人为的将 $\rm S$ 的$f_{in}$ 设置为 $0$ ，$f_{out}$ 设置为 $+\infty$。$\rm T$ 正好相反。</p>
<h1 id="EK-算法"><a href="#EK-算法" class="headerlink" title="EK 算法"></a>EK 算法</h1><p>其实，EK 身为大家眼中的基础算法，他居然是比 Dinic晚发表的……</p>
<p>全称是 $\rm Edmond-Karp$ ，由两位科学家一起发表的，复杂度上界大约在$\Theta(nm^2)$左右，<del>是个比较没用的算法</del>。</p>
<p>他的原理如下：</p>
<p>1、增广路</p>
<p>这个东西就是我们不断寻找从源点到汇点的可行路径，不断流直到不能流为止，也没有什么技巧可言，毕竟网络流是线性规划而不是动态规划，图集与解是单射的逻辑关系而不是一对多的非映射关系。</p>
<p>2、 反向边</p>
<p>虽然图集与解是单射的逻辑关系，即虽然对于同一张图 $\rm G(V, E)$ 无论怎么走，最优解（最大流）总是一个定值，但是我们在执行算法的时候可能会因为选择了错误的增广路经而导致算法的错误。所以此时我们考虑建立反向边。其实这就是一个小小的反悔操作。这个正确性在于我们建立了反向边，对于执行反悔操作并没有什么问题，对于执行正常的增广操作也不会影响什么结果，因为毕竟是反向边——是从 $\rm T$ 连向 $\rm S$ 的，等同于原来没反向边时的情况。</p>
<p>嗯，那么我们程序实现的时候，大概就是这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    fill(_F, _F + N + <span class="number">1</span>, Inf) ;</span><br><span class="line">    fill(dis, dis + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(S), dis[S] = <span class="number">1</span>, pre[T] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">-1</span> ; k = e[k].next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[k].v &amp;&amp; !dis[e[k].to])&#123;</span><br><span class="line">                    dis[e[k].to] = dis[now] + <span class="number">1</span> ;</span><br><span class="line">                    _F[e[k].to] = min(e[k].v, _F[now]) ;</span><br><span class="line">                    pre[e[k].to] = now, Last[e[k].to] = k ;</span><br><span class="line">                    q.push(e[k].to) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _EK()&#123;</span><br><span class="line">    <span class="keyword">while</span>(BFS())&#123;</span><br><span class="line">        now = T, MAX_F += _F[T] ;</span><br><span class="line">        <span class="keyword">while</span>(now != S)</span><br><span class="line">            e[Last[now]].v -= _F[T], e[Last[now] ^ <span class="number">1</span>].v += _F[T], now = pre[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>Last</code> 记录前驱，<code>dis</code> 就是个mark，<code>_F</code> 数组记录增广路上最大的流量 。</p>
<p>那我们接下来分析复杂度。值得注意的是，$\rm EK$ 由于采用 $\rm BFS$，所以每次找的一定是最短路。而在最短路不变的一段时间内一条边和它的反向边不可能都被增广（如果增广反向边的话，$dis_{min}$ 会加一），所以在每条边都作为残量最小值增广一次之后（至多 $m$ 次）最短路就会增加。而最短路最多从 $2$ 增到 $n$ ，所以最多增广 $n \times m$ 次。而每次 $bfs$ 至多是 $\Theta(m)$ 的，所以总复杂度上界是 $O(nm^2)$.</p>
<p>但事实上，随机的数据大多数情况下是要远远小于这个复杂度上界的，所以 $\rm EK$ 可以解决朴素的最大流问题。</p>
<p>全部的代码存档：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, S, T ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> MAX_F, i ;</span><br><span class="line"><span class="keyword">int</span> head[MAX], cnt = <span class="number">-1</span>, pre[MAX], now ;</span><br><span class="line"><span class="keyword">int</span> A, B, C, Last[MAX], _F[MAX], dis[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ cnt].to = v, e[cnt].v = w ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].to = u, e[cnt].v = <span class="number">0</span> ;</span><br><span class="line">    e[cnt].next = head[v],  head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    fill(_F, _F + N + <span class="number">1</span>, Inf) ;</span><br><span class="line">    fill(dis, dis + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(S), dis[S] = <span class="number">1</span>, pre[T] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">-1</span> ; k = e[k].next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(e[k].v &amp;&amp; !dis[e[k].to])&#123;</span><br><span class="line">                    dis[e[k].to] = dis[now] + <span class="number">1</span> ;</span><br><span class="line">                    _F[e[k].to] = min(e[k].v, _F[now]) ;</span><br><span class="line">                    pre[e[k].to] = now, Last[e[k].to] = k ;</span><br><span class="line">                    q.push(e[k].to) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _EK()&#123;</span><br><span class="line">    <span class="keyword">while</span>(BFS())&#123;</span><br><span class="line">        now = T, MAX_F += _F[T] ;</span><br><span class="line">        <span class="keyword">while</span>(now != S)</span><br><span class="line">            e[Last[now]].v -= _F[T], e[Last[now] ^ <span class="number">1</span>].v += _F[T], now = pre[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ;</span><br><span class="line">    fill (head + <span class="number">1</span>, head + N + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; ++ i)</span><br><span class="line">        A = qr(), B = qr(), C = qr(), add(A, B, C) ;</span><br><span class="line">    _EK() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MAX_F &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h1><p>Dinic在 EK 的基础上，采用了两个新的优化方案：</p>
<p>$Case1:$ 分层图</p>
<p>每次我们选择用 $\rm bfs + dfs$ 去增广一张“增广网”，大体上就是我们记录深度（或者说是离源点的最小距离），然后我们用 $\rm dfs$ 遍历这张增广网。</p>
<p>$Case2:$当前弧</p>
<p>我们依仗的是这一段（句）代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> &amp;i = cur[now] ; i != <span class="number">-1</span> ; i = line[i].nxt)</span><br></pre></td></tr></table></figure>
<p>其中比较重要的是引用符号，此处引用的目的是不断更新 $cur$，达到不重复枚举已经没有容量的边的目的。</p>
<p>那么整体代码就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, S, T ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v ; </span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> A, B, C, i ;</span><br><span class="line"><span class="keyword">int</span> head[MAX], cnt = <span class="number">-1</span>, now, cur[MAX], dis[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[++ cnt].to = v, e[cnt].v = w ;</span><br><span class="line">    e[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    e[++ cnt].to = u, e[cnt].v = <span class="number">0</span> ;</span><br><span class="line">    e[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    fill(dis, dis + N + <span class="number">23</span>, <span class="number">0</span>) ;</span><br><span class="line">    q.push(S), dis[S] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">-1</span> ; k = e[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!dis[e[k].to] &amp;&amp; e[k].v)</span><br><span class="line">                dis[e[k].to] = dis[now] + <span class="number">1</span>, q.push(e[k].to) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] ? <span class="number">1</span> : <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> St, <span class="keyword">int</span> Aim, <span class="keyword">int</span> Flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (St == Aim || !Flow) <span class="keyword">return</span> Flow ; <span class="keyword">int</span> Fl, res = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;k = cur[St] ; k != <span class="number">-1</span>; k = e[k].next)</span><br><span class="line">        <span class="keyword">if</span> (dis[e[k].to] == dis[St] + <span class="number">1</span> &amp;&amp; (Fl = dfs(e[k].to, Aim, min(Flow, e[k].v))))&#123;</span><br><span class="line">            res += Fl, e[k].v -= Fl, e[k ^ <span class="number">1</span>].v+= Fl ;</span><br><span class="line">            Flow -= Fl ; <span class="keyword">if</span> (!Flow) <span class="keyword">break</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; ++ i) cur[i] = head[i] ;</span><br><span class="line">        res += dfs(S, T, <span class="number">0x7fffffff</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ;</span><br><span class="line">    fill (head + <span class="number">1</span>, head + N + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M;  ++ i) </span><br><span class="line">        A = qr(), B = qr(), C = qr(), add(A, B, C) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Dinic() &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为对于一次$dfs$，在同一张分好层次的图上执行，不会出现重复用一条边的情况——我们认为每条边已经流满。那么当前弧可以保证不会重复走，也就是保证了 Dinic 的复杂度。</p>
<p>那么接下来证明一下 Dinic​ 的时间复杂度。</p>
<p>根据分层图而言，$t$ 的层次是单调增长的——因为每次增广完毕之后对于每条可行的增广路，都总会有至少一条边容量为零，所以最多会有 $n$ 次重新分层。而对于每次在增广网上的操作，至多有 $m$ 条增广路（每条边至多有一次机会置零），每条增广路要回溯+搜索总共 $2n$ 的操作。那么渐进意义上复杂度就是$\Theta(n^2m)$的。</p>
<p>很显然，这在随机数据的情况下也是跑不满的。而加了当前弧优化，复杂度理论上还是不变的，或者说，在跑满的情况下，复杂度更接近上限复杂度$\Theta(n^2m)$ 。</p>
<p>据说随机图上跑个$1 \cdot 1e4$~$5 \cdot 1e4$是没什么问题的。</p>
<h1 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h1><p>其实费用流……常见的，就是在最大流的前提下费用最小。那么我们直接把 EK 的 $bfs$ 换成 $\rm SPFA$ 就行了233</p>
<p>至于为什么不能 dinic，很显然是因为没法分层啊…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N, M, S, T ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v, c ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">bool</span> mark[MAX] ; <span class="keyword">int</span> MAX_F, MAX_C, i ;</span><br><span class="line"><span class="keyword">int</span> head[MAX], cnt = <span class="number">-1</span>, pre[MAX], now ;</span><br><span class="line"><span class="keyword">int</span> A, B, C, D, Last[MAX], _F[MAX], dis[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++ cnt].to = v, e[cnt].v = w ;</span><br><span class="line">    e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ;</span><br><span class="line">    e[++ cnt].to = u, e[cnt].v = <span class="number">0</span> ;</span><br><span class="line">    e[cnt].next = head[v], e[cnt].c = <span class="number">-1</span> * c, head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q ;</span><br><span class="line">    fill(_F, _F + N + <span class="number">1</span>, Inf) ;</span><br><span class="line">    fill(dis, dis + N + <span class="number">1</span>, Inf) ;</span><br><span class="line">    fill(mark, mark + N + <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">	q.push(S), dis[S] = <span class="number">0</span>, mark[S] = <span class="number">1</span>, pre[T] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop() ; mark[now] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">-1</span> ; k = e[k].next)</span><br><span class="line">			<span class="keyword">if</span> (dis[e[k].to] &gt; dis[now] + e[k].c &amp;&amp; e[k].v)&#123;</span><br><span class="line">                dis[e[k].to] = dis[now] + e[k].c ;</span><br><span class="line">                _F[e[k].to] = min(e[k].v, _F[now]) ;</span><br><span class="line">                pre[e[k].to] = now, Last[e[k].to] = k ;</span><br><span class="line">				<span class="keyword">if</span>(!mark[e[k].to])&#123;</span><br><span class="line">					q.push(e[k].to) ;</span><br><span class="line">					mark[e[k].to] = <span class="number">1</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] != Inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _EK()&#123;</span><br><span class="line">    <span class="keyword">while</span>(SPFA())&#123;</span><br><span class="line">        now = T, MAX_F += _F[T], MAX_C += dis[T] * _F[T] ;</span><br><span class="line">        <span class="keyword">while</span>(now != S)</span><br><span class="line">            e[Last[now]].v -= _F[T], e[Last[now] ^ <span class="number">1</span>].v += _F[T], now = pre[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; T ;</span><br><span class="line">    fill (head + <span class="number">1</span>, head + N + <span class="number">1</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; ++ i)</span><br><span class="line">        A = qr(), B = qr(), C = qr(), D = qr(), add(A, B, C, D) ;</span><br><span class="line">    _EK() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MAX_F &lt;&lt;<span class="string">" "</span>&lt;&lt; MAX_C &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑是否能用$dijkstra$来做。因为建反向边是要把代价取负，所以需要解决负权边问题。$rqy$ 当时是这么给我们讲的：</p>
<blockquote>
<p>考虑给每个点加一个“势”$h$ 。一条$u$ → $v$ 的费用为 $c$ 的边变成一条$u$→$v$费用是$c−h_v+h_u$ 的边。</p>
</blockquote>
<p>那么我们从点 $\rm S$ 到点 $\rm B$ 点的距离便从 $dis_B$ 变成了 $dis_B + h_s- h_B$，我们最后只需要把原来的势函数减去即可。</p>
<p>下面我们思考到底要选取什么作为势函数呢？</p>
<p>我们考虑将上次求出的最短路作为势函数，为什么呢？$rqy$是这么说的：</p>
<blockquote>
<p>这为什么是对的呢? </p>
<p>考虑一条边 $u→v$ ，费用为 $c$ 。</p>
<p>如果它上一次增广时残量不为 $0$ ，那么根据最短路的性质有$dis_u + c ≥ dis_v$ (不然的话说明最短路求错了)。 如果它上次增广时残量为 $0$ 而现在不为 $0$ ，那说明它的反向边被增广了。而增广的路径是最短路径，反向边是 $v → u$，费用 $−c$ 。所以$dis_v$ =$dis_u −c$ ，也就是说 $-c+dis_u −dis_v = 0$ 也是非负的，那么$w+h_u −h_v$就是非负的。 </p>
</blockquote>
<p>于是现在可以用 Dijkstra​ 增广，很快而且更难卡。</p>
<p>至于代码，大概长这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, c, f ;</span><br><span class="line">&#125;e[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> H[MAX], S ;</span><br><span class="line"><span class="keyword">int</span> dist[MAX], _F[MAX], Pre[MAX], i, k ;</span><br><span class="line"><span class="keyword">int</span> N, M, A, B, C, D, cnt = <span class="number">-1</span>, x1, x2, head[MAX] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dist, num ;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp; now) <span class="keyword">const</span>&#123;<span class="keyword">return</span> dist &gt; now.dist ; &#125;</span><br><span class="line">&#125;; priority_queue&lt;node&gt; q ; <span class="keyword">bool</span> vis[MAX] ; <span class="keyword">int</span> Last[MAX], MAX_F, MAX_C, t, ww ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (c &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[++ cnt].to = v, e[cnt].f = f ;</span><br><span class="line">    e[cnt].next = head[u], e[cnt].c = c, head[u] = cnt ;</span><br><span class="line">    e[++ cnt].to = u, e[cnt].f = <span class="number">0</span> ;</span><br><span class="line">    e[cnt].next = head[v], e[cnt].c = <span class="number">-1</span> * c, head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N; ++ i) dist[i] = _F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>, S&#125;) ; dist[S] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node now = q.top() ; q.pop() ; </span><br><span class="line">        <span class="keyword">while</span>(vis[now.num]&amp;&amp;!q.empty()) now = q.top(), q.pop();</span><br><span class="line">        x1 = now.num, x2 = now.dist ; <span class="keyword">if</span>(vis[x1]) <span class="keyword">continue</span> ; </span><br><span class="line">        vis[x1] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(k = head[x1] ; k != <span class="number">-1</span> ; k = e[k].next)</span><br><span class="line">            <span class="keyword">if</span> (e[k].f &gt; <span class="number">0</span> &amp;&amp; !vis[e[k].to] &amp;&amp; dist[e[k].to] &gt; x2 + e[k].c + H[x1] - H[e[k].to])&#123;</span><br><span class="line">                <span class="keyword">int</span> T = e[k].to ; dist[T] = x2 + e[k].c + H[x1] - H[T] ;</span><br><span class="line">                _F[T] = min(_F[x1], e[k].f), Pre[T] = x1, Last[T] = k, q.push((node)&#123;dist[T], T&#125;) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _EK()&#123;</span><br><span class="line">    <span class="keyword">while</span>(dijkstra())&#123;</span><br><span class="line">        ww = t, MAX_F += _F[t], MAX_C += (dist[t] - H[S] + H[t]) * _F[t] ;</span><br><span class="line">        <span class="keyword">while</span>(ww != S)</span><br><span class="line">            e[Last[ww]].f -= _F[t], e[Last[ww] ^ <span class="number">1</span>].f += _F[t], ww = Pre[ww] ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) H[i] += dist[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; t ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) head[i] = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        A = qr(), B = qr(), C = qr(), D = qr(), Add(A, B, C, D) ;</span><br><span class="line">    _EK() ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MAX_F &lt;&lt; <span class="string">" "</span> &lt;&lt; MAX_C &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流/最大流</tag>
        <tag>网络流/费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>随想二 · 丘吉尔</title>
    <url>/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一点功利的遐想？</p>
<a id="more"></a>
<hr>
<p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<hr>
<p>啊……还有几十天就 NOIP 了啊……</p>
<p>现在是下午四点，机房。</p>
<p>比我弱的都在颓废，比我强的都在做题。</p>
<p>唯独我在写博客。</p>
<p>我在想些什么呢？</p>
<hr>
<p>我是$pks$，没错，我不敢称自己为 Flower_pks，不敢称自己为“花”，因为这跟我实力不符——我不是那个在 $Luogu$ 这个 $OJ$ 上小有名气的「大佬」，不是那个题解写得十分详细的作者，更不是 SD 集训里面排的上号的人。</p>
<p>没错，我不配啊。</p>
<p>上午 rqy 出题，大概是被全方面碾压了吧。省队培训时虽然也考不多好，但是在学校里被平日里玩的很好的朋友碾压却是更加痛苦——我看不见路。</p>
<p>旁边的窗帘紧紧地闭着、贴着窗户，多云的日子里，挤进来阳光总是给人一种异样的感觉，洒在我的右肩上。</p>
<p>撇过头来看键盘上发着光的 w 键，突然有种想哭的欲望。</p>
<hr>
<p>我是真弱啊。</p>
<p>NOIP 现在省一都不稳吧，也就会写几个省选才会考到的板子了；板子也不怎么可以打出来吧，毕竟没有很强的记忆力——天生就是个弱者啊。</p>
<p>我总是特别羡慕别人敏锐的反应能了，羡慕独到的数学天赋，羡慕稳重的答题习惯，羡慕……</p>
<p>但我什么也没有。我也不是个富有毅力的人。</p>
<hr>
<p>我一直极其富有自尊，十分的自尊。所以我会拼了命地学别人不会的算法，并且十分不喜欢别人善意的和我共同进步，毕竟因为我太弱太弱。</p>
<p>我发现我这个人好诡异啊……其余走$OI$路的人都没有这种心理波动，只有我会把时间放在这上面吧。</p>
<p>估计是我什么都不适合吧。</p>
<hr>
<p>其实我不是特别喜欢去接近那些很强的人，因为他们总是凭着自己的实力不顾别人的感受。大概在这样的教育制度下，学习好、得了银牌或者怎样，才会有发言权吧。</p>
<p>这种人强到让我厌恶。让我悲哀。但却也让我为之疯魔。</p>
<p>好啦好啦你强好啦……我滚粗好了吧……</p>
<p>我并不是很服气，但是现实却总是不尽人意。</p>
<p>过去我一直能依靠着的、可以包容我的人已经与我一别两宽了，  估计以后也只能靠自己了吧。</p>
<p>我并不知道为什么我要选择承受这么多，大概是天性使然吧。</p>
<hr>
<p>我把丘吉尔的一句话当作人生的信条——当然不是唯一的信条。</p>
<blockquote>
<p>二战结束后的一天，年老的丘吉尔来到英国下议院，坐在一个年轻的议员旁边，突然问道：“年轻人，你知道是什么东西支撑我在各方面都取得了如此巨大的成就吗？”这个年轻的一员用非常渴望的眼神等待着这位德高望众的伟大人物的教诲，他说：“我非常想知道。”</p>
<p>“虚荣心！强烈的虚荣心！”丘吉尔大声说道，随即哈哈大笑，起身而去。</p>
</blockquote>
<p>路在哪呢……</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随想一 · 山丘</title>
    <url>/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hello，World！</p>
<a id="more"></a>
<p>“随想”系列索引：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p>
<hr>
<p>我是花，来自山东，今时今日写下这一篇，只是为了给并肩的$Oiers$一个不算多美的故事，为了给后来的$Oiers$一个对未来有所期望的愿景。</p>
<p>看着眼前发黄的电脑屏幕，不知道该说些什么。</p>
<p>现在的我即将高一，有着比较厉害的学长，和什么都不会的教练，每天来机房就是刷题-&gt;不会-&gt;刷题-&gt;不会。</p>
<p>大概我马上就要习惯了吧。</p>
<p>闷热的八月让人有一种说不出的惆怅，大概是初中毕业旧事未了，或者是即将$NOIp$但却并没太大信心，或者是教练总是给出不尽人意的安排打乱计划。</p>
<p>我捏着手边新换上的眼镜腿儿，默默地想到。</p>
<p>我依稀记得几个月前的快乐场景：每天都在学新算法、不亦乐乎地学、废寝忘食地学。最讨厌做模拟题、玛丽题或者搜索题。最喜欢去学习新的算法，所以导致我整天刷模板题：线段树、$Splay$、$LCA$……偶尔会兴致盎然地发几篇题解，也总是会用最生动的语言，盯着$luogu$的$markdown$那方小小的编辑框，一个字一个字地码着。二月的培训让我觉得是最有意义的一次培训了，大多数精致的$blog$都出自那时。一般都是回到宾馆后，开始联机颓废，等到半夜凌晨开始写博客，写到鱼肚泛白或者困意袭来才罢休。</p>
<p>可真是让人高兴的回忆啊……</p>
<p>回想这几个月，变化是日新月异的——就如同把一颗小小的石子扔进一池静水，起初不见多大声势，静候才可见其早已涤荡了半池——是波纹展开了。一开始来这儿，是实力悬殊的——初中有人努力、也有人不努力；初中时都挺聪明，在班里都名列前茅；初中时上奥赛几乎等于颓废，因为没多少人真正地在做题……</p>
<p>可惜时光不容许保留原来的模样。</p>
<p>主任盯得紧，教练怂主任从而也盯得紧；大多数人都因为外力的因素必须要努力，但也有根本不想努力的人；以前可以骄傲的资本、譬如文化课，现在早就变成了一纸空谈——作为所谓“奥赛负责人”的我，看到来到实验部第一次的月考成绩时，看到级部前二十（这一级实验部一共$116$个人）充斥着数学物理化学生物奥赛的人、却又跟信息学奥赛没有任何关系时，我不知道该怎么做。</p>
<p>于是我便开始加大压力：组织学生定期讲课、定期比赛。用这种空泛的压榨时间的行为来压榨效率无疑是可笑的，但是也起了一部分好的效果：几个$NOIp$内容都没会熟练的家伙开始跃跃欲试地学习$Splay$、学习网络流……我不知道这样做是否真的好，就如同我不知道我学习新东西是否会在十月、甚至十一月之前压垮所有人的神经——学完新东西、反过头来发现基础却根本不牢固——就如同为了学新知识，而去学新知识。这种功利让我不知道现在在走着一条怎样的路。</p>
<p>终于，差距出来了。经过几个月训练、实力强劲的人自然涌了上来，也有根本不行的人光辉逐渐黯淡。二月时的能力局面现在早就会焕然一新，有人选择走，有人选择苟活。我不清楚原来那些充满骄傲的、惬意的脸庞如今去了哪里，我只知道我给他们定的目标是今年全部省一、我只知道来到实验部之后，只能选择负重前行。</p>
<p>看着机房里其他人的变化，就宛如翻完了一部小说一般，跌宕而符合逻辑。</p>
<hr>
<p>告别了初中，留下了什么呢？或许是由于自身意气用事而破坏了原本纯洁的友情，但是我不能——真的不能仅仅把$Ta$当作一个不世出的好朋友。但当我跨越了自身的那一步之后才发现原来无人等候，才发现我只能把一些事情抛撒在风里，然后安慰自己“没事”。</p>
<hr>
<p>我喜欢李宗盛，喜欢他的歌里面唱出的人间无奈。而最喜欢的是他的《山丘》:</p>
<blockquote>
<p>给自己随便找了个理由，<br> 向情爱的挑逗，命运的左右。<br> 不自量力地还手，直至死方休——<br> 越过山丘——虽然已白了头；<br> 喋喋不休——时不我予的哀愁；<br> 还未如愿见着不朽<br> 就把自己先搞丢——<br> 越过山丘——才发现无人等候；<br> 喋喋不休——再也唤不回了温柔；<br> 为何记不得上一次是谁给的拥抱<br> 在什么时候。</p>
</blockquote>
<p>大概是能唱出柳永“杨柳岸晓风残月”几分意味的吧。</p>
<p>$2018/8/4$</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>随想/下下笔</tag>
      </tags>
  </entry>
</search>
