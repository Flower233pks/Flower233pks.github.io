<!DOCTYPE html><html class="theme-next gemini use-motion" lang=""><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/icon-32.png?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/icon-32.png?v=7.2.0"><link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.2.0"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Verdana:300,300italic,400,400italic,700,700italic|Verdana:300,300italic,400,400italic,700,700italic|Verdana:300,300italic,400,400italic,700,700italic|Verdana:300,300italic,400,400italic,700,700italic|Courier New:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.2.0",sidebar:{position:"left","Pisces | Gemini":270,width:270,display:"post",offset:12,onmobile:!1},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},copycode:{enable:!0,show_result:!0,style:"mac"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"}}</script><meta name="description" content="感觉自己真的是菜成一团… 感觉自己其实是地地道道的「empiricist」而不是「innovators」，也就是自己似乎并不具有「Pioneering thinking」。但为什么，为什么我想从事的一切恰恰都需要「Pioneering thinking」呢…？ 可能是人越缺少什么，就越向往什么吧？但是这怎么解释，我之前还不明白自己缺少什么的时候，怀抱着的对那片天空的无限憧憬呢？ 人总是喜欢问没有答"><meta property="og:type" content="article"><meta property="og:title" content="【泛做】简单题选做·第二弹"><meta property="og:url" content="https://www.orchidany.cn/2020/04/21/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC%E4%BA%8C%E5%BC%B9/index.html"><meta property="og:site_name" content="𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂&#39;𝔀 𝓫𝓵𝓸𝓰"><meta property="og:description" content="感觉自己真的是菜成一团… 感觉自己其实是地地道道的「empiricist」而不是「innovators」，也就是自己似乎并不具有「Pioneering thinking」。但为什么，为什么我想从事的一切恰恰都需要「Pioneering thinking」呢…？ 可能是人越缺少什么，就越向往什么吧？但是这怎么解释，我之前还不明白自己缺少什么的时候，怀抱着的对那片天空的无限憧憬呢？ 人总是喜欢问没有答"><meta property="article:published_time" content="2020-04-21T09:19:23.000Z"><meta property="article:modified_time" content="2020-04-24T10:23:50.000Z"><meta property="article:author" content="Orchidany"><meta property="article:tag" content="动态规划&#x2F;状压DP"><meta property="article:tag" content="动态规划&#x2F;有技巧的DP"><meta property="article:tag" content="思维题&#x2F;找性质"><meta property="article:tag" content="动态规划&#x2F;树形DP"><meta property="article:tag" content="动态规划&#x2F;单调队列"><meta property="article:tag" content="数学&#x2F;线性代数&#x2F;矩阵"><meta property="article:tag" content="图论&#x2F;Dilworth定理"><meta name="twitter:card" content="summary"><link rel="alternate" href="/atom.xml" title="𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂'𝔀 𝓫𝓵𝓸𝓰" type="application/atom+xml"><link rel="canonical" href="https://www.orchidany.cn/2020/04/21/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC%E4%BA%8C%E5%BC%B9/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>【泛做】简单题选做·第二弹 | 𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂'𝔀 𝓫𝓵𝓸𝓰</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="default"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂'𝔀 𝓫𝓵𝓸𝓰</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">A Soul Tune against Fate Should Be Played, now.</p></div><div class="site-nav-toggle"> <button aria-label="Toggle navigation bar"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li><li class="menu-item menu-item-friends"><a href="/Friends/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>Friends</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.orchidany.cn/2020/04/21/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC%E4%BA%8C%E5%BC%B9/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Orchidany"><meta itemprop="description" content="For code, science, tech. and more"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="𝓞𝓻𝓬𝓱𝓲𝓭𝓪𝓷𝔂'𝔀 𝓫𝓵𝓸𝓰"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">【泛做】简单题选做·第二弹</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-04-21 17:19:23" itemprop="dateCreated datePublished" datetime="2020-04-21T17:19:23+08:00">2020-04-21</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2020-04-24 18:23:50" itemprop="dateModified" datetime="2020-04-24T18:23:50+08:00">2020-04-24</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">Comments:</span><a href="/2020/04/21/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC%E4%BA%8C%E5%BC%B9/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/04/21/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A%C2%B7%E7%AC%AC%E4%BA%8C%E5%BC%B9/" itemprop="commentCount"></span></a></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> Views:<span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></span><br></div></header><div class="post-body" itemprop="articleBody"><p>感觉自己真的是菜成一团…</p><p>感觉自己其实是地地道道的「empiricist」而不是「innovators」，也就是自己似乎并不具有「Pioneering thinking」。但为什么，为什么我想从事的一切恰恰都需要「Pioneering thinking」呢…？</p><p>可能是人越缺少什么，就越向往什么吧？但是这怎么解释，我之前还不明白自己缺少什么的时候，怀抱着的对那片天空的无限憧憬呢？</p><p>人总是喜欢问没有答案的问题。因为求索总是让人感觉自己还切切实实活着在这个世界上啊。</p><p>Hide your skill from your clumsiness, make you fast in slowly.</p><p>本文共计 15 道题。</p><a id="more"></a><h1 id="UVA1407-Caves"><a href="#UVA1407-Caves" class="headerlink" title="UVA1407 Caves"></a><a href="https://uva.onlinejudge.org/external/14/p1407.pdf" target="_blank" rel="noopener">UVA1407 Caves</a></h1><blockquote><p>给定一棵 $n$ 个节点、边带权的树。$q$ 次询问，每次给定一个 $x$ ，询问从根出发走多少个点，满足走过的边权和 $&lt;x$ 且经过的点最多。点可以重复经过，但只会被计算一次。</p><p>$n\leq 500,q\leq 10^5,x\leq 5\cdot 10^8$ 。</p></blockquote><p>一个比较基础的思想是背包，但这时空显然不是背包能做的。这个地方考虑，点数只有 $500$，也就是至多只能走 $500$ 个点。于是就考虑把状态定义到点上，即 $f_{x,j}$ 表示以 $x$ 为根走了 $j$ 个不同的点的最小代价。注意到由于可以重复经过，所以多记一维 $0/1$ ，即 $f_{x,j,0/1}$ 表示以 $x$ 为根走了 $j$ 个不同的点，最终没回到/回到了 $i$ 的最小代价。考虑转移：</p><script type="math/tex;mode=display">
\begin{aligned}
f_{x,j,1}&=\min_{y\in son(x),1\leq k\leq size(y)}\{f_{x,k,1}+f_{y,j-k,1}+w\times 2\} \\
f_{x,j,0}&=\min_{y\in son(x),1\leq k\leq size(y)}\{f_{x,k,1}+f_{y,j-k,0}+w,f_{x,k,0}+f_{y,j-k,1}+w\times 2\} 
\end{aligned}</script><p>其中第二个转移表达的是这条路径的终点是否在以 $y$ 为根的子树内。注意转移的时候要倒序枚举 $j$ ，保证当前转移不重复。</p><p>发现 $f_{root}$ 显然是单调的，于是回答询问时二分即可。复杂度 $O(n^2+q\log n)$ 。因为好像有证明，这种东西的复杂度是 $O(n^2)$ 的…</p><h1 id="BZOJ4160-Exclusive-Access-2"><a href="#BZOJ4160-Exclusive-Access-2" class="headerlink" title="BZOJ4160 Exclusive Access 2"></a><a href="https://darkbzoj.tk/problem/4160" target="_blank" rel="noopener">BZOJ4160 Exclusive Access 2</a></h1><blockquote><p>给出 $n$ 个点 $m$ 条边的无向图，定向得到有向无环图，使得最长路最短。</p><p>$1\leq n ≤ 15, 1\leq m ≤ 100$ .</p></blockquote><p>大概是 $\rm dilworth$ 定理的应用，考虑 $\rm dilworth$ 定理：</p><blockquote><p>令 $(X,≤)$ 是一个有限偏序集，并令 $m$ 是反链的最大长度。则 $X$ 可以被划分成 $m$ 个但不能再少的链。 即：链的最少划分数 $=$ 反链的最长长度.。</p></blockquote><p>同时也存在对偶定理：</p><blockquote><p>令 $(X,≤)$ 是一个有限偏序集，并令 $r$ 是其最长链的大小。则 $X$ 可以被划分成 $r$ 个但不能再少的反链。</p></blockquote><p>也就是：</p><blockquote><p><strong>偏序集能划分成的最少的全序集个数等于最大反链的元素个数</strong> 。</p></blockquote><p>其中「全序集」指的是这样的一个偏序集 $(Y,\leq )$ ，改偏序集内部所有元素两两<strong>均可比</strong>。反链则指的是这样一个偏序集 $(Z,\leq )$ ，改偏序集内部所有元素两两均<strong>不可比</strong>。</p><p>换言之，假设给原图定向，那么根据 dilworth 定理，最长链的长度就是最小的独立集的大小，其中「独立集」的定义为原无向图中距离大于 $1$ 的两个点可以组成一个独立集(不考虑连通性)，因为只要两者没有边相连，两者的关系就是「不可比」。</p><p>于是这东西就可以状压了。$f_{s}$ 表示 $s$ 集合中最少有多少个独立集。这东西就可以先预处理一下每个 $s$ 是否是独立集，然后 $3^n$ 暴力 $dp$ 即可。</p><h1 id="POJ3735-Training-little-cats"><a href="#POJ3735-Training-little-cats" class="headerlink" title="POJ3735 Training little cats"></a><a href="http://poj.org/problem?id=3735" target="_blank" rel="noopener">POJ3735 Training little cats</a></h1><blockquote><p>现在给你一个长度为 $n$ 的序列，开始这个序列都是 0。对这个序列一共有三种操作：</p><p>操作 1：输入一个 $x$，把 $x$ 位置上的值 $+1$ 。</p><p>操作 2：输入一个 $x$ 一个 $y$，交换 $x$，$y$ 位置上的值。</p><p>操作 3：输入一个 $x$，把 $x$ 位置上的值变成 $0$ 。</p><p>我们接着对这个序列进行 $k$ 次操作。</p><p>我们把这 $k$ 次操作叫做一轮，现在这个 $k$ 个操作进行了 $m$ 轮。</p><p>输出最后的序列。</p><p>$1\leq n\leq 100,1\leq k\le 10^4,1\leq m\leq 10^9$ 。</p></blockquote><p>…矩阵快速幂神题 sto</p><p>考虑一开始把这个空的序列记作一个 $n+1$ 维向量 $A:[1,0,0\cdots,0]$ 。其中第一维留空赋值为 $1$ ，$2\sim n+1$ 分别代表序列的第 $1\sim n$ 号元素。</p><p>那么考虑由于 $m$ 比较大，但是每次操作都是一样的，于是启发要用矩阵快速幂。</p><p>考虑三个操作，以下默认右乘转移矩阵 $T$ 、位置 $p,q$ 都是原序列右移一位的位置。</p><p>1、位置 $p$ 的数 $+1$ 。</p><p>考虑对于 $n+1$ 阶单位矩阵</p><script type="math/tex;mode=display">
\begin{bmatrix}1&0&0&\cdots &0\\ 0&1&0&\cdots&0 \\ 0&0&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>考虑如何使得乘上这个矩阵的某个变形之后，位置 $p$ 实现 $+1$ 。考虑矩阵运算的本质是 $c_{i,j}=\sum_{k}a_{i,k}\cdot b_{k,j}$ ，那么 $A’_{1,p}=\sum _{i=1}^{n+1}A_{1,i}\cdot T_{i,p}$ ，因为 $A_{1,1}$ 恒定为 $1$ ，所以可知应该让 $T_{1,p}=1$ 实现 $+1$ 的功能。比如 $p=2$ ：</p><script type="math/tex;mode=display">
\begin{bmatrix}1&0&1&\cdots &0\\ 0&1&0&\cdots&0 \\ 0&0&1&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>2、交换位置 $p,q$ 的数。</p><p>还是考虑 $n+1$ 阶单位矩阵。观察矩阵乘法本质，$A’_{1,q}=\sum_{i=1}^{n+1}A_{1,i}T_{i,q}$ ，那么一方面要让之前 $q$ 位置的数消失，一方面又要让 $A’_{1,q}=A_{1,p}$ ，于是应该让 $T_{q,q}=0,T_{p,q}=1$ 。 即如果 $p=1,q=2$ ，则应该是：</p><script type="math/tex;mode=display">
\begin{bmatrix}1&0&0&\cdots &0\\ 0&0&1&\cdots&0 \\ 0&1&0&\cdots&0\\ \vdots&\vdots&\vdots&\ddots&\vdots\\ 0&0&0&\cdots&1\end{bmatrix}</script><p>3、位置 $p$ 的数清零。</p><p>…$T_{p,p}=0$ 就好了。</p><p>注意到上面都是单独进行一个操作的情况。如果出现多个操作冗杂在一起，那么一方面可以建 $k$ 个转移矩阵，每次新的转移矩阵要乘上之前的矩阵，这样复杂度就是 $O(n^3k+n^3\log m)$ 。有点爆炸。</p><p>注意到可以把这 $k$ 次操作都放到一个转移矩阵里面，第 $2,3$ 操作就要相应发生改变，$2$ 操作就需要对换 $T$ 的 $p$ 列和 $q$ 列，$3$ 操作则需要把 $p$ 这一列全部清零。这样复杂度就是 $O(nk+n^3\log m)$ 了， 可以通过本题。</p><p>但其实 $n$ 可以出到 $2000$。注意到本题中最多只有 $O(n)$ 个不为零的位置。所以只需要对这些位置做矩阵乘法即可。复杂度变成了 $O(nk+n^2\log m)$ 。</p><p>哦，poj 上多组数据，那没事了（</p><h1 id="UVA1437-String-painter"><a href="#UVA1437-String-painter" class="headerlink" title="UVA1437 String painter"></a><a href="https://www.luogu.com.cn/problem/UVA1437" target="_blank" rel="noopener">UVA1437 String painter</a></h1><blockquote><p>给定一个串 $s$ 和一个目标串 $t$。每次可以将 $s$ 的连续一段刷成一个同一个字符。求最少多少次操作使得 $s$ 变成 $t$ 。</p><p>$1\leq |s|,|t|\leq 500$ 。</p></blockquote><p>一开始的错误思路：考虑如果两个对应位置的字符相同，那么就可以把这对字符删掉不需要管，剩下的 $s$ 就可以看做空串。对这个进行 $dp$ ，$f_{i,j}$ 表示刷好了区间 $[i,j]$ 内字符的最小代价，每次转移考虑如果 $i$ 和 $j$ 相同就从 $f_{i+1,j}$ 或者 $f_{i,j-1}$ 转移过来之类的…反正很乱很乱很乱…</p><p>写了一发之后发现挂了。理了理思路，发现首先有个错误的点，即不一定「删掉不管」是最优的，可能相同的字符会先被覆盖然后再涂上。所以这个思路本来就是错的。之后再考虑，以 $1$ 为步长转移本身没有道理，因为转移时枚举一个子状态，要枚举一个可能存在的确定量。</p><p>所以设 $f_{i,j}$ 表示一个空串的 $[l,r]$ 刷成 $t[l…r]$ 的最少代价。转移时考虑枚举一个和 $l$ 或 $r$ 同色的端点 $k\in[l,r]$ 分成两个子问题即可。之后考虑如何把 $s$ 刷成 $t$ 。设 $g_i$ 表示 $s[1…i]$ 刷成 $t[1…i]$ 的最小代价。考虑比起一个空串，$s$ 中可能存在某些与 $t$ 对应相等的位置。这时只要 <code>chkmax(g[i], g[i - 1])</code> 即可。为了保证转移全面，直接枚举断点转移即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i) f[i][i] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span> ; len &lt; n ; ++ len)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n - len ; ++ i)&#123;</span><br><span class="line">		j = i + len ; f[i][j] = f[i][j - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = i ; k &lt;= j - <span class="number">1</span> ; ++ k)</span><br><span class="line">			<span class="keyword">if</span> (t[j] == t[k]) </span><br><span class="line">				chkmin(f[i][j], f[k + <span class="number">1</span>][j - <span class="number">1</span>] + f[i][k]) ;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">	g[i] = f[<span class="number">1</span>][i] ;</span><br><span class="line">	chkmin(g[i], s[i] == t[i] ? g[i - <span class="number">1</span>] : P) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= i ; ++ k)</span><br><span class="line">		chkmin(g[i], g[k - <span class="number">1</span>] + f[k][i]) ; </span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">//为什么总是学不会？</span></span><br></pre></td></tr></table></figure><h1 id="UVA1427-Parade"><a href="#UVA1427-Parade" class="headerlink" title="UVA1427 Parade"></a><a href="https://www.luogu.com.cn/problem/UVA1427" target="_blank" rel="noopener">UVA1427 Parade</a></h1><blockquote><p>有一个由 $n+1$ 条横向路和 $m+1$ 条竖向路构成的网格图，每条横向路有一个高兴值和经过的时间。</p><p>现在想从网格的最下方走到最上方，求能得到的最大的高兴值是多少。</p><p>走路有限制：不能多次经过同样的路，也不会从下往上走。另外，在每条横向路上所花的时间不能超过 $k$ 。</p><p>$1\leq n\leq 100,1\leq m\le 10^4$ 。</p></blockquote><p>一开始想的是直接暴力 $dp$，枚举每一行的每个出发点(即从上一行转移过来的点)，考虑向左走一定是走一个包含当前点的最大子段和，向右也是。然后一开始觉得这个思路很有道理，但有点疑惑：我把 $n$ 和 $m$ 读反了，导致我以为这个做法是 $n^2m$ 没准可以卡过去的…后来发现是 $m^2n$ …虽然 $n^2m$ 也必定过不去就是了。</p><p>后来想了想，大概可以定义一个比较靠谱的状态。$f_{i,j}$ 表示到达了 $(i,j)$ 的最大高兴值。那么每次转移可以定向，从右边或者从左边。注意到由于存在 $k$ 的限制，决策区间具有单调性。所以可以用单调队列优化掉一个 $m$ 。</p><p>好像很简单的样子…但是不能一眼 A 就是罪过吧…</p><h1 id="UVA11795-Mega-Man’s-Mission"><a href="#UVA11795-Mega-Man’s-Mission" class="headerlink" title="UVA11795 Mega Man’s Mission"></a><a href="https://www.luogu.com.cn/problem/UVA1427" target="_blank" rel="noopener">UVA11795 Mega Man’s Mission</a></h1><blockquote><p>洛克人最初只有一种武器 “Mega Buster”（这种武器可以消灭特定的一些机器人），你需要按照一定的顺序消灭 n 个其他机器人。每消灭一个机器人你将会得到他的武器（也可能没有得到武器），而这些武器可以消灭特定的机器人。你的任务是计算出消灭所有机器人的<strong>顺序总数</strong>。注意：一个机器人的武器可能可以消灭自己，但这对最终答案没有影响，因为必须先消灭这个机器人才能够得到他的武器。</p><p>$1\leq n\leq 16$ 。</p></blockquote><p>其实是很水的题…只是记录一个坑点。遇到这种求顺序总数的时候，我大脑总会选择性宕机…准确来说，显然这题是要预处理一个 $g_s$ 表示杀死 $s$ 中的怪物后可以获得那些武器。然后考虑 $f_s$ 表示杀死 $s$ 中的怪兽的顺序总数。对于 $f$ 的转移，我一开始是想的是要首先枚举每个元素，再去枚举这个元素第几个出现合法，但是这就需要再记一个其他元素的顺序，然后就爆炸了。</p><p>这也反映了自己并没有理解认真理解 $dp$ 子问题重叠的本质。考虑如何简化子问题。发现无论以什么顺序转移，最后一个加进去的元素是固定的(感性理解)。或者换句话说我们并不关心某个元素 $x$ 在集合内第几个出现，这些状态都可以合并到集合较小时 $x$ 最后一个加入的状态。所以只需要枚举最后一个元素+判断合法性即可。</p><p>菜成一坨，GGGGGGGGG。</p><h1 id="UVA1625-Color-Length"><a href="#UVA1625-Color-Length" class="headerlink" title="UVA1625 Color Length"></a><a href="https://uva.onlinejudge.org/external/16/p1625.pdf" target="_blank" rel="noopener">UVA1625 Color Length</a></h1><blockquote><p>输入两个长度分别是 $n$ 和 $m$ 的颜色序列，要求按顺序合并成同一个序列，即每次可以把一个序列开头的颜色放到新序列的尾部。</p><p>记 $L(c)$ 为关于颜色 $c$ 和合并之后的排列的一个函数，定义如下：</p><script type="math/tex;mode=display">
L(c)=\max_{p\in[1,n+m]\cap \mathbb{Z_+}}\{p~|~color(p)=c\} - \min_{p\in[1,n+m]\cap \mathbb{Z_+}}\{p~|~color(p)=c\}</script><p>你的任务是找一种合并方式，使得所有 $L(c)$ 的总和最小。</p><p>$1\leq n,m\leq 5000$ 。</p></blockquote><p>考虑朴素的状态当然是 $f_{i,j}$ 表示 $A$ 合并到位置 $i$，$B$ 合并到位置 $j$ 的最小总和…等下，似乎这东西并不可以很好的转移，因为考虑对于每个前驱状态，并不是很好记录每个颜色第一出现的位置，同时也不好维护最后出现的位置，根本没法转移。</p><p>考虑一个 trick，提前计算贡献。即虽然其余的都很麻烦，但是可以比较方便地知道有哪些颜色一定没有合并完。所以可以每次转移时，计算还没有合并完的贡献。这样做本质上是把贡献分摊到每个元素上面。因为考虑这种转移，对于每个终止状态，并不关心前面代价转移的形式，只关心代价转移的结果。</p><p>于是就预处理一个 $g_{i,j}$ 表示 $A$ 合并到位置 $i$，$B$ 合并到位置 $j$ 时有多少个字母还没有闭合。剩下的 $nm$ 转移即可。</p><h1 id="UVA1218-Perfect-Service"><a href="#UVA1218-Perfect-Service" class="headerlink" title="UVA1218 Perfect Service"></a><a href="https://onlinejudge.org/external/12/p1218.pdf" target="_blank" rel="noopener">UVA1218 Perfect Service</a></h1><blockquote><p>一个网络中有 $n$ 个节点，由 $n-1$ 条边连通，每个节点是服务器或者客户端。如果节点 $u$ 是客户端，就意味着 $u$ 所连接的所有点中有且仅有一台服务器。求最少要多少台服务器才能满足要求。</p><p>$1\leq n\leq 10^6$ 。</p></blockquote><p>这题比较水，主要是整理一下，给自己提个醒。如果设 $f_{x,0/1}$ 表示 $x$ 当根不选/选自己的话，注意到会出现 $f_{son_x,0}$ 没法转移到 $f_{x,1}$ 这种情况，因为不知道 $son_{son_x}$ 选没选。这种定义状态的方式就过于模糊。</p><p>于是考虑因为难以记儿子，所以记父亲。$f_{x,0/1/2}$ 分别表示「$x$ 和 $fa_x$ 都没选」、「$x$ 选了 $fa_x$ 不管(因为选不选都不引起冲突)」、「$x$ 没选 $fa_x$ 选了」，于是就是：</p><script type="math/tex;mode=display">
\begin{aligned}
f_{x,0}&=\min_{y\in son(x)}\{f_{y,1}+\sum_{z\in son(x),z\not=y} f_{z,0}\}\\
f_{x,1}&=1+\sum_{y\in son(x)} \min\{f_{y,1}+f_{y,2}\} \\
f_{x,2}&=\sum_{y\in son(x)} f_{y,0} 
\end{aligned}</script><p>注意到，其中 $f_{x,1}$ 这个状态，本质上是两个状态的合并。可以考虑分裂成 $f_{x,3/4}$ 表示 $x$ 选了 $fa_x$ 选没选，发现被转移的时候，两者转移是一样的。所以就可以简并成一个状态。</p><h1 id="UVA12099-The-Bookcase"><a href="#UVA12099-The-Bookcase" class="headerlink" title="UVA12099 The Bookcase"></a><a href="https://uva.onlinejudge.org/external/120/p12099.pdf" target="_blank" rel="noopener">UVA12099 The Bookcase</a></h1><blockquote><p>有 $n$ 本书，每本书有一个高度 $h_i$ 和一个宽度 $w_i$。 现在要构建一个 $3$ 层的书架，你可以选择将 $n$ 本书放在书架的哪一层。设 $3$ 层高度(每层书的最大高度)之和为 $h$，书架总宽度为 $w$，要求 $h×w$ 尽量小。</p><p>$3\le n\leq 70,1\leq h_i\leq 300,1\leq w_i\le 30$ 。</p></blockquote><p>本质上是要最优化两样东西，宽度和高度。所以不妨让其中一个变得有序，所以考虑先按照 $h_i$ 把所有书降序排序。</p><p>考虑如何设计状态。发现如果某一层有最高的那本书，那么无论怎么放书，这一层的高度都不会再受影响；同时，把每一层的高度和宽度都记下来是没有必要的，于是可以记某一维为某个确切数值时另一维的最小值。具体的，$f_{i,j,k}$ 表示考虑了前 $i$ 本书，第二层的宽度为 $j$，第三层宽度为 $k$ 时，第二层、第三层的最小高度和。此处记宽度为状态是因为一方面高度和宽度是对称的，另一方面宽度的数据范围显然比高度要小。</p><p>考虑转移。首先应该定一个顺序，比如第二层高度应该大于第三层，那么此时转移有：</p><script type="math/tex;mode=display">
f_{i,j,k}=\min\{f_{i-1,j,k}~,~f_{i-1,j-w_{i},k}+[j-w_i=0]\cdot h_i~,~f_{i-1,j,k-w_{i}}+[k-w_i=0]\cdot h_i\}</script><p>其中第三个决策当且仅当第二层已经有了一本书。</p><p>考虑这样 $dp$ 的复杂度，似乎是 $O(n\cdot \left(\sum w_i\right)^2)$ ，有点爆炸。考虑如何剪枝：</p><p>1、$j+k\leq \sum_{t=1}^iw_t$ 。</p><p>2、$\sum_{t=1}^iw_t-j-k+30\geq j,j+30\geq k$。</p><p>其中第一可行性个比较好理解，第二个最优性剪枝是在说，因为 $\max\{w_i\}\leq 30$，所以如果高层的宽度比低层的宽度 $+30$ 还要大，那么不妨将几本书放到低层，可知这样放一定不会使结果更劣。</p><p>这么一波剪枝之后似乎就跑的飞快了…似乎是要滚一下第一维的样子。</p><p>大概转移and初始赋值这些会有一点细节的样子吧。</p><h1 id="UVA10559-Blocks"><a href="#UVA10559-Blocks" class="headerlink" title="UVA10559 Blocks"></a><a href="https://uva.onlinejudge.org/external/105/p10559.pdf" target="_blank" rel="noopener">UVA10559 Blocks</a></h1><blockquote><p>有 $n$ 个带有颜色的方块，没消除一段长度为 $x$ 的连续的相同颜色的方块可以得到 $x^2$ 的分数，让你用一种最优的顺序消除所有方块使得得分最多。</p><p>$1\leq n\leq 200$ 。</p></blockquote><p>大概是比较神仙的 $dp$ 了吧…</p><p>第一感觉肯定就是 $f_{l,r}$ 嘛，但是这么做的话本质上就变成贪心了，因为可能转移时，$f_{l,k}$ 和 $f_{k,r}$ 是消掉中间一部分，再合并起来的模式。注意到，对于一段 $i,j$，假设 $i&lt;q&lt;j$ 满足 $q\sim j$ 同色，$i&lt;o&lt;p&lt;q$ 满足 $o\sim p$ 与 $q\sim j$ 同色，那么一种决策就是把这两段合并。但是注意到可能还会存在一个区间 $i&lt;s&lt;t&lt;o$ 满足 $s\sim t$ 和 $o\sim p$ 同色。</p><p>于是这就启发(个鬼，这怎么可能想得出来)要多记一维状态 $d$，即 $f_{l,r,d}$ 表示 $l\sim r$ 的这段区间内，区间右侧还有 $d$ 个元素和 $r$ 同颜色时的最大得分。这样每次就以「和右端点颜色相同的颜色段」为子决策进行转移。那么需要枚举每次有多少个块和右端点一起删掉，在这基础枚举一个和右端点同色的、靠左的点进行转移，表示右端点所在的同色段暂时先不删，加入继续向左延伸的长同色段的一部分。</p><p>复杂度的话，状态是 $O(n^3)$ 的，然后我这种写法好像很迷幻，<del>我觉得应该是 $n^5$ 但不知道为什么测出来极限数据(即所有颜色都相同)时运算量在 $n^4$ 量级</del> …剪枝是要剪的，每次只关心和 $r$ 同色的元素就好了。</p><p>好的，我又重新写了一下测了一下，觉得应该把访问记忆化结果也算 $1$ 次运算。发现 $100$ 个相同的颜色放在一起，这么写的运算量大概是 $258712510\approx2.6\cdot 10^8$，大概 $1s$ 内是可以跑出来结果的(uoj custom test 900ms左右)。$200$ 个颜色相同的就已经是紫荆花之恋那题跑不出来的程度了(即 $14s$ 以内跑不出来，只能本地测试)，似乎足足要 $1\min+$，大概是 $8136350020\approx8\cdot 10^9$ 的运算量<del>中间可执行文件还一度被系统给 kill 掉了</del> 。</p><p>然后…然后我就加了一个好像很牛逼的剪枝，大概就是判断一下 $l\sim r$ 这一整段是不是同色，如果是的话就直接算完了返回即可。发现这样之后极端数据就应该是只有两种颜色然后左右交替这种，就可以在 $370\sim400ms$ 左右跑出来<del>但似乎应该还是过不了，因为极限可以有15组数据，每组都这个速度肯定跑不进3s鸭</del>。</p><p>然后发现这个某个区间是否同色可以预处理，然后就预处理了一下，发现一组快的话只需要 $320ms$ 左右了…</p><p>然后又改了一下，发现可以稍微贪一下，「枚举每次有多少个块和右端点一起转移走」显然是最大的那个快最好了。但这并没有快…</p><p>删了点重复计算和冗杂判断…发现大概是稳定在 $320ms$ 左右了…</p><p>…发现自己是个弟弟，如果要把右边和左边合并的话，那肯定是全都一起合并最优。所以现在大概是真正的 $O(n^4)$ 算法了？一组大概是 $200ms$ 左右了…人艰不拆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1 最大点 400ms</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = r, j = lst[r] ; i &gt;= l ; j = lst[j], i = lst[i])</span><br><span class="line">		<span class="keyword">if</span> (i != j + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span> ; <span class="keyword">return</span> <span class="number">1</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ; </span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (check(l, r)) <span class="keyword">return</span> f[l][r][t] = (t + r - l + <span class="number">1</span>) * (t + r - l + <span class="number">1</span>) ;<span class="comment">//剪枝 1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= l &amp;&amp; base[i] == base[r] ; -- i)&#123;</span><br><span class="line">		chkmax(f[l][r][t], solve(l, i - <span class="number">1</span>, <span class="number">0</span>) + (t + r - i + <span class="number">1</span>) * (t + r - i + <span class="number">1</span>)) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = lst[i] ; j &gt;= l ; j = lst[j])</span><br><span class="line">			<span class="keyword">if</span> (base[j] == base[r]) </span><br><span class="line">				chkmax(f[l][r][t], solve(j + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, r - i + <span class="number">1</span> + t)) ; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本2 最大点 320- ms</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line">	<span class="keyword">if</span> (g[r] &lt;= l) <span class="keyword">return</span> f[l][r][t] = (t + r - l + <span class="number">1</span>) * (t + r - l + <span class="number">1</span>) ;</span><br><span class="line">	chkmax(f[l][r][t], solve(l, g[r] - <span class="number">1</span>, <span class="number">0</span>) + (t + r - g[r] + <span class="number">1</span>) * (t + r - g[r] + <span class="number">1</span>)) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = r ; i &gt;= g[r] ; -- i)&#123;</span><br><span class="line">		<span class="keyword">register</span> <span class="keyword">int</span> pq = t + r - i + <span class="number">1</span> ; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = lst[i] ; j &gt;= l ; j = lst[j])</span><br><span class="line">			chkmax(f[l][r][t], solve(j + <span class="number">1</span>, i - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, pq)) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T ; Q = T ;</span><br><span class="line">	<span class="keyword">while</span> (T --)&#123;</span><br><span class="line">		n = qr() ;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">		<span class="built_in">memset</span>(buc, <span class="number">0</span>, <span class="keyword">sizeof</span>(buc)) ;</span><br><span class="line">		<span class="built_in">memset</span>(lst, <span class="number">0</span>, <span class="keyword">sizeof</span>(lst)) ;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, Q - T) ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			lst[i] = buc[base[i] = qr()], buc[base[i]] = i ;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i ; j &gt;= <span class="number">1</span> ; -- j)</span><br><span class="line">				<span class="keyword">if</span> (base[i] == base[j]) g[i] = j ; <span class="keyword">else</span> <span class="keyword">break</span> ; </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; solve(<span class="number">1</span>, n, <span class="number">0</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本3 200- ms 左右 此时根本不需要判整段是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> f[l][r][t] = <span class="number">0</span> ;</span><br><span class="line">	<span class="keyword">if</span> (f[l][r][t]) <span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">	<span class="keyword">if</span> (l == r) <span class="keyword">return</span> f[l][r][t] = (t + <span class="number">1</span>) * (t + <span class="number">1</span>) ;</span><br><span class="line">	<span class="comment">//if (g[r] &lt;= l) return f[l][r][t] = (t + r - l + 1) * (t + r - l + 1) ;</span></span><br><span class="line">	chkmax(f[l][r][t], solve(l, g[r] - <span class="number">1</span>, <span class="number">0</span>) + (t + r - g[r] + <span class="number">1</span>) * (t + r - g[r] + <span class="number">1</span>)) ;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = lst[g[r]] ; j &gt;= l ; j = lst[j])</span><br><span class="line">		chkmax(f[l][r][t], solve(j + <span class="number">1</span>, g[r] - <span class="number">1</span>, <span class="number">0</span>) + solve(l, j, (t + r - g[r] + <span class="number">1</span>) )) ;</span><br><span class="line">	<span class="keyword">return</span> f[l][r][t] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA1380-A-Scheduling-Problem"><a href="#UVA1380-A-Scheduling-Problem" class="headerlink" title="UVA1380 A Scheduling Problem"></a><a href="https://onlinejudge.org/external/13/p1380.pdf" target="_blank" rel="noopener">UVA1380 A Scheduling Problem</a></h1><blockquote><p>给定一棵树，pks把其中某些边改成了有向边。现在要求把所有边都改成有向边，求最长链的长度最小值。</p><p>$1\leq n\leq 200$ 。</p></blockquote><p>考虑首先，对于这种带方向性的计算链长，在树上一般都是要分成两部分做。于是不妨令 $f_i$ 表示从 $i$ 开始，到 $i$ 子树中的某个点结束的最长链，令 $g_i$ 表示到 $i$ 结束，起点是子树内某个点的最长链。然后开始分类讨论，设当前点为 $x$ ：</p><p>1、如果对于某个 $x$ ，该点与所有儿子的连边均为有向边，那么：</p><p>那么就是比较朴素的转移。</p><script type="math/tex;mode=display">
f_{x}=1+\max_{y\in son(x)}\{f_{y}\cdot [\exists(x,y),x\to y]\}\\g_{x}=1+\max_{y\in son(x)}\{g_{y}\cdot [\exists(y,x),y\to x]\}\\</script><p>2、如果存在某个 $y\in son(x)$ ，$(x,y)$ 是无向边，那么：</p><p>那自然是再分类讨论这条边重定向成 $x\to y$ 还是 $y\to x$ 。但…这样做毕竟是 $2^{\mathrm{count}(son(x))}$ 的，如果一棵树全都是无向边那人就没了。</p><p>考虑观察一点更深刻的性质。发现如果对于某个 $y$ ，被定向成了 $y\to x$ ，那么考虑对于其他 $g_z&lt;g_y$ 的 $(x,z)$ 未定向的 $z\in son(x)$ ，一定是要定向成 $z\to x$ 的。原因是，定向成 $z\to x$ 对当前没有任何贡献，因为边不带权，且 $y$ 转移过来一定更优；同时 $z\to x$ 对另一边的 $f$ 的转移没有任何贡献。综上，这样做一定不会使得结果更劣。</p><p>那么就可以考虑，一开始用 <code>vector&lt;int&gt;</code> 将所有无向边连接的儿子给 <code>push_back</code> 进来。对于 $f$ 和 $g$ 分别处理。这个地方需要注意到题目中有个定理：</p><blockquote><p>假如 $\rm G$ 是一棵树，那么需要的天数是 $k$ 或 $k+1$ 。$k$ 满足：$k$ 是 $\rm G$ 中所有链中一条链能包含的最多顶点数。</p><p>链的定义：在一条路径 $ P=(x_1, x_2, …, x_k)$中 ，对于任意的 $i=1,2,…,k-1$，总有一条从 $x_i$ 指向 $x_{i+1}$ 的有向边。</p></blockquote><p><del>但其实这个定理也可以没有用。因为只需要在外层套一个二分就好了。</del>·</p><p>这提示我们只关心最长链是否 $&gt;k$，而不关心是否真的被最小化了。也就是说，我们致力于保证 $f$ 和 $g$ 是最优的，但是不用考虑 $f$ 和 $g$ 怎么合并——因为这个地方，可能会出现最优化 $g$ 和 $f$ 的时候，对于一条无向边被用了两次。但这并不重要，因为可能存在这么一个局面， $f_x$ 此时没有被最优化，$g_x$ 也没有被最优化，但是 $f_x+g_x\leq k$ 并且两者的决策不相交——这就可以保证至少在 $x$ 这里 $k$ 是合法的。那么就考虑在排完序扫两遍的过程中记录贡献即可。</p><p>注意一个问题，由于这个状态记录的不是子树的最大值(当然也可以多记一个这个)，所以如果中有以某点为根，路径长度 $&gt;k$ 的，需要将这个信息向上传导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_in</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v ; <span class="keyword">char</span> w ;</span><br><span class="line">	res = cnt = ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="number">0</span> ; n = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span>(fa)) ;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span> :: <span class="built_in">cin</span> &gt;&gt; u)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> ret ;</span><br><span class="line">        ret = <span class="number">1</span>, n = <span class="built_in">std</span> :: max(u, n) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%c"</span>, &amp;v, &amp;w) &amp;&amp; v)&#123;</span><br><span class="line">            fa[v] = u ; n = <span class="built_in">std</span> :: max(n, v) ;</span><br><span class="line">            <span class="keyword">if</span> (w == <span class="string">'d'</span>) add_e(u, v, <span class="number">2</span>), add_e(v, u, <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w == <span class="string">'u'</span>) add_e(u, v, <span class="number">1</span>), add_e(v, u, <span class="number">2</span>) ;</span><br><span class="line">            <span class="keyword">else</span> add_e(u, v, <span class="number">0</span>), add_e(v, u, <span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    ans = <span class="built_in">std</span> :: max(ans, len) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa &amp;&amp; val(k) == <span class="number">2</span>) dfs(to(k), x, len + <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">const</span> <span class="keyword">int</span> &amp; y)</span></span>&#123; <span class="keyword">return</span> f[x] &lt; f[y] ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp_g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; x, <span class="keyword">const</span> <span class="keyword">int</span> &amp; y)</span></span>&#123; <span class="keyword">return</span> g[x] &lt; g[y] ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">do_dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; x &lt;&lt; '\n' ;</span></span><br><span class="line">    f[x] = g[x] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> F, G, df, dg ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[x] ; k ; k = next(k))&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) != fa)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!do_dp(to(k), x)) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">if</span> (!val(k)) son[x].p_b(to(k)) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (val(k) &gt; <span class="number">1</span>)</span><br><span class="line">                 f[x] = <span class="built_in">std</span> :: max(f[x], f[to(k)] + <span class="number">1</span>) ;</span><br><span class="line">            <span class="keyword">else</span> g[x] = <span class="built_in">std</span> :: max(g[x], g[to(k)] + <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    F = f[x] ; G = g[x] ;</span><br><span class="line">	<span class="keyword">if</span> (son[x].empty()) <span class="keyword">return</span> (<span class="keyword">bool</span>)(F + G &lt;= ans) ;</span><br><span class="line">    f[x] = ans + <span class="number">1</span> ; suf[son[x].size()] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">std</span> :: sort(son[x].begin(), son[x].end(), comp_f) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = son[x].size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">        suf[i] = <span class="built_in">std</span> :: max(suf[i + <span class="number">1</span>], g[son[x][i]]) ;</span><br><span class="line"><span class="comment">//	debug(suf, 0, n) ;</span></span><br><span class="line">	<span class="keyword">if</span> (F + suf[<span class="number">0</span>] + <span class="number">1</span> &lt;= ans) f[x] = F ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[x].size() ; ++ i)&#123;</span><br><span class="line">        dg = <span class="built_in">std</span> :: max(G, suf[i + <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">        df = <span class="built_in">std</span> :: max(F, f[son[x][i]] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (df + dg &lt;= ans) f[x] = <span class="built_in">std</span> :: min(f[x], df) ;</span><br><span class="line">	&#125;</span><br><span class="line">    g[x] = ans + <span class="number">1</span> ; suf[son[x].size()] = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">std</span> :: sort(son[x].begin(), son[x].end(), comp_g) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = son[x].size() - <span class="number">1</span> ; i &gt;= <span class="number">-1</span> ; -- i)</span><br><span class="line">        suf[i] = <span class="built_in">std</span> :: max(suf[i + <span class="number">1</span>], f[son[x][i]]) ;</span><br><span class="line"><span class="comment">//	debug(suf, 0, n) ;</span></span><br><span class="line">	<span class="keyword">if</span> (G + suf[<span class="number">0</span>] + <span class="number">1</span> &lt;= ans) g[x] = G ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; son[x].size() ; ++ i)&#123;</span><br><span class="line">        df = <span class="built_in">std</span> :: max(F, suf[i + <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line">        dg = <span class="built_in">std</span> :: max(G, g[son[x][i]] + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">if</span>(df + dg &lt;= ans) g[x] = <span class="built_in">std</span> :: min(g[x], dg) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//	cout &lt;&lt; x &lt;&lt; " " &lt;&lt; F &lt;&lt; " " &lt;&lt; G &lt;&lt; " " &lt;&lt; f[x] &lt;&lt; " " &lt;&lt; g[x] &lt;&lt; '\n' ;</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">bool</span>)(f[x] &lt;= ans || g[x] &lt;= ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (read_in())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!fa[i]) root = i ;</span><br><span class="line">			dfs(i, <span class="number">0</span>, <span class="number">0</span>) ; son[i].clear() ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//		cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for (int i = 1 ; i &lt;= cnt ; ++ i)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; to(i) &lt;&lt; " " &lt;&lt; val(i) &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        res = do_dp(root, <span class="number">0</span>) ; <span class="comment">//return 0 ;</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; f[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">//      for (int i = 1 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">//			if (f[i] + g[i] &gt; ans)&#123; res = 1 ; break ; &#125;</span></span><br><span class="line"><span class="comment">//			cout &lt;&lt; i &lt;&lt; " " &lt;&lt; f[i] &lt;&lt; " " &lt;&lt; g[i] &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (res ? ans + <span class="number">1</span> : ans + <span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVA12170-Easy-Climb"><a href="#UVA12170-Easy-Climb" class="headerlink" title="UVA12170 Easy Climb"></a><a href="https://uva.onlinejudge.org/external/121/p12170.pdf" target="_blank" rel="noopener">UVA12170 Easy Climb</a></h1><blockquote><p>给出一堆山的高度 $h_i$ ，给定一个数 $d$ 。除了 $h_1,h_n$ 之外，可以任意修改山的高度，设改完之后山的高度是 $h’$，那么修改的代价是 $|h-h’|$ 。求使得任意两座相邻山峰的之间高度差得绝对值不超过 $d$ 的最小修改代价。</p><p>$1\leq n\leq 100,0\leq h_i\leq 10^9$ 。</p></blockquote><p><del>orz又是性质题，好烦啊怎么一直不会</del></p><p>考虑暴力怎么做。$f_{i,v}$ 表示把 $i$ 改成了 $v$ 后前 $i$ 座山彼此之间合法的最小代价和。你发现这个 $v$ 大概是没法直接转移的…</p><p>于是考虑一个深刻的性质。对于一个 $1&lt;i&lt;n$ ， $h_i$ 一定会被改成 $\max\{h_{i-1},h_{i+1}\}-d$ 或者 $\min\{h_{i-1},h_{i+1}\}+d$ 两者之一，如果一开始就满足性质就不用改，否则如果不满足就一定要去凑最近那个边界。类似的，考虑如果 $h_i ‘=h_{i+1}+d$ ，那么 $h_{i+1}’$ 就应该是关于 $h_{i}’$ 或者 $h_{i+2}$ 的一个带有常数个 $\mp d$ 的答案。那么这也就证明了，最终每座山都会变成某个 $h_p+q\cdot d$ 的形式，其中 $p\in [1,n]\cap\mathbb{Z_+}$，$q\in[-n,n]\cap\mathbb Z$ 。那么状态数就变成了 $O(n)\cdot O(n^2)=O(n^3)$ 个。考虑转移：</p><script type="math/tex;mode=display">
f_{i,x}=|x-h_i|+\min\{f_{i-1,y}\} \quad (x-d\leq y\leq x+d)</script><p>发现可以对 $x$ 这一维用单调队列。于是复杂度 $O(n^3)$ 。如果实现不精细可能会多一个 $\log$ 。注意到可以一开始把所有可能的 $x$ 值排序后存起来，这样就可以避免 <code>map</code> 或者 <code>set</code> 的滥用。</p><h1 id="UVA1228-Integer-Transmisson"><a href="#UVA1228-Integer-Transmisson" class="headerlink" title="UVA1228 Integer Transmisson"></a><a href="https://uva.onlinejudge.org/external/12/p1228.pdf" target="_blank" rel="noopener">UVA1228 Integer Transmisson</a></h1><blockquote><p>在一个仿真网络中传输一个 $n$ 比特的非负整数 $k$。各比特从左到右传输，第 $i$ 个比特的发送时刻为 $i$ 。每个比特的网络延迟总是为 $0\sim d$ 之间的整数(因此从左到右第 $i$ 个比特的到达时刻为 $i\sim i+d$ 之间)。若同时有多个比特到达，实际收到的顺序任意。</p><p>求实际收到的整数有多少种 ，以及它们的最小值和最大值。</p><p>例如，$n=3$，$d=1$，$k=2$ (二进制为<code>010</code>)实际收到的整数的二进制可能是 <code>001</code>(1)，<code>010</code>(2) 和 <code>100</code>(4)。</p><p>$1\leq n\leq 64,0\leq d\leq n,0\leq k\leq 2^n $。</p></blockquote><p>最小值和最大值都显然可以贪心。考虑求方案数。比较直接的想法就是设 $f_{i,j}$ 表示考虑前 $i$ 个 $0$ 和前 $j$ 个 $1$ 后，组成整数的方案数。但是转移并不知道要怎么转移，因为可能上一个 $0/1$ 的出现时间不确定，导致无法判定当前在整个数最右边插入 $0/1$ 是否合法。</p><p>然后就需要洞见一个比较深刻的性质了。考虑如果希望凑出某个数 $w$ ，那么对于任意时刻，最右边那位(指被收到的最右边那一位)必然可以<strong>没有延迟</strong> 。因为即使延迟了，结果也不会更优（即也不会存在没延迟拼不出来，只有延迟才能拼出来的情况）。证明的话比较简单，因为「若同时有多个比特到达，实际收到的顺序任意」，所以如果某个比特延后至 $&gt;$ 最右边的数接收的时间，就可以调整成等于然后重排。</p><p>于是就可以知道，假设第 $i$ 位的发送时间是 $t_i$，那么考虑如何从 $f_{i,j}$ 转移到 $f_{i+1,j}$ 和 $f_{i,j+1}$ 。观察到本质上是要求插入一个新的 $1$ 或者新的 $0$ 。那么考虑假设第 $i+1$ 个 $0$ 的发送时间是 $t_0$ ，第 $j+1$ 个 $1$ 的发送时间是 $t_1$ ，那么如果为了让 $0$ 能够被尽早接收到，就需要满足 $t_0\leq t_1+d$ ，同理如果是想要 $1$ 能够尽量早到，就需要 $t_1\leq t_0+d$ 。于是转移时判断一下即可。复杂度 $O(n^2)$ 。</p><p><del>代码懒得写了</del></p><h1 id="UVA1628-Pizza-Delivery"><a href="#UVA1628-Pizza-Delivery" class="headerlink" title="UVA1628 Pizza Delivery"></a><a href="https://onlinejudge.org/external/16/p1628.pdf" target="_blank" rel="noopener">UVA1628 Pizza Delivery</a></h1><blockquote><p>你是一个披萨店的老板，有一天突然收到了 $n$ 个客户的订单。</p><p>你所在的小镇只有一条笔直的大街，其中位置 $0$ 是你的披萨店，第 $i$ 个客户所在的位置为 $p_i$，如果你选择给第 $i$ 个客户送餐，他将会支付你 $e_i-t_i$ 元。其中 $t_i$ 是你到达他家的时刻。</p><p>当然，如果你到的太晚，使得 $e_i-t_i&lt;0$ 。你可以路过他家但是不能进去给他送餐，免得他反过来找你要钱。</p><p>最大化收益。</p><p>$n \leq 100$ 。</p></blockquote><p>考虑对于这种每秒代价递增的问题，一般都是代价提前计算。但是这题也不是最朴素的这类问题，因为存在可以放弃某些位置的情况。</p><p>然后就是比(我)较(又)神(不)仙(会)的状态设计环节。首先是，根据题面可知不用全部送餐，所以要把「准备送餐给ta」的人数 $k$ 放到状态里面。同时如果定义「选了某个区间内的全部数」作为状态，显然是不合适的。于是设 $f_{i,j,k,0/1}$ 表示<strong>不考虑</strong>区间 $[i,j]\cap\mathbb {Z_+}$ 内的元素，还要给 $k$ 个人送餐，当前位于 $i(0)$ 还是 $j(1)$ 的最小代价。那么最后答案就是</p><script type="math/tex;mode=display">
\max_{k=0}^n\{\max_{i=1}^n\{f_{i,i,k-1,0/1}+(e_i-|p_i|)\times k\}\}</script><p>考虑转移。发现对于一个 $f_{i,j,k,0/1}$ 而言，必然是由一个包含 $[i,j]$ 的更大的区间 $[l,r]$ 通过切分得来的，同时为了每次只转移走一个子问题，需要 $r=j$ 或者 $l=i$ 的更大区间。于是考虑每次只转移一个点，故转移为：</p><script type="math/tex;mode=display">
f_{i,j,k,0}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_i|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_i|)\}\\f_{i,j,k,1}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_j|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_j|)\}</script><p>然后就刷表就好了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = n - <span class="number">1</span> ; len ; -- len)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= n - len ; ++ k)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = i + len ; j &lt;= n ; ++ i, ++ j)&#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; '\n' ;</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> p = i + <span class="number">1</span> ; p &lt;= j ; ++ p)&#123;</span><br><span class="line">				chkmax(f[p][j][k + <span class="number">1</span>][<span class="number">0</span>], f[i][j][k][<span class="number">0</span>] + val[i] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[p] - pos[i])) ;</span><br><span class="line">				chkmax(f[p][j][k + <span class="number">1</span>][<span class="number">1</span>], f[i][j][k][<span class="number">0</span>] + val[i] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[i])) ;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> q = j - <span class="number">1</span> ; q &gt;= i ; -- q)&#123;</span><br><span class="line">				chkmax(f[i][q][k + <span class="number">1</span>][<span class="number">1</span>], f[i][j][k][<span class="number">1</span>] + val[j] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[q])) ;</span><br><span class="line">				chkmax(f[i][q][k + <span class="number">1</span>][<span class="number">0</span>], f[i][j][k][<span class="number">1</span>] + val[j] - (k + <span class="number">1</span>) * <span class="built_in">abs</span>(pos[j] - pos[i])) ;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这东西看似是 $n^4$ 的，实际上跑得很快（</p><h1 id="UVA12105-Bigger-is-Better"><a href="#UVA12105-Bigger-is-Better" class="headerlink" title="UVA12105 Bigger is Better"></a><a href="https://onlinejudge.org/external/121/p12105.pdf" target="_blank" rel="noopener">UVA12105 Bigger is Better</a></h1><blockquote><p>用不超过 $n$ 根火柴摆出一个尽量大的、能被 $m$ 整除的数。</p><p>$1\leq n\leq 100,1\leq m\leq 3000$ 。</p></blockquote><p>大概是个套路？遇到这种被 $m$ 整除余几的，大概需要在 $\bmod m$ 的余数之间来回转移。</p><p>然后可能是因为脑子抽了，一开始设计的状态是 $f_{i,j}$ 表示用了 $i$ 根火柴，模 $m$ 余 $j$ 时可以拼出来的最大的数，然后发现最多可以有 $50$ 位，但是 <code>__int128</code> 也只是大概 $36\cdot 10^{36}$ 多一点，不足以记下所有可行的的数字。</p><p>然后又尝试用 <code>string</code> ，写了一会儿才意识到 string 自定义的比较函数是按字典…<del>当然也可以写一个大整数类，似乎最多只会带一个 50 的常数</del>。</p><p>然后考虑这么设计不行，就只能去最小化贡献，然后手动构造了。考虑 $g_{i,j}$ 表示如果想要凑出从高到低的 $i$ 位，$\bmod m$ 余 $j$ 时最少需要用多少根火柴。转移和第一个转移…基本上差不多，刷就对了。然后考虑从第一位开始贪心地凑，注意判几次合法性就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int n, m ;</span></span><br><span class="line"><span class="comment">ll f[N][M], ans ;</span></span><br><span class="line"><span class="comment">int num[10] = &#123;6, 2, 5, 5, 5, 5, 6, 3, 7, 6&#125; ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int main()&#123;</span></span><br><span class="line"><span class="comment">    while (cin &gt;&gt; n)&#123;</span></span><br><span class="line"><span class="comment">        if (!n) return 0 ; ans = -1 ;</span></span><br><span class="line"><span class="comment">        cin &gt;&gt; m ; memset(f, -1, sizeof(f)) ;</span></span><br><span class="line"><span class="comment">        for (int i = 0 ; i &lt;= 9 ; ++ i) f[i % m][num[i]] = i ;</span></span><br><span class="line"><span class="comment">        for (int j = 2 ; j &lt;= n ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            for (int k = 0 ; k &lt;= 9 ; ++ k)&#123;</span></span><br><span class="line"><span class="comment">                for (int i = 0 ; i &lt; m ; ++ i)</span></span><br><span class="line"><span class="comment">                    chkmax(f[((i * 10) + k) % m][j + num[k]], f[i][j] * 10 + k) ;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        for (int i = 2 ; i &lt;= n ; ++ i)</span></span><br><span class="line"><span class="comment">            chkmax(ans, f[0][i]) ; cout &lt;&lt; ans &lt;&lt; '\n' ;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return 0 ;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, T ;</span><br><span class="line"><span class="keyword">int</span> pw[N], ans[N], f[N][M] ;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">63</span>, <span class="keyword">sizeof</span>(f)) ;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n, mid, res = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: "</span>, ++ T), <span class="built_in">cin</span> &gt;&gt; m ;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans)) ; f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; m ; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= <span class="number">9</span> ; ++ k)</span><br><span class="line">                        chkmin(f[i + <span class="number">1</span>][(j * <span class="number">10</span> + k) % m], f[i][j] + num[k]) ;</span><br><span class="line">		<span class="keyword">for</span> (res = n + <span class="number">1</span> ; f[res][<span class="number">0</span>] &gt; n ; -- res) ;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, cost = n ; pw[<span class="number">1</span>] = <span class="number">1</span> ; <span class="comment">//cout &lt;&lt; res &lt;&lt; '\n';</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= res ; ++ i) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">10</span> % m ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= res ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">9</span> ; j &gt;= <span class="number">0</span> ; -- j)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = j * pw[res - i + <span class="number">1</span>] % m ;</span><br><span class="line">                <span class="keyword">if</span> (num[j] + f[res - i][((m - p - t) % m + m) % m] &lt;= cost)&#123;</span><br><span class="line">                    cost -= num[j] ; (p += t) %= m ; ans[i] = j ; <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; res &lt;&lt; '\n' ;</span></span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span> ; <span class="keyword">while</span> (!ans[q] &amp;&amp; q &lt; res) ++ q ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = q ; i &lt;= res ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]) ;</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意几个细节：</p><p>1、最后数字的位数不具有可二分性，所以还是枚举吧。</p><p>2、注意可能存在前导 $0$ ，需要删掉。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实学到了许多吧？自己基础一点也不好，所以其实是把别人很早之前付出的努力，再重新付出了一遍。很遗憾，这些题目里面还是有不少无不太会做的题目…</p><p>感谢兔队的教导可以让我安心学下去：藏巧于拙，寓快于慢。只要努力，就一定会比昨天的我更优秀吧？</p><p>不过，努力和选择同样重要。希望在接下来越来越紧张的时间里面，我可以想清楚自己到底要做些什么题、要学习一些什么知识吧。加油吧！</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%8A%B6%E5%8E%8BDP/" rel="tag"><i class="fa fa-tag"></i> 动态规划/状压DP</a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%89%E6%8A%80%E5%B7%A7%E7%9A%84DP/" rel="tag"><i class="fa fa-tag"></i> 动态规划/有技巧的DP</a><a href="/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%89%BE%E6%80%A7%E8%B4%A8/" rel="tag"><i class="fa fa-tag"></i> 思维题/找性质</a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%A0%91%E5%BD%A2DP/" rel="tag"><i class="fa fa-tag"></i> 动态规划/树形DP</a><a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> 动态规划/单调队列</a><a href="/tags/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/" rel="tag"><i class="fa fa-tag"></i> 数学/线性代数/矩阵</a><a href="/tags/%E5%9B%BE%E8%AE%BA-Dilworth%E5%AE%9A%E7%90%86/" rel="tag"><i class="fa fa-tag"></i> 图论/Dilworth定理</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/04/19/%E7%AE%80%E5%8D%95%E9%A2%98%E9%80%89%E5%81%9A/" rel="next" title="【泛做】简单题选做"><i class="fa fa-chevron-left"></i> 【泛做】简单题选做</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2020/04/21/RE-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%AE%A1%E6%95%B0%E7%94%9F%E6%B4%BB/" rel="prev" title="【泛做】RE:从零开始的计数生活">【泛做】RE:从零开始的计数生活<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><div style=""><canvas id="canvas" style="width:60%">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){var t,o=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],e=document.getElementById("canvas");if(e.getContext){var l=e.getContext("2d");e.height=100,e.width=700,l.fillStyle="#f00",l.fillRect(10,10,50,50);var r=[],f=[],i=e.height/20-1;function n(t,e){for(var n=0;n<o[e].length;n++)for(var a=0;a<o[e][n].length;a++)1==o[e][n][a]&&(l.beginPath(),l.arc(14*(i+2)*t+2*a*(i+1)+(i+1),2*n*(i+1)+(i+1),i,0,2*Math.PI),l.closePath(),l.fill())}function h(t,e){for(var n=[1,2,3],a=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],l=0;l<o[e].length;l++)for(var r=0;r<o[e][l].length;r++)if(1==o[e][l][r]){var h={x:14*(i+2)*t+2*r*(i+1)+(i+1),y:2*l*(i+1)+(i+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*n[Math.floor(Math.random()*n.length)],color:a[Math.floor(Math.random()*a.length)],disY:1};f.push(h)}}t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),r.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6]),clearInterval(a);var a=setInterval(function(){!function(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),n=[];n.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var a=r.length-1;0<=a;a--)n[a]!==r[a]&&t.push(a+"_"+(Number(r[a])+1)%10);for(a=0;a<t.length;a++)h.apply(this,t[a].split("_"));r=n.concat()}(),function(){for(var t=0;t<f.length;t++)f[t].stepY+=f[t].disY,f[t].x+=f[t].stepX,f[t].y+=f[t].stepY,(f[t].x>700+i||f[t].y>100+i)&&(f.splice(t,1),t--)}(),function(){e.height=100;for(var t=0;t<r.length;t++)n(t,r[t]);for(t=0;t<f.length;t++)l.beginPath(),l.arc(f[t].x,f[t].y,i,0,2*Math.PI),l.fillStyle=f[t].color,l.closePath(),l.fill()}()},50)}}()</script><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> Overview</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Orchidany"><p class="site-author-name" itemprop="name">Orchidany</p><div class="site-description motion-element" itemprop="description">For code, science, tech. and more</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/%20%7C%7C%20archive"><span class="site-state-item-count">169</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/%20%7C%7C%20th"><span class="site-state-item-count">54</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/%20%7C%7C%20tags"><span class="site-state-item-count">117</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA1407-Caves"><span class="nav-number">1.</span> <span class="nav-text">UVA1407 Caves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BZOJ4160-Exclusive-Access-2"><span class="nav-number">2.</span> <span class="nav-text">BZOJ4160 Exclusive Access 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#POJ3735-Training-little-cats"><span class="nav-number">3.</span> <span class="nav-text">POJ3735 Training little cats</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA1437-String-painter"><span class="nav-number">4.</span> <span class="nav-text">UVA1437 String painter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA1427-Parade"><span class="nav-number">5.</span> <span class="nav-text">UVA1427 Parade</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA11795-Mega-Man’s-Mission"><span class="nav-number">6.</span> <span class="nav-text">UVA11795 Mega Man’s Mission</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA1625-Color-Length"><span class="nav-number">7.</span> <span class="nav-text">UVA1625 Color Length</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA1218-Perfect-Service"><span class="nav-number">8.</span> <span class="nav-text">UVA1218 Perfect Service</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA12099-The-Bookcase"><span class="nav-number">9.</span> <span class="nav-text">UVA12099 The Bookcase</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA10559-Blocks"><span class="nav-number">10.</span> <span class="nav-text">UVA10559 Blocks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA1380-A-Scheduling-Problem"><span class="nav-number">11.</span> <span class="nav-text">UVA1380 A Scheduling Problem</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA12170-Easy-Climb"><span class="nav-number">12.</span> <span class="nav-text">UVA12170 Easy Climb</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA1228-Integer-Transmisson"><span class="nav-number">13.</span> <span class="nav-text">UVA1228 Integer Transmisson</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA1628-Pizza-Delivery"><span class="nav-number">14.</span> <span class="nav-text">UVA1628 Pizza Delivery</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UVA12105-Bigger-is-Better"><span class="nav-number">15.</span> <span class="nav-text">UVA12105 Bigger is Better</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">16.</span> <span class="nav-text">总结</span></a></li></ol></div></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">𝒪𝓇𝒸𝒽𝒾𝒹𝒶𝓃𝓎</span></div><div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0</div> <span class="post-meta-divider">|</span><div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共348.7k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="Total Visitors"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="Total Views"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.2.0"></script><script src="/js/motion.js?v=7.2.0"></script><script src="/js/affix.js?v=7.2.0"></script><script src="/js/schemes/pisces.js?v=7.2.0"></script><script src="/js/scrollspy.js?v=7.2.0"></script><script src="/js/post-details.js?v=7.2.0"></script><script src="/js/next-boot.js?v=7.2.0"></script><script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });
</script><script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });
</script><script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return-1<GUEST.indexOf(e)}),new Valine({el:"#comments",verify:!1,notify:!1,appId:"V95HMkHzC6J9NvdCNbpg3A3E-gzGzoHsz",appKey:"gyf1NbCMlYbPnqykkSe7KuYC",placeholder:"ヾﾉ≧∀≦)o来啊，快活啊!",avatar:"mm",meta:guest,pageSize:"10",visitor:!1,lang:"zh-cn"})</script><script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script>$("body").find("div.pdf").length&&$.ajax({type:"GET",url:"//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js",dataType:"script",cache:!0,success:function(){$("body").find("div.pdf").each(function(e,t){PDFObject.embed($(t).attr("target"),$(t),{pdfOpenParams:{navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"},PDFJS_URL:"/lib/pdf/web/viewer.html",height:$(t).attr("height")||"500px"})})}})</script><script>
// GET RESPONSIVE HEIGHT PASSED FROM IFRAME

window.addEventListener("message", function(e) {
  var data = e.data;
  if ((typeof data === 'string') && (data.indexOf('ciu_embed') > -1)) {
    var featureID = data.split(':')[1];
    var height = data.split(':')[2];
    $(`iframe[data-feature=${featureID}]`).height(parseInt(height) + 30);
  }
}, false);
</script><canvas class="fireworks" style="position:fixed;left:0;top:0;z-index:1;pointer-events:none"></canvas><script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script type="text/javascript" src="/js/src/fireworks.js"></script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)0<=(t=c[r].getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n()},e.src=i}();var t}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this)</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script></body></html>